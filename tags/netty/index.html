<!DOCTYPE html>
<html  lang="en">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.9.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>Tag: Netty - Jade&#39;s Blog</title>


    <meta property="og:type" content="website">
<meta property="og:title" content="Jade&#39;s Blog">
<meta property="og:url" content="https://j2de.github.io/tags/netty/index.html">
<meta property="og:site_name" content="Jade&#39;s Blog">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://j2de.github.io/images/og_image.png">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jade&#39;s Blog">
<meta name="twitter:image" content="https://j2de.github.io/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="Jade&#39;s Blog" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/archives">Archives</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
                <a class="navbar-item"
                href="/tags">Tags</a>
                
                <a class="navbar-item"
                href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/tags">Tags</a></li>
            <li class="is-active"><a href="#" aria-current="page">Netty</a></li>
        </ul>
        </nav>
    </div>
</div>

    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2018-05-31T15:00:00.000Z">2018-06-01</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/server/">Server</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/server/netty/">Netty</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    23 minutes read (About 3378 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2018-06-01-netty-codec-framework/">Netty Codec Framework</a>
            
        </h1>
        <div class="content">
            <h3 id="코덱이란"><a href="#코덱이란" class="headerlink" title="코덱이란?"></a>코덱이란?</h3><blockquote>
<p>모든 어플리케이션은 네트워크 상에 원시 바이트를 주고 받는다. 바이트 형태의 데이터를 대상 어플리케이션에 맞는 데이터 포맷으로 분석하고 변환하는 것이 필요하다. 이러한 데이터 변환은 인코더와 디코더로 구성된 코덱에 의해 처리된다.</p>
</blockquote>
<blockquote>
<p>일반적으로 동영상 압축 알고리즘을 코덱이라고 부른다. 예를 들면 MPEG 알고리즘으로 압축된 동영상을 재생한다면, 원본 동영상을 MPEG 알고리즘으로 압축하고 시청자는 다시 MPEG 디코더로 압축 해제한 뒤 시청을 할 것 이다.</p>
</blockquote>
<br/>

<h2 id="디코더-Decoder"><a href="#디코더-Decoder" class="headerlink" title="디코더(Decoder)"></a>디코더(Decoder)</h2><p>디코더는 네트워크 스트림을 프로그램의 메세지 포맷으로 변환한다. 즉 인바운드 데이터를 처리한다. 디코더는 인바운드 데이터를 다른 포맷으로 변환하는 일을 하므로 <code>ChannelInboundHandler</code>를 상속받는다.  </p>
<ul>
<li>Netty의 디코더 클래스<ul>
<li><code>ByteToMessageDecoder</code> / <code>ReplayingDecoder</code> : 바이트 스트림을 메세지로 디코딩</li>
<li><code>MessageToMessageDecoder</code> : 메세지를 다른 메세지 유형으로 디코딩</li>
</ul>
</li>
</ul>
<h3 id="메세지란"><a href="#메세지란" class="headerlink" title="메세지란 ?"></a>메세지란 ?</h3><blockquote>
<p>특정 어플리케이션에서 의미가 있는 바이트의 시퀀스 구조를 메세지라고 한다. 인코더의 경우 이 메세지를 전송하기에 적합한 (보통 바이트 스트림) 형식으로 변환하고, 디코더는 네트워크 스트림을 다시 프로그램의 메세지 포맷으로 변환한다.</p>
</blockquote>
<p>디코더는 인바운드 데이터를 <code>ChannelPipeline</code>의 다음 <code>ChannelInboundHandler</code>를 위해 변환할 때 이용한다. ChannelPipeline은 설계 방식이 체인 형태이기 때문에 복잡한 논리도 여러 디코더를 체인으로 연결해서 쉽게 구현할 수 있다.</p>
<br/>

<h3 id="ByteToMessageDecoder"><a href="#ByteToMessageDecoder" class="headerlink" title="ByteToMessageDecoder"></a>ByteToMessageDecoder</h3><p>바이트 스트림을 메세지(또는 다른 바이트의 시퀀스)로 디코딩 하는 일반적인 작업을 지원하는 추상 기본 클래스. 원격 피어가 완성된 메세지를 한번에 보낼지 알 수 없으므로 이 클래스는 인바운드 데이터가 처리할 만큼 모일 때까지 버퍼에 저장한다.</p>
<ul>
<li>ByteToMessageDecoder API</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>decode(ChannelHandlerContext ctx, ByteBuf in, List<Obejct> out)</td>
<td>decode()는 구현해야하는 유일한 추상 메소드로 들어오는 데이터가 포함된 ByteBuf와 디코딩된 메세지가 추가될 List를 받는다. 이 호출은 더 이상 List에 추가할 항목이 없거나 ByteBuf에 읽을 바이트가 없을 때까지 반복된다. 그 이후 List가 비어있지 않은 경우 그 내용이 파이프라인의 다음 핸들러로 전달된다.</td>
</tr>
<tr>
<td>decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)</td>
<td>네티가 제공하는 기본 구현은 단순히 decode()를 호출한다. 이 메소드는 Channel이 비활성화될 때 한번 호출된다. 특별한 처리가 필요한 경우 이 메소드를 재정의한다.</td>
</tr>
</tbody></table>
<ul>
<li>ByteToMessageDecoder를 상속받은 ToIntegerDecoder 클래스</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 바이트를 특정 포맷으로 디코딩하기 위해서 ByteToMessageDecoder를 상속받음</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">// 최소 4바이트(int 길이)를 읽을 수 있는지 확인</span></span><br><span class="line">        out.add(in.readInt());</span><br><span class="line">        <span class="comment">// 인바운드 ByteBuf에서 int 하나를 읽고 이를 디코딩된 메세지의 List에 추가</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int를 포함하는 바이트 스트림을 받고 각각 별도로 처리하는 경우, 인바운드 <code>ByteBuf</code>에서 각 int를 읽고 이를 파이프라인의 다음 <code>ChannelInboundHandler</code>로 전달해야한다. 위의 예제는 인바운드 <code>ByteBuf</code>에서 4바이트씩 읽고 이를 int로 디코딩한 후 List로 추가한다. 그리고 List에 추가할 항목이 더 이상 없는 경우 그 내용을 다음 <code>ChannelInboundHandler</code>로 전달한다. 위의 예제는 <code>readableBytes</code> 메소드로 <code>ByteBuf</code>에 읽을 데이터가 있는지 확인하는 과정이 필요하다.</p>
<br/>

<h3 id="ReplayingDecoder"><a href="#ReplayingDecoder" class="headerlink" title="ReplayingDecoder"></a>ReplayingDecoder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span></span></span><br></pre></td></tr></table></figure>

<p><code>ReplayingDecoder</code>는 <code>ByteToMessageDecoder</code>를 상속받으며 위의 예제와 다르게 약간의 오버헤드를 감수하고 <code>readableBytes</code>를 호출할 필요를 없애준다. 이를 위해 들어오는 <code>ByteBuf</code>를 커스텀 ByteBuf 구현인 <code>ReplayingDecoderBuffer</code>로 래핑하는데 이 동작은 내부적으로 호출이 수행된다.</p>
<ul>
<li>ReplayingDecoder를 상속받은 ToIntegerDecoder 클래스</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 바이트 스트림을 메세지로 디코딩하기 위해 ReplayingDecoder&lt;Void&gt;를 상속받음</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">  // 들어오는 ByteBuf는 ReplayingDecoderBuffer이다.</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      out.add(in.readInt());</span><br><span class="line">      <span class="comment">// 인바운드 ByteBuf에서 int 하나를 읽고 이를 디코딩된 메세지의 List에 추가함</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ReplayingDecoder의 특징<ul>
<li>모든 ByteBuf 작업이 지원되는 것은 아니다.<br>지원되지 않는 메소드를 호출하면  <code>UnsupportedOperationException</code>이 발생한다.</li>
<li><code>ReplayingDecoder</code>는 <code>ByteToMessageDecoder</code>보다 약간 느리다</li>
</ul>
</li>
</ul>
<br/>

<h3 id="MessageToMessageDecoder"><a href="#MessageToMessageDecoder" class="headerlink" title="MessageToMessageDecoder"></a>MessageToMessageDecoder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span></span><br></pre></td></tr></table></figure>

<p>메세지 포맷을 변환하는 클래스이다. 예를 들면 POJO의 한 형식에서 다른 형식으로 바꾸는 등에 이용할 수 있다. 위의 형태에서 매개변수 I는 구현해야하는 유일한 메소드인 <code>decode()</code>에 입력 msg 인수의 형식을 알려준다.</p>
<ul>
<li>MessageToMessageDecoder API</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>decode(ChannelHandlerContext ctx, I msg, List<Object> out)</td>
<td>인바운드 메세지를 다른 포맷으로 디코딩할 때마다 호출된다. 디코딩된 메세지는 파이프라인의 다음 ChannelInboundHandler로 전달된다.</td>
</tr>
</tbody></table>
<ul>
<li>IntegerToStringDecoder 클래스</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, Integer msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      out.add(String.valueOf(msg));</span><br><span class="line">      <span class="comment">//Integer 메세지를 String 표현으로 변환한 후 출력 List에 추가</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h3 id="TooLongFrameException"><a href="#TooLongFrameException" class="headerlink" title="TooLongFrameException"></a>TooLongFrameException</h3><p>네티는 비동기 프레임워크이므로 디코딩할 수 있을 때까지 바이트를 메모리 버퍼에 저장해야한다. 또한 디코더가 메모리를 소진할 만큼 많은 데이터를 저장해서는 안된다. 이 문제를 해결하기 위해서 프레임이 지정한 크기를 초과하면 발생하는 <code>TooLongFrameException</code> 예외를 제공한다.</p>
<p>이 예외는 <code>ChannelHandler.exceptionCaught()</code>로 포착할 수 있다. 예외를 처리하는 방법은 디코더의 이용자가 결정할 수 있다. HTTP 같은 특정 프로토콜을 이용할 때는 특수한 응답을 반환할 수 있지만 그 밖의 경우에는 연결을 닫는 것이 유일한 방법이다.</p>
<ul>
<li>TooLongFrameException 예제</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 인바운드 바이트를 메세지로 디코딩하기 위해 ByteToMessageDecoder를 상속받음</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FRAME_SIZE = <span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 최대 바이트 수의 임계값을 설정한다.</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> readable = in.readableBytes();</span><br><span class="line">      <span class="keyword">if</span> (readable &gt; MAX_FRAME_SIZE)&#123;</span><br><span class="line">        <span class="comment">// 버퍼의 바이트 수가 MAX_FRAME_SIZE를 초과하는 지 확인</span></span><br><span class="line">        <span class="comment">// 읽을 수 있는 바이트를 모두 건너뛰고</span></span><br><span class="line">        <span class="comment">// TooLongFrameException을 생성한 후</span></span><br><span class="line">        <span class="comment">// 다른 ChannelHandler에 알림</span></span><br><span class="line">        in.skipBytes(readable);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException(<span class="string">"Frame Too big"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 필요한 작업을 수행</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ByteToMessageDecoder</code>가 <code>TooLongFrameException</code>을 이용해 <code>ChannelPipeline</code> 내의 다른 <code>ChannelHandler</code>에 프레임 초과를 알리는 코드이다. 이러한 예방책은 프레임 크기가 가변적인 프로토콜을 이용할 때 특히 중요하다.</p>
<br/>

<h2 id="인코더-Encoder"><a href="#인코더-Encoder" class="headerlink" title="인코더(Encoder)"></a>인코더(Encoder)</h2><p>인코더는 아웃바운드 데이터를 한 포맷에서 다른 포맷으로 변환한다. 즉 아웃바운드 데이터를 처리하므로 <code>ChannelOutboundHandler</code>를 상속받는다.</p>
<ul>
<li>Netty의 인코더 클래스<ul>
<li><code>MessageToByteEncoder</code> : 메세지를 바이트로 인코딩</li>
<li><code>MessageToMessageDecoder</code> : 메세지를 다른 메세지로 인코딩</li>
</ul>
</li>
</ul>
<br/>

<h3 id="MessageToByteEncoder"><a href="#MessageToByteEncoder" class="headerlink" title="MessageToByteEncoder"></a>MessageToByteEncoder</h3><p>앞의 <code>ByteToMessageDecoder</code>와 반대로 메세지를 바이트로 변환하는 클래스이다.</p>
<ul>
<li>MessageToByteEncoder API</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>encode(ChannelHandlerContext ctx, I msg, ByteBuf out)</td>
<td>encode 메소드는 구현해야하는 유일한 추상 메소드이다. ByteBuf로 인코딩할 아웃바운드 메세지(I 형식)을 전달하고 호출한다. 그런 다음 ByteBuf는 파이프라인의 다음 ChannelOutboundHandler로 전달된다.</td>
</tr>
</tbody></table>
<p>디코더에는 메소드가 두개이지만 인코더인 이 클래스는 메소드가 하나이다. 디코더의 메소드가 두 개인 이유는 <code>Channel</code>이 닫힌 후 마지막 메세지를 생성해야하는 일이 자주 있기 때문이다.(<code>decodeLast()</code> 메소드). 인코더는 연결이 닫힌 후 메세지를 생성할 필요가 없기 때문에 메소드가 하나이다.</p>
<ul>
<li>ShortToByteEncoder 클래스</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Short</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Short msg, ByteBuf out)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      out.writeShort(msg);</span><br><span class="line">      <span class="comment">// Short를 ByteBuf에 기록함</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Short 인스턴스를 메세지로 받고 이를 Short 기본형으로 인코딩한 후 <code>ByteBuf</code>에 저장하고 이를 파이프라인 내의 다음 <code>ChannelOutboundHandler</code>로 전달한다. 나가는 <code>Short</code>는 <code>ByteBuf</code>에서 2바이트를 차지한다.</p>
<br/>

<h3 id="MessageToMessageEncoder"><a href="#MessageToMessageEncoder" class="headerlink" title="MessageToMessageEncoder"></a>MessageToMessageEncoder</h3><p>메세지를 아웃바운드 데이터로 인코딩하는 클래스이다.</p>
<ul>
<li>MessageToMessageEncoder API</li>
</ul>
<table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>encode(ChannelHandlerContext ctx, I msg, List<Object> out)</td>
<td>encode()는 구현해야하는 유일한 메소드이다. write()로 기록한 각 메세지는 encode()로 전달된 후 하나 이상의 아웃바운드 메세지로 인코딩된다. 그런다음 파이프라인의 다음 ChannelOutboundHandler로 전달된다.</td>
</tr>
</tbody></table>
<ul>
<li>IntegerToStringEncoder 클래스</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Integer msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    out.add(String.valueOf(msg));</span><br><span class="line">    <span class="comment">// Integer를 String으로 변환하고 List에 추가</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="추상-코덱-클래스"><a href="#추상-코덱-클래스" class="headerlink" title="추상 코덱 클래스"></a>추상 코덱 클래스</h2><p>지금까지 인코더와 디코더를 별개로 다뤘지만 인바운드/아웃바운드 데이터와 메세지 변환을 한 클래스에서 관리할 수 있다. 네티의 추상 코덱 클래스는 디코더와 인코더의 작업을 함께 처리할 수 있다. 이 클래스는 <code>ChannelInboundHandler</code>와 <code>ChannelOutboundHandler</code>를 둘 다 구현한다. 이렇게 구현하는 경우 코드의 재사용성과 확장성은 떨어진다.</p>
<br/>

<h3 id="ByteToMessageCodec"><a href="#ByteToMessageCodec" class="headerlink" title="ByteToMessageCodec"></a>ByteToMessageCodec</h3><p>바이트를 일종의 메세지(ex-POJO)로 디코딩한 후 다시 인코딩해야하는 경우, <code>ByteToMessageDecoder</code>와 반대 작업을 하는 <code>MessageToByteEncoder</code>를 결합하는 <code>ByteToMessageCodec</code>을 이용하면 된다.</p>
<ul>
<li>ByteToMessageCodec API</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>decode(ChannelHanlder ctx, ByteBuf in, List<Object> out)</td>
<td>이 메소드는 읽을 바이트가 있을 때 호출되고, 인바운드 ByteBuf를 지정한 메세지 포맷으로 변환하고 파이프라인 내의 다음 ChannelInboundHandler로 전달한다.</td>
</tr>
<tr>
<td>decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)</td>
<td>이 메소드의 기본 구현은 decode()로 위임하는 것이다. 이 메소드는 Channel이 비활성화될 때 한번 호출된다. 특별한 처리가 필요한 경우 이 메소드를 재정의한다.</td>
</tr>
<tr>
<td>encode(ChannelHanlderContext ctx, I msg, ByteBuf out)</td>
<td>이 메소드를 I 형식의 각 메소드를 인코딩하고 아웃바운드 ByteBuf에 기록한다.</td>
</tr>
</tbody></table>
<br/>

<h3 id="MessageToMessageCodec"><a href="#MessageToMessageCodec" class="headerlink" title="MessageToMessageCodec"></a>MessageToMessageCodec</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">INBOUND_IN</span>, <span class="title">OUTBOUND_IN</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>MessageToMessageCodec의 메소드</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>protected abstract decode(ChannelHandlerContext ctx, INBOUND_IN msg, List<Object> out)</td>
<td>이 메소드는 INBOUND_IN 형식의 메세지를 받으면 이를 OUTBOUND_IN 형식의 메세지로 디코딩한다. 메세지는 ChannelPipeline 내의 다음 ChannelInboundHandler로 전달된다.</td>
</tr>
<tr>
<td>protected abstract encode(ChannelHandlerContext ctx, OUTBOUND_IN msg, List<Object> out)</td>
<td>이 메소드는 OUTBOUND_IN 형식의 각 메세지를 처리할 때마다 호출한다. 처리된 메세지는 INBOUND_IN 형식의 메세지로 인코딩된 후 파이프라인 내의 다음 ChannelOutboundHandler로 전달된다.</td>
</tr>
</tbody></table>
<p><code>INBOUND_IN</code> 메세지는 전송을 위한 형식이고 <code>OUTBOUND_IN</code> 메세지는 어플리케이션에서 처리하는 형식으로 생각하면 된다. 해당 코덱은 서로 다른 메세징 API 간에 메세지를 변환하는 경우 사용된다. 이런 패턴은 레거시 메세지 포맷이나 특정 기업의 메세지 포맷을 이용하는 API와 상호운용해야하는 경우에 사용된다.</p>
<br/>

<h3 id="CombinedChannelDuplexHandler"><a href="#CombinedChannelDuplexHandler" class="headerlink" title="CombinedChannelDuplexHandler"></a>CombinedChannelDuplexHandler</h3><p>디코더와 인코더를 결합해 사용하면 재사용성이 떨어지지만 <code>CombinedChannelDuplexHandler</code>를 이용하면 디코더와 인코더를 단일 유닛으로 배포하면서 재사용성 저하를 방지할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedChannelDuplexHandler</span></span></span><br><span class="line"><span class="class">  &lt;<span class="title">I</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandler</span>,</span></span><br><span class="line"><span class="class">  <span class="title">O</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandler</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>이 클래스는 <code>ChannelInboundHandler</code>와 <code>ChannelOutboundHandler</code>의 컨테이너 역할을 한다.</p>
<ul>
<li>ByteToCharDecoder 클래스</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToCharDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(in.readableBytes() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        out.add(in.readChar());</span><br><span class="line">        <span class="comment">// 나가는 List에 Character 객체를 한 개 이상 추가</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 <code>decode()</code>는 <code>ByteBuf</code>에서 한번에 2바이트씩 읽고 <code>Character</code> 객체로 자동 박싱되는 char로 List에 기록한다.</p>
<ul>
<li>CharToByteEncoder 클래스</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Character</span>&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Character msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      out.writeChar(msg);</span><br><span class="line">      <span class="comment">// Character를 char로 디코딩하고 아웃바운드 ByteBuf로 기록</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CharToByteEncoder</code>는 <code>Character</code>를 다시 바이트로 변환한다. 이 클래스는 char 메세지를 ByteBuf로 인코딩해야하므로 <code>MessageToByteEncoder</code>를 상속받으며, ByteBuf에 직접 기록하는 방법으로 인코딩한다.</p>
<ul>
<li>CombinedChannelDuplexHandler&lt;I,O&gt;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedByteCharCodec</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">  <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">ByteToCharDecoder</span>, <span class="title">CharToByteEncoder</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CombinedByteCharCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> ByteToCharDecoder(), <span class="keyword">new</span> CharToByteEncoder());</span><br><span class="line">    <span class="comment">// 인스턴스를 부모로 전달</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위의 인코더와 디코더를 이용해 결합해 코덱을 만들 수 있다.  </p>
<p>이처럼 코덱 클래스 중 하나를 이용해 구현하거나 구현한 코덱을 결합할 수도 있다.</p>
<hr>
<ul>
<li>참고 서적<ul>
<li>네티 인 액션</li>
<li>자바 네트워크 소녀 네티  </li>
</ul>
</li>
</ul>
<hr>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2018-05-31T15:00:00.000Z">2018-06-01</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/server/">Server</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/server/netty/">Netty</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    16 minutes read (About 2403 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2018-06-01-netty-embeddedchannel-unittest/">Netty EmbeddedChannel 이용한 단위 테스트</a>
            
        </h1>
        <div class="content">
            <h3 id="단위-테스트란"><a href="#단위-테스트란" class="headerlink" title="단위 테스트란?"></a>단위 테스트란?</h3><blockquote>
<p>다른 모듈이나 데이터베이스 및 네트워크 등 런타임 의존성으로부터 최대한 격리된 가능한 작은 크기의 코드로 테스트하는 것. 테스트를 통해 모든 단위가 정상적으로 작동하는 것을 확인하면 문제가 생겼을 때 원인을 찾기가 수월해진다.</p>
</blockquote>
<p>Netty에서는 ChannelHandler가 아주 중요한 요소이다. 네티에서는 <code>EmbeddedChannel</code>을 통해 ChannelHandler의 단위 테스트를 제공한다.</p>
<p>테스트하는 코드 모듈이나 단위를 보통 런타임 환경 밖에서 실행되므로 이를 실행하기 위한 프레임 워크나 도구가 필요하다. 여기서는 JUnit을 통해 테스트 해본다.</p>
<br/>

<h2 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h2><p><code>EmbeddedChannel</code>은 인바운드 또는 아웃바운드 데이터를 EmbeddedChannel에 기록하고 <code>ChannelPipeline</code> 끝에 도달하는 항목이 있는지 확인한다. 이를 통해 메세지가 인코딩 또는 디코딩 됐는지 확인할 수 있고 트리거 된 <code>ChannelHandler</code> 작업이 있는지 여부도 알 수 있다.</p>
<ul>
<li>EmbeddedChannel 주요 메소드</li>
</ul>
<table>
<thead>
<tr>
<th>이름</th>
<th>역할</th>
</tr>
</thead>
<tbody><tr>
<td>writeInbound(Object… msgs)</td>
<td>EmbeddedChannel에 인바운드 메세지를 기록한다. EmbeddedChannel에서 readInbound()를 통해 데이터를 읽을 수 있는 경우 true 반환</td>
</tr>
<tr>
<td>readInbound()</td>
<td>EmbeddedChannel에서 인바운드 메세지 읽는다. 반환되는 항목은 전체 ChannelPipeline을 통과한 것. 읽을 데이터가 없으면 null 반환</td>
</tr>
<tr>
<td>writeOutbound(Object… msgs)</td>
<td>EmbeddedChannel에 아웃바운드 메세지를 기록한다. EmbeddedChannel에서 readOutbound()를 통해 데이터를 읽을 수 있는 경우 true를 반환</td>
</tr>
<tr>
<td>writeInbound()</td>
<td>EmbeddedChannel에서 아웃바운드 메세지를 읽음 반환되는 항목은 전체 ChannelPipeline을 통과한 것. 읽을 항목이 없으면 null 반환</td>
</tr>
<tr>
<td>finish</td>
<td>EmbeddedChannel을 완료로 표시하고 전체 인바운드 또는 아웃바운드 데이터를 읽을 수 있는 경우 true를 반환한다. 이 메소드는  EmbeddedChannel의 close()를 호출함</td>
</tr>
</tbody></table>
<ul>
<li>EmbeddedChannel 데이터 흐름</li>
</ul>
<img alt="EmbeddedChannel" src="/images/2018-06-01/01.jpg">

<p>인바운드 데이터는 <code>ChannelInboundHandler</code>에 의해 처리되고 원격 피어에서 읽은 데이터를 나타낸다. 아웃바운드 데이터는 <code>ChannelOutboundHandler</code>에 의해 처리되고 원격 피어에 기록된 데이터를 나타낸다. 테스트하는 <code>ChannelHandler</code>를 어떻게 구성하느냐에 따라 구체적인 코드는 달라질 수 있다.  </p>
<p>[그림]은 <code>EmbeddedChannel</code>의 메소드를 이용해 <code>ChannelPipeline</code>에서의 데이터 흐름을 보여준다. 메세지를 <code>Channel</code>에 기록하고 아웃바운드 방향으로 <code>ChannelPipeline</code>을 통과시키는데 <code>writeOutbound()</code>를 이용한다. 그리고 다음 처리된 메세지를 읽고 예상한 결과가 나왔는지 확인하는 데는 <code>readOutbound()</code>를 이용한다. 인바운드 데이터를 테스트할 때는 반대로 사용하면 된다. (<code>xxxInboud</code>)  </p>
<p>메세지는 <code>ChannelPipeline</code>을 통과하고 해당하는 <code>ChannelInboundHandler</code>나 <code>ChannelOutboundHandler</code>를 통해 처리되는데 메세지가 소비되지 않은 경우 메세지가 처리된 후 <code>readInbound()</code>나 <code>readOutbound()</code>를 통해 이용해 <code>Channel</code>에서 읽을 수 있다.  </p>
<br/>

<h2 id="EmbeddedChannel을-이용한-ChannelHandler-테스트"><a href="#EmbeddedChannel을-이용한-ChannelHandler-테스트" class="headerlink" title="EmbeddedChannel을 이용한 ChannelHandler 테스트"></a>EmbeddedChannel을 이용한 ChannelHandler 테스트</h2><p>JUnit과 EmbeddedChannel을 이용해 ChannelHandler를 테스트 해보자  </p>
<h3 id="Junit-Assert"><a href="#Junit-Assert" class="headerlink" title="Junit Assert"></a>Junit Assert</h3><blockquote>
<p><code>org.junit.Assert</code> 클래스에는 테스트에 이용되는 여러 정적 메소드가 들어있다. 어설션이 실패하면 예외가 발생하고 현재 실행중인 테스트가 종료된다. 다음 import 문으로 사용할 수 있다. <code>import static org.junit.Assert.*;</code> 그리고 다음부터는 직접 Assert 메소드를 호출할 수 있다. <code>assertEquals(buf.readSlice(3), read);</code></p>
</blockquote>
<br/>

<h3 id="인바운드-메세지-테스트"><a href="#인바운드-메세지-테스트" class="headerlink" title="인바운드 메세지 테스트"></a>인바운드 메세지 테스트</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedLengthFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 인바운드 바이트를 처리하고 이를 메세지로 디코딩하기 위해서</span></span><br><span class="line">  <span class="comment">// ByteToMessageDecoder를 상속 받음</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> frameLength;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FixedLengthFrameDecoder</span><span class="params">(<span class="keyword">int</span> frameLength)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 생성할 프레임의 길이 지정</span></span><br><span class="line">    <span class="keyword">if</span>(frameLength &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"frameLength must be a positive integer:"</span>+frameLength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.frameLength = frameLength;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 다음 프레임을 처리하는 데 충분하게 바이트를 읽을 수 있는지 확인</span></span><br><span class="line">      <span class="keyword">while</span> (in.readableBytes() &gt;= frameLength) &#123;</span><br><span class="line">        ByteBuf buf = in.readBytes(frameLength);</span><br><span class="line">        <span class="comment">// ByteBuf에서 새로운 프레임을 읽음</span></span><br><span class="line">        out.add(buf);</span><br><span class="line">        <span class="comment">// 디코딩 된 메세지의 List에 프레임을 추가함</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ByteToMessageDecoder</code>는 고정된 3바이트의 프레임을 생성한다. 이 코드는 데이터가 충분히 있는 경우 고정 크기의 프레임을 생성한다. 반면에 읽을 데이터가 충분하지 않으면 다음 데이터를 기다린다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedLengthFrameDecoderTest</span></span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="comment">//JUnit이 메소드를 실행하도록 @Test 어노테이션을 지정해줌</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFrameDecoded</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ByteBuf buf = Unpooled.buffer();</span><br><span class="line">    <span class="comment">// ByteBuf를 생성하고 9바이트 저장</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">      buf.writeByte(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ByteBuf input = buf.duplicate();</span><br><span class="line">    EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">      <span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">3</span>));</span><br><span class="line">      <span class="comment">// EmbeddedChannel을 생성하고 3바이트 길이의 프레임으로 테스트할</span></span><br><span class="line">      <span class="comment">// FixedLengthFrameDecoder를 추가함</span></span><br><span class="line">    assertTrue(channel.writeInbound(input.retain()));</span><br><span class="line">    <span class="comment">// EmbeddedChannel에 바이트를 기록</span></span><br><span class="line">    assertTrue(channel.finish());</span><br><span class="line">    <span class="comment">// Channel을 완료로 표시</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 처리된 메세지를 읽고 각각 3바이트 프레임이 3개인지 확인함</span></span><br><span class="line">    ByteBuf read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line"></span><br><span class="line">    read (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>),read);</span><br><span class="line">    read.release();</span><br><span class="line"></span><br><span class="line">    read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line"></span><br><span class="line">    assertNull(channel.readInbound());</span><br><span class="line">    buf.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>testFrameDecoded()</code> 메소드는 읽을 수 있는 9바이트를 포함하는 ByteBuf 1개가 3바이트를 포함하는 ByteBuf 3개로 디코딩되는지 확인한다. 그리고 <code>writeInbound()</code>를 한번 호출해 ByteBuf는 읽기 가능한 9바이트로 채운다. 그 다음에 finish()를 실행해 EmbeddedChannel을 완료로 표시하고 마지막으로 <code>readInbound()</code>를 호출해 EmbeddedChannel에서 프레임 3개와 null 1개를 읽었다.</p>
<br/>

<h3 id="아웃바운드-메세지-테스트"><a href="#아웃바운드-메세지-테스트" class="headerlink" title="아웃바운드 메세지 테스트"></a>아웃바운드 메세지 테스트</h3><p>아웃바운드 메세지 테스트도 인바운드와 비슷하다. <code>ChannelOutboundHandler</code>는 메세지를 다른 포맷으로 변환하는 컴포넌트인 인코더 역할을 한다. 아래의 코드로 테스트 해보자.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsIntegerEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// MessageToMessageEncoder를 상속받아 메세지를 다른 포맷으로 인코딩 함</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 인코딩할 바이트가 충분한지 확인</span></span><br><span class="line">        <span class="keyword">int</span> value = Math.abs(in.readint());</span><br><span class="line">        <span class="comment">// ByteBuf에서 다음 int를 읽고 절대값을 계산</span></span><br><span class="line">        out.add(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsIntegerEncoderTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEncoded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ByteBuf buf = Unpooled.buffer();</span><br><span class="line">    <span class="comment">// ByteBuf를 생성하고 음의 정수 9개 기록</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">      buf.writeInd(i * -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">      <span class="keyword">new</span> AbsIntegerEncoder());</span><br><span class="line">      <span class="comment">// EmbeddedChannel을 생성하고 테스트할 AbsIntegerEncoder를 추가</span></span><br><span class="line">    assertTrue(channel.writeOutbound(buf));</span><br><span class="line">    <span class="comment">// ByteBuf를 기록하고 readOutbound()가 데이터를 생성하는지 확인</span></span><br><span class="line">    assertTrue(channel.finish());</span><br><span class="line">    <span class="comment">// Channel을 완료로 표시</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성된 값을 읽고 절댓 값을 포함하는지 확인</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">      assertEquals(i, channel.readOutbound());</span><br><span class="line">    &#125;</span><br><span class="line">    assertNull(channel.readOutbound());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>ByteBuf</code>에 4바이트 음의 정수를 기록한다.</li>
<li><code>EmbeddedChannel</code>을 생성하고 여기에 <code>AbsIntegerEncoder</code>를 할당한다.</li>
<li><code>EmbeddedChannel</code>의 <code>writeOutbound()</code>를 호출해 ByteBuf를 기록한다.</li>
<li><code>Channel</code>을 완료로 표시한다.</li>
<li><code>EmbeddedChannel</code>의 아웃바운드 쪽에서 모든 정수를 읽고 절대값만 생성됐는지 확인한다.</li>
</ol>
<br/>

<h2 id="예외-처리-테스트"><a href="#예외-처리-테스트" class="headerlink" title="예외 처리 테스트"></a>예외 처리 테스트</h2><p>데이터 변환외에도 입력이 잘못되거나 데이터가 너무 많은 경우 적절하게 처리해야할 필요가 있다 이런 경우 예외 처리를 따로 해줄 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameChunkDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 인바운드 바이트를 메세지로 디코딩하기 위해 ByteToMessageDecoder를 상속 받음</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxFrameSize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FrameChunkDecoder</span><span class="params">(<span class="keyword">int</span> maxFrameSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.maxFrameSize = maxFrameSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> readableBytes = in.readableBytes();</span><br><span class="line">      <span class="comment">// 생성할 프레임의 최대 허용 길이를 지정</span></span><br><span class="line">      <span class="keyword">if</span> (readableBytes &gt; maxFrameSize) &#123;</span><br><span class="line">        <span class="comment">// 프레임이 너무 큰 경우 폐기하고 TooLongFrameException을 생성함</span></span><br><span class="line">        in.clear();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException();</span><br><span class="line">      &#125;</span><br><span class="line">      ByteBuf buf = in.readBytes(readableBytes);</span><br><span class="line">      <span class="comment">// 그렇지 않은 경우 ByteBuf로부터 새 프레임을 읽음</span></span><br><span class="line">      out.add(buf);</span><br><span class="line">      <span class="comment">// 디코딩된 메세지의 List에 프레임을 추가</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>생성할 프레임의 최대 허용 길이를 설정하고 프레임의 크기가 이것을 넘어갈 경우 초과하는 바이트가 폐기되고 <code>TooLongFrameException</code>이 발생한다. 이 예외는 파이프라인의 <code>다른 ChannelHandler</code>에서 <code>exceptionCaught()</code>를 이용해 처리하거나 무시할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameChunkDecoderTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFrameDecoded</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ByteBuf buf = Unpooled.buffer();</span><br><span class="line">    <span class="comment">// ByteBuf를 생성하고 9바이트를 기록</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">      buf.writeByte(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ByteBuf input = buf.duplicate();</span><br><span class="line"></span><br><span class="line">    EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">      <span class="keyword">new</span> FrameChunkDecoder(<span class="number">3</span>));</span><br><span class="line">      <span class="comment">// EmbeddedChannel을 생성하고 프레임 크기가 3인</span></span><br><span class="line">      <span class="comment">// FixedLengthFrameDecoder를 추가</span></span><br><span class="line"></span><br><span class="line">    assertTrue(channel.writeInbound(input.readBytes(<span class="number">2</span>)));</span><br><span class="line">    <span class="comment">// 2바이트를 기록한 후 새로운 프레임이 생성되는지 확인</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      channel.writeInbound(input.readBytes(<span class="number">4</span>));</span><br><span class="line">      <span class="comment">// 4바이트 프레임을 기록하고 예상되는 TooLongFrameException을 포착</span></span><br><span class="line">      Assert.fail();</span><br><span class="line">      <span class="comment">// 예외가 발생하지 않은 경우 이 메소드가 적용되고 테스트가 실패함</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (TooLongFrameException e)&#123;</span><br><span class="line">      <span class="comment">// 예상된 예외</span></span><br><span class="line">    &#125;</span><br><span class="line">    assertTrue(channel.writeInbound(input.readBytes(<span class="number">3</span>)));</span><br><span class="line">    <span class="comment">// 남은 2바이트를 기록하고 프레임이 올바른지 확인</span></span><br><span class="line">    assertTrue(channel.finish());</span><br><span class="line">    <span class="comment">// Channel을 완료로 표시</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성된 메세지를 읽고 값을 확인함</span></span><br><span class="line">    ByteBuf read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">2</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line"></span><br><span class="line">    read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.skipBytes(<span class="number">4</span>).readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line">    buf.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 코드의 <code>try/catch</code> 블록은 EmbeddedChannel에서 특수하게 작용한다. <code>wrtie*</code> 메소드 중 하나에서 확인된 Exception이 발생하는 경우 이 <code>Exception</code>이 <code>RuntimeException</code>에 래핑된다. 이 방법을 데이터를 처리하는 동안 Exception이 처리됐는지 여부를 쉽게 테스트 할 수 있다. 그리고 이 테스트 방법은 <code>Exception</code>을 생성하는 모든 <code>ChannelHandler</code> 구현에 이용할 수 있다.</p>
<hr>
<ul>
<li>참고 서적<ul>
<li>네티 인 액션</li>
</ul>
</li>
</ul>
<br/>
        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2018-05-24T15:00:00.000Z">2018-05-25</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/server/">Server</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/server/netty/">Netty</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    42 minutes read (About 6260 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2018-05-25-netty-channel-event-and-eventhandler-and-pipeline/">Netty 채널 이벤트와 이벤트핸들러, 그리고 파이프라인</a>
            
        </h1>
        <div class="content">
            <p>Netty의 <code>ChannelPipeline</code>은 <code>Channel</code>에서 발생한 <code>이벤트</code>가 이동하는 통로이다. 이 통로를 통해 이동하는 이벤트를 처리하는 클래스가 <code>이벤트 핸들러</code>이다. 네티의 <code>이벤트 메소드</code>는 데이터가 수신되면 네티가 자동으로 호출한다.</p>
<blockquote>
<p>Netty의 전체적인 구조는 <a href="https://kodakyung.github.io/2018/05/21/old-post-Netty-2018-05-21-Netty-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-Component/">이 게시글</a>을 참고</p>
</blockquote>
<p>자바를 이용한 기존의 서버 프로그래밍은 소켓을 이용하고 데이터가 수신하기를 기다린다. 이와 같은 상황일때 프로세스는 아래와 같다.</p>
<ul>
<li><strong>기존 자바 네트워크 프로그래밍</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 소켓에 데이터가 있는지 확인한다.</span><br><span class="line">2. (1)에서 데이터가 존재하면 데이터를 읽어들이는 메소드를 호출한다.</span><br><span class="line">3. 읽어들일 데이터가 존재하지 않으면 데이터가 도착할 때까지 기다린다.(blocking)</span><br><span class="line">4. 데이터를 기다리는 중에 네트워크가 끊어지면 에러 처리를 위한 메소드를 호출한다.</span><br></pre></td></tr></table></figure>

<p>Netty로 네트워크 프로그래밍을 하면 <code>채널 파이프라인</code>과 <code>이벤트 핸들러</code>로 추상화했기 때문에, <em>데이터의 수신 여부, 소켓의 연결 여부에 대한 예외 상황에서 메소드 호출에 관여할 필요가 없다.</em></p>
<ul>
<li><strong>Netty 네트워크 프로그래밍</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 부트스트랩으로 네트워크 애플리케이션에 필요한 설정을 지정한다.</span><br><span class="line">2. 부트스트랩에 이벤트 핸들러를 사용하여 채널 파이프라인을 구성한다.</span><br><span class="line">3. 이벤트 핸들러의 데이터 수신 이벤트 메소드에서 데이터를 읽어들인다.</span><br><span class="line">4. 이벤트 핸들러의 네트워크 끊김 이벤트 메소드에서 에러 처리를 한다.</span><br></pre></td></tr></table></figure>

<p>위 처럼 네티의 <strong>이벤트 루프가 소켓 채널에서 발생한 이벤트에 해당하는 이벤트 메소드를 자동으로 실행한다.</strong> 소켓 채널에 데이터가 수신된 경우 아래와 같은 프로세스로 동작한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 네티의 이벤트 루프가 채널 파이프라인에 등록된 첫 번째 이벤트 핸들러를 가져온다.</span><br><span class="line">2. 이벤트 핸들러에 데이터 수신 이벤트가 구현되어 있으면 실행한다.</span><br><span class="line">3. 데이터 수신 이벤트 메소드가 구현되어 있지 않으면 다음 이벤트 핸들러를 가져온다.</span><br><span class="line">4. (2)를 수행한다.</span><br><span class="line">5. 채널 파이프라인에 등록된 마지막 이벤트 핸들러에 도달할 때까지 (1)을 반복한다.</span><br></pre></td></tr></table></figure>

<p>데이터를 처리하는 입출력은 네티가 이벤트로 관리하므로 <strong>해당 이벤트에 해당하는 코드만 구현하면 된다.</strong></p>
<br/>

<h1 id="ChannelPipeline-인터페이스"><a href="#ChannelPipeline-인터페이스" class="headerlink" title="ChannelPipeline 인터페이스"></a>ChannelPipeline 인터페이스</h1><p>Netty의 <code>ChannelPipeline</code>은 <code>Channel</code>과 <code>EventHandler</code> 사이에서 연결 통로 역할을 한다. Channel은 일반적인 소켓 프로그래밍의 <code>소켓</code>과 같다. 이 소켓에서 발생한 <code>이벤트</code>는 <code>채널 파이프라인</code>을 따라 흐른다. 그리고 이 <code>이벤트 핸들러</code>가 이벤트들을 수신하고 처리하는 기능을 한다. 하나의 채널 파이프라인에 여러 이벤트 핸들러를 등록할 수 있다. 종합하면 ChannelPipeline은 소켓 채널에서 발생한 이벤트 처리를 위한 추상화 모델이다.</p>
<br/>

<h2 id="ChannelPipeline-구성"><a href="#ChannelPipeline-구성" class="headerlink" title="ChannelPipeline 구성"></a>ChannelPipeline 구성</h2><img alt="channelpipline" src="/images/2018-05-25/01.jpeg">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 클라이언트 연결에 대응하는 소켓 객체를 생성하고 빈 채널 파이프라인 객체를 생성해서 소켓 채널에 할당한다.</span><br><span class="line">2. 소켓 채널에 등록된 ChannelInitializer 인터페이스 구현체를 가져와서 initChannel 메소드를 호출한다.</span><br><span class="line">3. 소켓 채널 참조로부터 (1)에서 등록한 파이프라인 객체를 가져오고 채널 파이프라인에 입력된 이벤트 핸들러 객체를 등록한다.</span><br></pre></td></tr></table></figure>

<p>위의 세 단계가 완료되면 채널이 등록됐다는 이벤트가 발생하고 이때부터 클라이언트와 서버간의 데이터 송수신을 위한 이벤트 처리가 시작된다.</p>
<p><code>ChannelPipeline</code>은 <code>ChannelInboundHandler</code>와 <code>ChannelOutboundHandler</code>가 모두 들어있는 <code>ChannelHandler</code>의 연속이다. 인바운드 이벤트가 트리거 되는 경우 <code>ChannelPipeline</code>의 시작부터 끝까지 전달된다. ChannelPipeline에는 ChannelPipeline 자체를 통해 전파되는 이벤트도 있다.</p>
<p>인바운드와 아웃바운드의 기준은 상대적이며 시작점을 어디로 기준으로 하느냐에 따라 다르다. 파이프라인은 이벤트를 전파하는 동안 파이프라인의 다음 <code>ChannelHandler</code>가 같은 이동 방향인지 확인한다. 그리고 이동방향이 다르면 <code>ChannelPipeline</code>은 방향이 일치하는 항목이 나올 때까지 <code>ChannelHandler</code>를 건너뛴다.</p>
<p>ChannelHandler는 ChannelPipeline에 다른 ChannelHandler를 추가 또는 제거하는 방법으로 ChannelPipeline을 실시간으로 수정할 수 있다. 심지어 자기 자신을 ChannelPipeline에서 제거할 수도 있다.</p>
<ul>
<li><strong>ChannelPipeline을 수정하는 ChannelHandler 메소드</strong></li>
</ul>
<table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>addFirst</td>
<td>ChannelHandler를 ChannelPipeline에 추가한다</td>
</tr>
<tr>
<td>addBefore</td>
<td></td>
</tr>
<tr>
<td>addAfter</td>
<td></td>
</tr>
<tr>
<td>addLast</td>
<td></td>
</tr>
<tr>
<td>remove</td>
<td>ChannelHandler를 ChannelPipeline에서 제거한다.</td>
</tr>
<tr>
<td>replace</td>
<td>ChannelPipeline 내의 ChannelHandler를 다른 ChannelHandler로 대체한다.</td>
</tr>
</tbody></table>
<ul>
<li>ChannelPipeline 수정 예제</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = ..;</span><br><span class="line">FirstHandler firstHandler = <span class="keyword">new</span> FirstHandler();</span><br><span class="line"><span class="comment">// FirstHandler 인스턴스 생성</span></span><br><span class="line">pipeline.addLast(<span class="string">"handler1"</span>, firstHandler);</span><br><span class="line"><span class="comment">// 생성한 인스턴스를 ChannelPipeline에</span></span><br><span class="line"><span class="comment">// "handler1"이라는 이름으로 추가함</span></span><br><span class="line">pipeline.addFirst(<span class="string">"handler2"</span>, <span class="keyword">new</span> SecondHandler());</span><br><span class="line"><span class="comment">// SecondHandler 인스턴스를 ChannelPipeline의</span></span><br><span class="line"><span class="comment">// 첫번째 슬록에 "handler2"라는 이름으로 추가해</span></span><br><span class="line"><span class="comment">// 기존의 "handler1"보다 앞에 배치</span></span><br><span class="line">pipeline.addLast(<span class="string">"handler3"</span>, <span class="keyword">new</span> ThirdHandler());</span><br><span class="line"><span class="comment">// ThirdHandler 인스턴스를 ChannelPipeline의</span></span><br><span class="line"><span class="comment">// 마지막 슬롯에 "handler3"라는 이름으로 추가</span></span><br><span class="line">...</span><br><span class="line">pipeline.remove(<span class="string">"handler3"</span>);</span><br><span class="line"><span class="comment">// 인스턴스 이름으로 지정해 제거</span></span><br><span class="line">pipeline.remove(firstHandler);</span><br><span class="line"><span class="comment">// FirstHandler를 참조해 제거(고유)</span></span><br><span class="line">pipeline.replace(<span class="string">"handler2"</span>, <span class="string">"handler4"</span>, <span class="keyword">new</span> FourthHandler());</span><br><span class="line"><span class="comment">// SecondHandler를 FourthHandler로 대체</span></span><br></pre></td></tr></table></figure>

<p>반면에 ChannelPipeline에서도 ChannelHandler에 접근이 가능하다.</p>
<ul>
<li><strong>ChannelHandler에 접근하는 ChannelPipeline 메소드</strong></li>
</ul>
<table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>get</td>
<td>지정한 형식이나 이름에 해당하는 ChannelHandler를 반환한다.</td>
</tr>
<tr>
<td>context</td>
<td>ChannelHandler에 바인딩된 ChannelHandlerContext를 반환한다.</td>
</tr>
<tr>
<td>names</td>
<td>ChannelPipeline에 포함된 모든 ChannelHandler의 이름을 반환한다.</td>
</tr>
</tbody></table>
<ul>
<li><strong>ChannelPipeline의 인바운드 작업</strong>  </li>
</ul>
<table>
<thead>
<tr>
<th>메소드 이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>fireChannelRegistered</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelRegistered(ChannelHandlerContext)를 호출한다</td>
</tr>
<tr>
<td>fireChannelUnregistered</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelUnregistered(ChannelHandlerContext)를 호출한다.</td>
</tr>
<tr>
<td>fireChannelActive</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelActive(ChannelHandlerContext)를 호출한다.</td>
</tr>
<tr>
<td>fireChannelInactive</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelInactive(ChannelHandlerContext)를 호출한다.</td>
</tr>
<tr>
<td>fireExceptionCaught</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 exceptionCaught(ChannelHandlerContext, Throwable)를 호출한다.</td>
</tr>
<tr>
<td>fireUserEventTriggered</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 userEventTriggered(ChannelHandlerContext, Object)를 호출한다.</td>
</tr>
<tr>
<td>fireChannelRead</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelRead(ChannelHandlerContext, Object msg)를 호출한다.</td>
</tr>
<tr>
<td>fireChannelReadComplete</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelReadComplete(ChannelHandlerContext)를 호출한다.</td>
</tr>
</tbody></table>
<ul>
<li><strong>ChannelPipeline의 아웃바운드 작업</strong>  </li>
</ul>
<table>
<thead>
<tr>
<th>메소드 이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>bind</td>
<td>Channel을 로컬 주소로 바인딩한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 bind(ChannelHandlerContext, SocketAddress, ChannelPromise)를 호출한다.</td>
</tr>
<tr>
<td>connect</td>
<td>Channel을 원격 주소로 연결한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 connect(ChannelHandlerContext, SocketAddress, ChannelPromise)를 호출한다.</td>
</tr>
<tr>
<td>disconnect</td>
<td>Channel 연결을 해제한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 disconnect(ChannelHandlerContext, ChannelPromise)를 호출한다.</td>
</tr>
<tr>
<td>close</td>
<td>Channel을 닫는다. ChannelPipeline의 다음 ChannelOutboundHandler에서 close(ChannelHandlerContext, ChannelPromise)를 호출한다.</td>
</tr>
<tr>
<td>deregister</td>
<td>이전에 할당한 EventExcutor(EventLoop)에서 Channel 등록을 해제한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 deregister(ChannelHandlerContext, ChannelPromise)를 호출한다.</td>
</tr>
<tr>
<td>flush</td>
<td>Channel의 대기 중인 기록을 모두 플러시한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 flush(ChannelHandlerContext)를 호출한다.</td>
</tr>
<tr>
<td>write</td>
<td>Channel에 메세지를 기록한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 write(ChannelHandlerContext, Objectmsg, ChannelPromise)를 호출한다. (기록을 요청하는 것이며 기반 Socket에 바로 메세지를 기록하는 것은 아니다. Socket으로 기록하려면 flush()나 writeAndFlush()를 호출한다.)</td>
</tr>
<tr>
<td>writeAndFlush</td>
<td>write()를 호출한 뒤 flush()를 호출하는 편의 메소드</td>
</tr>
<tr>
<td>read</td>
<td>Channel에서 데이터 읽기를 요청한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 read(ChannelHandlerContext)를 호출한다.</td>
</tr>
</tbody></table>
<br/>

<h1 id="ChannelHandler-인터페이스"><a href="#ChannelHandler-인터페이스" class="headerlink" title="ChannelHandler 인터페이스"></a>ChannelHandler 인터페이스</h1><p><strong>이벤트 핸들러는 네티의 소캣 채널에서 발생한 이벤트를 처리하는 인터페이스다.</strong> 소켓 채널의 이벤트를 인터페이스로 정의하고 이 인터페이스를 상속 받은 이벤트 핸들러를 작성해서 채널 파이프라인에 등록한다. 채널 파이프라인으로 입력되는 이벤트를 이벤트 루프가 가로채어 이벤트에 해당하는 메소드를 수행하는 구조다. 그러므로 <em>네티가 제공하는 이벤트의 종류나 발생 시기를 아는 것이 중요하다.</em></p>
<h2 id="Channel-수명주기"><a href="#Channel-수명주기" class="headerlink" title="Channel 수명주기"></a>Channel 수명주기</h2><table>
<thead>
<tr>
<th>상태</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>ChannelUnregistered</td>
<td>Channel이 생성됐지만 EventLoop에 등록되지 않음</td>
</tr>
<tr>
<td>ChannelRegistered</td>
<td>Channel이 EventLoop에 등록됨</td>
</tr>
<tr>
<td>ChannelActive</td>
<td>Channel이 활성화됨(원격 피어로 연결됨). 이제 데이터 주고받기 가능</td>
</tr>
<tr>
<td>ChannelInactive</td>
<td>Channel이 원격 피어로 연결되지 않음</td>
</tr>
</tbody></table>
<p>일반적인 수명주기는 <code>ChannelRegistered</code> -&gt; <code>ChannelActive</code> -&gt; <code>ChannelInactive</code> -&gt; <code>ChannelUnregistered</code> 순으로 이뤄진다.<br>수명주기 상태 변경이 수행될 때 해당하는 이벤트가 생성된다. 이런 이벤트는 <code>ChannelPipeline</code>에 있는 <code>ChannelHandler</code>로 전달된다.</p>
<h2 id="ChannelHandler-수명주기"><a href="#ChannelHandler-수명주기" class="headerlink" title="ChannelHandler 수명주기"></a>ChannelHandler 수명주기</h2><table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>handlerAdded</td>
<td>ChannelHandler가 ChannelPipeline에 추가될 때 호출</td>
</tr>
<tr>
<td>handlerRemoved</td>
<td>ChannelHandler가 ChannelPipeline에서 제거될 때 호출</td>
</tr>
<tr>
<td>exceptionCaught</td>
<td>ChannelPipeline에서 처리 중에 오류가 발생하면 호출</td>
</tr>
</tbody></table>
<p>위 메소드는 <code>ChannelHandler</code>가 <code>ChannelPipeline</code>에 추가 또는 제거된 후 호출된다. 각 메소드는 <code>ChannelHandlerContext</code> 인수를 받는다.  </p>
<p><code>ChannelHandler</code>는 하위 인터페이스 <code>ChannelInboundHandler</code>와 <code>ChannelOutboundHandler</code>로 나뉜다.</p>
<ul>
<li>ChannelInboundHandler : 모든 유형의 인바운드 데이터와 상태 변경을 처리</li>
<li>ChannelOutboundHandler : 아웃 바운드 데이터를 처리하고 모든 작업의 가로채기를 허용함</li>
</ul>
<br/>

<h2 id="ChannelInboundHandler-인터페이스"><a href="#ChannelInboundHandler-인터페이스" class="headerlink" title="ChannelInboundHandler 인터페이스"></a>ChannelInboundHandler 인터페이스</h2><p>클라이언트가 서버에 접속한 상태에서 서버로 데이터를 보내는 경우, 서버 측에서는 네티가 소켓에 읽을 데이터가 있다는 이벤트를 채널 파이프라인으로 보내게된다. 그러면 채널 파이프라인에 등록된 이벤트 핸들러 중에서 인바운드 이벤트 핸들러가 해당 이벤트에 해당하는 메소드를 수행한다.</p>
<ul>
<li>인바운드 이벤트 발생 순서</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 이벤트 루프에 채널 등록(channelRegistered)</span><br><span class="line">2. 채널 활성화(channelActive)</span><br><span class="line">3. 데이터 수신(channelRead)</span><br><span class="line">4. 데이터 수신 완료(channelReadComplete)</span><br><span class="line">5. 채널 비활성화(channelInactive)</span><br><span class="line">6. 이벤트 루프에서 채널 제거(channelUnregistered)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>channelRegistered</td>
<td>channel이 EventLoop에 등록되고 입출력을 처리할 수 있으면 호출됨</td>
</tr>
<tr>
<td>channelUnregistered</td>
<td>channel이 EventLoop에서 등록 해제되고 입출력을 처리할 수 없으면 호출됨</td>
</tr>
<tr>
<td>channelActive</td>
<td>channel의 연결과 바인딩이 완료되어 활성화되면 호출됨</td>
</tr>
<tr>
<td>channelInactive</td>
<td>channel이 활성 상태에서 벗어나 로컬 피어에 대한 연결이 해제되면 호출됨</td>
</tr>
<tr>
<td>channelReadComplete</td>
<td>channel에서 읽기 작업이 완료되면 호출됨</td>
</tr>
<tr>
<td>channelRead</td>
<td>channel에서 데이터를 읽을 때 호출 됨</td>
</tr>
<tr>
<td>channelWritabilityChanged</td>
<td>channel의 기록 가능 상태가 변경되면 호출된다. OutOfMemoryError를 방지하기 위해서 너무 빠르게 기록되지 않게 하거나 channel이 기록 가능한 상태가 되면 기록을 재개할 수 없다. Channel의 isWritable() 메소드를 호출해 해당 채널의 기록 가능 여부를 감지할 수 있다. 기록 가능 여부를 결정하는 임계값은 Channel.config().setWriteHighWaterMark()와 Channel.config().setWriteLowWaterMark() 메소드로 설정한다.</td>
</tr>
<tr>
<td>userEventTriggered</td>
<td>POJO가 ChannelPipeline을 통해 전달돼서 ChannelInboundHandler.fireUserEventTriggered()가 트리거되면 호출된다.</td>
</tr>
</tbody></table>
<p>위의 메소드들은 데이터가 수신되거나 연결된 Channel의 상태가 변경될 때 호출된다. 이런 메소드들은 <code>Channel의 수명 주기</code>와 관련이 깊다. 이 중 <code>channelRead</code> 메소드를 Override하는 경우 풀링된 ByteBuf 인스턴스의 메모리를 <code>release()</code> 메소드를 사용해 해제 해야한다.</p>
<p>매번 리소스 관리하기가 번거로운 경우 <code>SimpleChannelInboundHandler</code>를 상속받아 <code>channelRead0</code> 메소드를 사용하면 리소스를 해제 할 필요가 없다. 대신 메세지를 참조해 활용하는 경우 이 클래스를 사용하면 안된다.</p>
<ul>
<li>ChannelInboundHandlerAdapter 상속</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">    ReferenceCountUtil.release(msg);</span><br><span class="line">    <span class="comment">// 리소스 해제를 필수적으로 해줘야함</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SimpleChannelInboundHandler 상속</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDiscardHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 리소스를 해제할 필요 없음</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<ul>
<li><strong>서버와 클라이언트의 channelRegistered 발생 위치</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="right">네티 서버</th>
<th align="left">네티 클라이언트</th>
</tr>
</thead>
<tbody><tr>
<td align="right"></td>
<td align="left"><strong>connect() 호출</strong></td>
</tr>
<tr>
<td align="right">생성 및 이벤트 루프 호출</td>
<td align="left">생성 및 이벤트 루프 등록</td>
</tr>
<tr>
<td align="right">[서버 소켓 채널]</td>
<td align="left">[클라이언트 소켓 채널]</td>
</tr>
<tr>
<td align="right"><strong>↓</strong></td>
<td align="left"><strong>↓</strong></td>
</tr>
<tr>
<td align="right"><em>(1)channelRegistered 이벤트</em></td>
<td align="left"><em>(2)channelRegistered 이벤트</em></td>
</tr>
<tr>
<td align="right"><strong>↓</strong></td>
<td align="left"><strong>↓</strong></td>
</tr>
<tr>
<td align="right">연결</td>
<td align="left">요청</td>
</tr>
<tr>
<td align="right">[서버 소켓 채널]<strong>&lt;—–</strong></td>
<td align="left"><strong>—–</strong>[클라이언트 소켓 채널]</td>
</tr>
<tr>
<td align="right"><strong>↓</strong> accept()</td>
<td align="left"></td>
</tr>
<tr>
<td align="right">생성 및 이벤트 루프 등록</td>
<td align="left"></td>
</tr>
<tr>
<td align="right">[클라이언트 소켓 채널]</td>
<td align="left"></td>
</tr>
<tr>
<td align="right"><em>(3)channelRegistered 이벤트</em></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><code>channelRegistered</code> 이벤트는 <strong>(1)과 같은 처음 서버 소켓 채널을 생성할 때</strong>, <strong>(3)과 같이 새로운 클라이언트가 서버에 접속해 클라이언트 소켓 채널이 생성될 때</strong> 발생한다. 즉, 서버 소켓 채널에서 발생한 channelRegistered 이벤트와 서버에 연결된 클라이언트 소켓 채널에서 발생한 channelRegistered 이벤트 2가지다. 클라이언트에서는 <strong>(2)와 같이 서버 접속을 위한 connect 메소드를 수행할 때</strong> channelRegistered 이벤트가 발생한다. 즉 channelRegistered 이벤트는 서버 클라이언트 상관 없이 새로운 채널이 생성되는 시점에 발생한다.</p>
<br/>

<ul>
<li><strong>channelActive 이벤트</strong><br><code>channelActive</code> 이벤트는 channelRegistered 이벤트 이후에 발생한다. 채널이 생성되고 이벤트 루프에 등록된 후 네티 API를 통해 채널 입출력 상태가 가능하다는 것을 알려준다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 서버 어플리케이션에 연결된 클라이언트 갯수 세기</span><br><span class="line">- 서버 애플리케이션에 연결된 클라이언트에게 최초 연결에 대한 메세지 전송</span><br><span class="line">- 클라이언트 어플리케이션이 연결된 서버에 최초 메세지를 전달할 때</span><br><span class="line">- 클라이언트 어플리케이션이 서버에 연결된 상태에 대한 작업이 필요할 때</span><br></pre></td></tr></table></figure>

<p>위의 상황 같이 channelActive 이벤트를 서버 또는 클라이언트가 상대방에 연결한 직후 한번 수행하는 작업을 처리하기에 적합하다.</p>
<br/>

<h2 id="ChannelOutboundHandler-인터페이스"><a href="#ChannelOutboundHandler-인터페이스" class="headerlink" title="ChannelOutboundHandler 인터페이스"></a>ChannelOutboundHandler 인터페이스</h2><p>아웃바운드 이벤트는 소켓 채널에서 발생한 이벤트 중에서 네티 사용자가 요청한 동작에 해당하는 이벤트를 말한다. 연결 요청, 데이터 전송, 소켓 닫기 등이 해당한다. 아웃바운드 이벤트는 <code>ChannelOutboundHandler</code> 인터페이스로 제공되고 모든 <code>ChannelOutboundHandler</code> 이벤트는 <code>ChannelOutboundHandlerContext</code> 객체를 인수로 받는다. ChannelOutboundHandler는 작업이나 이벤트를 지연하는 기능이 있어 정교하게 요청을 처리할 수 있다. 예를 들면 원격 피어에 대한 기록이 일시 중단된 경우 플러시 작업을 지연하고 나중에 재개할 수 있다.</p>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>bind(ChannelHandlerContext, SocketAddress, ChannelPromise)</td>
<td>Channel을 로컬 주소로 바인딩 요청, 서버 소켓 채널이 클라이언트의 연결을 대기하는 IP와 포트가 설정되었을 때 발생. 즉 bind 이벤트에서는 서버 소켓 채널이 사용중인 SocketAddress 객체가 인수로 입력된다.</td>
</tr>
<tr>
<td>connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)</td>
<td>Channel을 원격 피어로 연결 요청 시 호출 됨. 원격지의 SocketAddress 정보와 로컬 SocketAddress 정보가 인수로 입력된다.</td>
</tr>
<tr>
<td>disconnect(ChannelHandlerContext, ChannelPromise)</td>
<td>Channel을 원격 피어로부터 연결 해제 요청시 호출 됨.</td>
</tr>
<tr>
<td>close(ChannelHandlerContext, ChannelPromise)</td>
<td>Channel을 닫는 요청 시 호출 됨</td>
</tr>
<tr>
<td>deregister(ChannelHandlerContext, ChannelPromise)</td>
<td>Channel을 EventLoop에서 등록 해제 요청시 호출됨</td>
</tr>
<tr>
<td>read(ChannelHandlerContext)</td>
<td>Channel에서 데이터 읽기 요청시 호출됨</td>
</tr>
<tr>
<td>flush(ChannelHandlerContext)</td>
<td>Channel을 통해 원격 피어로 큐에 있는 데이터의 플러시 요청시 호출</td>
</tr>
<tr>
<td>write(ChannelHandlerContext, Object, ChannelPromise)</td>
<td>Channel을 통해 원격 피어로 데이터 기록 요청 시 호출됨. 소켓 채널에 기록된 데이터 버퍼가 인수로 입력된다.</td>
</tr>
</tbody></table>
<ul>
<li>ChannelPromise ? ChannelFuture ?  </li>
</ul>
<blockquote>
<p>ChannelOutboundHandler에 있는 대부분 메소드는 작업이 완료되면 알림을 전달받을 ChannelPromise 인수가 있다. ChannelPromise는 ChannelFuture의 하위 인터페이스로 setSuccess()나 setFailure()와 같은 기록 가능 메소드를 정의해서 ChannelFuture을 읽기전용으로 만든다.</p>
</blockquote>
<h3 id="리소스-관리"><a href="#리소스-관리" class="headerlink" title="리소스 관리"></a>리소스 관리</h3><p><code>ChannelInboundHandler.channelRead()</code> 또는 <code>ChannelOutboundHandler.write()</code>를 호출해 데이터를 작업한 경우 리소스 누출이 발생하지 않게 관리해아한다. 네티는 참조 카운팅을 이용해 풀링된 ByteBuf를 관리한다. 따라서 ByteBuf 사용 후 참조 카운트를 조정하는 것이 필요하다.<br>네티가 제공하는 <code>ResourceLeakDetector</code> 클래스를 이용한다.</p>
<ul>
<li>리소스 누출 감지 수준</li>
</ul>
<table>
<thead>
<tr>
<th>수준</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>DISABLED</td>
<td>누출 감지를 비활성화한다. 이 설정은 포괄적인 테스트를 거친 후에만 이용한다.</td>
</tr>
<tr>
<td>SIMPLE</td>
<td>기본 샘플링 비율 1%를 이용해 발견된 누출을 보고한다. 기본 샘플링 비율은 대부분의 경우에 적합하다</td>
</tr>
<tr>
<td>ADVANCED</td>
<td>발견된 누출과 메세지에 접근한 위치를 보고한다. 기본 샘플링 비율을 이용한다</td>
</tr>
<tr>
<td>PARANOID</td>
<td>ADVANCED와 비슷하지만 모든 접근을 샘플링한다. 성능에 큰 영향을 미쳐서 디버깅 단계에서만 사용해야한다.</td>
</tr>
</tbody></table>
<p>자바 시스템 속성을 표에 있는 값 중에 하나로 변경하면 설정할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dio.netty.leakDetectionLevel=ADVANCED</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="ChannelHandlerContext-인터페이스"><a href="#ChannelHandlerContext-인터페이스" class="headerlink" title="ChannelHandlerContext 인터페이스"></a>ChannelHandlerContext 인터페이스</h2><p><code>ChannelHandlerContext</code>는 <code>ChannelHandler</code>와 <code>ChannelPipeline</code>간의 연결을 나타내며 <code>ChannelHandler</code>는 <code>ChannelPipeline</code>에 추가할 때마다 생성된다. <code>ChannelHandlerContext</code>에는 다양한 메소드가 있다.</p>
<p><code>ChannelHandlerContext</code>는 두 가지 네티 객체의 상호작용을 도와주는 인터페이스다. 첫번째는 채널에 대한 입출력 처리이며 두번째는 채널 파이프라인에 대한 상호작용이다.  </p>
<p>첫째 채널에 대한 입출력의 경우 <code>ChannelHandlerContext</code>의 <code>writeAndFlush</code>메소드로 채널에 데이터를 기록하고 <code>close</code> 메소드로 채널의 연결을 종료할 수 있다.    </p>
<p>두번째 파이프라인에 대한 상호작용은 사용자에 의한 이벤트 발생과 채널 파이프라인에 등록된 이벤트 핸들러의 상태가 변경되는 것 두가지가 있다. 파이프라인에는 여러 이벤트 핸들러는 등록할 수 있고 채널이 초기화될 때 채널 파이프라인의 이벤트 핸들러가 설정된다. <code>ChannelHandlerContext</code>는 채널이 초기화될 때 설정된 채널 파이프라인을 가져오는 메소드를 제공한다. 그래서 <code>ChannelHandlerContext</code>를 통해 설정된 채널 파이프라인을 수정할 수 있다.</p>
<br/>

<h2 id="예외-처리"><a href="#예외-처리" class="headerlink" title="예외 처리"></a>예외 처리</h2><h3 id="인바운드-예외-처리"><a href="#인바운드-예외-처리" class="headerlink" title="인바운드 예외 처리"></a>인바운드 예외 처리</h3><p>인바운드 이벤트가 처리되는 동안 예외가 발생하면 실행된 <code>ChannelInboundHandler</code>부터 시작해 예외가 <code>ChannelPipeline</code>을 통과하기 시작한다. 이런 인바운드 예외를 처리하기 위해 <code>exceptionCaught</code> 메소드를 재정의한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure>

<ul>
<li>기본 인바운드 예외 처리<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>모든 인바운드 이벤트는 인바운드 방향으로 진행된다. 예외 또한 마찬가지이다. 따라서 예외 처리 루틴을 채널 파이프라인의 끝부분에 배치하면 채널 파이프라인에 어느 위치에서 예외가 발생하더라도 모두 처리할 수 있다.</p>
<p>예외 대응 방식은 애플리케이션에 따라 다르지만 Channel을 닫거나 복구를 시도하며, 예외처리를 구현하지 않는 경우 관련 내용을 알리는 로깅을 할 수 있다.</p>
<ul>
<li><code>ChannelHandler.exceptionCaught()</code>의 기본 구현은 현재 예외를 다음 파이프라인의 예외로 전달한다.</li>
<li>예외가 파이프라인 끝에 도달하면 예외가 처리되지 않았음을 알리는 항목이 로깅된다.</li>
<li>예외를 처리하는 방식을 원하는대로 하고 싶다면 <code>exceptionCaught()</code>를 재정의한다. 예외를 외부로 전파할지 말지 여부는 개발자가 결정할 수 있다.</li>
</ul>
<h3 id="아웃바운드-예외-처리"><a href="#아웃바운드-예외-처리" class="headerlink" title="아웃바운드 예외 처리"></a>아웃바운드 예외 처리</h3><p>아웃바운드 작업에서 정상적인 완료와 예외 처리하는 옵션은 <code>ChannelFuture</code>를 이용한다.</p>
<ul>
<li>모든 아웃바운드 작업은 <code>ChannelFuture</code>를 반환한다. 작업이 완료되면 <code>ChannelFuture</code>에 등록된 <code>ChannelFutureListener</code>에 성공이나 오류에 대한 알림이 제공된다.</li>
<li><code>ChannelOutboundHandler</code>의 거의 모든 메소드에는 <code>ChannelPromise</code>가 전달된다. <code>ChannelFuture</code>의 하위 클래스인 <code>ChannelPromise</code>에도 비동기 알림을 위한 수신기를 할당할 수 있다. 그리고 <code>ChannelPromise</code>에도 즉시 알림을 지원하는 쓰기 가능 메소드가 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ChannelPromise <span class="title">setSuccess</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelPromise <span class="title">setFailure</span><span class="params">(Throwable cause)</span></span>;</span><br></pre></td></tr></table></figure>

<p>여기서 <code>ChannelFutureListener</code>를 추가하려면 <code>ChannelFuture</code> 인스턴스의 <code>addListener(Channel)</code>을 호출해야하는데 두가지 호출 방법이 있다.</p>
<p>(1) 아웃바운드 작업(write() 등)이 반환하는 <code>ChannelFuture</code>의 <code>addListener()</code>를 호출</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = channel.write(someMessage);</span><br><span class="line">future.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!f.isSuccess())&#123;</span><br><span class="line">      f.cause().printStackTrace();</span><br><span class="line">      f.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>(2) ChannelOutboundHandler 메소드에 인수로 전달되는 <code>ChannelPromise</code>에 <code>ChannelListener</code>를 추가</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutboundExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span></span>&#123;</span><br><span class="line">    promise.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f.isSuccess())&#123;</span><br><span class="line">          f.cause().printStackTrace();</span><br><span class="line">          f.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>예외를 세부적으로 처리하고 싶은 경우 (1)을, 간단하게 예외를 처리하고 싶다면 (2) 구현을 사용하는 것이 좋다.</p>
<br/>

<h2 id="이벤트-실행-흐름"><a href="#이벤트-실행-흐름" class="headerlink" title="이벤트 실행 흐름"></a>이벤트 실행 흐름</h2><p>위의 내용들을 종합해 <code>ChannelPipeline</code>과 <code>ChannelHandler</code>를 통해 이벤트가 실행되는 과정을 알아보자.</p>
<ul>
<li>ChannelPipeline에 여러개의 핸들러 등록</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span>&#123;</span><br><span class="line">        ChannelPipeline p = ch.pipeline();</span><br><span class="line">        p.addLast(<span class="keyword">new</span> EchoServerFirstHandler());</span><br><span class="line">        p.addLast(<span class="keyword">new</span> EchoServerSecondHandler());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ChannelPipeline</code>에 두개의 이벤트 핸들러를 등록했다.</p>
<ul>
<li>FirstHandler 이벤트 핸들러</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerFirstHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">    ByteBuf readMessage = (ByteBuf)msg;</span><br><span class="line">    System.out.println(<span class="string">"channelRead:"</span>+readMessage.toString(Charset.defaultCharset()));</span><br><span class="line">    ctx.write(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>채널 파이프라인에 첫번째로 등록된 이벤트 핸들러. <code>channelRead</code> 이벤트 메소드만 구현했다.</p>
<ul>
<li>SecondHandler 이벤트 핸들러</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerSecondHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"channelReadComplete 발생"</span>);</span><br><span class="line">    ctx.flush();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>채널 파이프라인에 두번째로 등록한 이벤트 핸들러. <code>channelReadComplete</code> 이벤트 메소드와 <code>exceptionCaught</code> 이벤트 메소드를 구현했다.</p>
<ol>
<li>EchoServer에서 클라이언트 채널이 생성되고 해당 채널의 파이프라인에 <code>ChannelActive</code> 이벤트 발생</li>
<li>등록된 2개의 이벤트 핸들러에 ChannelActive 이벤트 메소드가 없어서 ChannelActive 이벤트는 무시됨.</li>
<li>다음으로 <code>channelRead</code> 이벤트가 발생</li>
<li>채널 파이프라인에 등록된 <code>EchoServerFirstHandler</code>의 <code>channelRead</code> 이벤트 메소드가 수행된다.</li>
<li>마지막으로 <code>channelReadComplete</code> 이벤트가 발생하고 <code>EchoServerSecondHandler</code>에 구현된 <code>channelReadComplete</code> 이벤트 메소드가 수행된다.</li>
</ol>
<ul>
<li>즉 여러개의 이벤트 핸들러가 등록되어 있을 때 이벤트에 해당하는 이벤트 메소드만 수행된다.  </li>
</ul>
<h3 id="만약에-여러개의-핸들러가-같은-이벤트를-처리한다면"><a href="#만약에-여러개의-핸들러가-같은-이벤트를-처리한다면" class="headerlink" title="만약에 여러개의 핸들러가 같은 이벤트를 처리한다면 ?"></a>만약에 여러개의 핸들러가 같은 이벤트를 처리한다면 ?</h3><ul>
<li>EchoServerSecondHandler 수정</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> channelRead(ChannelHandlerContext ctx, Object msg)&#123;</span><br><span class="line">  ByteBuf readMessage = (ByteBuf) msg;</span><br><span class="line">  System.out.println(<span class="string">"SecondHandler channelRead:"</span></span><br><span class="line">    +readMessage.toString(Charset.defaultCharset()));</span><br><span class="line">    <span class="comment">// channelRead 이벤트 메소드를 추가</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EchoServerSecondHandler에 EchoServerFirstHandler와 같은 이벤트 메소드인 <code>channelRead</code>를 구현해본 뒤 실행하면 두번째 이벤트 핸들러는 실행되지 않는다. 왜냐하면 이벤트에 해당하는 이벤트 메소드가 첫번째 핸들러에서 수행되면서 이벤트가 사라졌기 때문. 즉 하나의 이벤트는 하나의 이벤트 메소드만 수행한다.</p>
<h3 id="만약에-두번째-이벤트-핸들러의-channelRead-메소드도-수행하고-싶다면"><a href="#만약에-두번째-이벤트-핸들러의-channelRead-메소드도-수행하고-싶다면" class="headerlink" title="만약에 두번째 이벤트 핸들러의 channelRead 메소드도 수행하고 싶다면 ?"></a>만약에 두번째 이벤트 핸들러의 channelRead 메소드도 수행하고 싶다면 ?</h3><ul>
<li>EchoServerFirstHandler 수정</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> channelRead(ChannelHandlerContext ctx, Object msg)&#123;</span><br><span class="line">  ByteBuf readMessage = (ByteBuf) msg;</span><br><span class="line">  System.out.println(<span class="string">"channelRead:"</span>+readMessage.toString(Charset.defaultCharset()));</span><br><span class="line">  ctx.write(msg);</span><br><span class="line">  ctx.fireChannelRead(msg); <span class="comment">// 이 부분을 추가한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음 이벤트 핸들러로 이벤트를 넘겨주기 위해서 <code>ChannelHandlerContext</code>인터페이스를 사용해서 <code>fireChannelRead</code> 메소드를 이용하였다. 이는 채널 파이프라인에 이벤트를 발생시킨다.</p>
<hr>
<ul>
<li>참고 서적<ul>
<li>네티 인 액션</li>
<li>자바 네트워크 소녀 네티  </li>
</ul>
</li>
</ul>
<hr>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2018-05-22T15:00:00.000Z">2018-05-23</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/server/">Server</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/server/netty/">Netty</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    27 minutes read (About 4080 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2018-05-23-netty-datacontainer-bytebuf/">Netty의 데이터 컨테이너(ByteBuf)</a>
            
        </h1>
        <div class="content">
            <p>네트워크 데이터의 기본 단위는 항상 바이트다. Java의 ByteBuffer보다 사용하기 쉬운 Netty의 데이터 컨테이너 <code>ByteBuf</code>에 대해 알아보자.  </p>
<br/>

<h2 id="Java-NIO-ByteBuffer"><a href="#Java-NIO-ByteBuffer" class="headerlink" title="Java NIO ByteBuffer"></a>Java NIO ByteBuffer</h2><p>자바 NIO 바이트 버퍼는 바이트 데이터를 저장하고 읽는 저장소다. 배열을 멤버 변수로 가지고 배열에 대한 읽고 쓰기 메소드를 제공한다. <code>xxxBuffer</code> 형태의 각 데이터별로 버퍼를 제공한다. ByteBuffer는 <code>capacity</code> / <code>position</code> / <code>limit</code> 세가지 속성을 가진다.</p>
<ul>
<li><strong>capacity</strong> : 버퍼에 저장할 수 있는 데이터의 최대 크기. 한번 정하면 바꿀 수 없다. 버퍼를 생성할 때 생성자의 인수로 입력된 값이다.</li>
<li><strong>position</strong> : 읽기 또는 쓰기 작업 중인 위치를 나타낸다. 버퍼 객체가 생성되면 0으로 초기화되고 쓰기(<code>put</code>) 또는 읽기(<code>get</code>) 작업이 수행되면 자동으로 증가한다.</li>
<li><strong>limit</strong> : 읽고 쓸 수 있는 버퍼 공간의 최대치. <code>limit</code> 메소드로 값을 조절할 수 있지만 <code>capacity</code>보다 크게 설정할 수 없다.</li>
</ul>
<br/>

<h2 id="Java-ByteBuffer-생성-및-종류"><a href="#Java-ByteBuffer-생성-및-종류" class="headerlink" title="Java ByteBuffer 생성 및 종류"></a>Java ByteBuffer 생성 및 종류</h2><p>자바의 ByteBuffer는 생성자가 아닌 추상 클래스의 메소드를 통해 생성한다. 아래의 메소드를 이용한다.</p>
<ul>
<li><p><strong>allocate</strong> : JVM 힙 영역에 바이트 버퍼를 생성. 이를 보통 <code>힙 버퍼</code>라고 한다. 인수는 앞에서 설명한 <code>capacity</code> 값에 해당하는 버퍼의 크기이다. 바이트 버퍼의 값은 모두 0으로 초기화된다. 힙 버퍼는 풀링이 사용되지 않는 경우 빠른 할당과 해제 속도를 보여준다.</p>
</li>
<li><p><strong>allocateDirect</strong> : JVM 힙 영역이 아닌 OS의 커널 영역에 바이트 버퍼를 생성한다. 이를 <code>다이렉트 버퍼</code>라고 한다. <code>allocateDirect</code> 메소드는 <code>ByteBuffer</code> 추상 클래스만 사용할 수 있다. 즉 <code>Direct Buffer</code>는 <code>ByteBuffer</code>로만 생성할 수 있다. 다이렉트 버퍼는 힙 버퍼에 비해 생성 시간은 길지만 더 빠른 IO 성능을 제공한다.</p>
<p>전송할 데이터가 힙에 할당된 버퍼에 있는 경우 JVM은 소켓을 통해 데이터를 전송하기 전에 내부적으로 버퍼를 다이렉트 버퍼로 복사한다. 다이렉트 버퍼를 사용하면 이런 오버헤드를 줄일 수 있다. 하지만 다이렉트 버퍼의 데이터에 접근하려면 복사본을 만들어야 접근할 수 있다는 단점이 있다.</p>
</li>
<li><p><strong>wrap</strong> : 입력된 바이트 배열을 이용해 바이트 버퍼를 생성한다. 입력에 사용된 바이트 배열이 변경되면 wrap을 사용해 생성한 바이트 배열의 값도 변경된다.</p>
</li>
</ul>
<br/>

<h2 id="그외-Java-NIO-ByteBuffer의-특징"><a href="#그외-Java-NIO-ByteBuffer의-특징" class="headerlink" title="그외 Java NIO ByteBuffer의 특징"></a>그외 Java NIO ByteBuffer의 특징</h2><ul>
<li>Java ByteBuffer는 읽기 / 쓰기 작업시 같은 <code>position</code>의 값이 바뀐다. 읽기 / 쓰기 인덱스가 분리되어 있지 않아서 작업 전환시 <code>flip()</code> 메소드를 사용해야한다. 그리고 다중 스레드 환경에서 바이트 버퍼를 공유하지 않아야한다.</li>
</ul>
<br/>

<h1 id="Netty-Architecture-Overview"><a href="#Netty-Architecture-Overview" class="headerlink" title="Netty Architecture Overview"></a>Netty Architecture Overview</h1><img alt="Netty Architecture" src="/images/2018-05-23/01.png">

<br/>

<h2 id="Netty-ByteBuf-특징"><a href="#Netty-ByteBuf-특징" class="headerlink" title="Netty ByteBuf 특징"></a>Netty ByteBuf 특징</h2><img width="686" alt="Netty ByteBuf" src="/images/2018-05-23/02.png">

<ul>
<li>별도의 <code>Read Index</code> / <code>Write Index</code>가 있다.</li>
<li>위의 이유로 <code>flip()</code> 메소드를 사용하지 않아도 된다.</li>
<li>가변 바이트 버퍼를 사용할 수 있다.</li>
<li>바이트 버퍼 풀 기능을 제공한다.</li>
<li>복합 버퍼 사용이 가능하다.(<code>Heap</code> + <code>Direct</code>)</li>
<li>Java의 ByteBuffer와 Netty의 ByteBuf의 상호 변환이 가능하다.</li>
</ul>
<br/>

<h2 id="Netty의-ByteBuf-생성"><a href="#Netty의-ByteBuf-생성" class="headerlink" title="Netty의 ByteBuf 생성"></a>Netty의 ByteBuf 생성</h2><p>네티의 바이트 버퍼는 자바의 바이트 버퍼와 다르게 프레임워크 레벨의 바이트 버퍼 풀을 제공하고 이를 통해 생성된 바이트 버퍼를 재사용한다. Netty의 바이트 버퍼를 바이트 버퍼 풀에 할당하려면 <code>ByteBufAllocator</code> 인터페이스를 사용한다. <code>ByteBufAllocator</code>의 하위 추상 구현체인 <code>PooledByteBufAllocator</code> 클래스로 각 바이트 버퍼를 생성한다.</p>
<br/>

<h2 id="Pooled-Unpooled-ByteBuf"><a href="#Pooled-Unpooled-ByteBuf" class="headerlink" title="Pooled / Unpooled ByteBuf"></a>Pooled / Unpooled ByteBuf</h2><p>자바의 바이트 버퍼는 데이터 형에 따른 ByteBuffer 생성을 지원했지만 네티는 풀링 여부로 ByteBuf를 구분한다. <code>Unpooled</code> 클래스와 <code>PooledByteBufAllocator</code> 사용해 생성하고 다이렉트 버퍼와 힙 버퍼를 생성하기 위해 <code>directBuffer</code> 메소드와 <code>heapBuffer</code> 메소드를 사용한다.</p>
<table>
<thead>
<tr>
<th>ByteBuf 종류</th>
<th>풀링 함</th>
<th>풀링 안 함</th>
</tr>
</thead>
<tbody><tr>
<td>힙 버퍼</td>
<td>PooledHeapByteBuf</td>
<td>UnpooledHeapByteBuf</td>
</tr>
<tr>
<td>다이렉트 버퍼</td>
<td>PooledDirectByteBuf</td>
<td>UnpooledDirectByteBuf</td>
</tr>
</tbody></table>
<p><code>PooledByteBufAllocator</code>는 <code>ByteBuf</code> 인스턴스를 풀링해 성능을 개선하고 메모리 단편화를 최소화한다. <code>UnpooledByteBufAllocator</code>는 <code>ByteBuf</code> 인스턴스를 풀링하지 않고 호출될 때마다 새로운 인스턴스를 반환한다.</p>
<table>
<thead>
<tr>
<th>생성 방법</th>
<th>풀링 함</th>
<th>풀링 안 함</th>
</tr>
</thead>
<tbody><tr>
<td>힙 버퍼</td>
<td>ByteBufAllocator.DEFAULT.heapBuffer()</td>
<td>Unpooled.buffer()</td>
</tr>
<tr>
<td>다이렉트 버퍼</td>
<td>ByteBufAllocator.DEFAULT.directBuffer()</td>
<td>Unpooled.directBuffer()</td>
</tr>
</tbody></table>
<ul>
<li><strong>ByteBuf 생성 예</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = Unpooled.buffer(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 바이트 버퍼 풀을 사용하지 않는 11바이트 크기의 힙 버퍼 생성</span></span><br><span class="line">ByteBuf buf = Unpooled.directBuffer(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 바이트 버퍼 풀을 사용하지 않는 11바이트 크기의 다이렉트 버퍼를 생성</span></span><br><span class="line">ByteBuf buf = PooledByteBufAllocator.DEFAULT.heapBuffer(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 풀링된 11바이트 크기의 힙 버퍼 생성</span></span><br><span class="line">ByteBuf buf = PooledByteBufAllocator.DEFAULT.directBuffer(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 풀링된 11바이트 크기의 다이렉트 버퍼 생성</span></span><br></pre></td></tr></table></figure>

<p>크기를 지정하지 않으면 Netty에 지정된 기본 값인 256바이트 크기의 바이트 버퍼가 생성된다.</p>
<br/>

<h2 id="Read-Write"><a href="#Read-Write" class="headerlink" title="Read / Write"></a>Read / Write</h2><p>ByteBuf의 읽을 수 있는 바이트 세그먼트에 실제 데이터가 저장된다. 이때 새로 할당, 래핑, 복사된 버퍼에서 <code>readerIndex</code>의 기본값은 0이다. read나 skip으로 시작하는 모든 메소드는 현재 <code>readerIndex</code> 위치에 있는 데이터를 읽거나 건너 뛰고 읽은 바이트 수 만큼 <code>readerIndex</code>를 증가시킨다.</p>
<p>ByteBuf의 기록할 수 있는 바이트 세그먼트는 정의되지 않은 내용이 들어 있고 기록할 수 있는 영역이다. 새로 할당된 버퍼의 <code>writerIndex</code> 기본값은 0이고 write로 시작하는 모든 메소드는 현재 <code>writerIndex</code> 위치부터 데이터를 기록하고 기록한 만큼 <code>writerIndex</code>를 증가시킨다.</p>
<table>
<thead>
<tr>
<th align="left">readBytes(ByteBuf dest)</th>
<th align="left">인수의 ByteBuf만큼 읽는다</th>
</tr>
</thead>
<tbody><tr>
<td align="left">writeBytes(ByteBuf dest)</td>
<td align="left">인수의 ByteBuf만큼 쓴다.</td>
</tr>
</tbody></table>
<ul>
<li><p>모든 데이터 읽기</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buffer = ...;</span><br><span class="line"><span class="keyword">while</span>(buffer.isReadable())&#123;</span><br><span class="line">  System.out.println(buffer.readByte());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>데이터 기록</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 버퍼의 기록할 수 있는 바이트를 임의의 정수로 채움</span></span><br><span class="line">ByteBuf buffer = ...;</span><br><span class="line"><span class="keyword">while</span>(buffer.writableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">  buffer.writeInt(random.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="읽기-쓰기-작업"><a href="#읽기-쓰기-작업" class="headerlink" title="읽기 / 쓰기 작업"></a>읽기 / 쓰기 작업</h3><p>Netty ByteBuf의 읽기, 쓰기 작업은 두가지로 나뉜다.</p>
<ul>
<li><code>get()</code>, <code>set()</code> 작업은 저장한 인덱스에서 시작하고 인덱스를 변경하지 않는다.</li>
<li><code>read()</code>, <code>write()</code> 작업은 지정한 인덱스에서 시작하고 접근한 바이트 수만큼 인덱스를 증가시킨다.</li>
</ul>
<h4 id="자주-쓰이는-get-작업"><a href="#자주-쓰이는-get-작업" class="headerlink" title="자주 쓰이는 get() 작업"></a>자주 쓰이는 get() 작업</h4><table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>getBoolean(int)</td>
<td>지정한 인덱스의 Boolean 값을 반환</td>
</tr>
<tr>
<td>getByte(int)</td>
<td>지정한 인덱스의 바이트를 반환</td>
</tr>
<tr>
<td>getUnsignedByte(int)</td>
<td>지정한 인덱스의 부호 없는 바이트 값을 short로 반환</td>
</tr>
<tr>
<td>getMedium(int)</td>
<td>지정한 인덱스의 24비트 미디엄 int값을 반환</td>
</tr>
<tr>
<td>getUnsignedMedium(int)</td>
<td>지정한 인덱스의 부호 없는 24비트 미디엄 int 값을 반환</td>
</tr>
<tr>
<td>getInt(int)</td>
<td>지정한 인덱스의 int값을 반환</td>
</tr>
<tr>
<td>getUnsignedInt(int)</td>
<td>지정한 인덱스의 부호 없는 int값을 long으로 반환</td>
</tr>
<tr>
<td>getLong(int)</td>
<td>지정한 인덱스의 long 값을 반환</td>
</tr>
</tbody></table>
<h4 id="자주-쓰이는-set-작업"><a href="#자주-쓰이는-set-작업" class="headerlink" title="자주 쓰이는 set() 작업"></a>자주 쓰이는 set() 작업</h4><table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>setBoolean(int, boolean)</td>
<td>지정한 인덱스의 Boolean 값을 설정</td>
</tr>
<tr>
<td>setByte(int index, int value)</td>
<td>지정한 인덱스의 바이트 값을 설정</td>
</tr>
<tr>
<td>setMedium(int index, int value)</td>
<td>지정한 인덱스의 24비트 미디엄 값을 설정</td>
</tr>
<tr>
<td>setInt(int index, int value)</td>
<td>지정한 인덱스의 int 값을 설정</td>
</tr>
<tr>
<td>setLong(int index, long value)</td>
<td>지정한 인덱스의 long 값을 설정</td>
</tr>
<tr>
<td>setShort(int index, int value)</td>
<td>지정한 인덱스의 short 값을 설정</td>
</tr>
</tbody></table>
<ul>
<li>get()/set() 예제<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Charset utf8 = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Netty !"</span>, utf8);</span><br><span class="line">System.out.println((<span class="keyword">char</span>)buf.getByte(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// 첫번째 문자 'N' 출력</span></span><br><span class="line"><span class="keyword">int</span> readerIndex = buf.readerIndex();</span><br><span class="line"><span class="keyword">int</span> writerIndex = buf.writerIndex();</span><br><span class="line"><span class="comment">// 현재 인덱스들을 저장</span></span><br><span class="line">buf.setByte(<span class="number">0</span>, (<span class="keyword">byte</span>)<span class="string">'B'</span>);</span><br><span class="line"><span class="comment">// 인덱스 0에 있는 바이트를 문자'B'로 변경</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>)buf.getByte(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// 첫번째 문자 'B'를 출력</span></span><br><span class="line"><span class="keyword">assert</span> readerIndex = buf.readerIndex();</span><br><span class="line"><span class="keyword">assert</span> writerIndex = buf.writerIndex();</span><br><span class="line"><span class="comment">// 인덱스가 바뀌지 않았으므로 성공</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="자주-쓰이는-read-작업"><a href="#자주-쓰이는-read-작업" class="headerlink" title="자주 쓰이는 read() 작업"></a>자주 쓰이는 read() 작업</h4><table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>readBoolean()</td>
<td>현재 readerIndex 위치의 Boolean 값을 반환하고 readerIndex를 1만큼 증가시킨다</td>
</tr>
<tr>
<td>readByte()</td>
<td>현재 readerIndex 위치의 바이트 값을 반환하고 readerIndex를 1만큼 증가시킨다</td>
</tr>
<tr>
<td>readUnsignedByte()</td>
<td>현재 readerIndex 위치의 short 값을 반환하고 readerIndex를 1만큼 증가시킨다</td>
</tr>
<tr>
<td>readMedium()</td>
<td>현재 readerIndex 위치의 24비트 미디엄 값을 반환하고 readerIndex를 3만큼 증가시킨다</td>
</tr>
<tr>
<td>readUnsignedMedium()</td>
<td>현재 readerIndex 위치의 부호 없는 24비트 미디엄 값을 반환하고 readerIndex를 3만큼 증가시킨다</td>
</tr>
<tr>
<td>readInt()</td>
<td>현재 readerIndex 위치의 int값을 반환하고 readerIndex를 4만큼 증가시킨다</td>
</tr>
<tr>
<td>readUnsignedInt()</td>
<td>현재 readerIndex 위치의 부호 없는 int값을 long으로 반환하고 readerIndex를 4만큼 증가시킨다</td>
</tr>
<tr>
<td>readLong()</td>
<td>현재 readerIndex 위치의 long 값을 반환하고 readerIndex를 8만큼 증가시킨다</td>
</tr>
<tr>
<td>readShort()</td>
<td>현재 readerIndex 위치의 short 값을 반환하고 readerIndex를 2만큼 증가시킨다</td>
</tr>
<tr>
<td>readUnsignedShort()</td>
<td>현재 readerIndex 위치의 부호 없는 short값을 int로 반환하고 readerIndex를 2만큼 증가시킨다</td>
</tr>
<tr>
<td>readBytes(ByteBuf | byte[] destination, int dstIndex [,int length])</td>
<td>현재 ByteBuf의 현재 readerIndex로부터 시작하는 바이트를 (length가 지정된 경우 length 바이트 만큼) 대상 ByteBuf또는 byte[]의 대상 dstIndex로부터 전송한다. 로컬 readerIndex는 전송된 바이트 수만큼 증가한다.</td>
</tr>
</tbody></table>
<h4 id="자주-쓰이는-write-작업"><a href="#자주-쓰이는-write-작업" class="headerlink" title="자주 쓰이는 write() 작업"></a>자주 쓰이는 write() 작업</h4><table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>writeBoolean(boolean)</td>
<td>현재 writerIndex 위치에 Boolean값을 기록하고 writerIndex를 1만큼 증가시킨다</td>
</tr>
<tr>
<td>writeByte(int)</td>
<td>현재 writerIndex 위치에 바이트 값을 기록하고 writerIndex를 1만큼 증가시킨다</td>
</tr>
<tr>
<td>writeMedium(int)</td>
<td>현재 writerIndex 위치에 미디엄 값을 기록하고 writerIndex를 3만큼 증가시킨다</td>
</tr>
<tr>
<td>writeInt(int)</td>
<td>현재 writerIndex 위치에 int 값을 기록하고 writerIndex를 4만큼 증가시킨다</td>
</tr>
<tr>
<td>writeLong(long)</td>
<td>현재 writerIndex 위치에 long값을 기록하고 writerIndex를 8만큼 증가시킨다</td>
</tr>
<tr>
<td>writeShort(int)</td>
<td>현재 writerIndex 위치에 short값을 기록하고 writerIndex를 2만큼 증가시킨다</td>
</tr>
<tr>
<td>writeBytes(source ByteBuf | byte[] [, int srcIndex, int length])</td>
<td>지정된 원본(ByteBuf 또는 byte[])의 현재 writerIndex부터 데이터 전송을 시작한다. srcIndex와 length가 지정된 경우 srcIndex부터 시작해 length 바이트 만큼 읽는다. 현재 writerIndex는 기록된 바이트 수만큼 증가한다</td>
</tr>
</tbody></table>
<ul>
<li>read()/write() 예제<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Charset utf8 = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Netty !"</span>, utf8);</span><br><span class="line"><span class="comment">// 지정한 문자열의 바이트를 저장하는 ByteBuf 생성</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>)buf.readByte());</span><br><span class="line"><span class="comment">// 첫번째 문자 'N'을 출력</span></span><br><span class="line"><span class="keyword">int</span> readerIndex = buf.readerIndex();</span><br><span class="line"><span class="keyword">int</span> writerIndex = buf.writerIndex();</span><br><span class="line"><span class="comment">// 현재 readerIndex/writerIndex 를 저장</span></span><br><span class="line">buf.writeByte((<span class="keyword">byte</span>)<span class="string">'?'</span>);</span><br><span class="line"><span class="comment">// 버퍼에 '?'를 추가</span></span><br><span class="line"><span class="keyword">assert</span> readerIndex == buf.readerIndex();</span><br><span class="line"><span class="keyword">assert</span> writerIndex != buf.writerIndex();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="기타-유용한-메소드"><a href="#기타-유용한-메소드" class="headerlink" title="기타 유용한 메소드"></a>기타 유용한 메소드</h4><table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>isReadable()</td>
<td>읽을 수 있는 바이트가 하나 이상이면 true를 반환</td>
</tr>
<tr>
<td>isWritable()</td>
<td>기록할 수 있는 바이트가 하나 이상이면 true를 반환</td>
</tr>
<tr>
<td>readableBytes()</td>
<td>읽을 수 있는 바이트 수를 반환</td>
</tr>
<tr>
<td>writableBytes()</td>
<td>기록할 수 있는 바이트 수를 반환</td>
</tr>
<tr>
<td>capacity()</td>
<td>ByteBuf가 저장할 수 있는 바이트 수를 반환한다. 이 수를 초과하면 maxCapacity()에 도달할 때까지 용량이 확장된다.</td>
</tr>
<tr>
<td>maxCapacity()</td>
<td>ByteBuf가 저장할 수 있는 최대 바이트 수를 반환</td>
</tr>
<tr>
<td>hasArray()</td>
<td>ByteBuf에 힙 버퍼가 있는 경우 true를 반환</td>
</tr>
<tr>
<td>array()</td>
<td>ByteBuf에 힙 버퍼가 있는 경우 해당 바이트 배열을 반환하며, 그렇지 않으면 <code>UnsupportedOperationException</code>을 발생시킨다.</td>
</tr>
</tbody></table>
<br/>

<h2 id="ByteBufAllocator"><a href="#ByteBufAllocator" class="headerlink" title="ByteBufAllocator"></a>ByteBufAllocator</h2><p>자바 바이트 버퍼는 언어 자체에서 제공하는 버퍼 풀이 없다. 따라서 바이트 버퍼 풀을 이용하려면 객체 풀링을 제공하는 서드파티 라이브러리를 사용하거나 직접 구현해야한다. 네티는 프레임 워크에서 바이트 버퍼 풀을 제공하고 있으며 다이렉트 버퍼와 힙 버퍼를 모두 풀링할 수 있다. 네티의 바이트 버퍼 풀링은 <code>ByteBufAllocator</code>를 사용해 바이트 버퍼를 생성할 때 자동으로 수행된다.</p>
<p><code>ByteBufAllocator</code>의 참조는 <code>Channel</code>에서 얻거나 <code>ChannelHandler</code>에 바인딩 된 <code>ChannelHandlerContext</code>를 통해 얻을 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">ByteBufAllocator allocator = channel.alloc()</span><br><span class="line"><span class="comment">// Channel에서 ByteBufAllocator를 얻음</span></span><br><span class="line">...</span><br><span class="line">ChannelHandlerContext ctx = ...;</span><br><span class="line">ByteBufAllocator allocator2 = ctx.alloc();</span><br><span class="line"><span class="comment">// ChannelHandlerContext에서 ByteBufAllocator를 얻음</span></span><br><span class="line">...</span><br><span class="line">ByteBuf newBuffer = ByteBufAllocator.buffer();</span><br><span class="line"><span class="comment">// ByteBufAllocator의 buffer 메소드를 사용해 생성된 바이트 버퍼</span></span><br><span class="line"><span class="comment">// 똑같이 ByteBufAllocator에서 관리된다.</span></span><br><span class="line"><span class="comment">// 바이트 버퍼를 채널에 기록하거나 명시적으로 release 호출 시 바이트 버퍼 풀로 돌아간다.</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// new Buffer 사용</span></span><br><span class="line">ctx.write(msg);</span><br><span class="line"><span class="comment">// write 메소드 인수로 바이트 버퍼가 입력되면 데이터를 채널에 기록하고 난 뒤 버퍼 풀로 돌아간다.</span></span><br></pre></td></tr></table></figure>

<h3 id="풀링되지-않은-버퍼"><a href="#풀링되지-않은-버퍼" class="headerlink" title="풀링되지 않은 버퍼"></a>풀링되지 않은 버퍼</h3><p><code>ByteBufAllocator</code>의 참조가 없는 경우, 네티는 풀링되지 않는 ByteBuf 인스턴스를 생성하는 정적 도우미 메서드 <code>Unpooled</code> 클래스를 제공한다.</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>buffer</td>
<td>풀링되지 않은 힙 기반 ByteBuf 반환</td>
</tr>
<tr>
<td>directBuffer</td>
<td>풀링되지 않은 다이렉트 ByteBuf 반환</td>
</tr>
<tr>
<td>wrappedBuffer</td>
<td>지정한 데이터를 래핑하는 ByteBuf 반환</td>
</tr>
<tr>
<td>copiedBuffer</td>
<td>지정한 데이터를 복사하는 ByteBuf 반환</td>
</tr>
</tbody></table>
<p>Unpooled 클래스는 다른 네티 컴포넌트가 필요 없는 네트워킹과 무관한 프로젝트에 ByteBuf를 제공해 확정성 높은 고성능 버퍼 API를 이용할 수 있게 해준다.</p>
<h3 id="참조-카운팅"><a href="#참조-카운팅" class="headerlink" title="참조 카운팅"></a>참조 카운팅</h3><p>네티는 바이트 버퍼를 풀링하기 위해 바이트 버퍼에 참조수를 기록한다. <code>ReferenceCountUtil</code> 클래스에 정의된 <code>retain</code> 메소드와 <code>release</code> 메소드를 사용할 수 있다 <code>retain</code> 메소드는 참조 수를 증가시키고 <code>release</code> 메소드는 참조 수를 감소 시키고 할당된 메모리가 해제 된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">ByteBufAllocator allocator = channel.alloc();</span><br><span class="line"><span class="comment">// channel에서 ByteBufAllocator를 얻음</span></span><br><span class="line">....</span><br><span class="line">ByteBuf buffer = allocator.directBuffer();</span><br><span class="line"><span class="comment">// ByteBufAllocator로부터 ByteBuf를 할당</span></span><br><span class="line"><span class="keyword">assert</span> buffer.refCnt() = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 참조 카운트가 1인지 확인</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">boolean</span> released = buffer.release();</span><br><span class="line"><span class="comment">// 객체에 대한 참조 카운트를 감소 시킴</span></span><br><span class="line"><span class="comment">// 참조 카운트가 0이 되면 객체가 해제되고 메소드가 true를 반환한다.</span></span><br></pre></td></tr></table></figure>

<p>참조 카운트가 0일 때 <code>release()</code>를 호출하면 <code>IllegalReferenceCountException</code>이 발생한다.<br>참조 해제는 각 객체가 새로 정의할 수 있다. 예를 들면 클래스의 <code>release()</code> 구현에서 참조 카운트를 현재 값과 상관 없이 0으로 설정하면 모든 활성 참조를 일시에 해제할 수 있다.</p>
<br/>

<h2 id="기타-작업"><a href="#기타-작업" class="headerlink" title="기타 작업"></a>기타 작업</h2><h3 id="부호-없는-값-읽기"><a href="#부호-없는-값-읽기" class="headerlink" title="부호 없는 값 읽기"></a>부호 없는 값 읽기</h3><p>자바는 부호 없는 데이터 형이 없어서 네티에서는 부호 없는 데이터를 처리하기 위한 메소드를 제공한다. 네티에서는 부호 없는 데이터를 읽을 때 읽을 데이터보다 큰 데이터 형에 할당한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf = Unpooled.buffer(<span class="number">11</span>);</span><br><span class="line">buf.writeShort(-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 빈 바이트 버퍼에 음수 -1 기록 (2byte)</span></span><br><span class="line"></span><br><span class="line">assertEquals(<span class="number">65535</span>, buf.getUnsignedShort(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// -1은 16진수 표기법으로 0xFFFF이고 이를 부호 없는 정수로 표현하면 65535가 된다.</span></span><br><span class="line"><span class="comment">// 이를 4byte로 저장한다.</span></span><br><span class="line"><span class="comment">// getUnsignedShort 메소드로 바이트 버퍼에 저장된 0번째 바이트부터 2바이트 읽어서</span></span><br><span class="line"><span class="comment">// 4바이트 데이터인 int로 읽어들이면 65535가 된다.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>부호 없는 데이터 지원 메소드</li>
</ul>
<table>
<thead>
<tr>
<th>메소드</th>
<th>원본 데이터형</th>
<th>리턴 데이터형</th>
</tr>
</thead>
<tbody><tr>
<td>getUnsignedByte</td>
<td>byte</td>
<td>short</td>
</tr>
<tr>
<td>getUnsignedShort</td>
<td>short</td>
<td>int</td>
</tr>
<tr>
<td>getUnsignedMedium</td>
<td>medium</td>
<td>int</td>
</tr>
<tr>
<td>getUnsignedInt</td>
<td>int</td>
<td>long</td>
</tr>
</tbody></table>
<h3 id="엔디안-변환"><a href="#엔디안-변환" class="headerlink" title="엔디안 변환"></a>엔디안 변환</h3><p>네티의 바이트 버퍼의 기본 엔디안은 자바와 동일하게 <code>빅엔디안</code>이다. <code>리틀 엔디안</code> 바이트 버퍼가 필요한 경우를 <code>order</code> 메소드로 엔디안을 변환할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = Unpooled.buffer();</span><br><span class="line">...</span><br><span class="line">ByteBuf lettleEndianBuf = buf.order(ByteOrder.LITTLE_ENDIAN);</span><br></pre></td></tr></table></figure>

<p><code>order</code> 메소드로 생성한 바이트 버퍼는 새로운 바이트 버퍼가 아닌 주어진 바이트 버퍼의 내용을 공유하는 <code>파생 버퍼</code>이다. 기존 바이트 버퍼의 배열과 인덱스들을 공유한다. 즉 내용은 같지만 리틀 엔디안으로 접근하는 바이트 버퍼를 생성한다.</p>
<hr>
<ul>
<li>참고 서적<ul>
<li>네티 인 액션</li>
<li>자바 네트워크 소녀 Netty</li>
</ul>
</li>
</ul>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2018-05-21T15:00:00.000Z">2018-05-22</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/server/">Server</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/server/netty/">Netty</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    17 minutes read (About 2553 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2018-05-22-netty-network-transport-api/">Netty Network Transport API</a>
            
        </h1>
        <div class="content">
            <p>Netty가 기본 제공하는 <code>Network Transport API</code> 구현과 사용법에 대해 알아보자.</p>
<p>실제 네트워크 프로그래밍을 하다보면 예상보다 많은 동시 접속을 지원해야하는데, 이때 <code>blocking</code> 프로그래밍을 했다면 <code>non-blocking</code>으로 바꿔야하는 상황이 생긴다. 기존 자바를 이용한 네트워크 프로그래밍은 블로킹 전송과 논블로킹 전송의 API 차이가 있어서 변경이 쉽지 않았다. 반면에 네티는 공통 API를 사용하기 때문에 변환이 훨씬 간단하다.  </p>
<br/>

<h2 id="Netty-OIO-블로킹-전송"><a href="#Netty-OIO-블로킹-전송" class="headerlink" title="Netty OIO 블로킹 전송"></a>Netty OIO 블로킹 전송</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OioServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(</span><br><span class="line">      Unpooled.copiedBuffer(<span class="string">"Hi!\r\n"</span>,</span><br><span class="line">      Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> OioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      <span class="comment">// ServerBootstrap 생성</span></span><br><span class="line">      b.group(group).channel(OioServerSocketChannel.class)</span><br><span class="line">      <span class="comment">// OioEventLoopGroup을 이용해 블로킹 모드를 허용함(OIO)</span></span><br><span class="line">        .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">          <span class="comment">// 연결이 수락될 때마다 호출 ChannelIntializer를 지정</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">              <span class="comment">// 이벤트를 가로채고 처리할 ChannelInboundHandlerAdapter를 추가</span></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">              </span>&#123;</span><br><span class="line">                ctx.writeAndFlush(buf.duplicate())</span><br><span class="line">                  .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">                <span class="comment">// 클라이언트로 메세지를 출력하고 ChannelFutureListener를 추가해</span></span><br><span class="line">                <span class="comment">// 메세지가 출력되면 연결을 닫음</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      ChannelFuture f = b.bind().sync();</span><br><span class="line">      <span class="comment">// 서버를 바인딩해 연결을 수락</span></span><br><span class="line">      f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">        <span class="comment">// 모든 리소스를 해제</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://kodakyung.github.io/2018/05/11/old-post-Netty-2018-05-11-Maven%EC%9C%BC%EB%A1%9C-Netty-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/">이전 게시글</a>의 <code>start()</code> 메소드 부분이다.</p>
<br/>

<h2 id="Netty-NIO-비동기-전송"><a href="#Netty-NIO-비동기-전송" class="headerlink" title="Netty NIO 비동기 전송"></a>Netty NIO 비동기 전송</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Hi!\r\n"</span>, Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="comment">// 논블로킹 모드를 위해 NioEventLoopGroup을 사용</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      <span class="comment">// ServerBootstrap 생성</span></span><br><span class="line">      b.group(group).channel(NioServerSocketChannel.class)</span><br><span class="line">        .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">          <span class="comment">// 연결이 수락될 때마다 호출 ChannelIntializer를 지정</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">              <span class="comment">// 이벤트를 가로채고 처리할 ChannelInboundHandlerAdapter를 추가</span></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">              </span>&#123;</span><br><span class="line">                ctx.writeAndFlush(buf.duplicate())</span><br><span class="line">                  .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">                <span class="comment">// 클라이언트로 메세지를 출력하고 ChannelFutureListener를 추가해</span></span><br><span class="line">                <span class="comment">// 메세지가 출력되면 연결을 닫음</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      ChannelFuture f = b.bind().sync();</span><br><span class="line">      <span class="comment">// 서버를 바인딩해 연결을 수락</span></span><br><span class="line">      f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">        <span class="comment">// 모든 리소스를 해제</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">...</span><br><span class="line">b.group(group).channel(NioServerSocketChannel.class) ...</span><br></pre></td></tr></table></figure>

<p>위 두줄을 제외하면 NioServer는 OioServer와 흡사하다. Netty는 어떤 방식을 선택해도 모든 Network Transport의 구현에 동일한 API를 사용하므로 전송 형식을 변경해도 코드는 거의 영향을 받지 않는다. <em>즉, 모든 구현이 <code>Channel</code>, <code>ChannelPipeline</code>, <code>ChannelHandler</code> 인터페이스 기준으로 정의된다.</em></p>
<br/>

<h2 id="Network-Transport-API"><a href="#Network-Transport-API" class="headerlink" title="Network Transport API"></a>Network Transport API</h2><ul>
<li><code>Channel</code> 인터페이스는 모든 입출력 작업에 이용되는 전송 API의 핵심이다.</li>
<li>Channel은 <code>Network Socket</code> 또는 <code>read</code>, <code>write</code>, <code>connect</code>, <code>bind</code>와 같은 I/O 작업에 대한 연결고리이다.</li>
</ul>
<img width="619" alt="Interface Channel1" src="/images/2018-05-22/01.png">

<p>Channel 인터페이스는 <code>AttributeMap</code>과 <code>java.lang.Comparable</code>을 SuperInterface로 둔다. 그리고 하위 인터페이스로 <code>ServerChannel</code>, <code>AbstractChannel</code> 등이 있다. 이는 Channel의 고유한 정렬 순서를 보장하기 위해서이며, AbstractChannel의 <code>compareTo()</code> 메소드로 두 Channel 인스턴스를 비교할 수 있다.</p>
<img width="612" alt="Interface Channel2" src="/images/2018-05-22/02.png">

<p>Channel 인터페이스는 채널의 현재 상태, 채널의 구성 파라미터(<code>ChannelConfig</code>), 채널이 지원하는 I/O작업, I/O 이벤트 및 요청을 처리하는 <code>ChannelPipeline</code>을 제공한다. (<em>자세한 내용은 <a href="http://netty.io/4.0/api/io/netty/channel/Channel.html">이 곳</a> 참고</em>)</p>
<p><code>ChannelPipeline</code>은 인바운드와 아웃바운드 데이터와 이벤트에 적용될 <code>ChannelHandler</code> 인스턴스를 포함한다. 이런 <code>ChannelHandler</code>는 애플리케이션의 상태 변경과 데이터 처리를 담당한다.</p>
<ul>
<li><strong>ChannelHandler의 일반적인 용도</strong><ul>
<li>데이터를 다른 포맷으로 변환</li>
<li>예외 알림 제공</li>
<li>Channel의 활성화 또는 비활성화에 대한 알림 제공</li>
<li>Channel을 EventLoop에 등록/해제할 때 알림 제공</li>
<li>사용자 정의 이벤트에 대해 알림 제공</li>
</ul>
</li>
</ul>
<p><code>Pipeline</code>은 유닉스 파이프와 같이 <code>Intercepting Filter</code> 구조이며, 여러 명령이 체인으로 연결되고 한 명령의 출력이 다음 명령의 입력이 된다.</p>
<br/>

<h2 id="Channel의-메소드"><a href="#Channel의-메소드" class="headerlink" title="Channel의 메소드"></a>Channel의 메소드</h2><table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>eventLoop</td>
<td>Channel에 할당된 EventLoop를 반환</td>
</tr>
<tr>
<td>pipeline</td>
<td>Channel에 할당된 ChannelPipeline을 반환</td>
</tr>
<tr>
<td>isActive</td>
<td>Channel이 활성 상태일 때 true 반환. 활성의 의미는 기본 전송에 따라 달라진다. 예를 들어 Socket은 원격 피어로 연결되면 활성 상태지만, Datagram 전송은 열리면 활성 상태다.</td>
</tr>
<tr>
<td>localAddress</td>
<td>로컬 SocketAddress를 반환</td>
</tr>
<tr>
<td>remoteAddress</td>
<td>원격 SocketAddress를 반환</td>
</tr>
<tr>
<td>write</td>
<td>데이터를 원격 피어로 출력. 이 때 데이터는 ChannelPipeline으로 전달되고, flush 되기 전까지 큐에 저장된다.</td>
</tr>
<tr>
<td>flush</td>
<td>기반 전송으로 이전에 출력된 데이터를 flush 한다.</td>
</tr>
<tr>
<td>writeAndFlush</td>
<td>write()와 flush()를 모두 호출</td>
</tr>
</tbody></table>
<p>Netty가 제공하는 기능들은 소수의 인터페이스를 통해 사용이 가능하기 때문에 코드를 전반적으로 리팩토링하지 않아도 애플리케이션 리팩토링을 쉽게 할 수 있다.</p>
<br/>

<h2 id="네티가-제공하는-전송"><a href="#네티가-제공하는-전송" class="headerlink" title="네티가 제공하는 전송"></a>네티가 제공하는 전송</h2><p>Netty는 바로 사용할 수 있는 여러 전송을 기본적으로 제공하는데, 이런 전송이 모든 프로토콜을 지원하는 것은 아니다. 따라서 <strong>애플리케이션에서 이용하는 프로토콜과 호환되는 전송을 선택</strong>해야한다.</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>패키지</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>NIO</td>
<td>io.netty.channel.socket.io</td>
<td>java.nio.channels 패키지를 기반으로 이용(셀렉터 기반 방식)</td>
</tr>
<tr>
<td>Epoll</td>
<td>io.netty.channel.epoll</td>
<td>epoll()과 논블로킹 입출력을 위해 JNI를 이용함. 이 전송은 SO_REUSEPORT와 마찬가지로 리눅스에서만 이용 가능하며, NIO 전송보다 빠르고 완전한 논블로킹.</td>
</tr>
<tr>
<td>OIO</td>
<td>io.netty.channel.socket.oio</td>
<td>java.net 패키지를 기반으로 이용(블로킹 스트림 이용)</td>
</tr>
<tr>
<td>로컬(Local)</td>
<td>io.netty.channel.local</td>
<td>VM에서 파이프를 통해 통신하는데 이용되는 로컬 전송</td>
</tr>
<tr>
<td>임베디드(Embedded)</td>
<td>io.netty.channel.embedded</td>
<td>실제 네트워크 전송 없이 ChannelHandler를 이용할 수 있게 해주는 임베디드 전송. ChannelHandler 구현을 테스트하는데 유용하다.</td>
</tr>
</tbody></table>
<h3 id="NIO-논블로킹-입출력"><a href="#NIO-논블로킹-입출력" class="headerlink" title="NIO 논블로킹 입출력"></a>NIO 논블로킹 입출력</h3><p>NIO는 모든 입출력 작업에서 완전한 비동기 구현을 제공한다. Netty의 NIO는 JDK의 Selector 기반 API를 사용한다.</p>
<p><code>Selector</code>는 아래와 같은 Channel의 상태가 변경되면 알림을 받을 수 있는 역할을 한다.</p>
<ul>
<li>새로운 Channel이 수락되고 준비됨</li>
<li>Channel 연결이 완료됨</li>
<li>Channel에 읽을 데이터가 있음</li>
<li>Channel을 이용해 데이터를 기록할 수 있음</li>
</ul>
<p><code>java.nio.channels.SelectionKey</code> 클래스에 정의된 상수 패턴으로 애플리케이션의 상태 변경을 지정할 수 있다.</p>
<table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>OP_ACCEPT</td>
<td>새로운 연결이 수락되고 Channel이 생성되면 알림</td>
</tr>
<tr>
<td>OP_CONNECT</td>
<td>연결되면 알림</td>
</tr>
<tr>
<td>OP_READ</td>
<td>Channel에서 데이터를 읽을 수 있으면 알림</td>
</tr>
<tr>
<td>OP_WRITE</td>
<td>Channel로 데이터를 기록할 수 있으면 알림. 소켓 버퍼가 완전히 차는 상황을 처리한다. 이런 상황은 원격 피어의 능력보다 데이터가 더 자주 전송될 때 흔히 발생함</td>
</tr>
</tbody></table>
<p><strong>NIO의 내부 흐름은 아래와 같다.</strong></p>
<ol>
<li>새로운 채널을 셀렉터에 등록</li>
<li>셀렉터가 상태 변경을 알림(등록)</li>
<li>셀렉터에는 이전에 등록한 채널들이 존재함</li>
<li>상태 변경이 수신되거나 제한 시간이 경과할 때까지 <code>Selector.select()</code>가 차단</li>
<li>상태 변경이 있는지 검사</li>
<li>상태 변경이 있으면 모든 상태 변경을 처리</li>
<li>(5)에서 상태 변경이 없거나 (6)이 완료된 후<br>셀렉터가 실행되는 동일한 스레드에서 다른 작업을 실행</li>
</ol>
<p>이러한 과정은 Netty의 사용자 수준 API에 숨겨진다.</p>
<h3 id="Epoll-리눅스용-네이티브-논블로킹-전송"><a href="#Epoll-리눅스용-네이티브-논블로킹-전송" class="headerlink" title="Epoll 리눅스용 네이티브 논블로킹 전송"></a>Epoll 리눅스용 네이티브 논블로킹 전송</h3><p>고성능 네트워킹 플랫폼으로써 성능 향상을 위해 리눅스 기반의 Epoll API가 발전하였다. 고부하 조건에서 JDK의 NIO구현보다 성능이 훨씬 우수하다. 사용법은 NIO 대신 epoll로 바꾸면 된다.</p>
<ul>
<li>제로 카피(Zero-copy)  </li>
</ul>
<blockquote>
<p>제로 카피는 NIO와 Epoll 전송에서만 이용가능한 기능이다. 파일 시스템의 데이터를 커널 공간에서 사용자 공간으로 복사하는 과정을 생략해 빠르고 효과적으로 네트워크로 이동할 수 있게 해준다. 모든 운영체제에서 이 기능을 지원하는 것은 아니다.</p>
</blockquote>
<h3 id="OIO-기존-블로킹-입출력"><a href="#OIO-기존-블로킹-입출력" class="headerlink" title="OIO 기존 블로킹 입출력"></a>OIO 기존 블로킹 입출력</h3><p>Netty의 OIO는 <code>java.net</code>의 블로킹 구현에 기반을 두어서 비동기 방식은 아니지만 블로킹 방식의 레거시 코드를 이식해야하는 경우 쓰인다. 우선 Netty의 OIO 전송을 이용하고 다음에 NIO 전송으로 바꿀 수 있다.</p>
<br/>

<h2 id="로컬-전송"><a href="#로컬-전송" class="headerlink" title="로컬 전송"></a>로컬 전송</h2><p>Netty는 동일한 JVM 내에서 실행되는 클라이언트와 서버간 비동기 통신을 위한 로컬 전송을 제공한다.<br>이 전송에서 <code>서버 Channel</code>과 연결되는 <code>SocketAddress</code>는 실제 네트워크 주소에 바인딩되지 않고 서버가 실행되는 동안 레지스트리에 저장되고, Channel이 닫히면 레지스트리에서 등록이 해제된다.</p>
<br/>

<h2 id="임베디드-전송-ChannelHandler-테스트"><a href="#임베디드-전송-ChannelHandler-테스트" class="headerlink" title="임베디드 전송(ChannelHandler 테스트)"></a>임베디드 전송(ChannelHandler 테스트)</h2><p>Netty는 <code>ChannelHandler</code>를 다른 ChannelHandler 안에 도우미 클래스로 넣을 수 있는 임베디드 전송을 제공한다. 이 방식을 이용하면 내부 코드를 수정하지 않고 ChannelHandler의 기능을 확장할 수 있다. 이 기능을 통해 단위 테스트를 진행할 수 있다.</p>
<br/>

<hr>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul>
<li><a href="https://homoefficio.github.io/2016/08/06/Java-NIO는-생각만큼-non-blocking-하지-않다/">Java NIO는 생각만큼 non-blocking 하지 않다</a></li>
<li><a href="http://jakarta.tistory.com/91">왜 Java NIO는 사용하기 힘든가?</a></li>
</ul>
<br/>
        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2018-05-20T15:00:00.000Z">2018-05-21</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/server/">Server</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/server/netty/">Netty</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    13 minutes read (About 1916 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2018-05-21-netty-component/">Netty 컴포넌트(Component)</a>
            
        </h1>
        <div class="content">
            <p>Netty의 Component <code>Channel</code>, <code>EventLoop</code>, <code>ChannelFuture</code>, <code>ChannelHandler</code>, <code>ChannelPipeline</code>, <code>Bootstrap</code>에 대해 알아보자.  </p>
<br>

<h3 id="Q-컴포넌트-Component-란"><a href="#Q-컴포넌트-Component-란" class="headerlink" title="Q 컴포넌트(Component)란?"></a>Q 컴포넌트(Component)란?</h3><blockquote>
<p>독립적인 소프트웨어 모듈을 의미하며,<br>  간단히 말하면 유저가 사용하는 시스템에 대한 조작 장치를 의미한다.</p>
</blockquote>
<br/>

<h1 id="Netty-Architecture-Overview"><a href="#Netty-Architecture-Overview" class="headerlink" title="Netty Architecture Overview"></a>Netty Architecture Overview</h1><img width="573" alt="Netty Architecture" src="/images/2018-05-21/01.png">

<p>위 다이어그램의 <strong>Extensible Event Model / Universal Communication API</strong> 에 해당하는 Netty Component를 알아보자.</p>
<br/>

<h1 id="Channel-EventLoop-ChannelFuture"><a href="#Channel-EventLoop-ChannelFuture" class="headerlink" title="Channel / EventLoop / ChannelFuture"></a>Channel / EventLoop / ChannelFuture</h1><p>: Netty의 네트워킹 추상화를 담당한 컴포넌트</p>
<h2 id="Channel-인터페이스"><a href="#Channel-인터페이스" class="headerlink" title="Channel 인터페이스"></a>Channel 인터페이스</h2><p><code>Channel</code>은 간단히 말하면 <strong>소켓(Socket)을 컨트롤</strong> 하는 인터페이스. 자바 기반 네트워크는 기본적으로 <code>Socket</code> 클래스를 사용한다. 기본 입출력 작업인 <code>bind()</code>, <code>connect()</code>, <code>read()</code>, <code>write()</code>는 자바의 기본형을 이용하지만 Netty의 API를 통해 덜 복잡하게 작업할 수 있다. <code>Channel</code>은 Netty의 비동기 I/O 인터페이스이다. 그 외에도 <code>Channel</code>은 다수의 미리 정의된 특수한 구현을 포함한 광범위한 클래스 계층의 루트이다.</p>
<ul>
<li><code>EmbeddedChannel</code></li>
<li><code>LocalServerChannel</code></li>
<li><code>NioDatagramChannel</code></li>
<li><code>NioSctpChannel</code></li>
<li><code>NioSocketChannel</code></li>
<li>…</li>
</ul>
<h2 id="EventLoop-인터페이스"><a href="#EventLoop-인터페이스" class="headerlink" title="EventLoop 인터페이스"></a>EventLoop 인터페이스</h2><p>제어 흐름, 멀티스레딩, 동시성 제어를 담당한 인터페이스. <strong>연결의 수명주기 중 발생하는 이벤트를 처리</strong> 하는 Netty의 핵심 추상화이다. <code>EventLoop</code>, <code>Thread</code>, <code>EventLoopGroup</code>의 관계는 다음과 같다.  </p>
<ul>
<li>한 <code>EventLoopGroup</code>은 하나 이상의 <code>EventLoop</code>를 포함한다.</li>
<li>한 <code>EventLoop</code>는 수명주기 동안 한 <code>Thread</code>로 바인딩된다.</li>
<li>한 <code>EventLoop</code>에서 처리되는 모든 입출력 이벤트는 전용 <code>Thread</code>에서 처리한다.</li>
<li>한 <code>Channel</code>은 수명주기 동안 한 <code>EventLoop</code>에 등록할 수 있다.</li>
<li>한 <code>EventLoop</code>를 하나 이상의 <code>Channel</code>로 할당할 수 있다.</li>
</ul>
<img alt="Netty Eventloop" src="/images/2018-05-21/02.jpeg">

<h2 id="ChannelFuture-인터페이스"><a href="#ChannelFuture-인터페이스" class="headerlink" title="ChannelFuture 인터페이스"></a>ChannelFuture 인터페이스</h2><p><strong>비동기 알림</strong>을 담당하는 인터페이스. Netty는 모든 입출력 작업이 비동기적이다. 즉 작업이 바로 반환되지 않아서 나중에 결과를 확인하는 방법이 필요하다. <code>ChannelFuture</code>의 <code>addListener()</code>는 작업이 완료되면 알림을 받을 <code>ChannelFutureListener</code>를 하나 등록한다.</p>
<br/>

<h1 id="ChannelHandler-ChannelPipeline"><a href="#ChannelHandler-ChannelPipeline" class="headerlink" title="ChannelHandler / ChannelPipeline"></a>ChannelHandler / ChannelPipeline</h1><p>: 데이터 흐름을 관리하고 애플리케이션 처리 논리를 실행하는 컴포넌트.</p>
<h2 id="ChannelHandler-인터페이스"><a href="#ChannelHandler-인터페이스" class="headerlink" title="ChannelHandler 인터페이스"></a>ChannelHandler 인터페이스</h2><p>인바운드와 아웃바운드 데이터의 처리에 적용되는 모든 애플리케이션 논리의 <strong>컨테이너</strong> 역할을 담당. <code>ChannelHandler</code>의 메소드는 네트워크 이벤트(광범위한 의미)에 의해 트리거되는데, 그때 <em>거의 모든 종류의 작업</em> 에 활용할 수 있다. <code>ChannelPipeline</code>을 통해 오가는 이벤트(데이터 포함)를 처리하는 모든 코드를 위한 범용 컨테이너이다. <a href="https://koda93.github.io/Maven으로-Netty-프로젝트-시작하기/">이전 게시글</a>에서 사용한 <code>ChannelInboundHandler</code>는 <code>ChannelHandler</code>로부터 파생된 것이다.</p>
<h2 id="ChannelPipeline-인터페이스"><a href="#ChannelPipeline-인터페이스" class="headerlink" title="ChannelPipeline 인터페이스"></a>ChannelPipeline 인터페이스</h2><p><code>ChannelHandler</code> 체인을 위한 컨테이너를 제공하며, 체인 상에서 인바운드와 아웃바운드 이벤트를 전파하는 API를 정의한다. <code>Channel</code>이 생성되면 여기에 자동으로 자체적인 <code>ChannelPipeline</code>이 할당된다. <code>ChannelHandler</code>는 <code>ChannelPipeline</code> 안에 설치된다.</p>
<ul>
<li><code>ChannelInitializer</code> 구현은 <code>ServerBootstrap</code>에 등록된다.</li>
<li><code>ChannelInitializer.initChannel()</code>이 호출되면 <code>ChannelInitializer</code>가 <code>ChannelHandler</code>의 커스텀 집합을 파이프라인에 설치한다.</li>
<li><code>ChannelInitializer</code>는 <code>ChannelPipeline</code>에서 자신을 제거한다.</li>
</ul>
<p>파이프라인을 통해 이벤트를 이동하는 역할은 애플리케이션의 부트스트랩 단계나 초기화 중에 설치된 <code>ChannelHandler</code>가 담당한다. <code>ChannelHandler</code>들은 이벤트를 수신하고, 구현된 처리 논리를 실행하고 체인 상의 다음 핸들러로 데이터를 전달한다. 실행되는 순서는 추가된 순서에 의해 결정된다.</p>
<img alt="Netty pipline" src="/images/2018-05-21/03.jpeg">

<p>인바운드와 아웃바운드 핸들러를 동일한 파이프라인에 설치할 수 있으며, 메세지나 다른 인바운드 이벤트를 읽을 때 파이프라인 앞쪽부터 시작해 첫번째 <code>ChannelInboundHandler</code>로 전달된다. 데이터를 처리한 후 체인 상의 다음 <code>ChannelInboundHandler</code>로 데이터를 전달한다. 최종적으로 데이터가 파이프라인의 뒤쪽에 도착하면 모든 처리가 종료된다. 아웃바운드의 경우도 동일하고, 데이터가 네트워크 전송에 도달하면 끝난다.</p>
<h2 id="ChannelHandler의-하위-클래스"><a href="#ChannelHandler의-하위-클래스" class="headerlink" title="ChannelHandler의 하위 클래스"></a>ChannelHandler의 하위 클래스</h2><p><code>ChannelHandler</code>는 다양한 작업에 사용되기 때문에 종류가 많으며, 각 기능은 상위 클래스가 무엇이냐에 따라 달려있다. Netty는 어댑터 클래스 형태로 여러 기본 핸들러 구현을 제공한다. 이러한 <em>어댑터 클래스 및 해당 상위 클래스가 기본적인 작업을 자동</em>으로 해주므로 <em>특수한 동작이 필요한 메소드와 이벤트만 재정의</em>해서 사용하면된다. 이런식으로 <code>커스텀 ChannelHandler</code>를 쉽게 작성할 수 있다.</p>
<ul>
<li>커스텀 ChannelHandler를 만들 때 자주 사용할 어댑터 클래스<ul>
<li><code>ChannelHandlerAdapter</code></li>
<li><code>ChannelInboundHandlerAdapter</code></li>
<li><code>ChannelOutboundHandlerAdapter</code></li>
<li><code>ChannelDuplexHandlerAdapter</code></li>
</ul>
</li>
</ul>
<h3 id="Encoder-Decoder"><a href="#Encoder-Decoder" class="headerlink" title="Encoder / Decoder"></a>Encoder / Decoder</h3><p>네트워크 데이터는 반드시 연속된 바이트 형태여야 하기 때문에 네트워크로 데이터를 송신/수신하는 경우 데이터를 변환해야한다. 인바운드 메세지는 바이트에서 다른 포맷(보통 자바 객체)으로 변환되는 디코딩을 거치며, 아웃바운드 메세지는 반대로 현재 포맷에서 바이트로 인코딩 된다.</p>
<p>Netty가 제공하는 모든 인코더/디코더 어댑터 클래스는 <code>ChannelInboundHandler</code>나 <code>ChannelInboundHandler</code>를 <code>implements</code> 한다. 인바운드 데이터의 경우 인바운드 <code>Channel</code>에서 읽는 각 메세지에 대해 호출되는 <code>channelRead</code> 메소드/이벤트를 재정의하고, 이 메소드는 제공된 디코더의 <code>decode()</code> 메소드를 호출한 뒤 디코딩된 바이트를 파이프라인의 다음 <code>ChannelInboundHandler</code>로 전달한다. 아웃바인드 데이터는 반대이다.</p>
<br/>

<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><p>: Netty의 <code>Bootstrap</code> 클래스는 애플리케이션의 <strong>네트워크 레이어를 구성하는 컨테이너</strong>이다. 프로세스를 지정한 포트로 바인딩하거나 프로세스를 지정된 호스트의 지정된 포트에서 실행 중인 다른 호스트로 연결하는 등의 일을 한다.</p>
<p><code>Bootstrap</code>은 클라이언트용(<code>Bootstrap</code>)과 서버용(<code>ServerBootstrap</code>) 두가지가 있다. 애플리케이션이 사용하는 프로토콜, 데이터 처리 유형과는 상관없이 수행하는 기능에 따라 어떤 클래스를 사용할지 결정한다.</p>
<table>
<thead>
<tr>
<th align="center">범주</th>
<th align="center">Bootstrap</th>
<th align="center">ServerBootstrap</th>
</tr>
</thead>
<tbody><tr>
<td align="center">네트워크 기능</td>
<td align="center">원격 호스트와 포트로 연결</td>
<td align="center">로컬 포트로 바인딩</td>
</tr>
<tr>
<td align="center">EventLoopGroup의 수</td>
<td align="center">1</td>
<td align="center">2</td>
</tr>
</tbody></table>
<p>서버는 연결 요청을 수신해야 하므로 포트로 바인딩하는 <code>ServerBootstrap</code>을 이용하지만, 클라이언트는 원격 피어로 연결해야 하므로 <code>Bootstrap</code>을 이용한다.</p>
<p>서버를 부트스트랩할 때는 <code>EventLoopGroup</code>이 두개 필요하다. 하나는 서버의 수신 소켓을 나타내는 <code>ServerChannel</code>이 포함되어있다. 두번째는 서버가 수락한 연결마다 하나씩 들어오는 클라이언트 연결을 처리하기 위해 생성된 모든 <code>Channel</code>을 포함한다.</p>
<p><code>ServerChannel</code>과 연결된 <code>EventLoopGroup</code>은 들어오는 연결 요청에 대해 <code>Channel</code>을 생성해 <code>EventLoop</code>에 하나 할당한다. 연결이 수락되면 두 번째 <code>EventLoopGroup</code>이 해당 <code>Channel</code>에 <code>EventLoop</code>를 할당한다.</p>
<br/>
        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2018-05-10T15:00:00.000Z">2018-05-11</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/server/">Server</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/server/netty/">Netty</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    13 minutes read (About 2011 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2018-05-11-start-a-netty-project-with-maven/">Maven으로 Netty 프로젝트 시작하기</a>
            
        </h1>
        <div class="content">
            <p>Netty 프로젝트를 시작하려면 우선 Netty 라이브러리를 설치해야한다. 직접 .jar 파일을 다운받아 추가하는 방법이 있고 Maven을 이용해 라이브러리를 받을 수 있다. 여기서는 Maven을 통해 라이브러리를 설치해 프로젝트를 시작해본다.<br/></p>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><blockquote>
<p>Maven은 아파치에서 개발된 소프트웨어 프로젝트 관리 도구이다. 소스 코드 관리, 라이브러리 의존성, 빌드, 테스트, 리포트, 프로젝트 배포 같은 소프트웨어 생명주기를 관리한다. 프로젝트를 진행하는데 라이브러리 갯수가 수십개가 넘어가면 코드 작성보다 설정 변경이 어렵게 되는데 이런 작업들을 자동화해준다.</p>
</blockquote>
<br/>

<p>Maven을 따로 설치해 CLI 환경에서 프로젝트를 진행할 수 있지만 우선은 따로 설치하지 않고 Maven이 내장된 <a href="https://spring.io/tools">STS(Spring Tool Suite)</a>을 이용하였다.</p>
<br/>

<ul>
<li>Maven 프로젝트를 생성해준다.<img width="325" alt="Maven project 생성" src="/images/2018-05-11/01.png">

</li>
</ul>
<br/>

<ul>
<li><p><code>groupId</code>와 <code>artifactId</code>를 입력해 프로젝트를 생성한다.</p>
<img width="614" alt="Maven project groupId, artifactId 설정" src="/images/2018-05-11/02.png">

<ul>
<li><code>groupId</code> :<br>메이븐 프로젝트를 생성한 조직이나 회사 등을 나타내는 유일한 이름. 주로 자바 패키지명 작성하는 형식과 동일하게 작성하고 필수항목이다.</li>
<li><code>artifactId</code> :<br>여기서 입력한 값이 프로젝트 명이 된다. 소스 코드가 포함된 프로젝트의 루트 폴더명이 된다.</li>
</ul>
</li>
</ul>
<br/>

<ul>
<li>메이븐 설정파일인 pom.xml을 수정해 Netty를 설치한다.  </li>
</ul>
<p>메이븐 설정파일을 수정하면 해당하는 라이브러리를 자동으로 설치한다. 메이븐 설정에 사용되는 의존성 설정은 <a href="http://mvnrepository.com/artifact/io.netty">메이븐 레포지터리 홈페이지</a>에 라이브러리 버전별로 기술되어 있다.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.0.28.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<br/>

<img width="318" alt="Maven project 생성" src="/images/2018-05-11/03.png">
Netty가 Maven Dependencies에 추가되었다.

<br/>

<h3 id="EchoServerHandler-java"><a href="#EchoServerHandler-java" class="headerlink" title="EchoServerHandler.java"></a>EchoServerHandler.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>@Sharable</code> : <code>ChannelHandler</code>를 여러 채널간에 안전하게 공유할 수 있음을 나타냄</li>
<li><code>ChannelInboundHandlerAdapter</code> : 간단한 프로젝트이므로 <code>ChannelInboundHandler</code>의 기본 구현을 제공하는 하위클래스 <code>ChannelInboundHandlerAdapter</code>로 구현한다. 해당 API는 손쉽게 각 메소드를 재정의해 이벤트 수명기에서 원하는 시점을 후크할 수 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">  ByteBuf in = (ByteBuf) msg;</span><br><span class="line">  System.out.println(<span class="string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">  <span class="comment">// 메세지 콘솔 로깅</span></span><br><span class="line">  ctx.write(in);</span><br><span class="line">  <span class="comment">// 아웃바운드 메세지를 플러시하지 않은 채로 받은 메세지를 발신자로 출력</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>channelRead()</code> : 메시지가 들어올 때마다 호출되는 함수. 여기서는 수신한 데이터를 모두 처리하기위해 재정의했다. 이 서버는 받은 데이터를 발신자에게 다시 보낸다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span></span>&#123;</span><br><span class="line">  ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">  .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  <span class="comment">// 대기 중인 메세지를 원격 피어로 플러시하고 채널을 닫음</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>channelReadComplete()</code> : <code>channelRead()</code>의 마지막 호출에서 현재 일괄 처리의 마지막 메세지를 처리했음을 알려준다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">  cause.printStackTrace(); <span class="comment">// 예외 스택 추적을 출력</span></span><br><span class="line">  ctx.close(); <span class="comment">// 채널 닫음</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exceptionCaught()</code> : 읽기 작업 중 예외 발생하면 호출된다.</p>
<br/>

<h3 id="EchoServer-java"><a href="#EchoServer-java" class="headerlink" title="EchoServer.java"></a>EchoServer.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(args.length != <span class="number">1</span>)&#123;</span><br><span class="line">    System.err.println(<span class="string">"Usage: "</span>+ EchoServer.class.getSimpleName() + <span class="string">"&lt;port&gt;"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// port 값을 설정</span></span><br><span class="line">  <span class="keyword">new</span> EchoServer(port).start();</span><br><span class="line">  <span class="comment">// 서버의 start() 메소드 호출</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;port&gt;</code>를 받은 뒤 서버의 <code>start()</code>를 호출한다.</p>
<br/>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">  EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">  <span class="comment">// EventLoopGroup 생성</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    <span class="comment">// ServerBootstrap 생성</span></span><br><span class="line">    b.group(group)</span><br><span class="line">      .channel(NioServerSocketChannel.class)</span><br><span class="line">      <span class="comment">// NIO 전송 채널 이용</span></span><br><span class="line">      .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">      <span class="comment">// 지정된 포트를 이용해 소켓 주소 설정</span></span><br><span class="line">      .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				ch.pipeline().addLast(serverHandler);</span><br><span class="line">        <span class="comment">// @Shareble 이므로 EchoServerHandler 이용 가능</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      ChannelFuture f = b.bind().sync();</span><br><span class="line">      <span class="comment">// 서버를 비동기 식으로 바인딩, sync()는 바인딩이 완료되기를 대기</span></span><br><span class="line">      <span class="comment">// sync()로 인해 블로킹 된다.</span></span><br><span class="line">      f.channel().closeFuture().sync();</span><br><span class="line">      <span class="comment">// 채널의 CloseFuture를 얻고 완료될 때까지 현재 스레드를 블로킹</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">      <span class="comment">// EventLoopGroup을 종료하고 모든 리소스 해제</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ChannelInitializer</code>를 이용해 새로운 연결을 수락한 후 새로운 자식 Channel을 생성한다. <code>ChannelInitializer</code>가 <code>EchoServerHandler</code>의 하나를 Channel의 <code>ChannelPipeline</code>으로 추가한다. 이 핸들러는 인바인드 메세지에 대한 알림을 받는다.</p>
<ul>
<li><code>EchoServerHandler</code>는 비즈니스 논리를 구현</li>
<li><code>main()</code> 메소드는 서버를 부트스트랩 함<ul>
<li><strong>부트스트랩 ?</strong> 서버를 구성하는 시동 코드를 의미. 최소한 서버가 연결 요청을 수신하는 포트를 서버와 바인딩하는 코드가 있어야함.<ol>
<li>서버를 부트스트랩하고 바인딩하는데 이용할 <code>ServerBootstrap</code> 인스턴스 생성</li>
<li>새로운 연결 수락 및 데이터 R/W와 같은 이벤트 처리를 수행할 <code>NioEventLoopGroup</code> 인스턴스를 생성하고 할당한다.</li>
<li>서버가 바인딩하는 로컬 <code>InetSocketAddress</code>를 지정.</li>
<li><code>EchoServerHandler</code> 인스턴스를 이용해 새로운 각 Channel을 초기화한다.</li>
<li><code>ServerBootstrap.bind()</code>를 호출해 서버를 바인딩</li>
</ol>
</li>
</ul>
</li>
</ul>
<br/>

<p>client도 똑같이 Maven 프로젝트 생성 후 pom.xml 설정을 해준다.</p>
<h3 id="EchoClientHanlder-java"><a href="#EchoClientHanlder-java" class="headerlink" title="EchoClientHanlder.java"></a>EchoClientHanlder.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>데이터를 처리하는 <code>ChannelInboundHandler</code>의 하위 클래스인 <code>SimpleChannelInboundHandler</code>를 상속받아 작업을 처리한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 채널 활성화 알림을 받으면 메세지를 전송</span></span><br><span class="line">  ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Netty Start!"</span>, CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>channelActive()</code>: 서버에 대한 연결이 만들어지면 호출된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 수신한 메세지의 덤프를 로깅</span></span><br><span class="line">  System.out.println(<span class="string">"Client received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>channelRead0()</code>: 서버로부터 메세지를 수신하면 호출된다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 예외 시 오류를 로깅하고 채널을 닫음</span></span><br><span class="line">  cause.printStackTrace();</span><br><span class="line">  ctx.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exceptionCaught</code>: 처리 중 예외가 발생하면 호출된다.</p>
<br/>

<h3 id="EchoClient-java"><a href="#EchoClient-java" class="headerlink" title="EchoClient.java"></a>EchoClient.java</h3><p>클라이언트 부트스트랩 코드</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    <span class="comment">// bootstrap을 생성</span></span><br><span class="line">    b.group(group)</span><br><span class="line">    <span class="comment">// 클라이언트 이벤트를 처리할 EventLoopGroup 지정, NIO 구현</span></span><br><span class="line">      .channel(NioSocketChannel.class)</span><br><span class="line">      <span class="comment">// 채널 유형으로 NIO 지정</span></span><br><span class="line">      .remoteAddress(<span class="keyword">new</span> InetSocketAddress(host, port))</span><br><span class="line">      <span class="comment">// 서버의 InitSocketAddress 설정</span></span><br><span class="line">      .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">        <span class="comment">// 채널이 생성될 때 파이프라인에 EchoClientHandler 하나를 추가</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          ch.pipeline().addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ChannelFuture f = b.connect().sync();</span><br><span class="line">    <span class="comment">// 원격 피어로 연결하고 연결이 완료되기를 기다림</span></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">    <span class="comment">// 채널이 닫힐 때 까지 블로킹</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    group.shutdownGracefully().sync();</span><br><span class="line">    <span class="comment">// 스레드 풀을 종료하고 모든 리소스 해제</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>클라이언트를 초기화하기 위한 <code>Bootstrap</code> 인스턴스를 생성한다.</li>
<li>새로운 연결을 생성하고 인바운드와 아웃바운드 데이터를 처리하는 것을 포함하는 이벤트 처리를 제어할 <code>NioEventLoopGroup</code> 인스턴스를 만들고 할당한다.</li>
<li>서버로 연결하기 위한 <code>InetSocketAddress</code>를 생성한다.</li>
<li>연결이 만들어지면 파이프라인에 <code>EchoClientHandler</code> 하나를 추가한다.</li>
<li>모든 준비가 완료되면 <code>Bootstrap.connect()</code>를 호출해 원격 서버로 연결한다.</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(args.length != <span class="number">2</span>)&#123;</span><br><span class="line">    System.err.println(</span><br><span class="line">        <span class="string">"Usage: "</span> + EchoClient.class.getSimpleName() + <span class="string">" &lt;host&gt; &lt;port&gt;"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String host = args[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">new</span> EchoClient(host, port).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br/>

<ul>
<li>실행하기 전 [Maven install]을 진행한다.<img width="328" alt="Maven install" src="/images/2018-05-11/04.png">
<img width="715" alt="Maven install success" src="/images/2018-05-11/05.png">

</li>
</ul>
<br/>

<ul>
<li><p>[Run Configuration]에서 서버 실행시 <code>&lt;Port&gt;</code>를 전달해준다.</p>
<img width="212" alt="Run Configuration" src="/images/2018-05-11/06.png">
<img width="589" alt="Run Configuration Port 설정" src="/images/2018-05-11/07.png">
</li>
<li><p>서버 실행 후 클라이언트는 <code>&lt;Host&gt; &lt;Port&gt;</code> 번호를 전달한다.</p>
<img width="588" alt="Run Configuration client 설정" src="/images/2018-05-11/08.png">

</li>
</ul>
<br/>

<p>클라이언트가 실행되면 서버로 메세지를 보내고, 서버는 받은 메세지를 그대로 출력한 뒤 다시 클라이언트로 메세지를 보낸다. 클라이언트는 <code>channelRead0</code> 메소드를 통해 메세지를 받아서 다시 출력한다.</p>
<br/>

<ul>
<li>Server Console 출력<img width="214" alt="Server Console" src="/images/2018-05-11/09.png"></li>
<li>Client Console 출력<img width="214" alt="Client Console" src="/images/2018-05-11/10.png">

</li>
</ul>
<hr>
<p>자세한 소스코드는 <a href="https://github.com/koda93/TIL/tree/master/Netty/">여기</a>를 참조</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2018-05-08T15:00:00.000Z">2018-05-09</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/server/">Server</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/server/netty/">Netty</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    7 minutes read (About 1006 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2018-05-09-netty-features-architecture/">Netty 특징과 아키텍처</a>
            
        </h1>
        <div class="content">
            <h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><blockquote>
<p>네티는 유지 관리가 용이한 고성능 프로토콜 서버와 클라이언트를 신속하게 개발하기 위한 <strong>비동기식 이벤트 기반</strong> 네트워크 애플리케이션 프레임워크이다.</p>
</blockquote>
<br/>

<h3 id="자바의-네트워킹"><a href="#자바의-네트워킹" class="headerlink" title="자바의 네트워킹"></a>자바의 네트워킹</h3><p> 최초의 자바 API(<code>java.net</code>)은 블로킹 함수(<code>accept()</code>)만 지원했다. 따라서 다수의 클라이언트를 관리하려면 새로운 클라이언트 Socket마다 새로운 Thread를 할당해야 한다.  </p>
<p>여러 스레드가 입,출력을 기다리며 무한정 대기 상태가 되는 경우 리소스 낭비가 될 수 있다. 또한 각 스레드가 스택 메모리를 할당해야하는데 스택 메모리를 차지하며, JVM의 컨텍스트 전환에 따른 오버헤드 문제가 생길 수 있다.</p>
<p><strong>10만명 이상의 동시 연결</strong>을 지원해야할 때는 이런 방식으로는 불가능 하다.</p>
<br/>

<h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><p>블로킹 시스템 호출 방식 외에 네이티브 소켓 라이브러리에는 논블로킹(non-blocking) 호출이 포함되 있다.</p>
<ul>
<li><p><code>setsocket()</code>을 이용하면 데이터가 없을 때 읽기/쓰기 호출이 즉시 반환된다.</p>
</li>
<li><p>시스템 이벤트 통지 API를 이용해 논블로킹 소켓을 등록하면 읽기/쓰기할 데이터가 준비됐는지 여부를 알 수 있다.</p>
<br/>

<h4 id="셀렉터-Selector"><a href="#셀렉터-Selector" class="headerlink" title="셀렉터(Selector)"></a>셀렉터(Selector)</h4><p><code>java.nio.channels.Selector</code> 클래스는 논블로킹 Socket의 집합에서 입출력 상태를 확인할 수 있어서 기존의 블로킹 방식과 다르게 한 스레드로 여러 동시 연결을 처리할 수 있다.</p>
<blockquote>
<p>직접 Java NIO API를 통해 제작하는 애플리케이션이 많지만 부하가 높은 상황에서 안정적으로 하기는 어렵다.<br>따라서 Netty와 같은 프레임 워크를 이용하는 것이 좋다.</p>
</blockquote>
</li>
</ul>
<br/>

<h3 id="Netty의-비동기성과-확장성"><a href="#Netty의-비동기성과-확장성" class="headerlink" title="Netty의 비동기성과 확장성"></a>Netty의 비동기성과 확장성</h3><ul>
<li>논 블로킹 네트워크 연결은 작업 완료를 기다릴 필요가 없다. 완전 비동기 입출력은 이 특징에 하나 더 추가되는데, 비동기 메소드는 즉시 반환하며 작업이 완료되면 직접 또는 나중에 이를 통지한다.</li>
<li>셀렉터는 적은 수의 스레드로 여러 연결에서 이벤트를 모니터링 할 수 있게 해준다.</li>
</ul>
<h3 id="Netty의-핵심-컴포넌트"><a href="#Netty의-핵심-컴포넌트" class="headerlink" title="Netty의 핵심 컴포넌트"></a>Netty의 핵심 컴포넌트</h3><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>하나 이상의 입출력 작업을 수행할 수 있는 HW 장치, 파일, Socket 등에 대한 열린 연결을 의미  </p>
<h4 id="CallBack"><a href="#CallBack" class="headerlink" title="CallBack"></a>CallBack</h4><p>네티는 이벤트를 처리할 때 내부적으로 콜백을 이용한다. 콜백이 트리거 되면 <code>ChannelHanlder</code> 인터페이스의 구현을 통해 이벤트를 처리한다.</p>
<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>작업이 완료되면 애플리케이션에 알린다. Future 객체는 비동기 작업의 결과를 담는 자리표시자(placeholder)의 역할을 하고, 미래의 어떤 시점에 작업이 완료되면 그 결과에 접근할 수 있게 해준다.</p>
<p>JDK가 <code>java.util.concurrent.Future</code> 인터페이스를 제공하지만 수동으로 작업을 해야했다. 그래서 Netty는 자체 구현 <code>ChannelFuture</code>를 제공한다.</p>
<h4 id="Event-amp-Handler"><a href="#Event-amp-Handler" class="headerlink" title="Event &amp; Handler"></a>Event &amp; Handler</h4><p>Netty는 작업의 상태 변화를 알리기 위해 고유한 이벤트를 이용하고, 발생한 이벤트를 기준으로 적절한 동작을 트리거한다.</p>
<ul>
<li><p>로깅</p>
</li>
<li><p>데이터 변환</p>
</li>
<li><p>흐름 제어</p>
</li>
<li><p>애플리케이션 논리  </p>
<ul>
<li><p>인바운드 이벤트</p>
<ul>
<li>연결 활성화 또는 비활성화</li>
<li>데이터 읽기</li>
<li>사용자 이벤트</li>
<li>오류 이벤트</li>
</ul>
</li>
<li><p>아웃바운드 트리거 이벤트</p>
<ul>
<li>원격 피어로 연결 열기 또는 닫기</li>
<li>소켓으로 데이터 쓰기 또는 플러시</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="각-채널의-EventLoop"><a href="#각-채널의-EventLoop" class="headerlink" title="각 채널의 EventLoop"></a>각 채널의 EventLoop</h4><ul>
<li>관심 이벤트 등록</li>
<li>이벤트를 <code>ChannelHanlder</code>로 발송</li>
<li>추가 동작 스케쥴링</li>
</ul>
<hr>
<h3 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h3><p><a href="http://netty.io/wiki/adopters.html">Netty를 도입한 기업 목록</a></p>

        </div>
        
        
        
    </div>
</div>








</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="" src="/images/avatar.png" alt="Your name">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        Your name
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        Your title
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Your location</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Posts
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            73
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Categories
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            18
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tags
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            41
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">
                Follow</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Github" href="https://github.com/ppoffice">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Facebook" href="https://facebook.com">
                
                <i class="fab fa-facebook"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Twitter" href="https://twitter.com">
                
                <i class="fab fa-twitter"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Dribbble" href="https://dribbble.com">
                
                <i class="fab fa-dribbble"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="RSS" href="/">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Links
        </h3>
        <ul class="menu-list">
        
            <li>
                <a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">Hexo</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">hexo.io</span>
                    </span>
                </a>
            </li>
        
            <li>
                <a class="level is-mobile" href="https://github.com/ppoffice" target="_blank" rel="noopener">
                    <span class="level-left">
                        <span class="level-item">PPOffice</span>
                    </span>
                    <span class="level-right">
                        <span class="level-item tag">github.com</span>
                    </span>
                </a>
            </li>
        
        </ul>
        </div>
    </div>
</div>

    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Categories
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/cs/">
            <span class="level-start">
                <span class="level-item">CS</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/cs/database/">
            <span class="level-start">
                <span class="level-item">DataBase</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/cs/os/">
            <span class="level-start">
                <span class="level-item">OS</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/programming/">
            <span class="level-start">
                <span class="level-item">Programming</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">37</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/programming/common/">
            <span class="level-start">
                <span class="level-item">Common</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programming/java/">
            <span class="level-start">
                <span class="level-item">Java</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">24</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/programming/javascript/">
            <span class="level-start">
                <span class="level-item">Javascript</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">9</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/server/">
            <span class="level-start">
                <span class="level-item">Server</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">16</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/server/netty/">
            <span class="level-start">
                <span class="level-item">Netty</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">8</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/server/orm/">
            <span class="level-start">
                <span class="level-item">ORM</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/server/spring/">
            <span class="level-start">
                <span class="level-item">Spring</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/server/test/">
            <span class="level-start">
                <span class="level-item">Test</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/system/">
            <span class="level-start">
                <span class="level-item">System</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">4</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/system/docker/">
            <span class="level-start">
                <span class="level-item">Docker</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/system/shell/">
            <span class="level-start">
                <span class="level-item">Shell</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/think/">
            <span class="level-start">
                <span class="level-item">Think</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/troubleshooting/">
            <span class="level-start">
                <span class="level-item">Troubleshooting</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">7</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/web/">
            <span class="level-start">
                <span class="level-item">Web</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Tag Cloud
        </h3>
        <a href="/tags/authrization/" style="font-size: 11.11px;">Authrization</a> <a href="/tags/design-pattern/" style="font-size: 10px;">Design Pattern</a> <a href="/tags/docker/" style="font-size: 12.22px;">Docker</a> <a href="/tags/effective-java/" style="font-size: 18.89px;">Effective Java</a> <a href="/tags/encryption/" style="font-size: 10px;">Encryption</a> <a href="/tags/fish-shell/" style="font-size: 10px;">Fish Shell</a> <a href="/tags/functional-programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/functional-thinking/" style="font-size: 12.22px;">Functional Thinking</a> <a href="/tags/git/" style="font-size: 11.11px;">Git</a> <a href="/tags/gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/http/" style="font-size: 10px;">HTTP</a> <a href="/tags/hash/" style="font-size: 10px;">Hash</a> <a href="/tags/hibernate/" style="font-size: 12.22px;">Hibernate</a> <a href="/tags/intellij/" style="font-size: 10px;">IntelliJ</a> <a href="/tags/jpa/" style="font-size: 10px;">JPA</a> <a href="/tags/java/" style="font-size: 20px;">Java</a> <a href="/tags/javascript/" style="font-size: 16.67px;">Javascript</a> <a href="/tags/junit/" style="font-size: 10px;">Junit</a> <a href="/tags/maven/" style="font-size: 10px;">Maven</a> <a href="/tags/meetup/" style="font-size: 10px;">Meetup</a> <a href="/tags/mysql/" style="font-size: 12.22px;">MySQL</a> <a href="/tags/netty/" style="font-size: 15.56px;">Netty</a> <a href="/tags/network/" style="font-size: 15.56px;">Network</a> <a href="/tags/oauth2/" style="font-size: 12.22px;">OAuth2</a> <a href="/tags/os/" style="font-size: 10px;">OS</a> <a href="/tags/reactjs/" style="font-size: 10px;">ReactJS</a> <a href="/tags/refactoring/" style="font-size: 10px;">Refactoring</a> <a href="/tags/sts/" style="font-size: 11.11px;">STS</a> <a href="/tags/shell/" style="font-size: 10px;">Shell</a> <a href="/tags/spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/springboot/" style="font-size: 12.22px;">SpringBoot</a> <a href="/tags/stub/" style="font-size: 10px;">Stub</a> <a href="/tags/study/" style="font-size: 12.22px;">Study</a> <a href="/tags/tdd/" style="font-size: 10px;">TDD</a> <a href="/tags/tacademy/" style="font-size: 10px;">Tacademy</a> <a href="/tags/test/" style="font-size: 12.22px;">Test</a> <a href="/tags/think/" style="font-size: 10px;">Think</a> <a href="/tags/troubleshooting/" style="font-size: 14.44px;">Troubleshooting</a> <a href="/tags/web/" style="font-size: 12.22px;">Web</a> <a href="/tags/women-who-code/" style="font-size: 10px;">Women Who Code</a> <a href="/tags/생활코딩/" style="font-size: 17.78px;">생활코딩</a>
    </div>
</div>
    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <a href="/2020-02-01-reverting-invalid-git-merge/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="git 커밋 중간에 잘못된 merge 되돌리기">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-02-01T14:41:26.000Z">2020-02-01</time></div>
                    <a href="/2020-02-01-reverting-invalid-git-merge/" class="title has-link-black-ter is-size-6 has-text-weight-normal">git 커밋 중간에 잘못된 merge 되돌리기</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/troubleshooting/">Troubleshooting</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020-01-20-women-who-code-talk-with-sonia-from-ms/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="Talk with Sonia from Microsoft - Inspiring Tech Women">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-01-20T13:54:30.000Z">2020-01-20</time></div>
                    <a href="/2020-01-20-women-who-code-talk-with-sonia-from-ms/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Talk with Sonia from Microsoft - Inspiring Tech Women</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/think/">Think</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020-01-19-encryption-vs-hash/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="암호화 vs 해시">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-01-19T12:03:04.000Z">2020-01-19</time></div>
                    <a href="/2020-01-19-encryption-vs-hash/" class="title has-link-black-ter is-size-6 has-text-weight-normal">암호화 vs 해시</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/programming/common/">Common</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019-10-20-java-stream/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="Java - Stream 기초">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-10-19T21:54:07.000Z">2019-10-20</time></div>
                    <a href="/2019-10-20-java-stream/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Java - Stream 기초</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/programming/java/">Java</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019-10-20-functional-thinking-ch7/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="함수형 사고 - ch7 실용적 사고">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-10-19T21:47:20.000Z">2019-10-20</time></div>
                    <a href="/2019-10-20-functional-thinking-ch7/" class="title has-link-black-ter is-size-6 has-text-weight-normal">함수형 사고 - ch7 실용적 사고</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/programming/common/">Common</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/02/">
                <span class="level-start">
                    <span class="level-item">February 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/01/">
                <span class="level-start">
                    <span class="level-item">January 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/10/">
                <span class="level-start">
                    <span class="level-item">October 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">6</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/09/">
                <span class="level-start">
                    <span class="level-item">September 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/07/">
                <span class="level-start">
                    <span class="level-item">July 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/06/">
                <span class="level-start">
                    <span class="level-item">June 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/04/">
                <span class="level-start">
                    <span class="level-item">April 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/03/">
                <span class="level-start">
                    <span class="level-item">March 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/02/">
                <span class="level-start">
                    <span class="level-item">February 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/01/">
                <span class="level-start">
                    <span class="level-item">January 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">10</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/12/">
                <span class="level-start">
                    <span class="level-item">December 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/11/">
                <span class="level-start">
                    <span class="level-item">November 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">6</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/10/">
                <span class="level-start">
                    <span class="level-item">October 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">6</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/09/">
                <span class="level-start">
                    <span class="level-item">September 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">5</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/08/">
                <span class="level-start">
                    <span class="level-item">August 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">11</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/07/">
                <span class="level-start">
                    <span class="level-item">July 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/06/">
                <span class="level-start">
                    <span class="level-item">June 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/05/">
                <span class="level-start">
                    <span class="level-item">May 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">9</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/authrization/">
                        <span class="tag">Authrization</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/design-pattern/">
                        <span class="tag">Design Pattern</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/docker/">
                        <span class="tag">Docker</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/effective-java/">
                        <span class="tag">Effective Java</span>
                        <span class="tag is-grey">21</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/encryption/">
                        <span class="tag">Encryption</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/fish-shell/">
                        <span class="tag">Fish Shell</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/functional-programming/">
                        <span class="tag">Functional Programming</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/functional-thinking/">
                        <span class="tag">Functional Thinking</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">Git</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/gradle/">
                        <span class="tag">Gradle</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/http/">
                        <span class="tag">HTTP</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/hash/">
                        <span class="tag">Hash</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/hibernate/">
                        <span class="tag">Hibernate</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/intellij/">
                        <span class="tag">IntelliJ</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/jpa/">
                        <span class="tag">JPA</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/java/">
                        <span class="tag">Java</span>
                        <span class="tag is-grey">25</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/javascript/">
                        <span class="tag">Javascript</span>
                        <span class="tag is-grey">9</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/junit/">
                        <span class="tag">Junit</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/maven/">
                        <span class="tag">Maven</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/meetup/">
                        <span class="tag">Meetup</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/mysql/">
                        <span class="tag">MySQL</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/netty/">
                        <span class="tag">Netty</span>
                        <span class="tag is-grey">8</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/network/">
                        <span class="tag">Network</span>
                        <span class="tag is-grey">8</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/oauth2/">
                        <span class="tag">OAuth2</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/os/">
                        <span class="tag">OS</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/reactjs/">
                        <span class="tag">ReactJS</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/refactoring/">
                        <span class="tag">Refactoring</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/sts/">
                        <span class="tag">STS</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/shell/">
                        <span class="tag">Shell</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/spring/">
                        <span class="tag">Spring</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/springboot/">
                        <span class="tag">SpringBoot</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/stub/">
                        <span class="tag">Stub</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/study/">
                        <span class="tag">Study</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/tdd/">
                        <span class="tag">TDD</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/tacademy/">
                        <span class="tag">Tacademy</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/test/">
                        <span class="tag">Test</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/think/">
                        <span class="tag">Think</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/troubleshooting/">
                        <span class="tag">Troubleshooting</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/web/">
                        <span class="tag">Web</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/women-who-code/">
                        <span class="tag">Women Who Code</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/생활코딩/">
                        <span class="tag">생활코딩</span>
                        <span class="tag is-grey">11</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <a href="/2020-02-01-reverting-invalid-git-merge/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="git 커밋 중간에 잘못된 merge 되돌리기">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-02-01T14:41:26.000Z">2020-02-01</time></div>
                    <a href="/2020-02-01-reverting-invalid-git-merge/" class="title has-link-black-ter is-size-6 has-text-weight-normal">git 커밋 중간에 잘못된 merge 되돌리기</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/troubleshooting/">Troubleshooting</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020-01-20-women-who-code-talk-with-sonia-from-ms/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="Talk with Sonia from Microsoft - Inspiring Tech Women">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-01-20T13:54:30.000Z">2020-01-20</time></div>
                    <a href="/2020-01-20-women-who-code-talk-with-sonia-from-ms/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Talk with Sonia from Microsoft - Inspiring Tech Women</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/think/">Think</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2020-01-19-encryption-vs-hash/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="암호화 vs 해시">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-01-19T12:03:04.000Z">2020-01-19</time></div>
                    <a href="/2020-01-19-encryption-vs-hash/" class="title has-link-black-ter is-size-6 has-text-weight-normal">암호화 vs 해시</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/programming/common/">Common</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019-10-20-java-stream/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="Java - Stream 기초">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-10-19T21:54:07.000Z">2019-10-20</time></div>
                    <a href="/2019-10-20-java-stream/" class="title has-link-black-ter is-size-6 has-text-weight-normal">Java - Stream 기초</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/programming/java/">Java</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <a href="/2019-10-20-functional-thinking-ch7/" class="media-left">
                <p class="image is-64x64">
                    <img class="thumbnail" src="/images/thumbnail.svg" alt="함수형 사고 - ch7 실용적 사고">
                </p>
            </a>
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-10-19T21:47:20.000Z">2019-10-20</time></div>
                    <a href="/2019-10-20-functional-thinking-ch7/" class="title has-link-black-ter is-size-6 has-text-weight-normal">함수형 사고 - ch7 실용적 사고</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/programming/common/">Common</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2020/02/">
                <span class="level-start">
                    <span class="level-item">February 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2020/01/">
                <span class="level-start">
                    <span class="level-item">January 2020</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/10/">
                <span class="level-start">
                    <span class="level-item">October 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">6</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/09/">
                <span class="level-start">
                    <span class="level-item">September 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/08/">
                <span class="level-start">
                    <span class="level-item">August 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/07/">
                <span class="level-start">
                    <span class="level-item">July 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/06/">
                <span class="level-start">
                    <span class="level-item">June 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/04/">
                <span class="level-start">
                    <span class="level-item">April 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/03/">
                <span class="level-start">
                    <span class="level-item">March 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/02/">
                <span class="level-start">
                    <span class="level-item">February 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/01/">
                <span class="level-start">
                    <span class="level-item">January 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">10</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/12/">
                <span class="level-start">
                    <span class="level-item">December 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/11/">
                <span class="level-start">
                    <span class="level-item">November 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">6</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/10/">
                <span class="level-start">
                    <span class="level-item">October 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">6</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/09/">
                <span class="level-start">
                    <span class="level-item">September 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">5</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/08/">
                <span class="level-start">
                    <span class="level-item">August 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">11</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/07/">
                <span class="level-start">
                    <span class="level-item">July 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">3</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/06/">
                <span class="level-start">
                    <span class="level-item">June 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/05/">
                <span class="level-start">
                    <span class="level-item">May 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">9</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/authrization/">
                        <span class="tag">Authrization</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/design-pattern/">
                        <span class="tag">Design Pattern</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/docker/">
                        <span class="tag">Docker</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/effective-java/">
                        <span class="tag">Effective Java</span>
                        <span class="tag is-grey">21</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/encryption/">
                        <span class="tag">Encryption</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/fish-shell/">
                        <span class="tag">Fish Shell</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/functional-programming/">
                        <span class="tag">Functional Programming</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/functional-thinking/">
                        <span class="tag">Functional Thinking</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/git/">
                        <span class="tag">Git</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/gradle/">
                        <span class="tag">Gradle</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/http/">
                        <span class="tag">HTTP</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/hash/">
                        <span class="tag">Hash</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/hibernate/">
                        <span class="tag">Hibernate</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/intellij/">
                        <span class="tag">IntelliJ</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/jpa/">
                        <span class="tag">JPA</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/java/">
                        <span class="tag">Java</span>
                        <span class="tag is-grey">25</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/javascript/">
                        <span class="tag">Javascript</span>
                        <span class="tag is-grey">9</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/junit/">
                        <span class="tag">Junit</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/maven/">
                        <span class="tag">Maven</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/meetup/">
                        <span class="tag">Meetup</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/mysql/">
                        <span class="tag">MySQL</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/netty/">
                        <span class="tag">Netty</span>
                        <span class="tag is-grey">8</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/network/">
                        <span class="tag">Network</span>
                        <span class="tag is-grey">8</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/oauth2/">
                        <span class="tag">OAuth2</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/os/">
                        <span class="tag">OS</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/reactjs/">
                        <span class="tag">ReactJS</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/refactoring/">
                        <span class="tag">Refactoring</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/sts/">
                        <span class="tag">STS</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/shell/">
                        <span class="tag">Shell</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/spring/">
                        <span class="tag">Spring</span>
                        <span class="tag is-grey">5</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/springboot/">
                        <span class="tag">SpringBoot</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/stub/">
                        <span class="tag">Stub</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/study/">
                        <span class="tag">Study</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/tdd/">
                        <span class="tag">TDD</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/tacademy/">
                        <span class="tag">Tacademy</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/test/">
                        <span class="tag">Test</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/think/">
                        <span class="tag">Think</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/troubleshooting/">
                        <span class="tag">Troubleshooting</span>
                        <span class="tag is-grey">7</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/web/">
                        <span class="tag">Web</span>
                        <span class="tag is-grey">3</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/women-who-code/">
                        <span class="tag">Women Who Code</span>
                        <span class="tag is-grey">1</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/생활코딩/">
                        <span class="tag">생활코딩</span>
                        <span class="tag is-grey">11</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="Jade&#39;s Blog" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 j2de&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'https://j2de.github.io',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>