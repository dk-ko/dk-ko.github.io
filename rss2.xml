<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Jade&#39;s Blog</title>
    <link>https://j2de.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>An archive for daily discovery</description>
    <pubDate>Wed, 03 Mar 2021 12:27:02 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>git 커밋 중간에 잘못된 merge 되돌리기</title>
      <link>https://j2de.github.io/2020/02/01/reverting-invalid-git-merge/</link>
      <guid>https://j2de.github.io/2020/02/01/reverting-invalid-git-merge/</guid>
      <pubDate>Sat, 01 Feb 2020 14:41:26 GMT</pubDate>
      <description>
      
        &lt;p&gt;어느날 오랜만에 커밋을 보니까,&lt;br&gt;&lt;code&gt;master&lt;/code&gt; 브랜치가 뭔가 잘못되어 있었다.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>어느날 오랜만에 커밋을 보니까,<br><code>master</code> 브랜치가 뭔가 잘못되어 있었다.</p><a id="more"></a><p><img src="01.png" alt="어.. 얘네가 여기 있으면 안되는데..?"></p><blockquote><p>deploy 브랜치에 있는 배포용 커밋이 master 브랜치에 있는 상황</p></blockquote><p>커밋 로그를 추적해보다가 <code>rebase conflict</code>를 해결하다 병합에 문제가 생긴걸 알았다.<br>(merge를 잘못해서 생긴것 일것으로 추측, 실수로 deploy 브랜치에서 작업 후 merge를 시도했다던지..)</p><blockquote><p>rebase는 커밋 이력이 남지 않아서, merge 실수를 일일히 찾아야한다.</p></blockquote><p><img src="02.png" alt="commit log"></p><p>과거의 내가 <code>fix: rebase conflict</code>라고 남겨놓아서 그나마 쉽게 찾을 수 있었다.</p><blockquote><p>오늘의 교훈 : 커밋 메세지를 잘남기자..</p></blockquote><p>아무튼 이걸 해결하려면 중간에 <code>잘못 머지한 이력</code>을 지우고 원래대로 <code>개발 완료한 커밋 내역</code>으로 돌려야한다.</p><p>검색해보니 <code>merge</code>를 되돌리기 위해서는 <code>reset</code>과 <code>revert</code>를 사용한다.<br><code>revert --mainline</code> 옵션으로 시도했지만 <code>revert</code>는 기존 커밋 내역을 보존하고 추가 커밋을 덧붙이는거라 지금 내 상황에 맞지 않았다.</p><p>만약 팀 프로젝트와 같이 <code>commit id</code>가 중요하면 <code>reset</code>과 같이 <strong>commit id가 변경</strong>되는 명령어를 쉽게 쓸 수 없었겠지만 상황상 <code>reset</code>으로 되돌리기를 시도했다.</p><p><img src="03.png" alt="git reset --merge [COMMIT_ID]"></p><p><code>git reset --merge [COMMIT_ID]</code> 적용 후 deploy 관련 커밋이 깔끔하게 삭제 되어 git graph가 깨끗해졌다. (기본 mixed 옵션으로 적용)</p><p><img src="04.png" alt="-111 커밋이 삭제된 master 브랜치"></p><p>이제 문제는 원래 개발했던 내용을 되돌려놓는 것</p><p>문제가 생겼던 프로젝트는 기존에 <code>git flow</code> 방식을 차용해서 커밋했기에 <code>develop branch</code>에<br>동작이 보증된 개발 완료된 코드들이 남아있었다.<br><code>master branch</code>는 <code>mixed option</code>으로 <code>reset</code> 했기에 stage가 깨끗해서 <code>develop</code>을 바로 master로 <code>merge</code>할 수 있다.</p><blockquote><p>만약 soft 옵션으로 reset 했다면 남아있는 파일을 모두 지우고 시도한다.</p></blockquote><blockquote><p>만약 branch 관리를 하지 않아 branch가 꼬여있었다면 이 방법으로 해결하지 못했을지도..</p></blockquote><p><img src="05.png" alt="develop 브랜치에 잘못 merge한 이후의 개발 이력이 남아있다."></p><p><img src="06.png" alt="master 브랜치에 develop을 merge한 뒤 3개 커밋이 추가되어 -108로 변경되었다."></p><p><img src="07.png" alt="최종적으로 정리된, develop merge 후 master 브랜치 log"></p><p><img src="08.png" alt="이전의, 중간 잘못된 merge commit 삭제 전 꼬여있는 master 브랜치 log"></p><p>이후 확인해보면 이력이 깨끗하게 정리된 것을 확인할 수 있다.</p><p>최종적으로 <code>master</code>에 푸시한다.<br><code>reset</code>으로 커밋 내역을 변경했기 때문에 당연히 <code>-f</code> 로 강제 push를 한다<br>강제 <code>push</code>는 브랜치에 protected가 걸려있으면 할 수 없다.<br>따라서 해당 방법은 아무래도 실무에서 여러가지 제약이 있으면 적용하기는 어려울 것 같고<br>실무에서는 잘못 merge시 revert를 통해 우회하는 방식을 사용해야할 것 같다.</p><p>git reset 후 변경 내역에 대해 새로 커밋을 하는 경우는 commit id가 변경되지만<br>기존에 있는 브랜치에서 병합했기 때문에 커밋 아이디는 변경되지 않았다.</p><h3 id="오늘-알게된-것"><a href="#오늘-알게된-것" class="headerlink" title="오늘 알게된 것."></a>오늘 알게된 것.</h3><ul><li>커밋을 잘 남기자.<ul><li>섣불리 rebase하지 말고 merge로 merge 이력을 남기자.</li></ul></li><li>브랜치를 잘 나눠서 사용하자</li></ul><h3 id="참고한-링크"><a href="#참고한-링크" class="headerlink" title="참고한 링크"></a>참고한 링크</h3><ul><li><a href="https://www.tuwlab.com/ece/22223">https://www.tuwlab.com/ece/22223</a></li><li><a href="https://victorydntmd.tistory.com/79">https://victorydntmd.tistory.com/79</a></li><li><a href="https://nesoy.github.io/articles/2018-07/Git-Revert">https://nesoy.github.io/articles/2018-07/Git-Revert</a></li></ul>]]></content:encoded>
      
      <comments>https://j2de.github.io/2020/02/01/reverting-invalid-git-merge/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Talk with Sonia from Microsoft - Inspiring Tech Women</title>
      <link>https://j2de.github.io/2020/01/20/women-who-code-talk-with-sonia-from-ms/</link>
      <guid>https://j2de.github.io/2020/01/20/women-who-code-talk-with-sonia-from-ms/</guid>
      <pubDate>Mon, 20 Jan 2020 13:54:30 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;Date 2020.1.20 Mon / Time PM 6:30~8:30 / Place 한국 마이크로소프트&lt;/p&gt;
&lt;p&gt;오랜만에 &lt;code&gt;Women Who Code&lt;/code&gt;의 Meetup에 참여하기 위해 한국 마이크로소프트 건물을 찾았다.&lt;br
        
      
      </description>
      
      <content:encoded><![CDATA[<p>Date 2020.1.20 Mon / Time PM 6:30~8:30 / Place 한국 마이크로소프트</p><p>오랜만에 <code>Women Who Code</code>의 Meetup에 참여하기 위해 한국 마이크로소프트 건물을 찾았다.<br>마이크로소프트 소속의 Sonia와 Tech에 대해 대화를 나누는 밋업이었다.</p><h2 id="Women-Who-Code란"><a href="#Women-Who-Code란" class="headerlink" title="Women Who Code란"></a>Women Who Code란</h2><ul><li><p>미국에서 시작해 전세계 60개국에서 활동중인 여성 단체로 더 많은 여성들이 기술 경력을 갖도록 장려하는 비영리 단체이다.</p></li><li><p>최근에 <code>Meetup App</code>으로 알게된 단체인데 알고보니 최근 한국으로 진출했다고 한다.</p></li><li><p>전세계적으로 네트워크가 있는 단체라 취업이나 여행시에 해당 국가에서 테크 관련된 행사를 참여하고 싶은 경우 네트워크 문의 가능하다고.</p></li><li><p>한국에서는 페이스북 그룹을 기반으로 활동하는 듯 하다.</p></li><li><p>연사 초청 강의, 해커톤 등의 행사, 구직 기회도 있다고 한다.</p></li></ul><h2 id="Talk-with-Sonia-from-Microsoft"><a href="#Talk-with-Sonia-from-Microsoft" class="headerlink" title="Talk with Sonia from Microsoft"></a>Talk with Sonia from Microsoft</h2><blockquote><p>Sonia가 우리에게 해준 말들</p></blockquote><p><img src="01.jpg" alt="Talk with Sonia"></p><h3 id="Change-your-plan"><a href="#Change-your-plan" class="headerlink" title="Change your plan."></a>Change your plan.</h3><blockquote><p>계획이 바뀌는 것에 관대해져라</p></blockquote><h3 id="If-you-are-not-sure-Answer-yes"><a href="#If-you-are-not-sure-Answer-yes" class="headerlink" title="If you are not sure, Answer yes"></a>If you are not sure, Answer yes</h3><blockquote><p>확실하지 않다면 두려워하지 말고 예스라고 해볼 것.</p></blockquote><ul><li>새로운 것에 도전하라는 의미.</li></ul><h3 id="If-you-hate-it-Then-leave"><a href="#If-you-hate-it-Then-leave" class="headerlink" title="If you hate it, Then leave."></a>If you hate it, Then leave.</h3><blockquote><p>싫어하면 떠나라</p></blockquote><ul><li>테크 환경에는 다양한 룰이 있다.</li><li>나에게 맞는 룰을 찾는데 시간이 걸릴 수 있다</li></ul><h3 id="Find-career-support-Take-their-advice"><a href="#Find-career-support-Take-their-advice" class="headerlink" title="Find career support. Take their advice."></a>Find career support. Take their advice.</h3><blockquote><p>내가 하고싶은 일을 도와주는 사람을 찾고 조언을 적극적으로 받아들이자.</p></blockquote><h3 id="Learn-and-understand-the-basics"><a href="#Learn-and-understand-the-basics" class="headerlink" title="Learn and understand the basics."></a>Learn and understand the basics.</h3><blockquote><p>끊임 없이 배우고, 기본을 이해하자.</p></blockquote><h3 id="Take-a-chance"><a href="#Take-a-chance" class="headerlink" title="Take a chance."></a>Take a chance.</h3><blockquote><p>뻔한 말이지만, 기회를 잡아라</p></blockquote><h3 id="Take-more-chances"><a href="#Take-more-chances" class="headerlink" title="Take more chances."></a>Take more chances.</h3><blockquote><p>또 뻔한 말이지만, 더 많은 기회를 잡아라.</p></blockquote><ul><li>누군가 기회를 준다면 바로 잡아라.</li></ul><h3 id="Know-your-worth"><a href="#Know-your-worth" class="headerlink" title="Know your worth."></a>Know your worth.</h3><blockquote><p>너의 가치를 알아라</p></blockquote><h3 id="Reliable-Dedicated-Persevering-Learning-Helpful-Sharing-Encouraging"><a href="#Reliable-Dedicated-Persevering-Learning-Helpful-Sharing-Encouraging" class="headerlink" title="Reliable, Dedicated, Persevering, Learning, Helpful, Sharing, Encouraging"></a>Reliable, Dedicated, Persevering, Learning, Helpful, Sharing, Encouraging</h3><h3 id="Look-after-yourselft"><a href="#Look-after-yourselft" class="headerlink" title="Look after yourselft"></a>Look after yourselft</h3><blockquote><p>그리고 나를 돌보면서 일해라.</p></blockquote><ul><li>나를 돌보는 방법 중 하나. 나와 잘 맞는 친구들을 찾는 것<br>나에게 괜찮다고 말해줄 수 있는.</li><li>그리고 쉬는 시간 여가시간, 취미를 즐기는 시간을 계획하자.<br>언젠가하려고 하면 할 수 없다.</li></ul><h3 id="Take-even-more-chances"><a href="#Take-even-more-chances" class="headerlink" title="Take even more chances."></a>Take even more chances.</h3><h3 id="Share-your-stories"><a href="#Share-your-stories" class="headerlink" title="Share your stories."></a>Share your stories.</h3><blockquote><p>사소한 이야기라도 나누자.</p></blockquote><ul><li>이런 이야기를 알거라고 생각하지만 모르는 경우가 많다</li><li>내가 했던 일을 다른 사람이 안했을 수도 있기 때문에, 사소한 이야기라도 나누자.</li><li>서로 공유를 통해 배울 수 있다.</li><li>내가 이 포스팅을 굳이 쓰고 있는 이유이기도 하다.</li></ul><h3 id="Always-be-learning"><a href="#Always-be-learning" class="headerlink" title="Always be learning"></a>Always be learning</h3><blockquote><p>항상 새로운 걸 배워라.</p></blockquote><ul><li>기술은 매일 변하니까 20년이 넘어도 항상 새로운 걸 배운다.</li><li>기본은 여전히 똑같다</li></ul><h3 id="Expand-your-scope"><a href="#Expand-your-scope" class="headerlink" title="Expand your scope."></a>Expand your scope.</h3><blockquote><p>나의 영역을 조금씩 확장해나가자.</p></blockquote><ul><li>내가 포커스하고 있는 영역 외에도 다른 영역에 관심을 가지는 것이 중요하다.</li><li>내가 어떤 일을 하게 될지 모르므로.</li></ul><hr><p>이 모든 것이 뻔하다면 뻔한말이지만, 중요한 것은 그 것을 직접 경험하고 이뤄온 인물을 눈앞에서 보고 “정말 그렇게 될 수 있구나”라고 느낄 수 있었다는 것이라 생각한다. <code>Inspiring</code>이라는 단어에 걸맞는 밋업이었다.</p><p>처음에는 영어로 진행되고 통역이 없는 것 같아서 참석에 망설였는데 현장에서 통역을 해주시는 분이 있어서 다행히 잘 들을 수 있었다. 정말 영어를 공부해야 나를 둘러싼 세계가 더 넓어지는구나 깨닫게 된 순간이기도 했다.</p><hr><h2 id="QnA"><a href="#QnA" class="headerlink" title="QnA"></a>QnA</h2><blockquote><p>아무래도 통역에 의존해서 내용이 정확하지 않을 수 있지만 인상적인 질문을 몇개 추려보았다.</p></blockquote><p>Q. 주변의 뛰어난 사람과 비교하며, 운이 좋아서 성공했다는 생각이 들 때 어떻게 극복했는지 ?<br>A. 그 사람과 같은 주제를 정하고 공부, 공유한다 &gt; 나와 크게 다르지 않다는걸 알게됨.<br>A. 긍정적인 피드백을 받으려고 함<br>A. 지금까지 해왔던 성취를 적어보면서 극복함</p><p>Q. 테크 업계에서 여성으로서의 어려움을 어떻게 극복해왔는지 ?<br>A. 여성으로서 어려움이 많지만 내가 바꿀 수 있는 것은 바꾸려고 하고 바꿀 수 없는 것은 내버려둔다.</p><p>Q. 비전공자가 테크 영역으로 가려는데 뭘 해야할까?<br>A. Technical Account Manager<br>A. 기술 영업 매니저<br>A. 오픈소스, 데브옵스 커뮤니티가서 현장에 일하는 사람의 얘기를 들어보는 것이 좋다.</p><p>Q. 기술 중심의 사람을 만날 때 압도당하는 기분을 느끼는데 어떻게 하는지?<br>A. 여자들이 질문을 하지 않고 트레이닝하려는 경향이 있다<br>A. 질문에 대한 대답하는 법을 모르기 때문<br>A. 그런 질문들에 답해줄 수 있는 사람을 찾는 것이 중요하다.<br>A. 여성이 여성에게 트레이닝하는 곳이 더 효과적이다.</p><p>Q. 스타트업을 하는 분이 조언을 구하는 질문 내용.<br>A. 네트워킹할때 내가 뭘 줄 수 있는지, 어떤걸 도움 받고 싶은지 명확하게 하라.<br>A. 주변에 많이 알려라. 그렇다면 지금 당장은 얻지 못해도 나중에 돌아올 수 있다.</p><p>Q. 한국에는 개발자의 주류가 남성이라 일터에서 성차별 문제가 있을때가 있는데 어떤식으로 극복했는지 ?<br>A. 이뤄왔던 성취를 봐라.<br>A. 성취가 없는 경우 그런 것을 해낼 수 있는 사람이라는 것을 보여줘라.<br>A. 성취를 크게 말하고 알려라. 내가 무엇을 했는지.</p><hr><p>마지막으로 좋았던 것은, Women Who Code의 공식 의식(?)인 <code>#ApplaudHer</code>였다.<br>지금의 우리를 모두 칭찬해주자는 의미로 하는 것으로, 현장에 있는 사람들이 스스로 또는 지금 함께 있는 사람들에게 칭찬하고 싶은 내용을 말하고 서로 박수치며 칭찬하는 것이다.</p><p>우리는 좋은 질문을 해준 서로를 칭찬하고, 이런 행사를 기획하고 추운 날씨에 퇴근 후 참여한 서로를 칭찬했다. 모두가 자연스럽게 칭찬하는 분위기가 되어 나도 용기를 내서 칭찬의 한마디를 건넸다.</p><p>여성 개발자로서 IT 모임에 갔을 때 대다수가 남자인 경험이 대부분이었던 나에게 같은 길을 걸어가는 여성 개발자들의 모임은 아무래도 힘이 된다. 항상 ‘보통’이 아니고 ‘특별’했는데, 여성이 개발자인 것이 이상하지 않다는 것만으로.</p><p>이제서야 커리어를 시작하는 병아리 개발자지만, 백엔드 업무에 여자 개발자가 더 많다는 것이 이상하게 느껴지지 않는 세상이 될 때까지 나도 이 자리를 지키고 있어야겠다는 생각이 든다.</p>]]></content:encoded>
      
      <comments>https://j2de.github.io/2020/01/20/women-who-code-talk-with-sonia-from-ms/#disqus_thread</comments>
    </item>
    
    <item>
      <title>암호화 vs 해시</title>
      <link>https://j2de.github.io/2020/01/19/encryption-vs-hash/</link>
      <guid>https://j2de.github.io/2020/01/19/encryption-vs-hash/</guid>
      <pubDate>Sun, 19 Jan 2020 12:03:04 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;암호화&quot;&gt;&lt;a href=&quot;#암호화&quot; class=&quot;headerlink&quot; title=&quot;암호화&quot;&gt;&lt;/a&gt;암호화&lt;/h2&gt;&lt;p&gt;: 복호화할 수 있다 = 원래대로 되돌릴 수 있다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;원래대로 되돌리는 것 = 가역&lt;/li&gt;
&lt;li
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="암호화"><a href="#암호화" class="headerlink" title="암호화"></a>암호화</h2><p>: 복호화할 수 있다 = 원래대로 되돌릴 수 있다</p><ul><li>원래대로 되돌리는 것 = 가역</li><li>공통키 암호 방식 vs 공개키 암호방식<ul><li>공통키 : 패스워드를 거는 것</li><li>공개키 : 암호화, 복호화에 각각 다른 암호화 키를 준비해 암호화하는 쪽의 키를 공개하는 방법</li><li>ex) DES, 3DES, AES 등</li></ul></li></ul><h2 id="해시"><a href="#해시" class="headerlink" title="해시"></a>해시</h2><p>: 복호화할 수 없다 = 원래대로 되돌릴 수 없다.</p><ul><li>원래대로 되돌릴 수 없는 것 = 불가역</li><li>해시화하기 전의 상태를 유추할 수 없다.</li><li>but 원래 데이터가 같으면 해시값도 동일한 값이 된다.</li><li>해시 방식에 따라 충돌이 일어나면 값이 다르지만 동일한 해시값이 될 수 있다.<ul><li>ex) MD5, SHA1, SHA256, SH512</li></ul></li></ul><h3 id="암호화를-푸는-방식"><a href="#암호화를-푸는-방식" class="headerlink" title="암호화를 푸는 방식"></a>암호화를 푸는 방식</h3><ol><li>알고리즘이 해독되어 있는 경우</li><li>추측되는 암호를 대입해 푸는 경우</li></ol><blockquote><p>따라서 알고리즘이 해독되어 있지 않고, RandomSeed가 불규칙해서 대입하는 방식으로 현실적으로 해독할 수 없는 경우를 채택해야함.</p></blockquote><h3 id="해시를-푸는-방식"><a href="#해시를-푸는-방식" class="headerlink" title="해시를 푸는 방식"></a>해시를 푸는 방식</h3><ul><li>암호화에 비해 복호화될 걱정은 거의 없는 편</li><li>하지만 문자열의 변환이기 때문에 패스워드같이 짧은 문자열은 해시화 방식이 알려지면 해시화된 목록을 갖고 있는 경우 해독될 가능성 있음</li><li>ex) A~Z, 0~9에 대해 md5한 목록을 이미 작성해 갖고 있으면 대입으로 유추 가능</li></ul><blockquote><p>이를 피하기 위해 특정 변환(길게 하기 = Salt 넣기)을 진행한 뒤 해시화하는 방법이 있다.</p></blockquote><ul><li>Salt란 ? 변환시 추가하는 임의의 데이터</li></ul><h2 id="외부로-유출되면-안되는-정보는"><a href="#외부로-유출되면-안되는-정보는" class="headerlink" title="외부로 유출되면 안되는 정보는.."></a>외부로 유출되면 안되는 정보는..</h2><ul><li>패스워드는 암호화가 아니라 <code>해시</code>로 보호</li><li>해시화의 방식과 관계없이, 해시화를 하는 경우 <code>길이가 긴 Salt</code>를 사용</li><li>해시화의 방식과 관계없이, 해시화의 원래 문자열(패스워드)에서 사용하는 <code>문자의 종류</code>를 늘린다.</li></ul>]]></content:encoded>
      
      <comments>https://j2de.github.io/2020/01/19/encryption-vs-hash/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java - Stream 기초</title>
      <link>https://j2de.github.io/2019/10/20/java-stream/</link>
      <guid>https://j2de.github.io/2019/10/20/java-stream/</guid>
      <pubDate>Sat, 19 Oct 2019 21:54:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Stream&quot;&gt;&lt;a href=&quot;#Stream&quot; class=&quot;headerlink&quot; title=&quot;Stream&quot;&gt;&lt;/a&gt;Stream&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;데이터의 흐름&lt;/li&gt;
&lt;li&gt;배열 또는 컬렉션 인스턴스에 &lt;code&gt;함수&lt;/code&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><ul><li>데이터의 흐름</li><li>배열 또는 컬렉션 인스턴스에 <code>함수</code> 여러개를 <code>조합</code>해 원하는 결과를 <code>필터링</code>하고 <code>가공된 결과</code>를 얻을 수 있다.</li><li>자바 8에서 추가된 것으로 람다를 활용할 수 있는 기술 중 하나.</li></ul><h3 id="Stream-VS-Collection"><a href="#Stream-VS-Collection" class="headerlink" title="Stream VS Collection"></a>Stream VS Collection</h3><p><strong>1. 스트림은 요소를 보관하지 않는다.</strong>  </p><ul><li>요소들은 하부 컬렉션에 보관되거나 필요할 때 생성된다.</li><li>ex) List기반으로 스트림을 생성한다면, 요소는 List에 저장되어 있는 것. 단지 그 위에 Stream이 생성된다.</li></ul><p><strong>2. 스트림 연산은 원본을 변경하지 않으며 결과를 담은 새로운 스트림을 반환한다.</strong><br><strong>3. 스트림은 가능한 지연(lazy) 처리된다.</strong>  </p><ul><li>즉 결과가 필요하기 전까지 실행되지 않는다.</li></ul><h2 id="생성하기"><a href="#생성하기" class="headerlink" title="생성하기"></a>생성하기</h2><ul><li>일반적으로 배열 또는 컬렉션으로 생성한다.</li></ul><h3 id="배열-스트림"><a href="#배열-스트림" class="headerlink" title="배열 스트림"></a>배열 스트림</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) Arrays.stream </span></span><br><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;; <span class="comment">// 배열 생성</span></span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(arr); </span><br><span class="line">Stream&lt;String&gt; streamOfArrayPart = Arrays.stream(arr, <span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">// (2) Stream.of </span></span><br><span class="line">Stream&lt;String&gt; stream2 = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br></pre></td></tr></table></figure><h3 id="컬렉션-스트림"><a href="#컬렉션-스트림" class="headerlink" title="컬렉션 스트림"></a>컬렉션 스트림</h3><ul><li><p>Java의 <code>컬렉션 타입</code>(Collection, List, Set)의 인터페이스에 <code>default method</code>로 <code>stream</code>이 추가되어 이를 통해 생성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = numbers.stream();</span><br></pre></td></tr></table></figure></li><li><p>그밖에도 빈 스트림, Stream.builder(), 무한 스트림(Stream.generate()), Stream.iterate(), 기본 타입 스트림, 문자열 스트림, 파일 스트림, 병렬 스트림(Paralle Stream)을 생성할 수 있다.</p></li><li><p>스트림 연결하기(Stream.concat)도 가능하다.</p></li></ul><h2 id="중간-연산-Intermediate-Operation"><a href="#중간-연산-Intermediate-Operation" class="headerlink" title="중간 연산(Intermediate Operation)"></a>중간 연산(Intermediate Operation)</h2><ul><li>Stream에서 원하는 내용만 <code>가공</code>하는 작업</li><li><code>Stream을 반환</code>하기 때문에 <code>method chainig</code>으로 호출할 수 있다.</li></ul><h3 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h3><ul><li><p><code>filter</code>로 스트림 내 원하는 요소를 걸러낸다.</p></li><li><p>인자로 <code>Predicate</code>를 받아 <code>boolean</code>을 리턴하는 함수형 인터페이스가 사용된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter 함수</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"><span class="comment">// 사용 예 </span></span><br><span class="line">System.out.println(</span><br><span class="line">  Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .filter(i -&gt; i &gt; <span class="number">3</span>) <span class="comment">// Lambda Expression</span></span><br><span class="line">        .count() <span class="comment">// Terminal Operation</span></span><br><span class="line">); <span class="comment">// "2" 출력</span></span><br></pre></td></tr></table></figure></li><li><p><code>filter()</code>함수가 인자로 <code>Predicate</code>를 받으므로 <code>i -&gt; i &gt; 3</code>가 <code>true</code>인 경우만 필터링 되어 <code>count()</code>함수에 의해 집계된다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(</span><br><span class="line">  Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment">// Anonymous Class</span></span><br><span class="line">        .filter(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (integer &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).count()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>Lambda 식을 사용하지 않으면 이렇게 불필요한 코드가 많아진다.</li></ul><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><ul><li><p><code>map</code>으로 스트림 내 요소들을 하나씩 특정 값으로 <code>변환</code>한다. (T &gt; R)</p></li><li><p>인자로 <code>Function&lt;T, R&gt;</code>을 사용한다.</p></li><li><p>함수형 인터페이스인 <code>Function</code>은 <code>T</code>를 받아 <code>R</code>을 리턴한다.</p></li><li><p>즉 <code>인자로 받은 데이터</code>와 <code>다른 데이터</code>를 반환할 때 쓰인다.</p></li><li><p>스트림에 들어있는 값이 input되어 사용자가 지정한 로직을 수행한 후 output 되어 리턴되는 새로운 스트림에 담긴다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 함수</span></span><br><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br><span class="line"><span class="comment">// 사용 예</span></span><br><span class="line">Stream&lt;String&gt; stringStream = </span><br><span class="line">  Stream.of(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">        .filter(i -&gt; i &gt; <span class="number">2</span>) <span class="comment">// filtering된 데이터를</span></span><br><span class="line">        .map(i -&gt; i * <span class="number">2</span>) <span class="comment">// (1) *2 한뒤</span></span><br><span class="line">        .map(i -&gt; <span class="string">"#"</span> + i); <span class="comment">// (2) #을 붙인 스트링값이 있는 Stream으로 반환한다.</span></span><br></pre></td></tr></table></figure></li><li><p>(1)에서 <code>3, 3, 5, 5</code>가 <code>6, 6, 10, 10</code>으로 변환된다.</p></li><li><p>(2)에서 <code>6, 6, 10, 10</code>이 <code>#6, #6, #10, #10</code>으로 변환된다. </p></li><li><p>Stream은 <code>Lazy</code>하게 동작하므로 위 코드는 <code>Terminal Operation</code>이 없어서 아직 수행되지 않는다.</p></li><li><p>그밖에도 flatMap, sorted, compare, peek 등이 있다.</p></li></ul><h2 id="최종-연산-Terminal-Operation"><a href="#최종-연산-Terminal-Operation" class="headerlink" title="최종 연산(Terminal Operation)"></a>최종 연산(Terminal Operation)</h2><ul><li>스트림 데이터로 부터 <code>결과</code>를 얻는 작업.</li><li>이 과정에서 사용하는 메소드를 <code>reduction method</code>라 한다. </li></ul><h3 id="단순-리덕션"><a href="#단순-리덕션" class="headerlink" title="단순 리덕션"></a>단순 리덕션</h3><ul><li><code>count()</code>, <code>sum()</code>, <code>min()</code>, <code>max()</code> 등 단순 계산을 수행한다.</li><li><code>Optional</code>로 반환한다.</li></ul><h3 id="리덕션-연산"><a href="#리덕션-연산" class="headerlink" title="리덕션 연산"></a>리덕션 연산</h3><ul><li><p><code>여러 Element</code>를 받아 하나하나 줄여나가 최종적으로 <code>하나</code>를 남긴다.</p></li><li><p>가장 단순한 형태는 이항 함수(Binary Function)을 받는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; values = ...;</span><br><span class="line">Optional&lt;Integer&gt; sum = values.reduce((x, y) -&gt; x + y);</span><br></pre></td></tr></table></figure></li><li><p>위의 경우 reduce는 <code>v0 + v1 + v2 + ...</code>을 계산한뒤 최종적으로 하나의 값(총합)을 반환한다.</p></li><li><p>리덕션에서 사용되는 연산은 (위의 +) <code>결합 법칙</code>을 지원해야한다.</p><ul><li>즉 요소들을 결합할 때 <code>순서</code>가 문제가 되어선 안된다.</li></ul></li></ul><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OptionalInt reduced = </span><br><span class="line">  IntStream.range(<span class="number">1</span>, <span class="number">4</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">            .reduce((a, b) -&gt; Integer.sum(a, b)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>처음에 <code>a = 1, b = 2</code>로 <code>sum</code>을 수행해 <code>3</code>이 된다.</li><li><code>a = 3(이전 상태), b = 3</code>으로 <code>3 + 3</code>으로 최종적으로 <code>6</code>이 된다.</li><li><code>Primitive Type Stream</code> 들은 기본적으로 <code>sum()</code>이 구현되어 있으므로 그걸 사용하는게 편하다.</li><li><code>Object Stream</code>의 경우 <code>sum()</code>을 구현한다면 <code>reduce()</code>를 사용해야한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> List&lt;Product&gt; products = Arrays.asList(</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">1L</span>, <span class="string">"A"</span>, <span class="keyword">new</span> BigDecimal(<span class="string">"100.50"</span>)),</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">2L</span>, <span class="string">"B"</span>, <span class="keyword">new</span> BigDecimal(<span class="string">"23.00"</span>)),</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">3L</span>, <span class="string">"C"</span>, <span class="keyword">new</span> BigDecimal(<span class="string">"31.45"</span>)),</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">4L</span>, <span class="string">"D"</span>, <span class="keyword">new</span> BigDecimal(<span class="string">"80.20"</span>)),</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">5L</span>, <span class="string">"E"</span>, <span class="keyword">new</span> BigDecimal(<span class="string">"7.50"</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Product 객체 리스트에서 price의 합을 구하고 싶을 때 </span></span><br><span class="line">System.out.println(<span class="string">"Total Price: "</span> +</span><br><span class="line">  products.stream() <span class="comment">// List에서 Stream 생성</span></span><br><span class="line">          .map(product -&gt; product.getPrice()) <span class="comment">// (1)</span></span><br><span class="line">          .reduce( <span class="comment">// (2)</span></span><br><span class="line">            BigDecimal.ZERO, </span><br><span class="line">            (price1, price2) -&gt; price1.add(price2))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>(1) <code>Product</code> 객체에서 <code>price value(BigDecimal 객체)</code>를 사용해야하므로 <code>map()</code>으로 데이터를 변환해준다. (Product &gt; BigDecimal)</li><li>(2) 초기값과 연산을 인자로 넣어준다.<ul><li>덧셈에 영향을 주지 않는 데이터가 0이므로 0을 넣는다.</li><li><code>100.50 + 23.00 + 31.45 ...</code> 를 수행한 뒤 결과(총 합)를 반환한다.</li></ul></li></ul><h3 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h3><ul><li><code>Collector</code> 타입의 인자를 받아 종료 작업을 한다.</li><li>주로 스트림을 <code>Collection 객체</code>로 변환하는 작업을 한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collectorCollection =</span><br><span class="line">  productList.stream()</span><br><span class="line">              .map(Product::getName) <span class="comment">// Product &gt; String</span></span><br><span class="line">              .collect(Collectors.toList() <span class="comment">// List&lt;String&gt; 반환</span></span><br><span class="line">  <span class="comment">// [A, B, C, D, E]</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>Product 객체의 이름을 추출해 List로 반환한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String listToString = </span><br><span class="line"> productList.stream()</span><br><span class="line">  .map(Product::getName)</span><br><span class="line">  .collect(Collectors.joining()); </span><br><span class="line">  <span class="comment">// ABCDE</span></span><br></pre></td></tr></table></figure><ul><li>연산 결과를 String으로 반환하고 싶은 경우 <code>joining</code>을 사용한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String listToString = </span><br><span class="line"> productList.stream()</span><br><span class="line">  .map(Product::getName)</span><br><span class="line">  .collect(Collectors.joining(<span class="string">", "</span>, <span class="string">"&lt;"</span>, <span class="string">"&gt;"</span>)); </span><br><span class="line">  <span class="comment">// &lt;A, B, C, D, E&gt;</span></span><br></pre></td></tr></table></figure><ul><li>구분자와 prefix, suffix를 지정할 수 있다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://futurecreator.github.io/2018/08/26/java-8-streams/">java 8 stream</a></li><li>가장 빨리 만나는 자바 8</li><li><a href="https://www.youtube.com/watch?v=mu9XfJofm8U&list=PLRIMoAKN8c6O8_VHOyBOhzBCeN7ShyJ27&index=1">케빈 TV - 모던 자바</a></li></ul>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/10/20/java-stream/#disqus_thread</comments>
    </item>
    
    <item>
      <title>함수형 사고 - ch7 실용적 사고</title>
      <link>https://j2de.github.io/2019/10/20/functional-thinking-ch7/</link>
      <guid>https://j2de.github.io/2019/10/20/functional-thinking-ch7/</guid>
      <pubDate>Sat, 19 Oct 2019 21:47:20 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Java-8&quot;&gt;&lt;a href=&quot;#Java-8&quot; class=&quot;headerlink&quot; title=&quot;Java 8&quot;&gt;&lt;/a&gt;Java 8&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java가 기존에 가지고 있는 Class와 Collection에 &lt;code&gt;map()&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h2><ul><li>Java가 기존에 가지고 있는 Class와 Collection에 <code>map()</code>과 <code>reduce()</code>와 같은 함수형 구조를 더했다.</li><li><code>함수형 구조</code>를 통해 Java의 컬렉션들을 효과적으로 처리할 수 있다.</li><li><code>reduce</code>의 경우 불변객체를 이용한 조작 연산이지만, Java 컬렉션의 대부분은 가변형이므로 가변 리듀스 작업을 하는 <code>collect</code>가 추가되었다.<ul><li>Java8에서 reduce는 불변 객체를, collect는 가변 객체를 조작할 때 사용한다.</li></ul></li></ul><h3 id="함수형-인터페이스-Functional-Interface"><a href="#함수형-인터페이스-Functional-Interface" class="headerlink" title="함수형 인터페이스(Functional Interface)"></a>함수형 인터페이스(Functional Interface)</h3><ul><li>Java의 <code>일급 객체</code>는 <code>Function</code>이 아니다.<ul><li>일급 객체(first-class object)란 ? <ul><li>다른 객체들에 일반적으로 <code>적용 가능한 연산</code>을 <code>모두 지원</code>하는 객체</li><li>보통 함수에 매개변수로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라 함.</li></ul></li></ul></li><li>따라서 함수 자체를 주고 받을 수 없으므로 인터페이스를 이용하며, 이를 <code>함수형 인터페이스</code>라한다.</li><li>Java의 함수형 인터페이스는 <code>단일 추상 메소드(Single Abstract Method, SAM) 인터페이스</code>이다.<ul><li>인터페이스에 추상 메소드가 1개인 것을 의미</li><li>default, static method는 상관 없다. </li><li>즉, 함수가 아닌 <code>인터페이스</code>를 주고 받는다. 그리고 구체적인 함수는 인터페이스 내부의 유일한 추상메소드를 <code>@Override</code>해 사용한다.</li><li>기존의 자바라면 익명 클래스를 사용하지만 <code>Lambda</code> 표현을 통해 간략하게 사용할 수 있다.</li></ul></li><li><code>@FunctionalInterface</code>로 함수형 인터페이스를 컴파일 레벨에서 check 할 수 있다.</li><li>Java8부터는 interface에 default method가 추가되었다.<ul><li>이 같은 개념을 mixin(믹신)이라 한다.</li><li>다른 클래스에서 사용될 메서드를 정의하지만 그 클래스의 상속 체계에 포함되지 않은 클래스</li><li>언어마다 다르지만 공통적으로 코드의 재사용이 좋아지고 다중상속의 모호함을 해결해준다.</li></ul></li></ul><h4 id="Java의-함수형-인터페이스"><a href="#Java의-함수형-인터페이스" class="headerlink" title="Java의 함수형 인터페이스"></a>Java의 함수형 인터페이스</h4><table><thead><tr><th>인터페이스</th><th>추상 메소드</th><th>설명</th></tr></thead><tbody><tr><td>Consumer<T></td><td>void accept(T t)</td><td>객체 T를 받아 소비함</td></tr><tr><td>Supplier<T></td><td>T get()</td><td>T 객체를 리턴함</td></tr><tr><td>Functioin&lt;T, R&gt;</td><td>R apply(T t)</td><td>객체 T를 객체 R로 매핑</td></tr><tr><td>Predicate<T></td><td>Boolean test(T t)</td><td>객체 T를 조사한 뒤 결과 반환</td></tr></tbody></table><ul><li>함수형 인터페이스 내의 메소드 명은 중요하지 않다.</li></ul><h3 id="Optional-옵셔널"><a href="#Optional-옵셔널" class="headerlink" title="Optional(옵셔널)"></a>Optional(옵셔널)</h3><ul><li>Stream이 종료된 후 Java의 내장 메소드는 <code>Optional</code>을 리턴한다.</li><li>Optional로 한번 감싸므로 <code>NPE</code>을 방지한다.</li></ul><h3 id="Java8-Stream"><a href="#Java8-Stream" class="headerlink" title="Java8 Stream"></a>Java8 Stream</h3><ul><li>대부분 함수형 언어들은 <code>Stream(스트림)</code>이라는 추상화가 포함되어 있다.<h4 id="스트림의-특징"><a href="#스트림의-특징" class="headerlink" title="스트림의 특징"></a>스트림의 특징</h4><ul><li>스트림은 <strong>값을 저장하지 않고</strong>, 종결 작업을 통해 <strong>입력에서 종착점까지 흐르는 파이프라인</strong>처럼 사용한다.</li><li><strong>상태를 유지하지 않는다.</strong><ul><li>ex) filter() 작업은 밑에 깔린 컬렉션을 바꾸지 않고 필터된 스트림을 받는 것</li></ul></li><li><strong>스트림은 Lazy Evaluation이다.</strong></li><li><strong>무한 스트림이 가능하다.</strong><ul><li><code>limit()</code>, <code>findFirst()</code> 같은 제한 메소드로 부분집합을 구할 수 있다.</li></ul></li></ul></li><li>스트림은 <code>중간 작업(Intermediate Operation)</code> 또는 <code>종결 작업(Terminal Operation)</code>이다.<ul><li>중간 작업은 항상 새 스트림을 리턴한다.</li><li>스트림은 게으르기(Lazy) 때문에 종결 작업까지 선언되어야 스트림에 해당하는 값을 구할 수 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"java"</span>);</span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line">Stream&lt;String&gt; stream = list.stream()</span><br><span class="line">  .filter(el -&gt; &#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">return</span> el.contains(<span class="string">"a"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">System.out.println(counter); <span class="comment">// "0"</span></span><br><span class="line"><span class="comment">// 종결 작업이 선언되지 않았기 때문에 </span></span><br><span class="line"><span class="comment">// 스트림 연산이 이루어지지 않아 값이 나오지 않는다.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Immutable-Objects"><a href="#Immutable-Objects" class="headerlink" title="Immutable Objects"></a>Immutable Objects</h3><ul><li>함수형 프로그래밍은 <code>불변성</code>이 기본이다.</li><li>불변형 객체는 <code>변이</code>가 없으므로 테스트가 간편해지고, 기본적으로 thread-safe해 동기화 문제가 없으며, 상태를 알 수 없거나 잘못된 상태를 가질일이 없다.</li><li>불변 객체는 <code>생성될 때 초기화</code>가 일어나므로 생성 시 모든 문제를 알 수 있다.(컴파일 레벨에서 확인)<ul><li>이를 <code>실패의 원자성(Failure Atomicity)</code>이라 한다.</li></ul></li></ul><h4 id="Immutable-Objects-of-Java"><a href="#Immutable-Objects-of-Java" class="headerlink" title="Immutable Objects of Java"></a>Immutable Objects of Java</h4><ol><li>모든 필드를 final 선언</li><li>클래스를 final 선언해 Override 방지</li><li>인수가 없는 생성자를 제공하지 않는다.<ul><li>불변형은 생성시 초기화 되므로 인수 없는 생성자가 필요하지 않다.</li></ul></li><li>적어도 하나의 생성자를 제공한다.</li><li>생성자 외에 변이 메소드(setter)를 제공하지 않는다.<ul><li>setter 외에도 가변 객체 참조를 전달하지 않게 주의해야한다.</li></ul></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>함수형 사고</li><li><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce">java 8 streams collect vs reduce</a></li><li><a href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4">일급 객체</a></li><li><a href="https://futurecreator.github.io/2018/08/26/java-8-streams-advanced/">java 8 stream advanced</a></li><li><a href="https://palpit.tistory.com/673">람다식 - 표준 API의 함수적 인터페이스1</a></li></ul>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/10/20/functional-thinking-ch7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>데이터베이스의 성능 향상(feat. 인덱스)</title>
      <link>https://j2de.github.io/2019/10/17/database-index/</link>
      <guid>https://j2de.github.io/2019/10/17/database-index/</guid>
      <pubDate>Wed, 16 Oct 2019 17:56:01 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;성능이란&quot;&gt;&lt;a href=&quot;#성능이란&quot; class=&quot;headerlink&quot; title=&quot;성능이란 ?&quot;&gt;&lt;/a&gt;성능이란 ?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;기본적으로 “빠르기”를 기준으로 한 개념&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="성능이란"><a href="#성능이란" class="headerlink" title="성능이란 ?"></a>성능이란 ?</h2><blockquote><p>기본적으로 “빠르기”를 기준으로 한 개념</p></blockquote><h3 id="성능을-측정하는-2가지-지표"><a href="#성능을-측정하는-2가지-지표" class="headerlink" title="성능을 측정하는 2가지 지표"></a>성능을 측정하는 2가지 지표</h3><ol><li><code>처리시간(Processing Time)</code> or <code>응답시간(Response Time)</code><ul><li>어떤 특정 처리의 시작부터 종료까지 걸린 시간</li></ul></li><li><code>처리율(Throughput)</code><ul><li>특정 처리(트랜잭션)를 단위 시간에 몇 건 처리 가능한가<ul><li>ex) 트랜잭션을 초당 50건 처리하는 것이 가능하면, 50 TPS(Transaction Per Second)</li></ul></li></ul></li></ol><h3 id="정점과-한계"><a href="#정점과-한계" class="headerlink" title="정점과 한계"></a>정점과 한계</h3><ul><li><p><code>처리율이 높은</code> 시스템일수록 (CPU나 하드웨어같은) <code>자원이 많이</code> 필요하다</p><ul><li>즉 동시에 실행되는 처리가 증가할 수록 필요한 물리 자원도 증가한다.</li></ul></li><li><p>이때 동시 실행 처리 수가 자원의 한계를 넘어서는 경우 응답시간이 상승하고 처리율이 떨어지며 성능이 나빠진다.</p></li><li><p>한 가지 자원이라도 한계에 이르면 성능이 나빠지기 시작하는데 이를 <code>버틀넥 포인트(Bottleneck Point)</code>, <code>병목</code>이라 한다.</p></li><li><p>시스템은 동시에 실행되는 처리가 가장 많아질 때를 기준으로 자원을 준비하지 않으면 <code>정점(Peek)</code>일 때 극단적인 지연을 일으킨다.</p></li><li><p>정점을 상정한 자원을 확보해두는 것을 <code>사이징(Sizing)</code>이나 <code>캐퍼시티 플랜(Capacity Planinig)</code>이라 한다.</p></li><li><p>정점일때와 아닐 때의 차이가 큰 경우 정점에 맞추는 경우 평상시에 낭비되는 자원이 크다.</p></li><li><p>그렇기에 클라우드를 통해 스케일업과 스케일아웃을 하며 동적인 자원관리를 하는 추세이다.</p><ul><li><code>스케일업(Scale-Up)</code> : 고성능 장비 도입</li><li><code>스케일아웃(Scale-Out)</code> : 장비 추가 도입</li></ul></li></ul><h2 id="데이터베이스의-성능"><a href="#데이터베이스의-성능" class="headerlink" title="데이터베이스의 성능"></a>데이터베이스의 성능</h2><h3 id="데이터베이스-병목"><a href="#데이터베이스-병목" class="headerlink" title="데이터베이스 병목"></a>데이터베이스 병목</h3><blockquote><p>데이터 베이스가 시스템에서 병목이 되기 쉬운 이유</p></blockquote><p><strong>1. 취급하는 데이터 양이 많다.</strong></p><ul><li>최근들어 저장되는 데이터가 폭발적으로 증가하는 추세라 데이터를 보존하는 저장소에서 병목이 일어나는 경우가 많다.</li></ul><p><strong>2. 자원 증가(스케일 아웃)를 통한 성능 향상이 어렵다.</strong></p><ul><li>데이터베이스의 병목 지점은 CPU나 메모리가 아니라 <code>주로 보조기억 장치</code>이므로 스케일 아웃이 어렵다.<ul><li>데이터베이스는 기본적으로 <code>Active-StandBy</code>나 <code>Active-Active</code> 구성을 취하기 때문</li><li>이런 이유로 주로 한정된 자원을 효율적으로 쓰기 위한 ‘<code>튜닝</code>‘이 발전함</li></ul></li><li>최근에는 저장소를 더 고속 매체인 <code>메모리</code>에 적재하는 등으로 <code>스케일업</code>에 의한 성능 개선도 이루어지고 있다. <ul><li>이런 발상으로 만들어진 데이터베이스가 인메모리 데이터베이스(In-memory)</li></ul></li></ul><h2 id="데이터베이스-성능을-결정하는-요인"><a href="#데이터베이스-성능을-결정하는-요인" class="headerlink" title="데이터베이스 성능을 결정하는 요인"></a>데이터베이스 성능을 결정하는 요인</h2><h3 id="데이터베이스의-실행-과정"><a href="#데이터베이스의-실행-과정" class="headerlink" title="데이터베이스의 실행 과정"></a>데이터베이스의 실행 과정</h3><p><strong>1. 파스 (Parse)</strong></p><ul><li>내부 프로그램인 Parsor가 구문 오류를 체크한다.</li></ul><p><strong>2. 실행계획 (Execution Plan OR Access Plan)</strong><br><strong>- 실행계획 작성 &gt; 실행계획 평가</strong></p><ul><li><p>내부 프로그램인 <code>Optimizer</code>가 SQL문에 어떤 경로로 접근할지 <code>계획</code>한다.</p><ul><li>프로그래머는 SQL을 선언만하고 과정은 옵티마이저가 하므로 일반적인 절차형 언어와 다르게 <code>선언형 언어</code>라 하기도 함.</li><li>옵티마이저가 보통 프로그래머보다 효율적인 실행계획을 세우므로 직접 실행계획을 세우는 것은 지양하는 것이 좋다.</li><li>옵티마이저가 최적의 속도로 동작할 수 있는 환경을 구성해주는 것이 중요</li></ul></li><li><p><code>통계 정보</code>를 참고해 <code>실행 계획</code>을 세운다.</p><ul><li><p>통계 정보란 ? 옵티마이저가 실행계획을 세울 때 참고하는 정보</p><ol><li>테이블의 행수,열수</li><li>각 열의 길이와 데이터형</li><li>테이블의 크기</li><li>열에 대한 기본키나 NOT NULL 제약의 정보</li><li>열값의 분산과 편향 등.</li></ol></li><li><p>통계 정보는 테이블에 보존되어 있다.</p><ul><li><p><code>show table status;</code><br><img src="01.png" alt="show table status"></p><ul><li>Rows : 행 수</li><li>Avg_row_length : 평균 레코드 크기</li></ul></li><li><p><code>show index from [TABLE_NAME];</code><br><img src="02.png" alt="show index from TABLE_NAME"></p><ul><li>Cardinality : 인덱스 대상의 분산도</li></ul></li></ul></li><li><p>통계 데이터는 대부분 <code>자동으로 수집</code>되어 구현된다.</p><ul><li>대체로 대량의 데이터가 변경되거나 특정 시간을 정할 수 있다.</li></ul></li></ul></li></ul><ol start="3"><li>데이터 액세스</li></ol><h3 id="데이터베이스가-실행계획을-세우는-기준"><a href="#데이터베이스가-실행계획을-세우는-기준" class="headerlink" title="데이터베이스가 실행계획을 세우는 기준"></a>데이터베이스가 실행계획을 세우는 기준</h3><blockquote><p>인덱스 </p></blockquote><ul><li><p>인덱스의 유무로 <code>풀 스캔(full scan)</code>과 <code>레인지 스캔(range scan)</code>이 나뉜다.</p><ul><li>풀 스캔: 테이블의 레코드를 전부 읽는 것</li><li>레인지 스캔: 테이블 일부 레코드만 읽는 것</li></ul></li><li><p>인덱스가 있는 경우<br><img src="03.png" alt="인덱스가 있는 경우 1"><br><img src="04.png" alt="인덱스가 있는 경우 2"></p><ul><li><code>TYPE</code>이 All이 아닌 <code>CONST</code>, <code>RANGE</code></li><li>스캔 종류의 이름은 조건에 따라 조금씩 달라진다.</li></ul></li><li><p>인덱스가 없는 경우<br><img src="05.png" alt="인덱스가 없는 경우"></p><ul><li>현재 예시 테이블은 <code>id</code>와 <code>fk</code>에만 인덱스가 존재한다.</li><li>인덱스가 없는 컬럼을 조회하므로 <code>ALL 풀 스캔</code>을 한다. </li><li><code>기본키</code>는 따로 설정하지 않아도 인덱스가 존재한다.</li></ul></li><li><p>인덱스 생성</p><ul><li><code>create index [INDEX_NAME] on [TABLE_NAME]([COLOMN_NAME])</code></li></ul></li></ul><h2 id="인덱스의-구조"><a href="#인덱스의-구조" class="headerlink" title="인덱스의 구조"></a>인덱스의 구조</h2><p><img src="btree.png" alt="B-Tree 구조"></p><ul><li>B-Tree 로 되어있다.</li><li>따라서 데이터들은 반드시 <code>정렬</code>된 데이터로 유지된다.</li><li>B-Tree는 균형 트리이기에 어떤 값에 대해서도 <code>속도가 일정</code>하다(최선, 최악의 경우가 비슷)<ul><li>일반적으로 B-Tree는 3~4층 정도로 조절된다.</li></ul></li><li>처음 생성시 <code>균형 트리</code>이지만 <code>INSERT/DELETE/UPDATE</code> 등이 일어나면 트리가 깨지며 성능이 나빠질 수 있다.</li><li>따라서 <code>갱신</code> 빈도가 높은 테이블은 정기적으로 인덱스 재구성이 필요하다.</li></ul><h2 id="인덱스의-성능"><a href="#인덱스의-성능" class="headerlink" title="인덱스의 성능"></a>인덱스의 성능</h2><p><strong>- 데이터에 비례해 효과가 좋아진다.</strong></p><ul><li>어느정도 큰 데이터에서 생성하는 것이 좋다.  </li></ul><p><strong>- 정렬을 건너뛰는 것이 가능하다.</strong></p><ul><li>예를 들면 groupby로 count하는 경우<ul><li>인덱스가 없다면 <code>풀 스캔</code> + <code>정렬을 위한 임시영역에 파일을 저장</code>한다.<ul><li>이런식으로 임시영역을 사용해 처리하면 매우 느려 성능 이슈를 일으킬 수 있다.</li></ul></li><li>인덱스가 있다면 이미 정렬되어 있으므로 고속 처리가 가능하다.</li></ul></li><li>SQL 내부에서 정렬하는 경우<ul><li>GROUP BY</li><li>COUNT/SUM/AVG 등의 집약 함수</li><li>UNION/INTERSECT/EXCEPT 등의 집합연산</li></ul></li></ul><h2 id="인덱스-주의사항"><a href="#인덱스-주의사항" class="headerlink" title="인덱스 주의사항"></a>인덱스 주의사항</h2><ul><li>인덱스는 <code>SELECT</code> 성능을 향상시키고 <code>INSERT/UPDATE/DELECT</code> 성능을 약화시킨다.<ul><li>인덱스 갱신의 오버헤드로 성능이 떨어진다.</li></ul></li><li>너무 많은 인덱스를 만드는 경우 의도한 것과 다르게 실행될 수 있다.<ul><li>인덱스를 생성만 할 뿐 실행은 옵티마이저가 자동으로 하기 때문에 의도와 다르게 동작해 더 느릴 수 있다.</li></ul></li><li>따라서 크기가 큰 테이블에만 만들고</li><li>기본키 제약이나 유일성 제약이 붙은 경우 자동으로 인덱스가 생성되므로 추가 생성하지 않는다.</li><li><code>Cardinality</code>가 높은 열에 만든다.</li></ul><h2 id="성능-안티-패턴"><a href="#성능-안티-패턴" class="headerlink" title="성능 안티 패턴"></a>성능 안티 패턴</h2><ul><li>통계 정보 갱신 설정이 off인 경우</li><li>정기 갱신을 설정하고 데이터양이 급격하게 바뀌는 경우<ul><li>정기 갱신 전 바뀐 데이터에 대해 인덱스가 적용되지 않은 상태라 성능 향상을 기대하기 어렵다.</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>데이터베이스 첫걸음 </li></ul>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/10/17/database-index/#disqus_thread</comments>
    </item>
    
    <item>
      <title>함수형 사고 - ch2 전환</title>
      <link>https://j2de.github.io/2019/10/16/functional-thinking-ch2/</link>
      <guid>https://j2de.github.io/2019/10/16/functional-thinking-ch2/</guid>
      <pubDate>Wed, 16 Oct 2019 11:54:04 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;생각의-전환&quot;&gt;&lt;a href=&quot;#생각의-전환&quot; class=&quot;headerlink&quot; title=&quot;생각의 전환&quot;&gt;&lt;/a&gt;생각의 전환&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;새로운 언어를 배우는 것은 쉽지만, &lt;code&gt;새로운 패러타임&lt;/code&gt;을 익히는 것
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="생각의-전환"><a href="#생각의-전환" class="headerlink" title="생각의 전환"></a>생각의 전환</h2><ul><li>새로운 언어를 배우는 것은 쉽지만, <code>새로운 패러타임</code>을 익히는 것은 어렵다.</li><li>함수형 코드를 제대로 작성하기 위해서는 <code>문제를 접근하는 방식의 전환</code>이 필요하다.</li></ul><h2 id="명령형에서-함수형으로의-전환"><a href="#명령형에서-함수형으로의-전환" class="headerlink" title="명령형에서 함수형으로의 전환"></a>명령형에서 함수형으로의 전환</h2><h3 id="명령형-처리"><a href="#명령형-처리" class="headerlink" title="명령형 처리"></a>명령형 처리</h3><ul><li>명령형 프로그래밍이란 <code>상태</code>를 <code>변경하는 명령</code>으로 이루어진 프로그래밍 (일반적으로 for 루프)</li></ul><script src="https://gist.github.com/kodakyung/02948b60d265572d4fd90464fe8e04e5.js"></script><ul><li>이러한 프로그래밍은 개발자가 <code>루프 내에서 연산</code>하기를 권장한다.</li><li>한 글자 이름 필터, 목록에 남아 있는 이름 대문자 변형, 목록을 하나의 문자열로 변환하는 일련의 과정을 모두 <code>저 수준의 매커니즘</code>에서 사용한다. </li></ul><h3 id="함수형-처리"><a href="#함수형-처리" class="headerlink" title="함수형 처리"></a>함수형 처리</h3><ul><li><code>필터, 변형, 변환</code> 등 논리적 분류로 구현한다.</li><li><code>고계함수</code>에 <code>매개변수로 주어지는 함수</code>를 이용해 저수준의 작업을 커스텀한다.<ul><li>고계함수란 ? 함수를 다루는 함수, 함수를 인자로 받을 수 있고 함수를 반환하기도 함. 함수가 정수와 동등하게 다루어짐</li></ul></li></ul><script src="https://gist.github.com/kodakyung/f891d3978441e6991f3c3e7deb2fb5a3.js"></script><ul><li>한 글자 이름을 필터하고, 이 연산의 결과를 map 함수에 넘긴뒤 reduce를 통해 결합한다.</li><li>모든 함수형 언어에서 비슷한 기능을 제공해준다.</li></ul><blockquote><p>이와 같이 함수형 사고로의 전환은 “세부적인 구현을 하지 않고 고수준 추상 개념을 적용하는 법”을 배우는 것이다. </p></blockquote><h3 id="고수준의-추상적-사고로-얻는-이점들"><a href="#고수준의-추상적-사고로-얻는-이점들" class="headerlink" title="고수준의 추상적 사고로 얻는 이점들"></a>고수준의 추상적 사고로 얻는 이점들</h3><ol><li><p>문제의 공통점을 고려해 <code>다른 방식으로 분류</code>하는 것을 권장함</p></li><li><p><code>런타임</code>이 <code>최적화</code>를 잘할 수 있도록 한다.</p><ul><li>더 적은 아이템을 처리하는 경우</li><li>ex) Java8 Supplier를 이용한 Lazy Evaluation 등</li></ul></li><li><p>개발자가 <code>엔진의 세부사항</code>을 깊게 고려하지 않고 프로그래밍 할 수 있다. </p><ul><li><p>책에서는 <del>“개발자가 엔진 세부사항에 깊이 파묻힐 경우 불가능한 해답을 가능하게 한다.”</del> 고 나와 있지만 위의 뜻인 것 같다. </p></li><li><p>예를 들면 위의 명령형 처리 로직에 스레드 처리가 추가된다면 스레드 관련 코드가 로직 코드에 섞여 들어간다. 하지만 함수형으로 프로그래밍한다면 병렬 처리를 의미하는 코드 한줄만 추가하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cleanNamesP</span><span class="params">(List&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (names == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">return</span> names</span><br><span class="line">          .parallelStream() <span class="comment">// 이 한줄이 추가되었다. </span></span><br><span class="line">          .filter(n -&gt; n.length() &gt; <span class="number">1</span>) </span><br><span class="line">          .map(e -&gt; capitalize(e))</span><br><span class="line">          .collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>이후 저수준의 세부적인 최적화는 런타임이 담당한다. </p></li></ul></li></ol><h3 id="명령형에서-함수형으로의-전환-과정"><a href="#명령형에서-함수형으로의-전환-과정" class="headerlink" title="명령형에서 함수형으로의 전환 과정"></a>명령형에서 함수형으로의 전환 과정</h3><ul><li><code>OOP</code> 언어는 캡슐화가 이점이므로 <code>내부 상태</code> 사용이 보편적이고 권장된다.</li><li><code>FP</code>은 내부 변수를 사용하지 않고 필요한 값을 <code>매개변수</code>로 넘긴다.<ul><li>부수 효과가 없는 <code>순수 함수</code>를 사용한다.<ul><li>입력만 결과에 영향을 주는 함수</li></ul></li><li>따라서 캐싱하지 않고 항상 계산 하기때문에 성능이 떨어지며, 이를 막기 위해 <code>메모이제이션</code>을 사용한다.</li></ul></li><li>완전한 <code>FP</code>은 <code>Stream</code>을 이용한다.<ul><li>연산의 중간과정을 스트림에 저장한 뒤 완전히 연산히 끝났을 때 스트림을 종료하고 값을 생성한다.</li><li>이를 <code>게으른 평가(Lazy Evaluation)</code>이라 한다.</li></ul></li></ul><h2 id="함수형-언어들의-공통된-빌딩-블록"><a href="#함수형-언어들의-공통된-빌딩-블록" class="headerlink" title="함수형 언어들의 공통된 빌딩 블록"></a>함수형 언어들의 공통된 빌딩 블록</h2><ul><li><code>필터 / 변형 / 변환</code>에 관한 내용은 함수형 언어 및 프레임 워크에 <code>공통적</code>으로 존재한다.</li></ul><h3 id="1-필터"><a href="#1-필터" class="headerlink" title="1. 필터"></a>1. 필터</h3><ul><li><code>사용자가 정한 조건</code>으로 목록에 있는 요소를 <code>필터</code>해서 더 작은 목록으로 만든다.</li><li>ex) java8 - filter()</li></ul><h3 id="2-맵"><a href="#2-맵" class="headerlink" title="2. 맵"></a>2. 맵</h3><ul><li>각 요소에 <code>같은 함수</code>를 적용해 <code>새로운 컬렉션</code>을 만든다.</li><li>ex) java8 - map()</li></ul><h3 id="3-폴드-리듀스"><a href="#3-폴드-리듀스" class="headerlink" title="3. 폴드 / 리듀스"></a>3. 폴드 / 리듀스</h3><ul><li>언어마다 이름도 다양하고 약간의 의미도 다르지만, 기본적으로 캐터모피즘(catamorphism)이라는 <code>목록 조작 개념의 변형</code>을 의미한다. <ul><li>목록을 접어서 다른 형태로 만드는 연산</li></ul></li><li>ex) java8의 filter로 값을 추출 후 reduce를 통해 추가 연산 후 결과를 반환</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>함수형 사고(Functional Thinking), 한빛미디어</li><li><a href="https://github.com/oreillymedia/functional_thinking">Functional Thinking Code</a></li></ul>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/10/16/functional-thinking-ch2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>함수형 사고 - ch1 왜?</title>
      <link>https://j2de.github.io/2019/10/16/functional-thinking-ch1/</link>
      <guid>https://j2de.github.io/2019/10/16/functional-thinking-ch1/</guid>
      <pubDate>Wed, 16 Oct 2019 11:26:14 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;함수형-프로그래밍을-하는-이유&quot;&gt;&lt;a href=&quot;#함수형-프로그래밍을-하는-이유&quot; class=&quot;headerlink&quot; title=&quot;함수형 프로그래밍을 하는 이유&quot;&gt;&lt;/a&gt;함수형 프로그래밍을 하는 이유&lt;/h2&gt;&lt;h3 id=&quot;1-패러다임의-전
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="함수형-프로그래밍을-하는-이유"><a href="#함수형-프로그래밍을-하는-이유" class="headerlink" title="함수형 프로그래밍을 하는 이유"></a>함수형 프로그래밍을 하는 이유</h2><h3 id="1-패러다임의-전환"><a href="#1-패러다임의-전환" class="headerlink" title="1. 패러다임의 전환"></a>1. 패러다임의 전환</h3><ul><li><p>문제에 대해 사람이 생각하는 것과 같은 방식으로 프로그래밍 할 수 있다.</p><ul><li><p>예를 들면, Java에서 <code>1)텍스트 파일을 읽고 2)가장 많이 사용된 단어를 찾고 3)그 단어들과 빈도를 정렬된 목록으로 출력해야 한다</code>면 일반적으로 성능을 위해 한 loop 안에서 3가지 연산을 섞어서 사용 할 것</p><blockquote><p>책에서는 이것을 “성능을 명료함과 맞바꾸었다”고 표현함.</p></blockquote></li><li><p>반면에 함수형 프로그래밍을 한다면 <code>map</code>과 <code>filter</code>와 같은 고계함수를 이용해 사람이 생각하는 것과 같은 흐름(위의 <code>1)</code>~<code>3)</code>)으로 프로그래밍 할 수 있게 한다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">wordFreq</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">  TreeMap&lt;String, Integer&gt; wordMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">  regexToList(words, <span class="string">"\\w+"</span>).stream() <span class="comment">// 정규표현식을 검색한 뒤 스트림으로 변경</span></span><br><span class="line">    .map(w -&gt; w.toLowerCase()) <span class="comment">// 소문자로 바꾼다.</span></span><br><span class="line">    .filter(w -&gt; !NON_WORDS.contains(w))<span class="comment">// 비단어를 골라내고</span></span><br><span class="line">    .forEach(w -&gt; wordMap.put(w, wordMap.getOrDefault(w, <span class="number">0</span>) + <span class="number">1</span>)); <span class="comment">// 단어 빈도수를 센다.</span></span><br><span class="line">  <span class="keyword">return</span> wordMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-최근-언어-트렌드"><a href="#2-최근-언어-트렌드" class="headerlink" title="2. 최근 언어 트렌드"></a>2. 최근 언어 트렌드</h3><ul><li>주요 언어들이 함수형 기능을 더하고 있다. </li><li>즉 함수형 패러다임을 이해한다면 다른 최신 함수형 언어들을 쉽게 익히고 사용할 수 있게된다.</li></ul><h3 id="3-언어-런타임에-제어를-양도함"><a href="#3-언어-런타임에-제어를-양도함" class="headerlink" title="3. 언어/런타임에 제어를 양도함"></a>3. 언어/런타임에 제어를 양도함</h3><ul><li>c++에서 Java로 GC를 사용하는 것처럼, 까다로운 <code>저수준의 문제</code>를 언어나 런타임에 최대한 맡길수록 <code>더 중요한 문제</code>에 집중 할 수 있게 된다.</li></ul><h3 id="4-간결함"><a href="#4-간결함" class="headerlink" title="4. 간결함"></a>4. 간결함</h3><blockquote><p>객체지향 프로그래밍은 움직이는 부분을 캡슐화하여 코드 이해를 돕고, 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드 이해를 돕는다. </p></blockquote><ul><li>캡슐화, 스코핑, 가시성 등의 <code>상태 변화</code>에 대해 필요한 세밀한 제어들을 직접 제어 하기 보다는 이 부분을 <code>제거</code>하는데 주력한다.</li><li>객체지향 개발자는 항상 새로운 자료구조(Object)와 거기에 메소드를 만드므로 메서드 수준의 재사용보다<code>큰 프레임워크 스타일의 재사용</code>을 하게된다.</li><li>함수 수준의 캡슐화는 모든 문제에 새로운 클래스를 생성하기보다는 <code>더 세부적인 수준에서 재사용</code>을 가능하게 한다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>함수형 사고(Functional Thinking), 한빛미디어</li><li><a href="https://github.com/oreillymedia/functional_thinking">Functional Thinking Code</a></li></ul>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/10/16/functional-thinking-ch1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MySQL 트랜잭션과 동시성 제어</title>
      <link>https://j2de.github.io/2019/10/15/mysql-transaction-and-concurrency-control/</link>
      <guid>https://j2de.github.io/2019/10/15/mysql-transaction-and-concurrency-control/</guid>
      <pubDate>Tue, 15 Oct 2019 14:20:32 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;트랜잭션과-동시성제어&quot;&gt;&lt;a href=&quot;#트랜잭션과-동시성제어&quot; class=&quot;headerlink&quot; title=&quot;트랜잭션과 동시성제어&quot;&gt;&lt;/a&gt;트랜잭션과 동시성제어&lt;/h1&gt;&lt;h2 id=&quot;트랜잭션이란&quot;&gt;&lt;a href=&quot;#트랜잭션이란&quot; cla
        
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="트랜잭션과-동시성제어"><a href="#트랜잭션과-동시성제어" class="headerlink" title="트랜잭션과 동시성제어"></a>트랜잭션과 동시성제어</h1><h2 id="트랜잭션이란"><a href="#트랜잭션이란" class="headerlink" title="트랜잭션이란?"></a>트랜잭션이란?</h2><p><strong>복수의 쿼리의 처리 단위</strong></p><ul><li>데이터 갱신은 단일 쿼리보다 <code>복수 쿼리를 연속적</code>으로 수행하는 경우가 많다.</li><li><code>동시성 제어</code>를 위해 필요</li></ul><h3 id="MyISAM-vs-InnoDB"><a href="#MyISAM-vs-InnoDB" class="headerlink" title="MyISAM vs InnoDB"></a>MyISAM vs InnoDB</h3><ul><li>전자는 테이블 단위 잠금, <code>트랜잭션 사용 불가</code></li><li>후자는 행 단위 잠금, <code>트랜잭션 사용 가능</code></li></ul><h2 id="트랜잭션-특성-ACID-특성"><a href="#트랜잭션-특성-ACID-특성" class="headerlink" title="트랜잭션 특성 (ACID 특성)"></a>트랜잭션 특성 (ACID 특성)</h2><ol><li><p>Atomicity(원자성)</p><ul><li>데이터 변경(<code>update, delete, insert</code>)시 데이터 조작이 전부 성공 or 전부 실패하도록 보증</li></ul></li><li><p>Consistency(일관성)</p><ul><li>데이터 조작 전후로 상태를 유지하는 것을 보증함…?</li><li>ex) 일관성을 유지하기 위해 사용자 등록 시 사용자 구분하기 위한 일련 번호에 unique 제약 조건을 검</li></ul></li><li><p>Isolation(고립성, 격리성)</p><ul><li><p><code>복수의 사용자</code>가 <code>데이터 조작</code>을 해도 각각 처리가 <code>모순 없이</code> 동작함</p></li><li><p>모순 없이 동작한다는 것은 동시에 말고 순서대로 실행 시켰을 때와 같은 동작을 한다는 것을 의미</p><ul><li><p>병렬로 실행되지 않은 상태를 의미(<code>직렬</code>)</p></li><li><p>ex) 호텔방 예약 시 1. 빈 방 확인 2. 빈방에서 -1 후 결과를 빈방 수로 되돌려준다는 로직을 수행하는 경우 사용자 a와 사용자 b가 동시에 수행하면 8개가 아닌 9개가 남았다고 될 수 있음</p></li></ul></li><li><p>Isolation을 유지하기 위해 <code>lock</code> 을 사용</p><ul><li>잠금 단위는 테이블 전체, 블록, 행 등</li></ul></li><li><p>MySQL은 주로 트랜잭션 처리 시 <code>행 단위</code> 잠금 이용 (<code>select ~ for update</code>)</p><ul><li>후속 처리는 해당 잠금이 해제될 때 (<code>commit</code> or <code>rollback</code> )까지 대기한 후 처리한다.</li></ul></li><li><p>InnoDB형 테이블은 <code>MVCC</code> 구조로 동작하기 때문에 단순 값 참조 시 <code>select ~ for update</code> 구준은 불필요. 읽기가 블록되지 않음.</p><ul><li>이 때 테이블 갱신하는 사용자가 소수고 참조하는 사용자가 많은 경우 사용자의 동시성, 병렬성이 높아짐.</li></ul></li><li><p>모순 없는 동작(직렬)을 위해 DBMS에서  <code>Serializable</code> (직렬화 가능) 이라는 <code>격리 수준</code>을 제공함</p></li><li><p>이때 항상 <code>동시에 동작하는 트랜잭션</code>이 <code>1개</code>여야 하므로 성능에서 실용적이지 않음</p></li><li><p>따라서 격리 수준을 완화해 <code>단계별</code>로 제공한다.</p></li></ul><br><h3 id="Trasaction-Isolation-Level-트랜잭션-격리-수준"><a href="#Trasaction-Isolation-Level-트랜잭션-격리-수준" class="headerlink" title="Trasaction Isolation Level(트랜잭션 격리 수준)"></a>Trasaction Isolation Level(트랜잭션 격리 수준)</h3><ol><li>커밋되지 않은 읽기(<code>Read Uncommied</code>) - 가장 완화</li><li>커밋된 읽기(<code>Read Committed</code>)</li><li>반복 읽기(<code>Repeatable Read</code>) - MySQL의 기본 설정</li><li>직렬화 가능(<code>Serializable</code>) - 가장 엄격</li></ol><br><h3 id="격리-수준-완화에-따라-일어나는-현상"><a href="#격리-수준-완화에-따라-일어나는-현상" class="headerlink" title="격리 수준 완화에 따라 일어나는 현상"></a>격리 수준 완화에 따라 일어나는 현상</h3><ol><li>더티 읽기(<code>Dirty Read</code>) (1 이하)<ul><li>어떤 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽는 현상</li></ul></li><li>애매한 읽기(<code>Fuzzy/Non-Repetable Read</code>) (2 이하)<ul><li>어떤 트랜잭션이 이전에 읽어들인 데이터에를 다시 읽을 때 2회 이후의 결과가 1회 때와 다른 것</li></ul></li><li>팬텀 읽기(<code>Phantom Read</code>) (3 이하)<ul><li>어떤 트랜잭션을 읽을 때 데이터가 나타나거나 사라지는 현상.</li></ul></li></ol><table><thead><tr><th>격리수준</th><th>더티 읽기</th><th>애매한 읽기</th><th>팬텀 읽기</th></tr></thead><tbody><tr><td>커밋되지 않은 읽기</td><td>O</td><td>O</td><td>O</td></tr><tr><td>커밋된 읽기</td><td>X</td><td>O</td><td>O</td></tr><tr><td>반복 읽기</td><td>X</td><td>X</td><td>O</td></tr><tr><td>직렬화 가능</td><td>X</td><td>X</td><td>X</td></tr></tbody></table></li><li><p>Durability(지속성)</p><ul><li>commit 후 (데이터 조작 완료 후) 완료 통지를 사용자가 받는 시점에서 그 조작이 <code>영구적</code>이고 결과를 잃지 않는 경우를 의미</li><li>시스템이 비정상일 때도 성립해야함(os 이상종료 등의 시스템 장애에도 해당)</li><li>MySQL과 같은 데이터베이스는 트랜잭션 조작을 하드 디스크에 <code>로그</code> 로 기록, 시스템 이상 발생 시 그 로그를 사용해 발생 전 상태로 복원함.</li></ul></li></ol><h2 id="다른-커넥션에서-테이블을-보는-경우"><a href="#다른-커넥션에서-테이블을-보는-경우" class="headerlink" title="다른 커넥션에서 테이블을 보는 경우"></a>다른 커넥션에서 테이블을 보는 경우</h2><ul><li>DDL에 의한 테이블 작성과 , DML에 의한 데이터 저장은 <code>트랜잭션 커밋 전까지 다른 커넥션에서 보이지 않지만</code> 이와 별개로 보이는 경우가 있다.</li></ul><ol><li><p>DDL에 의한 암묵적인 커밋</p><ul><li>MySQL이나 Oracle에서 create  table같은 <code>DDL 실행시 암묵적인 커밋</code> 발생.</li><li>따라서 한개의 커넥션에서 실행된 create table 성공시 다른 커넥션에서도 참조 가능</li></ul></li><li><p>오토커밋 설정</p><ul><li>트랜잭션의 개시(begin transaction, start transaction 등)가 명시적으로 지정되지 않았을 때 2가지 모드로 구분함</li></ul><ol><li><code>하나의 SQL</code>문을 하나의 트랜잭션으로</li><li>사용자가 <code>commit 또는 rollback을 실행할 때 까지</code>가 하나의 트랜잭션</li></ol><ul><li>일반적인 dbms에서는 선택 가능.</li><li>mysql, postgreSQL, SQL Server는 기본 설정이 2.오토커밋</li></ul></li></ol><ul><li>이와 별개로 갱신을 수행하는 트랜잭션 자신은 트랜잭션 격리 수준, commit, rollback과 상관없이 자신이 수행한 갱신을 즉시 볼 수 있다.</li></ul><h2 id="MVCC에-따른-MySQL-InnoDB-의-특성"><a href="#MVCC에-따른-MySQL-InnoDB-의-특성" class="headerlink" title="MVCC에 따른 MySQL(InnoDB)의 특성"></a>MVCC에 따른 MySQL(InnoDB)의 특성</h2><h3 id="MVCC-Multi-Versioning-Concurrency-Control"><a href="#MVCC-Multi-Versioning-Concurrency-Control" class="headerlink" title="MVCC(Multi Versioning Concurrency Control)"></a>MVCC(Multi Versioning Concurrency Control)</h3><p>: 다중 버전 동시성 제어</p><ul><li><p>RDBMS는 <code>공유 데이터</code>를 사용하기 때문에 <code>동시성 제어가 필요</code>함</p></li><li><p>이를 <code>Rock</code>을 통해 <code>상호배제</code>를 해 컨트롤 했지만 이는 <code>대기 현상</code>이 발생하기 때문에 <code>성능</code>이 떨어짐</p></li><li><p>어떤 데이터에 여러 차례 수정이 가해진 경우 <code>수정이 가해진 시점</code>에 대해 <code>버전 별</code>로 <code>데이터</code>를 저장하고 읽기와 쓰기간 경합을 최소화해 <code>동시성 제어</code> 성능을 높임.</p></li></ul><ol><li><strong><code>읽기</code>를 수행할 경우 갱신 중이라도 <code>블록되지 않는다</code>(읽기←&gt;읽기는 서로 블록되지 않음)</strong></li><li>읽기 내용은 <code>격리 수준에 따라</code> 내용이 바뀌는 경우가 있다.<ul><li>반복 읽기의 경우 최초 쿼리 실행한 시점에 커밋된 데이터를 읽음. 따라서 같은 쿼리 복수 회 실행 시 사이에 다른 트랜잭션이 커밋해도 그 내용은 반영되지 않음</li><li>커밋된 읽기는 쿼리를 실행한 시점에서 커밋된 데이터를 읽는다. 같은 쿼리 복수 회 실행시 그 사이에 다른 트랜잭션에서 커밋시 최신 쿼리 실행 개시 시점의 커밋된 데이터를 읽음</li></ul></li><li><code>갱신(데이터 쓰기)</code> 시 <code>배타적 잠금</code>을 얻는다. 잠금은 기본적으로 행 단위이며 트랜잭션이 종료될 때까지 유지한다. 격리 수준이나 InnoDB 설정에 따라 실제로 잠금하는 행의 범위가 다를 수 있음.</li><li><strong>갱신과 갱신은 나중에 온 트랜잭션이 잠금을 획득하려할 때 <code>블록</code>된다. 일정 시간을 기다리고, 그 안에 잠금을 얻을 수 없을 시 <code>잠금 타임아웃(lock timeout)</code>된다.</strong></li><li>갱신하는 경우 갱신 전 데이터를 <code>undo 로그</code>로 ‘롤백 세그먼트’영역에 유지한다. <ul><li>undo 로그 용도 2가지</li></ul><ol><li>갱신하는 트랜잭션 <code>롤백</code> 시 <code>갱신 전</code>으로 되돌리는 것</li><li>복수의 트랜잭션에서 격리 수준에 따라 대응하는 <code>갱신 데이터를 참조</code>하는데 이용함.<ul><li>같은 행 갱신할 때마다 undo로그가 작성되고 같은 행에 대한 복수 버전이 존재한다.</li><li>이에 의해 1,2가 실현된다.</li></ul></li></ol></li></ol><h3 id="MVCC에서의-잠금-같은-행인-경우"><a href="#MVCC에서의-잠금-같은-행인-경우" class="headerlink" title="MVCC에서의 잠금(같은 행인 경우)"></a>MVCC에서의 잠금(같은 행인 경우)</h3><ul><li>트랜잭션 A, B 둘다 읽기 &gt; O</li><li>A 읽기, B 쓰기 &gt; O</li><li>A 쓰기, B 쓰기 &gt; X<ul><li>A가 lock을 얻고 수행하는 동안 B는 block된다</li><li>지정된 시간안에 lock을 얻을 수 없는 경우 lock timeout 된다.</li></ul></li></ul><h3 id="MVCC에서의-커밋되지-않은-읽기"><a href="#MVCC에서의-커밋되지-않은-읽기" class="headerlink" title="MVCC에서의 커밋되지 않은 읽기"></a>MVCC에서의 커밋되지 않은 읽기</h3><ul><li>커밋되지 않은 읽기 격리 수준은 커밋되지 않은 경우, 읽기도 블록되는 경우 이를 허용하는 것.</li><li>MVCC는 <code>읽기가 블록되는 경우가 없어서</code> 이 레벨이 필요하지 않다.</li></ul><h2 id="잠금-타임아웃과-교착-상태"><a href="#잠금-타임아웃과-교착-상태" class="headerlink" title="잠금 타임아웃과 교착 상태"></a>잠금 타임아웃과 교착 상태</h2><h3 id="잠금-타임아웃"><a href="#잠금-타임아웃" class="headerlink" title="잠금 타임아웃"></a>잠금 타임아웃</h3><ul><li>갱신과 갱신이 부딪칠 때 <code>나중에 온 갱신</code>이 <code>잠금 대기 상태</code>가 됨.</li><li>잠금을 건 쪽이 언제 잠금을 풀지 알 수 없어서 잠금 해제를 기다리는 쪽에서<ol><li>기다리거나</li><li>기다리지 않거나</li><li>어느정도 기다릴지 를 설정할 수 있다.<ul><li><code>innodb_lock_wait_timeout</code> 시스템 변수에 설정</li><li>MySQL에서는 잠금 대기로 타임아웃 발생 시 롤백되는 단위는 기본으로 오류가 발생한 쿼리임.</li></ul></li></ol></li></ul><h3 id="교착-상태"><a href="#교착-상태" class="headerlink" title="교착 상태"></a>교착 상태</h3><ul><li>트랜잭션 A가 테이블 A의 lock을, 트랜잭션 B가 테이블 B의 lock을 가진 상태에서 서로 잠금한 테이블의 자원이 필요한 경우 <strong>아무리 기다려도 상황이 바뀌지 않음</strong>. 이를 교착상태(데드락)이라 함.</li></ul><h3 id="교착상태의-빈도를-낮추는-대책"><a href="#교착상태의-빈도를-낮추는-대책" class="headerlink" title="교착상태의 빈도를 낮추는 대책"></a>교착상태의 빈도를 낮추는 대책</h3><ul><li><p>잠금 타임 아웃과 달리 교착 상태를 기다려도 상황이 개선되지 않는다.</p></li><li><p>따라서 일반적으로 DBMS에서는 <code>교착상태</code>를 검출해 <code>보고</code>한다.</p><ul><li>MySQL의 경우 교착 상태가 일어나면 시스템 영향이 작은 쪽 트랜잭션을 트랜잭션 개시 시점까지 롤백한다.</li></ul></li><li><p>교착 상태를 모두 없애는 것은 불가.</p></li><li><p>따라서 항상 트랜잭션이 교착 상태를 일으켜 롤백되는 경우 트랜잭션을 재실행할 수 있는 구조로 만들어야함.</p></li><li><p>DBMS의 전반적인 대책</p></li></ul><ol><li>트랜잭션을 자주 커밋, 트랜잭션이 <code>더 작은 단위</code>가 되어 교착상태 가능성을 낮춤</li><li><code>정해진 순서</code>로 테이블(과 행)에 액세스 하게 한다.<ul><li>ex) 트랜잭션 A가 테이블 a&gt;테이블b로 엑세스 하고 트랜잭션 B가 테이블 b&gt; 테이블 a로 액세스해 교착상태가 발생한 것이므로 어떤 트랜잭션도 테이블 a&gt;b순으로 엑세스 하도록함.</li></ul></li><li>필요 없는 경우 <code>읽기 잠금 획득(select ~ for update)</code> 사용을 피한다</li><li>쿼리에 의한 <code>잠금 범위</code>를 좁히거나(테이블 &gt; 행 등), <code>잠금 정도</code>를 더 작은 것으로 (격리 레벨 완화) 한다.<ul><li>테이블 잠금보다 행 잠금을 사용</li><li>MySQL은 기본 설정인 반복 읽기가 아닌 커밋된 읽기로 설정</li></ul></li><li>동시에 많은 연결에서 갱신 때문에 교착 상태가 자주 발생하는 경우 테이블 단위 잠금을 획득해 갱신을 <code>직렬화</code> 하면 동시성은 떨어져도 교착상태는 회피할 수 있어 전체 처리로 보면 좋을 수도 있다.</li><li>(MySQL(InnoDB)의 대책) 테이블에 적절한 인덱스를 추가해 인덱스가 이를 이용하게 한다. 인덱스가 사용되지 않는 경우에는 필요한 행의 잠금이 아닌 스캔한 행 전체에 대해 잠금이 걸리게된다. …? 이해안됨</li></ol><h2 id="해서는-안-되는-트랜잭션-처리"><a href="#해서는-안-되는-트랜잭션-처리" class="headerlink" title="해서는 안 되는 트랜잭션 처리"></a>해서는 안 되는 트랜잭션 처리</h2><ol><li>오토커밋<ul><li>MySQL의 새로운 연결은 모두 기본값으로 오토 커밋</li><li>오토 커밋은 <code>쿼리 단위</code>로 <code>커밋</code>하는 것.</li><li>테스트용으로는 좋지만 애플리케이션에 사용하기엔 <code>부하</code>가 너무 높음</li></ul></li><li>긴 트랜잭션<ul><li>긴 트랜잭션은 데이터베이스 트랜잭션의 <code>동시성</code>이나 <code>자원의 효율성</code>을 저하함.</li><li>갱신을 포함한 트랜잭션은 같은 데이터를 갱신하려는 다른 테이블을 <code>블록</code>하고 이에 <code>타임아웃</code>될 수 있음.</li><li>이 잠금과 블록 사이에 교차가 발생하면 <code>교착상태</code>도 발생, 이에 긴 트랜잭션 중 하나가 롤백됨</li><li>이를 위해 <code>교착상태의 빈도를 낮추는 대책</code> 에 나온 방법을 시행하는 것이 좋음.</li></ul></li></ol><ul><li>그밖의 피해야할 것.<ol><li><code>대량 처리</code>를 한 개의 트랜잭션이 실행<ul><li>대량의 갱신 처리를 한개의 트랜잭션으로 실행하면 트랜잭션으로 이 처리를 롤백하기 위해 <code>대량의 undo 로그</code>를 트랜잭션 종료 시까지 유지해야 한다.</li><li>Undo 로그가 불필요해진 시점에 해당 영역은 해제되어 재사용되지만 os파일 시스템에서의 크기는 줄어들지 않는다 .</li><li>이 때문에 겉보기에 불필요하게 undo 로그가 큰 경우가 있음.</li><li>이를 막기 위해 대량 처리를 <code>적당한 크기</code>의 트랜잭션으로 나누어 처리하는 것이 좋다.</li><li>예를 들면 신규테이블에 데이터를 로드할 때 1만건당 커밋</li></ul></li><li>아무것도 하지 않는 트랜잭션 유의<ul><li>테이블을 <code>select</code>한 후 아무것도 하지 않고 트랜잭션을 <code>열린 채로 두면</code> 같은 테이블에 갱신을 실행할 때 이 테이블의 반복 읽기를 유지하기 위해 <code>undo 로그</code>가 계속 유지된다 .따라서 피하는 것이 좋다.</li></ul></li><li>트랜잭션 중 <code>대화 처리</code>를 넣는 경우<ul><li>dbms의 트랜잭션은 빡빡한 처리를 동시에 실행하는 구조</li><li>따라서 언제 끝날지 알 수 없는 <code>불명확한 처리</code>를 포함해선 안된다.</li></ul></li><li>처리 능력 이상의 트랜잭션 수<ul><li>트랜잭션에서 어떤 잠금이 있는 처리를 수행할 때 이 잠금이 다른 트랜잭션의 처리를 막지 않는 것이 좋지만, 트랜잭션 실행이 다른 트랜잭션 잠금 때문에 막힌다면 잠금 타임아웃이나 교착 상태 확률이 증가하고 성능 저하로 이어짐.</li><li>커넥션이 잘 작동하는 수나 동시 실행할 수 있는 수의 상한을 어느정도로 설정할 지는 시스템 요건(갱신이 많은지 검색이 많은지)나 하드웨어 성능에도 좌우되므로 <code>최적의 트랜잭션 수</code>는 <code>부하 실행</code>을 수행해 측정할 수 밖에 없다.</li><li>MySQL은 데이터베이스 서버의 커넥션 수 상한을 설정하는 <code>max_connections</code> 라는 시스템 변수가 있어 이것으로 조절할 수 있다.</li></ul></li></ol></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>데이터베이스 첫걸음</li></ul>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/10/15/mysql-transaction-and-concurrency-control/#disqus_thread</comments>
    </item>
    
    <item>
      <title>🐥병아리 개발자가 IT 정보를 얻는 방법들</title>
      <link>https://j2de.github.io/2019/09/26/how-junior-developers-get-it-information/</link>
      <guid>https://j2de.github.io/2019/09/26/how-junior-developers-get-it-information/</guid>
      <pubDate>Thu, 26 Sep 2019 13:30:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;개발을 처음 시작하거나, 잘 모르는 경우 &lt;code&gt;IT/개발 정보&lt;/code&gt;를 어디에서 얻어야하는지부터 잘 모르는 경우가 있다.&lt;br&gt;본인 또한 IT 정보를 얻고 커뮤니케이션을 하는 방법을 잘 몰랐기 때문에,&lt;br&gt;과거의 나처럼 잘 모르는 병
        
      
      </description>
      
      <content:encoded><![CDATA[<p>개발을 처음 시작하거나, 잘 모르는 경우 <code>IT/개발 정보</code>를 어디에서 얻어야하는지부터 잘 모르는 경우가 있다.<br>본인 또한 IT 정보를 얻고 커뮤니케이션을 하는 방법을 잘 몰랐기 때문에,<br>과거의 나처럼 잘 모르는 병아리 개발자들에게 정보를 공유하고 싶어서 글을 적게되었다.</p><h2 id="1-페이스북"><a href="#1-페이스북" class="headerlink" title="1. 페이스북"></a>1. 페이스북</h2><p>개발자들이 <code>가장 빠른 정보</code>를 주고 받는 플랫폼은 페이스북인 것 같다.<br>특히 <code>세미나/컨퍼런스</code>에 대한 정보를 실시간으로 얻기 좋다.<br>그리고 IT 계에서 유명한 분들의 글 중 특히 양질의 글이 추천으로 올라오기도 한다.<br>SNS를 하기 싫더라도 페이스북은 구독용 계정이라도 만드는 것을 추천한다.(<del>본인 얘기</del>)<br>자신이 관심 있는 분야의 페이지를 구독하는 것이 좋지만, 정말 아무 것도 모른다면 <code>생활코딩</code> 페이지를 구독하자. <code>생활코딩</code> 페이지에서 글을 보다보면 다른 페이지의 글을 공유해오기도 하고 다른 여러 IT 관련 페이지들이 추천으로 뜨는 편이다.  </p><h3 id="기본적으로-추천하는-페이지들"><a href="#기본적으로-추천하는-페이지들" class="headerlink" title="기본적으로 추천하는 페이지들"></a>기본적으로 추천하는 페이지들</h3><ul><li>생활코딩 : 온갖 IT 글이 종류를 가리지 않고 올라온다.</li><li>출퇴근길 개발 읽기 : 개발에 관련된 양질의 포스팅이 올라온다.</li><li>좋은 지식 공유 Popit : Popit 사이트의 글이 올라온다.</li><li>초보 개발자 모임</li></ul><blockquote><p>우선 이 4개 페이지는 구독하고 시작하자</p></blockquote><h2 id="2-RSS"><a href="#2-RSS" class="headerlink" title="2. RSS"></a>2. RSS</h2><p>좋은 개발자 블로그는 많은데, 블로그를 매번 찾아가서 신규 게시글을 읽는건 생각보다 엄청나게 힘든일이다. 그때 RSS 구독을 이용하는 것을 추천한다. 개발자들이라면 보통 블로그에 RSS 설정을 해둔 곳이 많다. (<del>이 블로그도 되어있다..</del>)<br><code>Chrome Extension</code>이나 <code>Feedly</code> 등의 App을 이용하면 이런 개발자들의 블로그들을 구독할 수 있다. 관심 있는 분야의 블로그를 구독해두고 짬짬히 글을 읽는 것을 추천한다.<br>하지만 RSS 구독은 <code>push</code>가 오지 않기 때문에 버릇을 들이지 않으면 자주 안읽게 된다는 단점이 있다. 그래서 가급적이면 하루 1번은 들어가려고 노력 중이다..  </p><p><img src="01.png" alt="Feedly"></p><blockquote><p>이런식으로 블로그글을 한번에 모아서 볼 수 있다.<br>또한 인기 있는 글도 모아서 보여준다. </p></blockquote><p>그 밖에도 좋은 개발 블로그들을 모아둔 <a href="https://github.com/isme2n/awesome-blogs">awesome-blogs</a>도 RSS 서비스를 제공하니 구독하는 것을 추천한다. </p><h2 id="3-Slack"><a href="#3-Slack" class="headerlink" title="3. Slack"></a>3. Slack</h2><p>관심 있는 IT 커뮤니티의 Slack에 참여하는 것도 정보를 얻는 좋은 방법이다.<br><code>DjangoGirls</code>나 <code>9XD</code>, <code>백준 알고리즘</code>과 같이 관심 있는 IT 커뮤니티의 Slack에 가입해보자.</p><h2 id="4-메일링-서비스"><a href="#4-메일링-서비스" class="headerlink" title="4. 메일링 서비스"></a>4. 메일링 서비스</h2><p>개인적으로 IT 정보를 얻을 때 메일링 서비스를 애용하는 편이 아니라 구독하는 경로는 잘모르지만 RSS보다 메일링 서비스를 선호하는 경우도 많다.<br><a href="http://daily-devblog.com">Daily DevBlog</a>에서 개발자 블로그를 메일링 해주며, <code>매일 프로그래밍</code>은 매일 아침 알고리즘 문제를 보내준다. 그밖에 <a href="https://newneek.co">NewNeek</a>은 간단한 시사이슈를 정리해 메일링해준다.</p><h2 id="5-기타-IT-커뮤니티"><a href="#5-기타-IT-커뮤니티" class="headerlink" title="5. 기타 IT 커뮤니티"></a>5. 기타 IT 커뮤니티</h2><p>가장 대중적으로 유명한 커뮤니티는 <a href="https://okky.kr/">okky</a>이다. 위의 모든 것들을 읽고 나면 커뮤니티까지 가기는 어려워서 자주 가진 않지만 좋은 글들이 많다.</p><h2 id="6-동료-개발자들"><a href="#6-동료-개발자들" class="headerlink" title="6. 동료 개발자들"></a>6. 동료 개발자들</h2><p>가장 중요한 것은 열정적인 <code>동료 개발자들</code>(🐏🐑)이 주변에 있는 것이라 생각한다.<br>1번부터 5번까지 현실적으로 모든 정보를 혼자서 다 얻기는 어려운 일이다.<br>주변에 함께 개발을 하는 친구들과 개발에 대한 얘기를 나누다보면 서로의 관심사에 대해 알게되고,<br>서로의 관심사에 대해 알게되면 관련된 IT 정보를 얻게 되었을 때 서로가 서로에게 알려주며 도움도 되고 자극 받으며 성장할 수 있는 것 같다.</p><p>개발을 할수록, 개발자의 문화에 익숙해질수록 개발자끼리의 커뮤니케이션이 굉장히 중요하다는 생각이 든다.<br>다른 직업들도 그렇겠지만 개발자야말로 외골수가 아닌 커뮤니케이터가 필요하다는 것을 깨닫게 된다.</p>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/09/26/how-junior-developers-get-it-information/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Gradle로 빌드 시 현재 git branch 사용하기</title>
      <link>https://j2de.github.io/2019/08/31/using-gradle-build-current-git-branch/</link>
      <guid>https://j2de.github.io/2019/08/31/using-gradle-build-current-git-branch/</guid>
      <pubDate>Sat, 31 Aug 2019 09:38:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;현재 대외 IT 동아리인 YAPP에서 동아리 프로젝트 아카이빙 프로젝트를 진행하고 있다.&lt;br&gt;기존에는 AWS를 이용해 프로젝트를 진행하고 배포까지 했으나 동아리에서 &lt;code&gt;네이버 클라우드 플랫폼(Naver Cloud Platform, 이하 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>현재 대외 IT 동아리인 YAPP에서 동아리 프로젝트 아카이빙 프로젝트를 진행하고 있다.<br>기존에는 AWS를 이용해 프로젝트를 진행하고 배포까지 했으나 동아리에서 <code>네이버 클라우드 플랫폼(Naver Cloud Platform, 이하 NCP)</code>을 지원 받게 되어 서버 이전 작업을 진행중이다.<br>AWS로 프로젝트를 진행할 때에는 <code>Travis CI</code>를 이용해 테스트와 CI를 하고 <code>AWS S3</code>,<code>AWS CodeDeploy</code>를 이용해 <code>AWS EC2</code> 프리티어 인스턴스에 자동으로 배포 되도록 설정을 해두었다.<br>NCP에서 비슷한 기능을 찾아보니 유료로 제공되고 동아리 지원금을 마음대로 쓸 수 없어서 어쩔수 없이 자동으로 배포되는 것을 포기하고 수동으로 <code>Shell Script</code>를 짜서 배포를 하기로 결정했다.</p><p>배포를 진행하다 문제가 된 것은 현재 프로젝트에서 배포용 코드는 <code>deploy branch</code>에 분리해두었는데 스크립트로 빌드(<code>gradle build</code>)를 실행해 배포하는 경우 <code>master branch</code> 기준으로 빌드가 되는 것이었다. </p><p><code>profile</code>을 변경해 실행 하는 경우 아래의 <code>java -jar</code> 명령어를 사용하거나</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Dspring.profiles.active=<span class="variable">$&#123;profile&#125;</span> <span class="variable">$&#123;jarfile&#125;</span></span><br></pre></td></tr></table></figure><p>Gradle의 <code>BootRun</code>을 이용하는 경우 아래의 설정을 이용하면 된다. </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bootRun &#123;</span><br><span class="line">    String activeProfile = System.properties[<span class="string">'spring.profiles.active'</span>]</span><br><span class="line">    systemProperty <span class="string">"spring.profiles.active"</span>, activeProfile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금은 <code>profile</code>이 아닌 <code>git branch</code>으로 빌드가 되어야했기 때문에 구글에 검색해보니 비슷한 사례가 나왔다.<br><code>gradle-git plugin</code>을 사용하는 경우가 있고 플러그인 없이 사용하는 방법이 있다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gradle-git plugin 사용하는 경우 </span></span><br><span class="line"><span class="keyword">task</span> getBranchName(type: GitBranchList) &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">print</span> getWorkingBranch().name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugin 없이 사용하는 경우 </span></span><br><span class="line"><span class="keyword">def</span> gitBranch() &#123;</span><br><span class="line">    <span class="keyword">def</span> branch = <span class="string">""</span></span><br><span class="line">    <span class="keyword">def</span> proc = <span class="string">"git rev-parse --abbrev-ref HEAD"</span>.execute()</span><br><span class="line">    proc.in.<span class="keyword">eachLine</span> &#123; line -&gt; branch = line &#125;</span><br><span class="line">    proc.err.<span class="keyword">eachLine</span> &#123; line -&gt; <span class="keyword">println</span> line &#125;</span><br><span class="line">    proc.waitFor()</span><br><span class="line">    branch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://stackoverflow.com/questions/15061277/how-can-i-get-the-current-git-branch-in-gradle">https://stackoverflow.com/questions/15061277/how-can-i-get-the-current-git-branch-in-gradle</a></li><li><a href="http://coders-kitchen.com/2013/11/01/gradle-git-how-to-map-your-branch-to-a-deployment-profile/">http://coders-kitchen.com/2013/11/01/gradle-git-how-to-map-your-branch-to-a-deployment-profile/</a></li></ul>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/08/31/using-gradle-build-current-git-branch/#disqus_thread</comments>
    </item>
    
    <item>
      <title>OS - 동기화(Synchronization)와 임계 영역(Critical Section)</title>
      <link>https://j2de.github.io/2019/07/17/os-synchronization-and-critical-section/</link>
      <guid>https://j2de.github.io/2019/07/17/os-synchronization-and-critical-section/</guid>
      <pubDate>Wed, 17 Jul 2019 14:46:37 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;병렬 프로그래밍에서 임계영역 까지의 흐름을 정리해보았다. &lt;/p&gt;
&lt;h2 id=&quot;병렬-프로그래밍-Parallel-Programming&quot;&gt;&lt;a href=&quot;#병렬-프로그래밍-Parallel-Programming&quot; class=&quot;headerlink&quot; t
        
      
      </description>
      
      <content:encoded><![CDATA[<p>병렬 프로그래밍에서 임계영역 까지의 흐름을 정리해보았다. </p><h2 id="병렬-프로그래밍-Parallel-Programming"><a href="#병렬-프로그래밍-Parallel-Programming" class="headerlink" title="병렬 프로그래밍(Parallel Programming)"></a>병렬 프로그래밍(Parallel Programming)</h2><ul><li>멀티코어(<code>Multi-Core</code>)가 등장한 이후 여러 개의 코어를 효과적으로 사용하기 위해 등장.</li><li>하나의 프로그램이 <code>동시에 여러 일</code>을 수행하게 만드는 방법을 통칭하는 용어이다.</li><li>여기서는 동시 프로그래밍(<code>Concurrent Programming</code>) 의미의 병렬프로그램이다.<ul><li>다른 의미로 고성능 컴퓨팅(High Performance Computing)의 한 분야를 지칭하기도 한다. </li></ul></li><li>규모가변성(<code>Scalability</code>)이 뛰어난 프로그램이라면 코어의 수를 늘렸을 때 프로그램의 성능이 향상된다.</li><li>규모가변성이 보장되면서 스레드 세이프(<code>Thread-Safe</code>)한 코드를 작성하는 것은 매우 어려운 편이다.</li></ul><h3 id="고전적인-병렬-프로그램-예시들"><a href="#고전적인-병렬-프로그램-예시들" class="headerlink" title="고전적인 병렬 프로그램 예시들"></a>고전적인 병렬 프로그램 예시들</h3><ul><li>공통된 자원을 공유하고 락(Lock)과 컨디션 변수(Condition Variable)를 통해 공유 자원의 접근을 통제하는 멀티 스레드 프로그래밍(Multi-Thread Programming).</li><li>OS 프로세스 여러개에 프로세스 간 통신(Inter-Process Communication)을 통해 데이터를 처리하는 경우. </li><li>등등…</li></ul><h2 id="멀티-스레드-프로그래밍"><a href="#멀티-스레드-프로그래밍" class="headerlink" title="멀티 스레드 프로그래밍"></a>멀티 스레드 프로그래밍</h2><ul><li>공유 자원(or 메모리)를 여러 개의 스레드가 동시에 프로그래밍을 수행하며 같은 자원에 데이터를 읽고 쓰며 통신하는 것.</li><li>일반적으로 운영체제나 시스템 SW에 사용됐지만 <code>Java</code>의 <code>Monitor</code> 개념에 도입되면서 일반 개발자들도 많이 사용한다.</li><li>멀티스레드 프로그래밍은 오류 없이 설계하기 어렵고 비결정적이며 테스트가 어렵고 버그도 재현이 어려워 디버깅이 거의 불가능하다.</li><li>즉 <code>안정성</code>과 <code>규모가변성</code>이 상충되기 때문에 적절한 프로그래밍을 하는 것이 어렵다.</li></ul><blockquote><p>참고  </p><ul><li>아래부터 언급하는 Process는 해당 개념이 사용되는 영역이 어떤 것이냐에 따라 Thread로 해석할 수 있다.</li><li>ex) OS(ex Linux)에서는 Process 기준, Java에서는 Thread 기준이다.</li></ul></blockquote><h2 id="동기화-Synchronization"><a href="#동기화-Synchronization" class="headerlink" title="동기화(Synchronization)"></a>동기화(Synchronization)</h2><ul><li><code>레이스 컨디션</code> 상황을 막기 위해 프로세스/스레드들에 하나의 자원에 대한 처리 <code>권한</code>을 주거나 <code>순서</code>를 조정해주는 기법이다. </li><li><code>다중 스레드</code> 환경에 공유되는 자원이 있다면 필수적으로 고려해야한다. </li><li>프로세스의 경우 OS 레벨에서 공유 자원 문제를 처리해주지만 한 프로세스 내에서 실행되는 여러 개의 스레드들은 공유 자원에 대해 동기화 문제를 고려해야한다. </li></ul><h3 id="경쟁-상황-레이스-컨디션-Race-Condition"><a href="#경쟁-상황-레이스-컨디션-Race-Condition" class="headerlink" title="경쟁 상황(레이스 컨디션, Race Condition)"></a>경쟁 상황(레이스 컨디션, Race Condition)</h3><ul><li><code>공유 자원</code>에 여러 프로세스/스레드가 동시에 접근하기 위해 <code>경쟁</code>하는 상태를 뜻한다.<ul><li>ex) OS에서 CPU 점유율 등 </li></ul></li><li><code>동기화 처리</code>를 제대로 하지 않으면 의도하지 않은 잘못된 결과가 나올 수 있다. </li></ul><h2 id="임계-영역-Critical-Section"><a href="#임계-영역-Critical-Section" class="headerlink" title="임계 영역(Critical Section)"></a>임계 영역(Critical Section)</h2><ul><li><code>공유 자원</code>에 <code>접근</code>하는 프로세스 내부의 코드 영역.</li><li>한 프로세스의 임계 영역이 수행 중일 때 다른 프로세스가 같은 공유 자원을 사용하는 임계 영역을 수행한다면 문제가 발생할 수 있다.</li><li>따라서 한 번에 한 프로세스만 접근해 사용한다.</li><li>임계 영역을 들어오는 진입 영역(entry section), 나가는 부분인 퇴출 영역(exit section), 나머지 영역(remainder section)으로 구분된다. </li></ul><h2 id="임계-영역의-조건"><a href="#임계-영역의-조건" class="headerlink" title="임계 영역의 조건"></a>임계 영역의 조건</h2><h3 id="상호-배제-Mutual-Exclusion-Mutex"><a href="#상호-배제-Mutual-Exclusion-Mutex" class="headerlink" title="상호 배제(Mutual Exclusion( == Mutex))"></a>상호 배제(Mutual Exclusion( == Mutex))</h3><ul><li>한 프로세스가 자신의 임계 영역 내에서 실행되는 동안, 다른 프로세스가 같은 공유 자원을 사용하는 자신의 임계 영역에서 실행될 수 없는 것.</li></ul><h3 id="진행-Progress"><a href="#진행-Progress" class="headerlink" title="진행 (Progress)"></a>진행 (Progress)</h3><ul><li>임계 영역을 실행 중인 프로세스가 없고 자신의 임계 영역으로 진입하려는 프로세스가 있다면, 나머지 영역에서 실행 중이지 않은 프로세스들만 임계 영역으로 진입하기 위해 요청할 수 있다.</li><li>이는 무기한 연기될 수 없다.</li></ul><h3 id="한정된-대기-Bounded-waiting"><a href="#한정된-대기-Bounded-waiting" class="headerlink" title="한정된 대기 (Bounded waiting)"></a>한정된 대기 (Bounded waiting)</h3><ul><li>프로세스가 자신의 임계 영역에 진입하기 위해 요청을 한 뒤, 그 요청이 허가될 때까지 다른 프로세스들이 자신의 임계 영역에 진입하도록 허용하는 횟수의 제한이 있어야한다. </li></ul><h2 id="임계-영역-해결-방안-동기화"><a href="#임계-영역-해결-방안-동기화" class="headerlink" title="임계 영역 해결 방안(동기화)"></a>임계 영역 해결 방안(동기화)</h2><ul><li>하드웨어 기반 동기화와 소프트웨어 기반 동기화로 나뉜다.</li><li>대표적인 소프트웨어 기반 동기화 기법으로 상호 배제(<code>Mutex</code>), 세마포어(<code>Semaphore</code>), 모니터(<code>Monitor</code>) 등이 있다.</li></ul><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://skyul.tistory.com/327">소프트웨어 트랜잭션 메모리와 하스켈</a></li><li><a href="https://tiredsleeper.tistory.com/32?category=779575">프로세스 동기화의 필요성, 임계 영역</a></li><li><a href="https://12bme.tistory.com/68">멀티 스레드와 동기화</a></li></ul>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/07/17/os-synchronization-and-critical-section/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SpringBoot-ReactJS 프로젝트에서 OAuth 소셜 로그인 구현 중 마주친 CORS 문제</title>
      <link>https://j2de.github.io/2019/06/16/springboot-react-cors/</link>
      <guid>https://j2de.github.io/2019/06/16/springboot-react-cors/</guid>
      <pubDate>Sat, 15 Jun 2019 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;code&gt;SpringBoot&lt;/code&gt; 프로젝트에 &lt;code&gt;OAuth2&lt;/code&gt; 소셜 로그인을 구현하는 프로젝트에서 발생한 문제이다. 작은 규모의 프로젝트였기 때문에 SpringBoot와 View단의 &lt;code&gt;ReactJS&lt;/code&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><code>SpringBoot</code> 프로젝트에 <code>OAuth2</code> 소셜 로그인을 구현하는 프로젝트에서 발생한 문제이다. 작은 규모의 프로젝트였기 때문에 SpringBoot와 View단의 <code>ReactJS</code>를 따로 호스팅하지 않고 SpringBoot의 정적 리소스에 React Build 파일을 포함해 배포를 하였다. 여기서 React에서 Login API를 호출하는데 CORS 에러가 발생하였다.</p><h3 id="CORS란"><a href="#CORS란" class="headerlink" title="CORS란?"></a>CORS란?</h3><blockquote><p>Cross Origin Resource Sharing의 약자로 현재 웹페이지가 이 페이지를 받은 서버가 아닌 다른 서버의 리소스를 호출하는 것을 의미한다.</p></blockquote><p>우선 OAuth 로그인 프로세스를 살펴보면 여러가지 승인 타입이 있는데 이 중 <code>권한 부여 코드 승인 타입(Authorization Code Grant Type)</code>을 이용해 로그인을 구현하였다. 페이스북이나 구글, 카카오 등에서 위 타입의 방식으로 웹 서버 클라이언트를 지원한다.</p><h3 id="권한-부여-코드-승인-타입-Authorization-Code-Grant-Type"><a href="#권한-부여-코드-승인-타입-Authorization-Code-Grant-Type" class="headerlink" title="권한 부여 코드 승인 타입(Authorization Code Grant Type)"></a>권한 부여 코드 승인 타입(Authorization Code Grant Type)</h3><p><img src="/images/2019-06-16/auth_code_flow.png" alt="authorization-code-grant-type"></p><blockquote><p><a href="http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/">이미지 출처</a></p></blockquote><p>인증 과정을 살펴보면 처음에 <code>client</code>가 <code>Authorization Code Request</code>를 한뒤 <code>Authorization Server</code>에서 <code>client_id</code>와 <code>redirect_uri</code>, <code>response_type</code>을 확인한 뒤 <code>Resource Owner</code>가 로그인할 수 있도록 한다. 이후 <code>Resource Owner</code>가 로그인을 하면 뒤의 인증과정이 더 이루어지는 것이다.</p><p>여기서 <code>Authorization Server</code> 즉 소셜로그인을 하려는 대상인 서버(현 프로젝트에서는 Google)에서 필요한 조건들을 확인한 뒤 <code>Login</code>창으로 <code>Redirect</code>를 해주는데 현 프로젝트에서 <code>CORS</code> 에러가 발생한 부분이 이 부분이었다.<br>즉 처음 <code>Request</code>를 보내고 정상적으로 동작한다면 <code>302</code> code를 받고 로그인 창으로 이동하고, 유저가 로그인을 하면 내부적으로 인증 과정이 동작해야하는데 <code>302</code> 코드가 아닌 <code>405</code> 코드를 반환하면서 에러가 발생했다.</p><ul><li>302, 405 Status Code</li></ul><blockquote><p>3으로 시작하는 코드는 Redirection을 의미한다. 그 중 302는 Found로 리퀘스트된 리소스에 새로운 URI가 할당되어 있고 그 URI를 참조하라는 의미이다. 301,302,303 코드가 되돌아오면 대부분 브라우저에서는 POST를 GET으로 바꾸어 리퀘스트의 엔티티 바디를 삭제하고 리퀘스트를 자동적으로 재송신하도록 되어있다.</p></blockquote><blockquote><p>405 코드는 Method Not Allowed. 허용되지 않은 메소드를 호출한 것을 의미한다.</p></blockquote><h2 id="Error-Message"><a href="#Error-Message" class="headerlink" title="Error Message"></a>Error Message</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.</span><br><span class="line">&gt; OPTIONS https://LOGIN-ENDPOINT/login&amp;response_type=code&amp;scope=email%20profile&amp;state=6Zy6nR 405</span><br><span class="line"></span><br><span class="line">Access to XMLHttpRequest at &apos;https://accounts.google.com/o/oauth2/v2/auth?client_id=CLIENT_ID_VALUE&amp;redirect_uri=http://LOGIN-ENDPOINT/login&amp;response_type=code&amp;scope=email%20profile&amp;state=6Zy6nR&apos; from origin &apos;https://REQUESTER&apos; has been blocked by CORS policy: Response to preflight request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.</span><br></pre></td></tr></table></figure><p>처음에 뜬 에러는 이 메세지가 아닐수도 있다. 어느 쪽 코드가 잘못된 것인지 많은 경우의 수가 있어서 Front 코드 하나 Server 코드 하나하나 수정해가면서 서버에 배포해서 확인하느라 하나하나 기록하지는 못했다. 우선 트러블슈팅 후반부(?)에 계속 참고한 에러 메세지는 이것이었다.<br>(이외에도 request시 origin이 null이 된다는 등 다양한 에러가 계속 발생했었다.)</p><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><p>우선 서버에 문제가 있나 확인하기 위해서 <code>curl</code> 명령어로 확인을 해보았다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl \                                     </span><br><span class="line">  --verbose \</span><br><span class="line">  --request GET \</span><br><span class="line">  &apos;https://LOGIN-ENDPOINT/login&apos; \</span><br><span class="line">  --header &apos;Origin: http://REQUESTER&apos; \</span><br><span class="line">  --header &apos;Access-Control-Request-Headers: Origin, Accept, Content-Type&apos; \</span><br><span class="line">  --header &apos;Access-Control-Request-Method: GET&apos;</span><br></pre></td></tr></table></figure><p>curl에서는 정상적으로 <code>302</code> 코드를 반환하였다. 즉 서버의 문제가 아닌 <code>React</code>와 합쳐서 배포하는 과정에서 생긴 이슈인 것을 알았다.</p><hr><ul><li><p>CORS 동작과정 (<a href="https://www.popit.kr/corss-domain-api-서버-구성/">참고링크</a>)</p><ul><li>브라우저는 다른 도메인으로 Ajax 등의 호출을 보내기 전에 다음과 같은 순서로 동작합니다.  </li></ul><ol><li>“preflight” 확인 요청을 OPTIONS method로 전송(요청 시 Http Header의 속성으로 “Origin”에 자신의 도메인을 전송) </li><li>이 요청을 받은 서버는 정상적인 요청인지 확인하여, 정상적인 요청이면 Response에 허용 가능한 도메인(Access-Control-Allow-Origin), Method(Access-Control-Allow-Methods), Header 속성(Access-Control-Allow-Headers) 등을 설정하여 응답  </li><li>OPTIONS 요청에 대해 수신을 받은 브라우저는 Header의 “Access-Control-Allow-*” 정보를 이용하여 요청을 보낼 수 있는지 판단하여 권한이 없는 경우 위와 같은 에러 처리를 하고 요청을 보낼 수 있으면 요청 전송</li></ol></li></ul><hr><p>위 에러 메세지를 기반으로 여러가지를 찾아봤는데 초기에는 Front 쪽에서 API를 호출할 때 Header에 CORS 허용을 하지 않아서(<code>Access-Control-Allow-Origin</code> 설정) 많은 시간을 허비했다. 하지만 이 이후에도 CORS 에러가 해결되지 않았다. 그리고 위 링크에서 Spring을 사용하는 경우 <code>@CrossOrigin</code> 어노테이션으로 쉽게 해결할 수 있다 했지만 OAuth Social Login Endpoint의 경우 <strong>컨트롤러를 직접 만드는 것이 아니기 때문에 위 문제로 해결할 수 없었다.</strong><br>(login / logout endpoint외에는 전부 Controller로 작성했기 때문에 CORS 관련 Config 설정을 하기 전에 임시로 @CrossOrigin 어노테이션을 붙여뒀다. 이 어노테이션을 붙이는 경우 Front에서 <code>Access-Control-Allow-Origin</code> 설정을 하지 않아도 API 호출에 CORS 에러가 발생하지 않는다. 이 부분 때문에 좀 더 헷갈렸던 것도 있다.)</p><p><code>405</code>를 반환한다는 것은 허용되지 않은 메소드를 호출했다는 것인데 그래서 이후에는 <code>preflight</code> 확인 요청을 <code>OPTIONS method</code>로 보내는 과정에 문제가 있는지 찾아보았다.</p><p>이 <a href="https://oddpoet.net/blog/2017/04/27/cors-with-spring-security/">링크</a>를 참고해서 <code>Spring Security Config</code>에 <code>PreFlightRequest</code>를 허용해주었지만 이 코드도 동작하지 않았다.</p><p>혹시나해서 Front쪽에서 <code>axios</code>가 아닌 <code>XMLHttpRequest</code>를 직접 사용해봤지만 새로운 에러만 발생했다. </p><blockquote><p>찾아본 바로는 오히려 OAuth 기반 서비스는 XHR이나 Fetch API를 사용하면 안된다고 한다.</p></blockquote><p><code>Spring Security Config</code>에 <code>OPTIONS</code>를 전부 허용하고(permitAll), <code>CORS Filter</code>를 인증 필터 제일 앞단에 위치하도록 코드도 작성했지만 이 문제도 실패했다.</p><p>이쯤 되니 혹시 배포 서버에 설정한 <code>Reverse Proxy Server</code>의 <code>Nginx</code> 설정이 문제일까 의심이 들어서 설정을 몇개 수정해보았지만 감이 잡히지 않았다. (<a href="http://oskarhane.com/avoid-cors-with-nginx-proxy_pass/">Avoid cors with nginx proxy pass 참고</a>) (Nginx 설정은 지정한 도메인으로 http나 https 요청이 들어오면 https를 가리키도록 하는 것이 다였다.)</p><p>아무리 생각해도 코드 레벨에서 서버에서 할 수 있는 모든 설정을 다 한 것 같았다. 처음 <code>get</code>으로 login uri를 호출할 때는 Server 기준에서 호출하는데 이후 302 코드를 받고 자동으로 다시 리다이렉트 uri를 호출하는 과정에 Front 기준으로 호출해서 이런 에러가 발생한 것 같았다.</p><p>이후 찾아본 <a href="https://stackoverflow.com/questions/45602875/trying-to-redirect-client-to-google-oauth-getting-405-error">StackOverFlow 링크</a>에서 힌트를 얻었다.</p><p>3xx의 상태코드를 받으면 브라우저가 자동으로 클라이언트를 대신해 반환된 위치로 <code>get</code> 요청을 보내는데 이를 Front에서 캐치해서 수동으로 redirection을 하라는 답변이었다.<br>여기에 힌트를 얻어서 Front에서 <code>window.locaion</code>으로 새창을 띄워 login api를 호출하니 자동으로 redirect되며 문제가 해결되었다. 새로 띄운 창에서는 Front 코드의 영향을 받지 않아서 Server의 설정대로 잘 동작을 한 것 같다. </p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이번 프로젝트로 <code>CORS</code>의 동작방식과 <code>OPTIONS</code> 메소드와 <code>preflight</code>에 대해 많이 알게되었다. <del>지금 해결한 방식이 완벽한 해결방식은 아니고 우회한 방법에 가깝다고 생각하지만 현재로써는 이 이상 해결하긴 어려울 것 같다.</del> (2019.9 - CORS로 시작했지만 결과적으로 <strong>인증</strong>의 문제였던 것 같다.) 그리고 아예 MSA로 분리하면 분리했지 애매하게 붙여서 배포하는 것이 에러가 발생했을 때 더 확인하기 어렵다는 것을 알았다. Front와 Server를 분리해서 개발하면서 배포는 함께 하니까 이렇게 <em>배포했을 때 어느 부분에서 에러가 발생했는지 조차 모르는 경우 에러를 추적하기가 어려웠다.</em>   </p><p>팀원과 함께 오류를 찾으며 느낀 것은 <em>내가 개발한/맡은 부분이 잘못되었을 수 있다는 생각을 갖는게 중요하다는 점이었다.</em> 만약 나 또는 상대 개발자가 서로 자신의 코드가 잘못되었을 수 있다는 가정을 하지 않았다면 이 문제를 해결하는데 더 오래걸렸을 것 같다. 이전 프로젝트에서도 자신의 코드가 무조건 옳다고 주장해서 팀원의 코드를 전부 뜯어보느라 해결하는데 오래 걸린 경우가 있었다.<br>알고있는 분야가 서로 다르므로 서로 열린 마음으로 자신이 아는 부분, 고민하는 부분을 함께 교류하고 소통해야한다고 생각한다. 그리고 그렇게해서 이 문제를 해결할 수 있었던 것 같다. 개발자로써 좀 더 상대방과 소통할 수 있는 개발자가 되어야겠다는 생각이 든다. </p><h3 id="참고한-링크들"><a href="#참고한-링크들" class="headerlink" title="참고한 링크들"></a>참고한 링크들</h3><ul><li><a href="https://www.popit.kr/corss-domain-api-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%84%B1/">https://www.popit.kr/corss-domain-api-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%84%B1/</a></li><li><a href="https://oddpoet.net/blog/2017/04/27/cors-with-spring-security/">https://oddpoet.net/blog/2017/04/27/cors-with-spring-security/</a></li><li><a href="https://www.popit.kr/cors-preflight-인증-처리-관련-삽질/">https://www.popit.kr/cors-preflight-인증-처리-관련-삽질/</a></li><li><a href="https://homoefficio.github.io/2015/07/21/Cross-Origin-Resource-Sharing/">https://homoefficio.github.io/2015/07/21/Cross-Origin-Resource-Sharing/</a></li><li><a href="https://medium.com/@muiruri/spring-oauth2-and-cors-configuration-3529337525b4">https://medium.com/@muiruri/spring-oauth2-and-cors-configuration-3529337525b4</a></li><li><a href="http://oskarhane.com/avoid-cors-with-nginx-proxy_pass/">http://oskarhane.com/avoid-cors-with-nginx-proxy_pass/</a></li><li><a href="https://stackoverflow.com/questions/45602875/trying-to-redirect-client-to-google-oauth-getting-405-error">https://stackoverflow.com/questions/45602875/trying-to-redirect-client-to-google-oauth-getting-405-error</a></li></ul>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/06/16/springboot-react-cors/#disqus_thread</comments>
    </item>
    
    <item>
      <title>IntelliJ에서 SpringBoot DevTools 사용하기</title>
      <link>https://j2de.github.io/2019/06/11/intellij-devtools/</link>
      <guid>https://j2de.github.io/2019/06/11/intellij-devtools/</guid>
      <pubDate>Mon, 10 Jun 2019 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;SpringBoot의 경우 정적 리소스(html,css,js 등)들을 &lt;code&gt;resource&lt;/code&gt; 폴더 하위에서 관리하기 때문에 정적 리소스를 갱신하기 위해 &lt;code&gt;Tomcat&lt;/code&gt;을 재시작해야한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>SpringBoot의 경우 정적 리소스(html,css,js 등)들을 <code>resource</code> 폴더 하위에서 관리하기 때문에 정적 리소스를 갱신하기 위해 <code>Tomcat</code>을 재시작해야한다.</p><p><code>DevTools</code> 를 사용하면 자동으로 정적 리소스를 <code>reload</code> 할 수 있게 된다.</p><p>하지만 IntelliJ에서 사용시 DevTools을 추가해도 적용이 안되는 경우가 있다.</p><blockquote><p>intellij devtools not working</p></blockquote><p>이 때 IntelliJ에서 추가적인 설정을 해주어야 한다.</p><ul><li>IntelliJ에서 DevTool 사용하기</li></ul><p><img src="/images/2019-06-11/intellij-devtools1.png" alt="devtools1"></p><ul><li><code>cmd + shift + a</code> : <code>registry</code> 검색</li></ul><p><img src="/images/2019-06-11/intellij-devtools2.png" alt="devtools2"></p>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/06/11/intellij-devtools/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java - Use overloading judiciously</title>
      <link>https://j2de.github.io/2019/04/18/java-use-overloading-judiciously/</link>
      <guid>https://j2de.github.io/2019/04/18/java-use-overloading-judiciously/</guid>
      <pubDate>Wed, 17 Apr 2019 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Effective-Java-Item-52&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-52&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 52&quot;&gt;&lt;/a&gt;Effective Java Item 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Effective-Java-Item-52"><a href="#Effective-Java-Item-52" class="headerlink" title="Effective Java Item 52"></a>Effective Java Item 52</h2><blockquote><p>다중정의(Overloading)는 신중히 사용하라</p></blockquote><h3 id="Overriding-VS-Overloading"><a href="#Overriding-VS-Overloading" class="headerlink" title="Overriding VS Overloading"></a>Overriding VS Overloading</h3><ul><li><code>Overriding</code>한 메소드는 <code>동적</code>으로 선택되고, <code>Overloading</code>한 메소드는 <code>정적</code>으로 선택된다.</li><li>따라서 <code>Overloading</code>의 경우 <strong>해당 객체의  타입</strong>이 어떤 메소드를 호출할지 <strong>기준</strong>이 된다.</li></ul><h4 id="Overriding-예"><a href="#Overriding-예" class="headerlink" title="Overriding 예"></a>Overriding 예</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class Wine &#123;</span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"포도주"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Class SparklingWine extends Wine &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"발포성 포도주"</span>&#125;; <span class="comment">// Overriding</span></span><br><span class="line">&#125;</span><br><span class="line">Class Champagne extends SparklingWine &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"샴페인"</span>&#125;; <span class="comment">// Overriding</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class Overriding &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Wine&gt; wineList = List.of(</span><br><span class="line">      <span class="keyword">new</span> Wine(), <span class="keyword">new</span> SparklingWine(), <span class="keyword">new</span> Champagne());</span><br><span class="line">    <span class="keyword">for</span>(Wine wine : wineList)</span><br><span class="line">      System.out.println(wine.name()); <span class="comment">// Overriding한 메소드 호출</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/WegraLee/effective-java-3e-source-code/tree/master/src/effectivejava/chapter8/item52">출처</a></p></blockquote><ul><li>기대한 대로 “포도주, “발포성 포도주”, “샴페인”순으로 출력된다.</li><li>가장 하위에 정의한 재정의 메소드가 실행되기 때문</li></ul><h4 id="Overloading-예"><a href="#Overloading-예" class="headerlink" title="Overloading 예"></a>Overloading 예</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionClassifier</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Set&lt;?&gt; s)</span></span>&#123; <span class="comment">// Overloading</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"집합"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(List&lt;?&gt; list)</span></span>&#123; <span class="comment">// Overloading</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"리스트"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span></span>&#123; <span class="comment">// Overloading</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"그 외"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Collection&lt;?&gt;[] collections = &#123;</span><br><span class="line">      <span class="keyword">new</span> HashSet&lt;String&gt;(),</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(),</span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;String, String&gt;().values()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Collection&lt;?&gt; c : collections)</span><br><span class="line">      System.out.println(classify(c)); <span class="comment">// Overloading한 메소드 호출</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/WegraLee/effective-java-3e-source-code/tree/master/src/effectivejava/chapter8/item52">출처</a></p></blockquote><ul><li>예상과는 다르게 “그 외”를 3회 출력한다.</li><li><code>Overloading</code>은 <strong>컴파일 타임</strong>에 <strong>타입</strong>이 결정되기 때문이다.</li><li>해당 코드에서는 컴파일 타임에 항상 <code>Collection&lt;?&gt;</code> 타입으로 받아 <code>Overloading</code>에 영향을 주지 못했다.</li></ul><h3 id="다중정의-Overloading-시-주의할-점"><a href="#다중정의-Overloading-시-주의할-점" class="headerlink" title="다중정의(Overloading)시 주의할 점"></a>다중정의(Overloading)시 주의할 점</h3><ul><li><code>일반적으로 프로그래머가 기대하는 코드</code>와 <code>다른 결과</code>를 보여주는 헷갈릴 수 있는 코드는 작성하지 않는 것이 좋다.</li><li>특히 공개 API의 경우 사용자가 매개변수를 넘길때 어떤 <code>다중정의된 메소드</code>가 동작할지 <code>예측</code>되지 않는다면 더 좋지 않다.</li><li>서로 다른 <code>함수형 인터페이스라</code>도 <code>같은 위치의 인수</code>로 받아선 안된다. </li></ul><h3 id="그나마-안전하게-다중정의-Overloading-하려면"><a href="#그나마-안전하게-다중정의-Overloading-하려면" class="headerlink" title="그나마 안전하게 다중정의(Overloading) 하려면"></a>그나마 안전하게 다중정의(Overloading) 하려면</h3><ol><li><code>매개변수 수</code>가 같은 다중정의를 가급적 피한다.</li><li><code>가변인수</code>를 사용하는 메소드는 절대 다중정의하지 않는다.<ul><li>아이템 53</li></ul></li><li>다중정의 대신 <code>메소드 이름</code>을 다르게 지어준다.<ul><li>ex) <code>ObjectOutputStream</code> Class의 <code>write</code> 메소드 들 &gt; <code>writeBoolean(boolean)</code>, <code>writeInt(int)</code>, …</li></ul></li><li>1~3을 지키기 어려운 <code>생성자</code>의 경우 매개변수를 형변환해 정확한 메소드가 선택되도록 한다.</li><li><code>매개변수 수</code>가 같은 다중정의 메소드가 많은 경우 그 매개변수 중 하나 이상이 “근본적으로 다르다(radically different)”면 괜찮다.<ul><li>“근본적으로 다르다”는 “두 타입이 (null 제외) 서로 어느 쪽으로도 형변환할 수 없다는 뜻”</li></ul></li><li>5가 되지 않는다면 <code>같은 객체</code>를 <code>입력</code>받는 <code>다중 메소드</code>가 모두 <code>같은 동작</code>을 하도록한다.<ul><li>ex) 기존 클래스를 수정해 새로운 Interface를 implements 하는 경우<ul><li>기존에 있던 String 클래스에 <code>CharSequence</code> 인터페이스 등장 후 기존에 있던 <code>contentEquals(StringBuffer)</code> 메소드가 <code>contentEquals(CharSequence)</code>로 다중 정의 되었지만 같은 동작을 하기 때문에 사용자 입장에서 문제가 없다. </li></ul></li></ul></li><li>서로 다른 <code>함수형 인터페이스</code>라도 같은 위치의 인수로 받지 않는다.</li></ol><h3 id="생성자-다중정의-Overloading"><a href="#생성자-다중정의-Overloading" class="headerlink" title="생성자 다중정의(Overloading)"></a>생성자 다중정의(Overloading)</h3><ul><li>생성자는 이름을 다르게 지을 수 없기 때문에 위의 1~3 규칙을 적용하기 어렵다.</li><li>이때는 <code>정적 팩터리</code>를 사용한다.</li><li>그래도 생성자는 재정의가 안되기 때문에 다중정의와 혼용될 가능성은 적다.</li><li>5의 규칙을 따라서 다중정의 한다면 다중정의 메소드 중 어떤 메소드를 선택해 호출할 지 매개변수의 런타임 타입으로 결정된다. </li></ul><h3 id="함수형-인터페이스의-다중정의"><a href="#함수형-인터페이스의-다중정의" class="headerlink" title="함수형 인터페이스의 다중정의"></a>함수형 인터페이스의 다중정의</h3><ul><li>“<code>암시적 타입 람다식</code>이나 <code>부정확한 메소드 참조</code> 같은 표현식은 목표 타입이 선택되기 전까지 의미가 정해지지 않기 때문에 적용성 테스트 때 무시된다.” 고 책에서 말한다.<ul><li>부정확한 메소드 참조 타입이란 메소드와 인자 모두 다중 정의된 경우를 뜻한다. </li></ul></li><li>말이 어려운데, 간단히 말하자면 정확한 타입이 정해지기 전까지는 의도한대로 동작하지 않는다는 말이다.</li><li>따라서 <code>함수형 인터페이스</code>는 서로 다른 타입이어도 결과적으로 Overloading 때 같은 타입으로 인식한다. </li></ul><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul><li>다중정의된 메소드 중 하나를 선택하는 규칙은 복잡하기 때문에 프로그래머가 모두 알고 프로그래밍하기는 어렵다. </li><li>따라서 매개변수가 같을 때는 가급적 다중정의를 피하거나 그것이 안된다면 안전하게 다중정의하는 규칙을 따라 만드는 것이 좋다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Effective Java (3rd Edition)</li><li><a href="https://jeong-pro.tistory.com/148">JVM 구조와 자바 런타임 메모리 구조</a></li></ul><br>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/04/18/java-use-overloading-judiciously/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java - Design method signatures carefully</title>
      <link>https://j2de.github.io/2019/04/17/java-design-method-signatures-carefully/</link>
      <guid>https://j2de.github.io/2019/04/17/java-design-method-signatures-carefully/</guid>
      <pubDate>Tue, 16 Apr 2019 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Effective-Java-Item-51&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-51&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 51&quot;&gt;&lt;/a&gt;Effective Java Item 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Effective-Java-Item-51"><a href="#Effective-Java-Item-51" class="headerlink" title="Effective Java Item 51"></a>Effective Java Item 51</h2><blockquote><p>메서드 시그니처를 신중히 설계하라</p></blockquote><h2 id="API-설계-요령"><a href="#API-설계-요령" class="headerlink" title="API 설계 요령"></a>API 설계 요령</h2><h3 id="1-메서드-이름을-신중히"><a href="#1-메서드-이름을-신중히" class="headerlink" title="1. 메서드 이름을 신중히"></a>1. 메서드 이름을 신중히</h3><ul><li>표준 명명 규칙을 따른다<ul><li>E.J의 아이템 68 참고</li></ul></li></ul><h3 id="2-지나친-편의-메서드-남발-금물"><a href="#2-지나친-편의-메서드-남발-금물" class="headerlink" title="2. 지나친 편의 메서드 남발 금물"></a>2. 지나친 편의 메서드 남발 금물</h3><ul><li>아주 자주 쓰일 때만 별도의 편의 메서드로 작성한다.<ul><li>이 부분에 관점에 따라 상충되는 듯하다. </li><li>예를 들면 박재성(자바지기)님의 경우 Test를 위해 가급적 메소드를 잘게 쪼개는 것을 추천한다. 즉 한번에 한가지 기능만 갖고 있는 원자성을 띄는 메소드를 작성하는걸 추천한다. </li><li>이 책의 저자는 메소드가 너무 많은 경우 클래스를 익히고 사용하는게 어렵기 때문에 추천하지 않는다고 한다.</li><li><del>알아서 걸러듣자..</del></li></ul></li></ul><h3 id="3-매개변수-목록은-가능한-짧게"><a href="#3-매개변수-목록은-가능한-짧게" class="headerlink" title="3. 매개변수 목록은 가능한 짧게"></a>3. 매개변수 목록은 가능한 짧게</h3><ul><li>4개 이하가 좋다고 한다.</li><li>특히 같은 타입의 매개변수가 여러개 나오는 경우가 좋지 않은 경우다. 왜냐하면 실수로 순서를 바꿔 입력해도 컴파일러가 눈치채지 못하기 때문.</li></ul><h3 id="4-매개변수-타입은-클래스보단-인터페이스로"><a href="#4-매개변수-타입은-클래스보단-인터페이스로" class="headerlink" title="4. 매개변수 타입은 클래스보단 인터페이스로"></a>4. 매개변수 타입은 클래스보단 인터페이스로</h3><ul><li>아이템 64</li><li>클래스를 인자로 받는다면 매개변수를 특정 구현체로 한정하기 때문에 좋지 않다.</li></ul><h3 id="5-Boolean-보다-원소-2개인-Enum-타입으로"><a href="#5-Boolean-보다-원소-2개인-Enum-타입으로" class="headerlink" title="5. Boolean 보다 원소 2개인 Enum 타입으로"></a>5. Boolean 보다 원소 2개인 Enum 타입으로</h3><ul><li>의미상 Boolean이 더 나은경우가 아니라면 열거체를 사용하는게 좋다.</li><li>왜냐하면 코드상 의미가 더 명확하기 때문</li><li>또한 개별 열거타입별 의존성을 추가해주기도 좋다. (열거타입 내부 메소드로)</li></ul><br><h3 id="긴-매개변수를-짧게-줄이는-기술들"><a href="#긴-매개변수를-짧게-줄이는-기술들" class="headerlink" title="긴 매개변수를 짧게 줄이는 기술들"></a>긴 매개변수를 짧게 줄이는 기술들</h3><h4 id="1-여러-메서드로-쪼갠다"><a href="#1-여러-메서드로-쪼갠다" class="headerlink" title="1. 여러 메서드로 쪼갠다."></a>1. 여러 메서드로 쪼갠다.</h4><ul><li>API 설계 요령 2번과 상충되는 것 같지만, API를 공통점이 없는 기능으로 잘 분리한다면 결과적으로 매개변수의 길이가 줄어들 수 있다.</li><li>잘게 쪼개둘수록 여러가지로 조합할 수 있기 때문</li></ul><h4 id="2-도우미-클래스를-만든다"><a href="#2-도우미-클래스를-만든다" class="headerlink" title="2. 도우미 클래스를 만든다."></a>2. 도우미 클래스를 만든다.</h4><ul><li>매개변수 여러개를 묶는 도우미 클래스를 만든다.</li><li>매개변수 몇 개를 독립된 하나의 단위로 볼 수 있는 경우</li><li>ex) 카드게임에서 카드를 의미하는 부분</li></ul><h4 id="3-메서드에-빌더-Builder-패턴을-응용한다"><a href="#3-메서드에-빌더-Builder-패턴을-응용한다" class="headerlink" title="3. 메서드에 빌더(Builder)패턴을 응용한다."></a>3. 메서드에 빌더(Builder)패턴을 응용한다.</h4><ul><li>매개변수가 많은데, 그 중 일부는 생략해도 되는 경우 도움이 된다.</li></ul><br><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Effective Java (3rd Edition)</li></ul><br>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/04/17/java-design-method-signatures-carefully/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java - Make defensive copies when needed</title>
      <link>https://j2de.github.io/2019/04/10/java-make-defensive-copies-when-needed/</link>
      <guid>https://j2de.github.io/2019/04/10/java-make-defensive-copies-when-needed/</guid>
      <pubDate>Tue, 09 Apr 2019 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Effective-Java-Item-50&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-50&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 50&quot;&gt;&lt;/a&gt;Effective Java Item 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Effective-Java-Item-50"><a href="#Effective-Java-Item-50" class="headerlink" title="Effective Java Item 50"></a>Effective Java Item 50</h2><blockquote><p>적시에 방어적 복사본을 만들라</p></blockquote><ul><li>자바는 비교적 안전한 언어이지만, <code>불변식</code>이 깨질 수 있다는 가정하에 최대한 방어적으로 프로그래밍해야한다. </li><li>어떤 객체든 허락없이 외부에서 내부를 수정하는 일은 불가해야한다. </li><li>가변 타입으로 작성된 코드도 불변식을 깨지지 않게 하기 위해 필요하다.</li><li>자기 자신 외에는 가변 필드에 접근할 수 없도록해야 완벽한 캡슐화이다.</li></ul><h3 id="가변-매개변수를-받는-경우"><a href="#가변-매개변수를-받는-경우" class="headerlink" title="가변 매개변수를 받는 경우"></a>가변 매개변수를 받는 경우</h3><ul><li>책의 <a href="https://github.com/WegraLee/effective-java-3e-source-code/blob/master/src/effectivejava/chapter8/item50/Period.java#L15">Period</a> 객체를 보면 불변 같아 보이지만 생성자로 받는 <code>Date</code>가 가변이기 때문에 불변식이 깨진다.</li><li>불변식을 유지하기 위해 간단하게는 대신할 수 있는 <code>불변 아이템</code>을 사용하거나 가변 매개변수를 각각 <code>방어적으로 복사</code>해야한다.</li></ul><h4 id="방어적-복사-defensive-copy"><a href="#방어적-복사-defensive-copy" class="headerlink" title="방어적 복사(defensive copy)"></a>방어적 복사(defensive copy)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 생성자에서 방어적 복사 수행</span></span><br><span class="line">    <span class="comment">// 가변 인자를 받아서 새 객체를 생성해 복사한다.</span></span><br><span class="line">    <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime()); </span><br><span class="line">    <span class="keyword">this</span>.end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 방어적 복사를 진행한 뒤 유효성을 검사한다.</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.start.compareTo(<span class="keyword">this</span>.end) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="keyword">this</span>.start + <span class="string">" after "</span> + <span class="keyword">this</span>.end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>반드시 매개변수 유효성 검사를 하기 전에 방어적 복사를 해야한다. </li><li>TOCTOU(time-of-check/time-of-use) 공격. 즉, 유효성 검사 후 복사를 실행하는 사이에 원본 객체가 수정될 위험이 있기 때문이다.</li><li>생성자 뿐만 아니라 접근자(setter)에서도 Date 객체를 반환한다면 공격당할 수 있기 때문에 setter에서도 방어적 복사를 해주는 것이 좋다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 접근자에서 방어적 복사 수행</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="clone-사용-여부"><a href="#clone-사용-여부" class="headerlink" title="clone 사용 여부"></a>clone 사용 여부</h4><ul><li>매개 변수가 불변 객체가 아닐 경우 방어적 복사본을 만드는 데 <code>clone</code>을 사용하면 안된다.</li><li>악의 적인 하위 클래스가 clone을 정의한 경우 공격받을 수 있기 때문이다.</li><li>그 외에도 Item13의 이유로 clone 사용을 지양하는 것이 좋다. </li></ul><h3 id="그래서-방어적복사를-언제-해야하는데"><a href="#그래서-방어적복사를-언제-해야하는데" class="headerlink" title="그래서 방어적복사를 언제 해야하는데?"></a>그래서 방어적복사를 언제 해야하는데?</h3><ul><li>메서드나 생성자나 클라이언트가 제공한 객체의 참조를 내부에 저장하는 경우 객체가 변경될 가능성이 있는지 생각해야한다.</li><li>변경될 수 있는 객체라면 변경된 후 클래스가 문제 없이 동작할지 고려해본다.</li><li>이 때 확신할 수 없다면 복사본을 만들어 저장해라</li><li>반대로 내부 객체를 외부에 전달할 때 안심할 수 없다면 방어적 복사를 해야한다. </li><li>내부에서 사용하는 배열을 외부에 반환할 때는 항상 방어적 복사를 해라.(Item15 참고)</li></ul><h3 id="방어적-복사를-생략하는-경우"><a href="#방어적-복사를-생략하는-경우" class="headerlink" title="방어적 복사를 생략하는 경우"></a>방어적 복사를 생략하는 경우</h3><ul><li>해당 클래스와 클라이언트가 상호 신뢰할 수 있을 때<ul><li>통제권을 이전하기 위한 메서드나 생성자의 경우 호출 후 더이상 객체를 직접 수정하지 않는다고 문서에 명시한다.</li></ul></li><li>불변식이 깨져도 그 영향이 호출한 클라이언트에만 그칠때<ul><li>ex) Wrapper Class</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Effective Java (3rd Edition)</li></ul><br>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/04/10/java-make-defensive-copies-when-needed/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java - Prefer side-effect-free functions in streams</title>
      <link>https://j2de.github.io/2019/03/23/java-prefer-side-effect-free-functions-in-streams/</link>
      <guid>https://j2de.github.io/2019/03/23/java-prefer-side-effect-free-functions-in-streams/</guid>
      <pubDate>Fri, 22 Mar 2019 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Effective-Java-Item-46&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-46&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 46&quot;&gt;&lt;/a&gt;Effective Java Item 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Effective-Java-Item-46"><a href="#Effective-Java-Item-46" class="headerlink" title="Effective Java Item 46"></a>Effective Java Item 46</h2><blockquote><p>스트림에서는 부작용 없는 함수를 사용하라.</p></blockquote><h3 id="스트림-패러다임"><a href="#스트림-패러다임" class="headerlink" title="스트림 패러다임"></a>스트림 패러다임</h3><ul><li>스트림은 <code>함수형 프로그래밍</code> 패러다임이다. </li><li>스트림을 통해 <code>표현력</code>, <code>속도</code>, <code>병렬성</code>을 얻을 수 있다. </li><li>계산을 <code>일련의 변환</code>으로 재구성한다.</li><li>각 변환 단계를 가능한 이전 단계의 결과를 받아 처리하는 <strong>순수 함수</strong>여야한다.</li><li><strong>순수 함수란 오직 입력만이 결과에 영향을 주는 함수이다.</strong><ul><li>가변 상태를 참조하지 않고 함수 스스로도 다른 상태를 변경하지 않는다.</li></ul></li><li>즉 스트림 연산에 사용되는 함수 객체는 모두 <code>side effect</code>가 없어야한다. </li><li>스트림의 <code>for each</code>는 스트림 계산 결과를 보여주는 용도로만 사용하는 것이 좋다. </li></ul><h3 id="스트림의-수집기-Collector"><a href="#스트림의-수집기-Collector" class="headerlink" title="스트림의 수집기(Collector)"></a>스트림의 수집기(Collector)</h3><ul><li><code>java.util.stream.Collectors</code></li><li>수집기가 생성하는 객체는 일반적으로 컬렉션이다. </li><li><code>Collector</code>를 통해 스트림의 원소들을 쉽게 원소 하나(컬렉션)로 모을 수 있다. </li><li>수집기는 <code>toList()</code>, <code>toSet()</code>, <code>toCollection(collectionFactory)</code>로 <code>리스트</code>, <code>집합</code>, <code>프로그래머가 지정한 컬렉션 타입</code>을 반환한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; freq;</span><br><span class="line">...</span><br><span class="line">List&lt;String&gt; topTen = freq.keySet().stream() <span class="comment">// (1)</span></span><br><span class="line">    .sorted(comparing(freq::get).reversed()) <span class="comment">// (2)</span></span><br><span class="line">    .limit(<span class="number">10</span>)</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure><ol><li>Map에서 key를 뽑아내 stream으로 만든다.</li><li>sorted에 비교자 생성 메서드인 comparing으로 비교 기준을 넘긴다. </li><li>단어 10개까지 뽑아서</li><li>List로 변경해 반환한다.</li></ol><ul><li>나머지 메소드들은 대부분 스트림을 맵으로 취합하는 기능을 가진다. 스트림의 각 원소는 키 하나와 값 하나에 연관되어있지만 <strong>다수의 스트림 원소가 같은 키에 연관될 수 있다.</strong> </li></ul><h3 id="맵-수집기-Map-Collector"><a href="#맵-수집기-Map-Collector" class="headerlink" title="맵 수집기(Map Collector)"></a>맵 수집기(Map Collector)</h3><ul><li><p>가장 간단한 맵 수집기는 <code>toMap(keyMapper, valueMapper)</code> 인자 2개를 받는 메소드이다.</p></li><li><p>스트림 원소를 <strong>키에 맵핑하는 함수</strong>와 <strong>값에 맵핑하는 함수</strong>를 인수로 받는다. </p></li><li><p>이 경우는 스트림의 각 원소가 고유한 키에 매핑되어 있을 때 적절하다. </p></li><li><p>더 복잡한 형태는 <code>toMap(keyMapper, valueMapper, mergeMethod)</code> 3가지를 인자로 받는 메소드로 처리한다.</p></li><li><p>병합 함수는 <code>BinaryOperator&lt;T&gt;</code>로 같은 <code>&lt;T&gt;</code> 형태의 두개의 파라미터를 받아서 람다식대로 계산하고 계산 후 결과 값도 <code>&lt;T&gt;</code> 형태로 반환한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Artist, Album&gt; topHits = albums.collect(</span><br><span class="line">  toMap(Album::artist, a-&gt;a, maxBy(comparing(Album::sales)));</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>책에서는 병합 함수로 <code>BinaryOperator</code>에서 정적 임포트한 <code>maxBy</code>라는 정적 팩터리 메소드를 사용한다.</li><li><code>maxBy</code>는 <code>Comparator&lt;T&gt;</code>를 입력 받아 <code>BinaryOperator&lt;T&gt;</code>를 반환한다. </li><li><code>comparing</code>이 비교자 생성 메서드로 키 추출 함수로 <code>Album::sales</code>를 넘겨 비교자를 반환한다.</li></ul></li><li><p>가장 복잡한 경우는 <code>toMap(keyMapper,valueMapper, mergeMethod, MapFactory)</code> 네가지 인자를 받는다. </p></li><li><p>네번째 인수로 받는 맵 팩터리는 특정 맵 구현체(TreeMap 등)를 직접 지정할 수 있다.</p></li></ul><h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h3><ul><li><p>인수로 분류 함수를 받고 입력받은 원소가 속한 카테고리를 반환한다. 그리고 이 카테고리가 맵의 키로 쓰인다.</p></li><li><p>가장 간단한 형태는 분류 함수 하나를 인수로 받아 맵을 생성하는 것이다. <code>groupingBy(classifier)</code></p></li><li><p>이때 반환된 맵에는 각 값마다 해당 카테고리에 속한 원소들을 담은 리스트가 있다. <code>Map&lt;CategoryType, List&lt;DataType&gt;&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">words.collect(groupingBy(word -&gt; alp))</span><br></pre></td></tr></table></figure></li><li><p>반환되는 수집기가 리스트외에 특정 형태로 지정하고 싶다면(위의 반환형이 List가 아닌 다른 자료 형태이길 원한다면) 다운스트림(downstream) 수집기도 표기해야한다. <code>groupingBy(classifier, downstream)</code></p></li><li><p><code>toSet()</code>을 사용하면 <code>Set</code>으로 <code>toCollection(collectionFactory)</code>을 사용하면 원하는 컬렉션 타입을 선택할 수 있다. </p></li><li><p><code>counting()</code>을 사용하는 경우 해당 카테고리에 속한 원소의 값과 매핑한 맵을 얻는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; freq = words</span><br><span class="line">  .collect(groupingBy(String::toLowerCase, counting()));</span><br></pre></td></tr></table></figure><ul><li><code>counting</code> 메소드를 사용해 개수를 반환하기 때문에 <code>Long</code>으로 반환된다. </li></ul></li></ul><h3 id="joining"><a href="#joining" class="headerlink" title="joining"></a>joining</h3><ul><li><code>CharSequence</code> 인스턴스 스트림에만 적용이 가능한 메소드이다.</li><li>매개 변수 없는 <code>joining()</code>은 원소들을 연결(concatenate)하는 역할을 한다.</li><li>매개 변수 하나인 <code>joining(delimiter)</code>은 구분자를 받아 연결 부위에 구분자를 삽입한다. </li><li>매개변수 3개인 <code>joining</code>은 구분자와 접두문자(prefix)와 접미문자(suffix)도 지정할 수 있다.</li></ul><br/>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/03/23/java-prefer-side-effect-free-functions-in-streams/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java - Prefer method references to lambdas</title>
      <link>https://j2de.github.io/2019/02/21/java-prefer-method-references-to-lambdas/</link>
      <guid>https://j2de.github.io/2019/02/21/java-prefer-method-references-to-lambdas/</guid>
      <pubDate>Wed, 20 Feb 2019 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Effective-Java-Item-43&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-43&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 43&quot;&gt;&lt;/a&gt;Effective Java Item 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Effective-Java-Item-43"><a href="#Effective-Java-Item-43" class="headerlink" title="Effective Java Item 43"></a>Effective Java Item 43</h2><blockquote><p>람다보다는 메소드 참조를 사용하라</p></blockquote><br><h3 id="lambda-VS-method-reference"><a href="#lambda-VS-method-reference" class="headerlink" title="lambda VS method reference"></a>lambda VS method reference</h3><ul><li>함수 객체를 람다보다 <strong>간결</strong>하게 표현할 수 있는 것이 <code>method reference</code>(메소드 참조)이다.</li><li>이 중 <em>람다의 코드가 의미 없이 길다</em>면 또는 <em>이미 구현된 라이브러리</em>로 메소드 참조를 할 수 있다면, 메소드 참조를 사용하는 것이 낫다.</li><li>그리고 메소드 참조를 사용하는 경우 매개변수를 제거하므로, 람다의 매개변수 이름이 있어야 코드의 의미가 명확해진다면 람다를 사용하는 것이 낫다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.merge(key, <span class="number">1</span>, (count, incr) -&gt; count+incr); <span class="comment">// lambda</span></span><br><span class="line">map.merge(key, <span class="number">1</span>, Integer::sum); <span class="comment">// method reference</span></span><br></pre></td></tr></table></figure><ul><li>항상 메소드 참조가 람다보다 간결한 것은 아니다. </li><li>메소드 참조의 경우 Class나 Obejct 이름을 항상 써야하기 때문에 <strong>같은 클래스에 있는 메소드</strong>를 사용한다면 람다 표현을 사용하는 것이 더 간결하다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service.execute(GoshThisClassNameIsHumongous::action); <span class="comment">// method reference</span></span><br><span class="line">service.execute(()-&gt;action()); <span class="comment">// lambda</span></span><br></pre></td></tr></table></figure><h2 id="method-reference의-사용"><a href="#method-reference의-사용" class="headerlink" title="method reference의 사용"></a>method reference의 사용</h2><ul><li>메소드 참조를 사용하는 경우 (1) 기존에 구현된 라이브러리를 사용하거나(ex-위의 <code>Integer::sum</code>은 Integer 클래스의 static sum 메소드를 사용한 것)</li><li>lambda 표현이 길어지는 경우(보통 3줄을 넘어가지 않는 것이 좋다) (2) 따로 메소드를 작성해 람다 대신 메소드 참조를 사용한다. </li></ul><h2 id="method-reference의-유형"><a href="#method-reference의-유형" class="headerlink" title="method reference의 유형"></a>method reference의 유형</h2><ol><li>정적 메소드 참조</li></ol><ul><li><code>Class::staticMethod</code> 형식으로 사용한다. </li><li>ex) <code>Integer::parseInt</code>는 <code>str-&gt;Integer.parseInt(str)</code>과 같다</li></ul><ol start="2"><li>한정적 인스턴스 메소드 참조</li></ol><ul><li><code>object::instanceMethod</code></li><li>(1)의 정적 메소드 참조와 비슷하다. </li><li>즉, 함수 객체가 받는 인수와 참조 되는 메소드가 받는 인수가 같다.</li><li>ex) <code>Instant.now()::isAfter</code>은 <code>Instant then = Instant.now(); \n t-&gt;then.isAfter(t)</code>와 같다.</li></ul><ol start="3"><li>비한정적 인스턴스 메소드 참조</li></ol><ul><li>수신 객체를 한정하지 않는 다는 의미해서 비한정적 메소드 참조이다.</li><li>따라서 함수 객체가 받는 인수와 참조되는 메소드가 받는 인수가 다르다.</li><li>그래서 함수 객체를 적용하는 시점에 수신 객체를 알려준다. </li><li>ex) <code>String::toLowerCase</code>은 <code>str-&gt;str.toLowerCase()</code>와 같다.</li></ul><ol start="4"><li>클래스 생성자 메소드 참조</li></ol><ul><li>생성자 레퍼런스와 메소드 레퍼런스는 거의 흡사하다. </li><li>생성자 종류가 많을 경우 문맥으로 파악한다.</li></ul><ol start="5"><li>배열 생성자 메소드 참조</li></ol><br><ul><li>결과적으로 method reference를 사용하면 메소드의 모든 매개변수가 사라진다. 그러므로 lambda를 사용할 때와 같이 사용하려는 자바 라이브러리에 대한 정확한 이해가 필요하다. </li></ul><br>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/02/21/java-prefer-method-references-to-lambdas/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java - Use instance fields instead of ordinals</title>
      <link>https://j2de.github.io/2019/02/20/java-use-instance-fields-instead-of-ordinals/</link>
      <guid>https://j2de.github.io/2019/02/20/java-use-instance-fields-instead-of-ordinals/</guid>
      <pubDate>Tue, 19 Feb 2019 15:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Effective-Java-Item-35&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-35&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 35&quot;&gt;&lt;/a&gt;Effective Java Item 
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="Effective-Java-Item-35"><a href="#Effective-Java-Item-35" class="headerlink" title="Effective Java Item 35"></a>Effective Java Item 35</h2><blockquote><p>ordinal 메서드 대신 인스턴스 필드를 사용하라 </p></blockquote><br><h2 id="ordinal-method"><a href="#ordinal-method" class="headerlink" title="ordinal method"></a>ordinal method</h2><ul><li>enum 타입에 제공되는 메소드로 열거 타입에서 몇번째 위치인지를 반환한다. </li><li>enum 타입과 연결된 정수가 필요할 때 이 메소드를 사용한다면 코드도 직관적이지 않고 쓰이지 않는 값도 많아질 것이다. </li></ul><h2 id="ordinal-대신-인스턴스-필드에-저장"><a href="#ordinal-대신-인스턴스-필드에-저장" class="headerlink" title="ordinal 대신 인스턴스 필드에 저장"></a>ordinal 대신 인스턴스 필드에 저장</h2><ul><li>따라서 ordinal 대신 열거 타입 상수에 연결된 값은 인스턴스 필드에 저장하는 것이 좋다. </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">    SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfMusicians; </span><br><span class="line">    Ensemble(<span class="keyword">int</span> size) &#123; <span class="keyword">this</span>.numverOfMusicials = size; &#125;</span><br><span class="line">    <span class="comment">// 생성자에서 인스턴스 필드에 초기화 한다.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numberOfMusicians;&#125;</span><br><span class="line">    <span class="comment">// 메소드에서 인스턴스 필드에 저장된 값은 반환한다. </span></span><br><span class="line">    <span class="comment">// ordinal 메소드를 사용하지 않는다. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://j2de.github.io/2019/02/20/java-use-instance-fields-instead-of-ordinals/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
