{"meta":{"title":"Jade's Blog","subtitle":"An archive for daily discovery","description":null,"author":"j2de","url":"https://j2de.github.io","root":"/"},"pages":[{"title":"About Me","date":"2019-07-11T19:39:31.000Z","updated":"2020-03-20T15:44:39.512Z","comments":true,"path":"about/index.html","permalink":"https://j2de.github.io/about/index.html","excerpt":"","text":"I’m a student majoring in Software Engineering.This blog is the place to record daily discoveries. More InformationPrevious Blog Contact mej2de.dev@gmail.com"}],"posts":[{"title":"git 커밋 중간에 잘못된 merge 되돌리기","slug":"reverting-invalid-git-merge","date":"2020-02-01T14:41:26.000Z","updated":"2020-03-20T15:44:39.476Z","comments":true,"path":"2020-02-01-reverting-invalid-git-merge/","link":"","permalink":"https://j2de.github.io/2020-02-01-reverting-invalid-git-merge/","excerpt":"","text":"어느날 오랜만에 커밋을 보니까,master 브랜치가 뭔가 잘못되어 있었다. deploy 브랜치에 있는 배포용 커밋이 master 브랜치에 있는 상황 커밋 로그를 추적해보다가 rebase conflict를 해결하다 병합에 문제가 생긴걸 알았다.(merge를 잘못해서 생긴것 일것으로 추측, 실수로 deploy 브랜치에서 작업 후 merge를 시도했다던지..) rebase는 커밋 이력이 남지 않아서, merge 실수를 일일히 찾아야한다. 과거의 내가 fix: rebase conflict라고 남겨놓아서 그나마 쉽게 찾을 수 있었다. 오늘의 교훈 : 커밋 메세지를 잘남기자.. 아무튼 이걸 해결하려면 중간에 잘못 머지한 이력을 지우고 원래대로 개발 완료한 커밋 내역으로 돌려야한다. 검색해보니 merge를 되돌리기 위해서는 reset과 revert를 사용한다.revert --mainline 옵션으로 시도했지만 revert는 기존 커밋 내역을 보존하고 추가 커밋을 덧붙이는거라 지금 내 상황에 맞지 않았다. 만약 팀 프로젝트와 같이 commit id가 중요하면 reset과 같이 commit id가 변경되는 명령어를 쉽게 쓸 수 없었겠지만 상황상 reset으로 되돌리기를 시도했다. git reset --merge [COMMIT_ID] 적용 후 deploy 관련 커밋이 깔끔하게 삭제 되어 git graph가 깨끗해졌다. (기본 mixed 옵션으로 적용) 이제 문제는 원래 개발했던 내용을 되돌려놓는 것 문제가 생겼던 프로젝트는 기존에 git flow 방식을 차용해서 커밋했기에 develop branch에동작이 보증된 개발 완료된 코드들이 남아있었다.master branch는 mixed option으로 reset 했기에 stage가 깨끗해서 develop을 바로 master로 merge할 수 있다. 만약 soft 옵션으로 reset 했다면 남아있는 파일을 모두 지우고 시도한다. 만약 branch 관리를 하지 않아 branch가 꼬여있었다면 이 방법으로 해결하지 못했을지도.. 이후 확인해보면 이력이 깨끗하게 정리된 것을 확인할 수 있다. 최종적으로 master에 푸시한다.reset으로 커밋 내역을 변경했기 때문에 당연히 -f 로 강제 push를 한다강제 push는 브랜치에 protected가 걸려있으면 할 수 없다.따라서 해당 방법은 아무래도 실무에서 여러가지 제약이 있으면 적용하기는 어려울 것 같고실무에서는 잘못 merge시 revert를 통해 우회하는 방식을 사용해야할 것 같다. git reset 후 변경 내역에 대해 새로 커밋을 하는 경우는 commit id가 변경되지만기존에 있는 브랜치에서 병합했기 때문에 커밋 아이디는 변경되지 않았다. 오늘 알게된 것. 커밋을 잘 남기자. 섣불리 rebase하지 말고 merge로 merge 이력을 남기자. 브랜치를 잘 나눠서 사용하자 참고한 링크 https://www.tuwlab.com/ece/22223 https://victorydntmd.tistory.com/79 https://nesoy.github.io/articles/2018-07/Git-Revert","categories":[{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/categories/troubleshooting/"}],"tags":[{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/tags/troubleshooting/"},{"name":"Git","slug":"git","permalink":"https://j2de.github.io/tags/git/"}]},{"title":"Talk with Sonia from Microsoft - Inspiring Tech Women","slug":"women-who-code-talk-with-sonia-from-ms","date":"2020-01-20T13:54:30.000Z","updated":"2020-03-20T15:44:39.470Z","comments":true,"path":"2020-01-20-women-who-code-talk-with-sonia-from-ms/","link":"","permalink":"https://j2de.github.io/2020-01-20-women-who-code-talk-with-sonia-from-ms/","excerpt":"","text":"Date 2020.1.20 Mon / Time PM 6:30~8:30 / Place 한국 마이크로소프트 오랜만에 Women Who Code의 Meetup에 참여하기 위해 한국 마이크로소프트 건물을 찾았다.마이크로소프트 소속의 Sonia와 Tech에 대해 대화를 나누는 밋업이었다. Women Who Code란 미국에서 시작해 전세계 60개국에서 활동중인 여성 단체로 더 많은 여성들이 기술 경력을 갖도록 장려하는 비영리 단체이다. 최근에 Meetup App으로 알게된 단체인데 알고보니 최근 한국으로 진출했다고 한다. 전세계적으로 네트워크가 있는 단체라 취업이나 여행시에 해당 국가에서 테크 관련된 행사를 참여하고 싶은 경우 네트워크 문의 가능하다고. 한국에서는 페이스북 그룹을 기반으로 활동하는 듯 하다. 연사 초청 강의, 해커톤 등의 행사, 구직 기회도 있다고 한다. Talk with Sonia from Microsoft Sonia가 우리에게 해준 말들 Change your plan. 계획이 바뀌는 것에 관대해져라 If you are not sure, Answer yes 확실하지 않다면 두려워하지 말고 예스라고 해볼 것. 새로운 것에 도전하라는 의미. If you hate it, Then leave. 싫어하면 떠나라 테크 환경에는 다양한 룰이 있다. 나에게 맞는 룰을 찾는데 시간이 걸릴 수 있다 Find career support. Take their advice. 내가 하고싶은 일을 도와주는 사람을 찾고 조언을 적극적으로 받아들이자. Learn and understand the basics. 끊임 없이 배우고, 기본을 이해하자. Take a chance. 뻔한 말이지만, 기회를 잡아라 Take more chances. 또 뻔한 말이지만, 더 많은 기회를 잡아라. 누군가 기회를 준다면 바로 잡아라. Know your worth. 너의 가치를 알아라 Reliable, Dedicated, Persevering, Learning, Helpful, Sharing, EncouragingLook after yourselft 그리고 나를 돌보면서 일해라. 나를 돌보는 방법 중 하나. 나와 잘 맞는 친구들을 찾는 것나에게 괜찮다고 말해줄 수 있는. 그리고 쉬는 시간 여가시간, 취미를 즐기는 시간을 계획하자.언젠가하려고 하면 할 수 없다. Take even more chances.Share your stories. 사소한 이야기라도 나누자. 이런 이야기를 알거라고 생각하지만 모르는 경우가 많다 내가 했던 일을 다른 사람이 안했을 수도 있기 때문에, 사소한 이야기라도 나누자. 서로 공유를 통해 배울 수 있다. 내가 이 포스팅을 굳이 쓰고 있는 이유이기도 하다. Always be learning 항상 새로운 걸 배워라. 기술은 매일 변하니까 20년이 넘어도 항상 새로운 걸 배운다. 기본은 여전히 똑같다 Expand your scope. 나의 영역을 조금씩 확장해나가자. 내가 포커스하고 있는 영역 외에도 다른 영역에 관심을 가지는 것이 중요하다. 내가 어떤 일을 하게 될지 모르므로. 이 모든 것이 뻔하다면 뻔한말이지만, 중요한 것은 그 것을 직접 경험하고 이뤄온 인물을 눈앞에서 보고 “정말 그렇게 될 수 있구나”라고 느낄 수 있었다는 것이라 생각한다. Inspiring이라는 단어에 걸맞는 밋업이었다. 처음에는 영어로 진행되고 통역이 없는 것 같아서 참석에 망설였는데 현장에서 통역을 해주시는 분이 있어서 다행히 잘 들을 수 있었다. 정말 영어를 공부해야 나를 둘러싼 세계가 더 넓어지는구나 깨닫게 된 순간이기도 했다. QnA 아무래도 통역에 의존해서 내용이 정확하지 않을 수 있지만 인상적인 질문을 몇개 추려보았다. Q. 주변의 뛰어난 사람과 비교하며, 운이 좋아서 성공했다는 생각이 들 때 어떻게 극복했는지 ?A. 그 사람과 같은 주제를 정하고 공부, 공유한다 &gt; 나와 크게 다르지 않다는걸 알게됨.A. 긍정적인 피드백을 받으려고 함A. 지금까지 해왔던 성취를 적어보면서 극복함 Q. 테크 업계에서 여성으로서의 어려움을 어떻게 극복해왔는지 ?A. 여성으로서 어려움이 많지만 내가 바꿀 수 있는 것은 바꾸려고 하고 바꿀 수 없는 것은 내버려둔다. Q. 비전공자가 테크 영역으로 가려는데 뭘 해야할까?A. Technical Account ManagerA. 기술 영업 매니저A. 오픈소스, 데브옵스 커뮤니티가서 현장에 일하는 사람의 얘기를 들어보는 것이 좋다. Q. 기술 중심의 사람을 만날 때 압도당하는 기분을 느끼는데 어떻게 하는지?A. 여자들이 질문을 하지 않고 트레이닝하려는 경향이 있다A. 질문에 대한 대답하는 법을 모르기 때문A. 그런 질문들에 답해줄 수 있는 사람을 찾는 것이 중요하다.A. 여성이 여성에게 트레이닝하는 곳이 더 효과적이다. Q. 스타트업을 하는 분이 조언을 구하는 질문 내용.A. 네트워킹할때 내가 뭘 줄 수 있는지, 어떤걸 도움 받고 싶은지 명확하게 하라.A. 주변에 많이 알려라. 그렇다면 지금 당장은 얻지 못해도 나중에 돌아올 수 있다. Q. 한국에는 개발자의 주류가 남성이라 일터에서 성차별 문제가 있을때가 있는데 어떤식으로 극복했는지 ?A. 이뤄왔던 성취를 봐라.A. 성취가 없는 경우 그런 것을 해낼 수 있는 사람이라는 것을 보여줘라.A. 성취를 크게 말하고 알려라. 내가 무엇을 했는지. 마지막으로 좋았던 것은, Women Who Code의 공식 의식(?)인 #ApplaudHer였다.지금의 우리를 모두 칭찬해주자는 의미로 하는 것으로, 현장에 있는 사람들이 스스로 또는 지금 함께 있는 사람들에게 칭찬하고 싶은 내용을 말하고 서로 박수치며 칭찬하는 것이다. 우리는 좋은 질문을 해준 서로를 칭찬하고, 이런 행사를 기획하고 추운 날씨에 퇴근 후 참여한 서로를 칭찬했다. 모두가 자연스럽게 칭찬하는 분위기가 되어 나도 용기를 내서 칭찬의 한마디를 건넸다. 여성 개발자로서 IT 모임에 갔을 때 대다수가 남자인 경험이 대부분이었던 나에게 같은 길을 걸어가는 여성 개발자들의 모임은 아무래도 힘이 된다. 항상 ‘보통’이 아니고 ‘특별’했는데, 여성이 개발자인 것이 이상하지 않다는 것만으로. 이제서야 커리어를 시작하는 병아리 개발자지만, 백엔드 업무에 여자 개발자가 더 많다는 것이 이상하게 느껴지지 않는 세상이 될 때까지 나도 이 자리를 지키고 있어야겠다는 생각이 든다.","categories":[{"name":"Think","slug":"think","permalink":"https://j2de.github.io/categories/think/"}],"tags":[{"name":"Meetup","slug":"meetup","permalink":"https://j2de.github.io/tags/meetup/"},{"name":"Women Who Code","slug":"women-who-code","permalink":"https://j2de.github.io/tags/women-who-code/"}]},{"title":"암호화 vs 해시","slug":"encryption-vs-hash","date":"2020-01-19T12:03:04.000Z","updated":"2020-03-20T15:44:39.465Z","comments":true,"path":"2020-01-19-encryption-vs-hash/","link":"","permalink":"https://j2de.github.io/2020-01-19-encryption-vs-hash/","excerpt":"","text":"암호화: 복호화할 수 있다 = 원래대로 되돌릴 수 있다 원래대로 되돌리는 것 = 가역 공통키 암호 방식 vs 공개키 암호방식 공통키 : 패스워드를 거는 것 공개키 : 암호화, 복호화에 각각 다른 암호화 키를 준비해 암호화하는 쪽의 키를 공개하는 방법 ex) DES, 3DES, AES 등 해시: 복호화할 수 없다 = 원래대로 되돌릴 수 없다. 원래대로 되돌릴 수 없는 것 = 불가역 해시화하기 전의 상태를 유추할 수 없다. but 원래 데이터가 같으면 해시값도 동일한 값이 된다. 해시 방식에 따라 충돌이 일어나면 값이 다르지만 동일한 해시값이 될 수 있다. ex) MD5, SHA1, SHA256, SH512 암호화를 푸는 방식 알고리즘이 해독되어 있는 경우 추측되는 암호를 대입해 푸는 경우 따라서 알고리즘이 해독되어 있지 않고, RandomSeed가 불규칙해서 대입하는 방식으로 현실적으로 해독할 수 없는 경우를 채택해야함. 해시를 푸는 방식 암호화에 비해 복호화될 걱정은 거의 없는 편 하지만 문자열의 변환이기 때문에 패스워드같이 짧은 문자열은 해시화 방식이 알려지면 해시화된 목록을 갖고 있는 경우 해독될 가능성 있음 ex) A~Z, 0~9에 대해 md5한 목록을 이미 작성해 갖고 있으면 대입으로 유추 가능 이를 피하기 위해 특정 변환(길게 하기 = Salt 넣기)을 진행한 뒤 해시화하는 방법이 있다. Salt란 ? 변환시 추가하는 임의의 데이터 외부로 유출되면 안되는 정보는.. 패스워드는 암호화가 아니라 해시로 보호 해시화의 방식과 관계없이, 해시화를 하는 경우 길이가 긴 Salt를 사용 해시화의 방식과 관계없이, 해시화의 원래 문자열(패스워드)에서 사용하는 문자의 종류를 늘린다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Common","slug":"programming/common","permalink":"https://j2de.github.io/categories/programming/common/"}],"tags":[{"name":"Encryption","slug":"encryption","permalink":"https://j2de.github.io/tags/encryption/"},{"name":"Hash","slug":"hash","permalink":"https://j2de.github.io/tags/hash/"}]},{"title":"Java - Stream 기초","slug":"java-stream","date":"2019-10-19T21:54:07.000Z","updated":"2020-03-20T15:44:39.465Z","comments":true,"path":"2019-10-20-java-stream/","link":"","permalink":"https://j2de.github.io/2019-10-20-java-stream/","excerpt":"","text":"Stream 데이터의 흐름 배열 또는 컬렉션 인스턴스에 함수 여러개를 조합해 원하는 결과를 필터링하고 가공된 결과를 얻을 수 있다. 자바 8에서 추가된 것으로 람다를 활용할 수 있는 기술 중 하나. Stream VS Collection1. 스트림은 요소를 보관하지 않는다. 요소들은 하부 컬렉션에 보관되거나 필요할 때 생성된다. ex) List기반으로 스트림을 생성한다면, 요소는 List에 저장되어 있는 것. 단지 그 위에 Stream이 생성된다. 2. 스트림 연산은 원본을 변경하지 않으며 결과를 담은 새로운 스트림을 반환한다.3. 스트림은 가능한 지연(lazy) 처리된다. 즉 결과가 필요하기 전까지 실행되지 않는다. 생성하기 일반적으로 배열 또는 컬렉션으로 생성한다. 배열 스트림123456// (1) Arrays.stream String[] arr = new String[]&#123;\"a\", \"b\", \"c\"&#125;; // 배열 생성Stream&lt;String&gt; stream = Arrays.stream(arr); Stream&lt;String&gt; streamOfArrayPart = Arrays.stream(arr, 1, 3); // (2) Stream.of Stream&lt;String&gt; stream2 = Stream.of(\"a\", \"b\", \"c\"); 컬렉션 스트림 Java의 컬렉션 타입(Collection, List, Set)의 인터페이스에 default method로 stream이 추가되어 이를 통해 생성할 수 있다. 12final List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);Stream&lt;Integer&gt; stream = numbers.stream(); 그밖에도 빈 스트림, Stream.builder(), 무한 스트림(Stream.generate()), Stream.iterate(), 기본 타입 스트림, 문자열 스트림, 파일 스트림, 병렬 스트림(Paralle Stream)을 생성할 수 있다. 스트림 연결하기(Stream.concat)도 가능하다. 중간 연산(Intermediate Operation) Stream에서 원하는 내용만 가공하는 작업 Stream을 반환하기 때문에 method chainig으로 호출할 수 있다. Filtering filter로 스트림 내 원하는 요소를 걸러낸다. 인자로 Predicate를 받아 boolean을 리턴하는 함수형 인터페이스가 사용된다. 12345678// filter 함수Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);// 사용 예 System.out.println( Stream.of(1, 2, 3, 4, 5) .filter(i -&gt; i &gt; 3) // Lambda Expression .count() // Terminal Operation); // \"2\" 출력 filter()함수가 인자로 Predicate를 받으므로 i -&gt; i &gt; 3가 true인 경우만 필터링 되어 count()함수에 의해 집계된다. 1234567891011System.out.println( Stream.of(1, 2, 3, 4, 5) // Anonymous Class .filter(new Predicate&lt;Integer&gt;() &#123; @Override public boolean test(Integer integer) &#123; if (integer &gt; 3) return true; else return false; &#125; &#125;).count()); Lambda 식을 사용하지 않으면 이렇게 불필요한 코드가 많아진다. Mapping map으로 스트림 내 요소들을 하나씩 특정 값으로 변환한다. (T &gt; R) 인자로 Function&lt;T, R&gt;을 사용한다. 함수형 인터페이스인 Function은 T를 받아 R을 리턴한다. 즉 인자로 받은 데이터와 다른 데이터를 반환할 때 쓰인다. 스트림에 들어있는 값이 input되어 사용자가 지정한 로직을 수행한 후 output 되어 리턴되는 새로운 스트림에 담긴다. 12345678// map 함수&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);// 사용 예Stream&lt;String&gt; stringStream = Stream.of(1, 3, 3, 5, 5) .filter(i -&gt; i &gt; 2) // filtering된 데이터를 .map(i -&gt; i * 2) // (1) *2 한뒤 .map(i -&gt; \"#\" + i); // (2) #을 붙인 스트링값이 있는 Stream으로 반환한다. (1)에서 3, 3, 5, 5가 6, 6, 10, 10으로 변환된다. (2)에서 6, 6, 10, 10이 #6, #6, #10, #10으로 변환된다. Stream은 Lazy하게 동작하므로 위 코드는 Terminal Operation이 없어서 아직 수행되지 않는다. 그밖에도 flatMap, sorted, compare, peek 등이 있다. 최종 연산(Terminal Operation) 스트림 데이터로 부터 결과를 얻는 작업. 이 과정에서 사용하는 메소드를 reduction method라 한다. 단순 리덕션 count(), sum(), min(), max() 등 단순 계산을 수행한다. Optional로 반환한다. 리덕션 연산 여러 Element를 받아 하나하나 줄여나가 최종적으로 하나를 남긴다. 가장 단순한 형태는 이항 함수(Binary Function)을 받는다. 12Stream&lt;Integer&gt; values = ...;Optional&lt;Integer&gt; sum = values.reduce((x, y) -&gt; x + y); 위의 경우 reduce는 v0 + v1 + v2 + ...을 계산한뒤 최종적으로 하나의 값(총합)을 반환한다. 리덕션에서 사용되는 연산은 (위의 +) 결합 법칙을 지원해야한다. 즉 요소들을 결합할 때 순서가 문제가 되어선 안된다. reduce()1234OptionalInt reduced = IntStream.range(1, 4) // [1, 2, 3] .reduce((a, b) -&gt; Integer.sum(a, b)); 처음에 a = 1, b = 2로 sum을 수행해 3이 된다. a = 3(이전 상태), b = 3으로 3 + 3으로 최종적으로 6이 된다. Primitive Type Stream 들은 기본적으로 sum()이 구현되어 있으므로 그걸 사용하는게 편하다. Object Stream의 경우 sum()을 구현한다면 reduce()를 사용해야한다. 123456789101112131415161718192021222324@Data@AllArgsConstructorpublic class Product &#123; private Long id; private String name; private BigDecimal price;&#125;final List&lt;Product&gt; products = Arrays.asList( new Product(1L, \"A\", new BigDecimal(\"100.50\")), new Product(2L, \"B\", new BigDecimal(\"23.00\")), new Product(3L, \"C\", new BigDecimal(\"31.45\")), new Product(4L, \"D\", new BigDecimal(\"80.20\")), new Product(5L, \"E\", new BigDecimal(\"7.50\")));// Product 객체 리스트에서 price의 합을 구하고 싶을 때 System.out.println(\"Total Price: \" + products.stream() // List에서 Stream 생성 .map(product -&gt; product.getPrice()) // (1) .reduce( // (2) BigDecimal.ZERO, (price1, price2) -&gt; price1.add(price2))); (1) Product 객체에서 price value(BigDecimal 객체)를 사용해야하므로 map()으로 데이터를 변환해준다. (Product &gt; BigDecimal) (2) 초기값과 연산을 인자로 넣어준다. 덧셈에 영향을 주지 않는 데이터가 0이므로 0을 넣는다. 100.50 + 23.00 + 31.45 ... 를 수행한 뒤 결과(총 합)를 반환한다. collect() Collector 타입의 인자를 받아 종료 작업을 한다. 주로 스트림을 Collection 객체로 변환하는 작업을 한다. 123456List&lt;String&gt; collectorCollection = productList.stream() .map(Product::getName) // Product &gt; String .collect(Collectors.toList() // List&lt;String&gt; 반환 // [A, B, C, D, E]); Product 객체의 이름을 추출해 List로 반환한다. 12345String listToString = productList.stream() .map(Product::getName) .collect(Collectors.joining()); // ABCDE 연산 결과를 String으로 반환하고 싶은 경우 joining을 사용한다. 12345String listToString = productList.stream() .map(Product::getName) .collect(Collectors.joining(\", \", \"&lt;\", \"&gt;\")); // &lt;A, B, C, D, E&gt; 구분자와 prefix, suffix를 지정할 수 있다. Reference java 8 stream 가장 빨리 만나는 자바 8 케빈 TV - 모던 자바","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"},{"name":"Functional Programming","slug":"functional-programming","permalink":"https://j2de.github.io/tags/functional-programming/"}]},{"title":"함수형 사고 - ch7 실용적 사고","slug":"functional-thinking-ch7","date":"2019-10-19T21:47:20.000Z","updated":"2020-03-20T15:44:39.465Z","comments":true,"path":"2019-10-20-functional-thinking-ch7/","link":"","permalink":"https://j2de.github.io/2019-10-20-functional-thinking-ch7/","excerpt":"","text":"Java 8 Java가 기존에 가지고 있는 Class와 Collection에 map()과 reduce()와 같은 함수형 구조를 더했다. 함수형 구조를 통해 Java의 컬렉션들을 효과적으로 처리할 수 있다. reduce의 경우 불변객체를 이용한 조작 연산이지만, Java 컬렉션의 대부분은 가변형이므로 가변 리듀스 작업을 하는 collect가 추가되었다. Java8에서 reduce는 불변 객체를, collect는 가변 객체를 조작할 때 사용한다. 함수형 인터페이스(Functional Interface) Java의 일급 객체는 Function이 아니다. 일급 객체(first-class object)란 ? 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체 보통 함수에 매개변수로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라 함. 따라서 함수 자체를 주고 받을 수 없으므로 인터페이스를 이용하며, 이를 함수형 인터페이스라한다. Java의 함수형 인터페이스는 단일 추상 메소드(Single Abstract Method, SAM) 인터페이스이다. 인터페이스에 추상 메소드가 1개인 것을 의미 default, static method는 상관 없다. 즉, 함수가 아닌 인터페이스를 주고 받는다. 그리고 구체적인 함수는 인터페이스 내부의 유일한 추상메소드를 @Override해 사용한다. 기존의 자바라면 익명 클래스를 사용하지만 Lambda 표현을 통해 간략하게 사용할 수 있다. @FunctionalInterface로 함수형 인터페이스를 컴파일 레벨에서 check 할 수 있다. Java8부터는 interface에 default method가 추가되었다. 이 같은 개념을 mixin(믹신)이라 한다. 다른 클래스에서 사용될 메서드를 정의하지만 그 클래스의 상속 체계에 포함되지 않은 클래스 언어마다 다르지만 공통적으로 코드의 재사용이 좋아지고 다중상속의 모호함을 해결해준다. Java의 함수형 인터페이스 인터페이스 추상 메소드 설명 Consumer void accept(T t) 객체 T를 받아 소비함 Supplier T get() T 객체를 리턴함 Functioin&lt;T, R&gt; R apply(T t) 객체 T를 객체 R로 매핑 Predicate Boolean test(T t) 객체 T를 조사한 뒤 결과 반환 함수형 인터페이스 내의 메소드 명은 중요하지 않다. Optional(옵셔널) Stream이 종료된 후 Java의 내장 메소드는 Optional을 리턴한다. Optional로 한번 감싸므로 NPE을 방지한다. Java8 Stream 대부분 함수형 언어들은 Stream(스트림)이라는 추상화가 포함되어 있다.스트림의 특징 스트림은 값을 저장하지 않고, 종결 작업을 통해 입력에서 종착점까지 흐르는 파이프라인처럼 사용한다. 상태를 유지하지 않는다. ex) filter() 작업은 밑에 깔린 컬렉션을 바꾸지 않고 필터된 스트림을 받는 것 스트림은 Lazy Evaluation이다. 무한 스트림이 가능하다. limit(), findFirst() 같은 제한 메소드로 부분집합을 구할 수 있다. 스트림은 중간 작업(Intermediate Operation) 또는 종결 작업(Terminal Operation)이다. 중간 작업은 항상 새 스트림을 리턴한다. 스트림은 게으르기(Lazy) 때문에 종결 작업까지 선언되어야 스트림에 해당하는 값을 구할 수 있다.12345678910List&lt;String&gt; list = Arrays.asList(\"apple\", \"banana\", \"java\");counter = 0;Stream&lt;String&gt; stream = list.stream() .filter(el -&gt; &#123; counter++; return el.contains(\"a\"); &#125;);System.out.println(counter); // \"0\"// 종결 작업이 선언되지 않았기 때문에 // 스트림 연산이 이루어지지 않아 값이 나오지 않는다. Immutable Objects 함수형 프로그래밍은 불변성이 기본이다. 불변형 객체는 변이가 없으므로 테스트가 간편해지고, 기본적으로 thread-safe해 동기화 문제가 없으며, 상태를 알 수 없거나 잘못된 상태를 가질일이 없다. 불변 객체는 생성될 때 초기화가 일어나므로 생성 시 모든 문제를 알 수 있다.(컴파일 레벨에서 확인) 이를 실패의 원자성(Failure Atomicity)이라 한다. Immutable Objects of Java 모든 필드를 final 선언 클래스를 final 선언해 Override 방지 인수가 없는 생성자를 제공하지 않는다. 불변형은 생성시 초기화 되므로 인수 없는 생성자가 필요하지 않다. 적어도 하나의 생성자를 제공한다. 생성자 외에 변이 메소드(setter)를 제공하지 않는다. setter 외에도 가변 객체 참조를 전달하지 않게 주의해야한다. Reference 함수형 사고 java 8 streams collect vs reduce 일급 객체 java 8 stream advanced 람다식 - 표준 API의 함수적 인터페이스1","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Common","slug":"programming/common","permalink":"https://j2de.github.io/categories/programming/common/"}],"tags":[{"name":"Functional Thinking","slug":"functional-thinking","permalink":"https://j2de.github.io/tags/functional-thinking/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"데이터베이스의 성능 향상(feat. 인덱스)","slug":"database-index","date":"2019-10-16T17:56:01.000Z","updated":"2020-03-20T15:44:39.458Z","comments":true,"path":"2019-10-17-database-index/","link":"","permalink":"https://j2de.github.io/2019-10-17-database-index/","excerpt":"","text":"성능이란 ? 기본적으로 “빠르기”를 기준으로 한 개념 성능을 측정하는 2가지 지표 처리시간(Processing Time) or 응답시간(Response Time) 어떤 특정 처리의 시작부터 종료까지 걸린 시간 처리율(Throughput) 특정 처리(트랜잭션)를 단위 시간에 몇 건 처리 가능한가 ex) 트랜잭션을 초당 50건 처리하는 것이 가능하면, 50 TPS(Transaction Per Second) 정점과 한계 처리율이 높은 시스템일수록 (CPU나 하드웨어같은) 자원이 많이 필요하다 즉 동시에 실행되는 처리가 증가할 수록 필요한 물리 자원도 증가한다. 이때 동시 실행 처리 수가 자원의 한계를 넘어서는 경우 응답시간이 상승하고 처리율이 떨어지며 성능이 나빠진다. 한 가지 자원이라도 한계에 이르면 성능이 나빠지기 시작하는데 이를 버틀넥 포인트(Bottleneck Point), 병목이라 한다. 시스템은 동시에 실행되는 처리가 가장 많아질 때를 기준으로 자원을 준비하지 않으면 정점(Peek)일 때 극단적인 지연을 일으킨다. 정점을 상정한 자원을 확보해두는 것을 사이징(Sizing)이나 캐퍼시티 플랜(Capacity Planinig)이라 한다. 정점일때와 아닐 때의 차이가 큰 경우 정점에 맞추는 경우 평상시에 낭비되는 자원이 크다. 그렇기에 클라우드를 통해 스케일업과 스케일아웃을 하며 동적인 자원관리를 하는 추세이다. 스케일업(Scale-Up) : 고성능 장비 도입 스케일아웃(Scale-Out) : 장비 추가 도입 데이터베이스의 성능데이터베이스 병목 데이터 베이스가 시스템에서 병목이 되기 쉬운 이유 1. 취급하는 데이터 양이 많다. 최근들어 저장되는 데이터가 폭발적으로 증가하는 추세라 데이터를 보존하는 저장소에서 병목이 일어나는 경우가 많다. 2. 자원 증가(스케일 아웃)를 통한 성능 향상이 어렵다. 데이터베이스의 병목 지점은 CPU나 메모리가 아니라 주로 보조기억 장치이므로 스케일 아웃이 어렵다. 데이터베이스는 기본적으로 Active-StandBy나 Active-Active 구성을 취하기 때문 이런 이유로 주로 한정된 자원을 효율적으로 쓰기 위한 ‘튜닝‘이 발전함 최근에는 저장소를 더 고속 매체인 메모리에 적재하는 등으로 스케일업에 의한 성능 개선도 이루어지고 있다. 이런 발상으로 만들어진 데이터베이스가 인메모리 데이터베이스(In-memory) 데이터베이스 성능을 결정하는 요인데이터베이스의 실행 과정1. 파스 (Parse) 내부 프로그램인 Parsor가 구문 오류를 체크한다. 2. 실행계획 (Execution Plan OR Access Plan)- 실행계획 작성 &gt; 실행계획 평가 내부 프로그램인 Optimizer가 SQL문에 어떤 경로로 접근할지 계획한다. 프로그래머는 SQL을 선언만하고 과정은 옵티마이저가 하므로 일반적인 절차형 언어와 다르게 선언형 언어라 하기도 함. 옵티마이저가 보통 프로그래머보다 효율적인 실행계획을 세우므로 직접 실행계획을 세우는 것은 지양하는 것이 좋다. 옵티마이저가 최적의 속도로 동작할 수 있는 환경을 구성해주는 것이 중요 통계 정보를 참고해 실행 계획을 세운다. 통계 정보란 ? 옵티마이저가 실행계획을 세울 때 참고하는 정보 테이블의 행수,열수 각 열의 길이와 데이터형 테이블의 크기 열에 대한 기본키나 NOT NULL 제약의 정보 열값의 분산과 편향 등. 통계 정보는 테이블에 보존되어 있다. show table status; Rows : 행 수 Avg_row_length : 평균 레코드 크기 show index from [TABLE_NAME]; Cardinality : 인덱스 대상의 분산도 통계 데이터는 대부분 자동으로 수집되어 구현된다. 대체로 대량의 데이터가 변경되거나 특정 시간을 정할 수 있다. 데이터 액세스 데이터베이스가 실행계획을 세우는 기준 인덱스 인덱스의 유무로 풀 스캔(full scan)과 레인지 스캔(range scan)이 나뉜다. 풀 스캔: 테이블의 레코드를 전부 읽는 것 레인지 스캔: 테이블 일부 레코드만 읽는 것 인덱스가 있는 경우 TYPE이 All이 아닌 CONST, RANGE 스캔 종류의 이름은 조건에 따라 조금씩 달라진다. 인덱스가 없는 경우 현재 예시 테이블은 id와 fk에만 인덱스가 존재한다. 인덱스가 없는 컬럼을 조회하므로 ALL 풀 스캔을 한다. 기본키는 따로 설정하지 않아도 인덱스가 존재한다. 인덱스 생성 create index [INDEX_NAME] on [TABLE_NAME]([COLOMN_NAME]) 인덱스의 구조 B-Tree 로 되어있다. 따라서 데이터들은 반드시 정렬된 데이터로 유지된다. B-Tree는 균형 트리이기에 어떤 값에 대해서도 속도가 일정하다(최선, 최악의 경우가 비슷) 일반적으로 B-Tree는 3~4층 정도로 조절된다. 처음 생성시 균형 트리이지만 INSERT/DELETE/UPDATE 등이 일어나면 트리가 깨지며 성능이 나빠질 수 있다. 따라서 갱신 빈도가 높은 테이블은 정기적으로 인덱스 재구성이 필요하다. 인덱스의 성능- 데이터에 비례해 효과가 좋아진다. 어느정도 큰 데이터에서 생성하는 것이 좋다. - 정렬을 건너뛰는 것이 가능하다. 예를 들면 groupby로 count하는 경우 인덱스가 없다면 풀 스캔 + 정렬을 위한 임시영역에 파일을 저장한다. 이런식으로 임시영역을 사용해 처리하면 매우 느려 성능 이슈를 일으킬 수 있다. 인덱스가 있다면 이미 정렬되어 있으므로 고속 처리가 가능하다. SQL 내부에서 정렬하는 경우 GROUP BY COUNT/SUM/AVG 등의 집약 함수 UNION/INTERSECT/EXCEPT 등의 집합연산 인덱스 주의사항 인덱스는 SELECT 성능을 향상시키고 INSERT/UPDATE/DELECT 성능을 약화시킨다. 인덱스 갱신의 오버헤드로 성능이 떨어진다. 너무 많은 인덱스를 만드는 경우 의도한 것과 다르게 실행될 수 있다. 인덱스를 생성만 할 뿐 실행은 옵티마이저가 자동으로 하기 때문에 의도와 다르게 동작해 더 느릴 수 있다. 따라서 크기가 큰 테이블에만 만들고 기본키 제약이나 유일성 제약이 붙은 경우 자동으로 인덱스가 생성되므로 추가 생성하지 않는다. Cardinality가 높은 열에 만든다. 성능 안티 패턴 통계 정보 갱신 설정이 off인 경우 정기 갱신을 설정하고 데이터양이 급격하게 바뀌는 경우 정기 갱신 전 바뀐 데이터에 대해 인덱스가 적용되지 않은 상태라 성능 향상을 기대하기 어렵다. Reference 데이터베이스 첫걸음","categories":[{"name":"CS","slug":"cs","permalink":"https://j2de.github.io/categories/cs/"},{"name":"DataBase","slug":"cs/database","permalink":"https://j2de.github.io/categories/cs/database/"}],"tags":[{"name":"MySQL","slug":"mysql","permalink":"https://j2de.github.io/tags/mysql/"}]},{"title":"함수형 사고 - ch2 전환","slug":"functional-thinking-ch2","date":"2019-10-16T11:54:04.000Z","updated":"2020-03-20T15:44:39.464Z","comments":true,"path":"2019-10-16-functional-thinking-ch2/","link":"","permalink":"https://j2de.github.io/2019-10-16-functional-thinking-ch2/","excerpt":"","text":"생각의 전환 새로운 언어를 배우는 것은 쉽지만, 새로운 패러타임을 익히는 것은 어렵다. 함수형 코드를 제대로 작성하기 위해서는 문제를 접근하는 방식의 전환이 필요하다. 명령형에서 함수형으로의 전환명령형 처리 명령형 프로그래밍이란 상태를 변경하는 명령으로 이루어진 프로그래밍 (일반적으로 for 루프) 이러한 프로그래밍은 개발자가 루프 내에서 연산하기를 권장한다. 한 글자 이름 필터, 목록에 남아 있는 이름 대문자 변형, 목록을 하나의 문자열로 변환하는 일련의 과정을 모두 저 수준의 매커니즘에서 사용한다. 함수형 처리 필터, 변형, 변환 등 논리적 분류로 구현한다. 고계함수에 매개변수로 주어지는 함수를 이용해 저수준의 작업을 커스텀한다. 고계함수란 ? 함수를 다루는 함수, 함수를 인자로 받을 수 있고 함수를 반환하기도 함. 함수가 정수와 동등하게 다루어짐 한 글자 이름을 필터하고, 이 연산의 결과를 map 함수에 넘긴뒤 reduce를 통해 결합한다. 모든 함수형 언어에서 비슷한 기능을 제공해준다. 이와 같이 함수형 사고로의 전환은 “세부적인 구현을 하지 않고 고수준 추상 개념을 적용하는 법”을 배우는 것이다. 고수준의 추상적 사고로 얻는 이점들 문제의 공통점을 고려해 다른 방식으로 분류하는 것을 권장함 런타임이 최적화를 잘할 수 있도록 한다. 더 적은 아이템을 처리하는 경우 ex) Java8 Supplier를 이용한 Lazy Evaluation 등 개발자가 엔진의 세부사항을 깊게 고려하지 않고 프로그래밍 할 수 있다. 책에서는 “개발자가 엔진 세부사항에 깊이 파묻힐 경우 불가능한 해답을 가능하게 한다.” 고 나와 있지만 위의 뜻인 것 같다. 예를 들면 위의 명령형 처리 로직에 스레드 처리가 추가된다면 스레드 관련 코드가 로직 코드에 섞여 들어간다. 하지만 함수형으로 프로그래밍한다면 병렬 처리를 의미하는 코드 한줄만 추가하면 된다. 12345678public String cleanNamesP(List&lt;String&gt; names) &#123; if (names == null) return \"\"; return names .parallelStream() // 이 한줄이 추가되었다. .filter(n -&gt; n.length() &gt; 1) .map(e -&gt; capitalize(e)) .collect(Collectors.joining(\",\"));&#125; 이후 저수준의 세부적인 최적화는 런타임이 담당한다. 명령형에서 함수형으로의 전환 과정 OOP 언어는 캡슐화가 이점이므로 내부 상태 사용이 보편적이고 권장된다. FP은 내부 변수를 사용하지 않고 필요한 값을 매개변수로 넘긴다. 부수 효과가 없는 순수 함수를 사용한다. 입력만 결과에 영향을 주는 함수 따라서 캐싱하지 않고 항상 계산 하기때문에 성능이 떨어지며, 이를 막기 위해 메모이제이션을 사용한다. 완전한 FP은 Stream을 이용한다. 연산의 중간과정을 스트림에 저장한 뒤 완전히 연산히 끝났을 때 스트림을 종료하고 값을 생성한다. 이를 게으른 평가(Lazy Evaluation)이라 한다. 함수형 언어들의 공통된 빌딩 블록 필터 / 변형 / 변환에 관한 내용은 함수형 언어 및 프레임 워크에 공통적으로 존재한다. 1. 필터 사용자가 정한 조건으로 목록에 있는 요소를 필터해서 더 작은 목록으로 만든다. ex) java8 - filter() 2. 맵 각 요소에 같은 함수를 적용해 새로운 컬렉션을 만든다. ex) java8 - map() 3. 폴드 / 리듀스 언어마다 이름도 다양하고 약간의 의미도 다르지만, 기본적으로 캐터모피즘(catamorphism)이라는 목록 조작 개념의 변형을 의미한다. 목록을 접어서 다른 형태로 만드는 연산 ex) java8의 filter로 값을 추출 후 reduce를 통해 추가 연산 후 결과를 반환 Reference 함수형 사고(Functional Thinking), 한빛미디어 Functional Thinking Code","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Common","slug":"programming/common","permalink":"https://j2de.github.io/categories/programming/common/"}],"tags":[{"name":"Functional Thinking","slug":"functional-thinking","permalink":"https://j2de.github.io/tags/functional-thinking/"}]},{"title":"함수형 사고 - ch1 왜?","slug":"functional-thinking-ch1","date":"2019-10-16T11:26:14.000Z","updated":"2020-03-20T15:44:39.464Z","comments":true,"path":"2019-10-16-functional-thinking-ch1/","link":"","permalink":"https://j2de.github.io/2019-10-16-functional-thinking-ch1/","excerpt":"","text":"함수형 프로그래밍을 하는 이유1. 패러다임의 전환 문제에 대해 사람이 생각하는 것과 같은 방식으로 프로그래밍 할 수 있다. 예를 들면, Java에서 1)텍스트 파일을 읽고 2)가장 많이 사용된 단어를 찾고 3)그 단어들과 빈도를 정렬된 목록으로 출력해야 한다면 일반적으로 성능을 위해 한 loop 안에서 3가지 연산을 섞어서 사용 할 것 책에서는 이것을 “성능을 명료함과 맞바꾸었다”고 표현함. 반면에 함수형 프로그래밍을 한다면 map과 filter와 같은 고계함수를 이용해 사람이 생각하는 것과 같은 흐름(위의 1)~3))으로 프로그래밍 할 수 있게 한다. 12345678public Map wordFreq(String words) &#123; TreeMap&lt;String, Integer&gt; wordMap = new TreeMap&lt;&gt;(); regexToList(words, \"\\\\w+\").stream() // 정규표현식을 검색한 뒤 스트림으로 변경 .map(w -&gt; w.toLowerCase()) // 소문자로 바꾼다. .filter(w -&gt; !NON_WORDS.contains(w))// 비단어를 골라내고 .forEach(w -&gt; wordMap.put(w, wordMap.getOrDefault(w, 0) + 1)); // 단어 빈도수를 센다. return wordMap;&#125; 2. 최근 언어 트렌드 주요 언어들이 함수형 기능을 더하고 있다. 즉 함수형 패러다임을 이해한다면 다른 최신 함수형 언어들을 쉽게 익히고 사용할 수 있게된다. 3. 언어/런타임에 제어를 양도함 c++에서 Java로 GC를 사용하는 것처럼, 까다로운 저수준의 문제를 언어나 런타임에 최대한 맡길수록 더 중요한 문제에 집중 할 수 있게 된다. 4. 간결함 객체지향 프로그래밍은 움직이는 부분을 캡슐화하여 코드 이해를 돕고, 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드 이해를 돕는다. 캡슐화, 스코핑, 가시성 등의 상태 변화에 대해 필요한 세밀한 제어들을 직접 제어 하기 보다는 이 부분을 제거하는데 주력한다. 객체지향 개발자는 항상 새로운 자료구조(Object)와 거기에 메소드를 만드므로 메서드 수준의 재사용보다큰 프레임워크 스타일의 재사용을 하게된다. 함수 수준의 캡슐화는 모든 문제에 새로운 클래스를 생성하기보다는 더 세부적인 수준에서 재사용을 가능하게 한다. Reference 함수형 사고(Functional Thinking), 한빛미디어 Functional Thinking Code","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Common","slug":"programming/common","permalink":"https://j2de.github.io/categories/programming/common/"}],"tags":[{"name":"Functional Thinking","slug":"functional-thinking","permalink":"https://j2de.github.io/tags/functional-thinking/"}]},{"title":"MySQL 트랜잭션과 동시성 제어","slug":"mysql-transaction-and-concurrency-control","date":"2019-10-15T14:20:32.000Z","updated":"2020-03-20T15:44:39.458Z","comments":true,"path":"2019-10-15-mysql-transaction-and-concurrency-control/","link":"","permalink":"https://j2de.github.io/2019-10-15-mysql-transaction-and-concurrency-control/","excerpt":"","text":"트랜잭션과 동시성제어트랜잭션이란?복수의 쿼리의 처리 단위 데이터 갱신은 단일 쿼리보다 복수 쿼리를 연속적으로 수행하는 경우가 많다. 동시성 제어를 위해 필요 MyISAM vs InnoDB 전자는 테이블 단위 잠금, 트랜잭션 사용 불가 후자는 행 단위 잠금, 트랜잭션 사용 가능 트랜잭션 특성 (ACID 특성) Atomicity(원자성) 데이터 변경(update, delete, insert)시 데이터 조작이 전부 성공 or 전부 실패하도록 보증 Consistency(일관성) 데이터 조작 전후로 상태를 유지하는 것을 보증함…? ex) 일관성을 유지하기 위해 사용자 등록 시 사용자 구분하기 위한 일련 번호에 unique 제약 조건을 검 Isolation(고립성, 격리성) 복수의 사용자가 데이터 조작을 해도 각각 처리가 모순 없이 동작함 모순 없이 동작한다는 것은 동시에 말고 순서대로 실행 시켰을 때와 같은 동작을 한다는 것을 의미 병렬로 실행되지 않은 상태를 의미(직렬) ex) 호텔방 예약 시 1. 빈 방 확인 2. 빈방에서 -1 후 결과를 빈방 수로 되돌려준다는 로직을 수행하는 경우 사용자 a와 사용자 b가 동시에 수행하면 8개가 아닌 9개가 남았다고 될 수 있음 Isolation을 유지하기 위해 lock 을 사용 잠금 단위는 테이블 전체, 블록, 행 등 MySQL은 주로 트랜잭션 처리 시 행 단위 잠금 이용 (select ~ for update) 후속 처리는 해당 잠금이 해제될 때 (commit or rollback )까지 대기한 후 처리한다. InnoDB형 테이블은 MVCC 구조로 동작하기 때문에 단순 값 참조 시 select ~ for update 구준은 불필요. 읽기가 블록되지 않음. 이 때 테이블 갱신하는 사용자가 소수고 참조하는 사용자가 많은 경우 사용자의 동시성, 병렬성이 높아짐. 모순 없는 동작(직렬)을 위해 DBMS에서 Serializable (직렬화 가능) 이라는 격리 수준을 제공함 이때 항상 동시에 동작하는 트랜잭션이 1개여야 하므로 성능에서 실용적이지 않음 따라서 격리 수준을 완화해 단계별로 제공한다. Trasaction Isolation Level(트랜잭션 격리 수준) 커밋되지 않은 읽기(Read Uncommied) - 가장 완화 커밋된 읽기(Read Committed) 반복 읽기(Repeatable Read) - MySQL의 기본 설정 직렬화 가능(Serializable) - 가장 엄격 격리 수준 완화에 따라 일어나는 현상 더티 읽기(Dirty Read) (1 이하) 어떤 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽는 현상 애매한 읽기(Fuzzy/Non-Repetable Read) (2 이하) 어떤 트랜잭션이 이전에 읽어들인 데이터에를 다시 읽을 때 2회 이후의 결과가 1회 때와 다른 것 팬텀 읽기(Phantom Read) (3 이하) 어떤 트랜잭션을 읽을 때 데이터가 나타나거나 사라지는 현상. 격리수준 더티 읽기 애매한 읽기 팬텀 읽기 커밋되지 않은 읽기 O O O 커밋된 읽기 X O O 반복 읽기 X X O 직렬화 가능 X X X Durability(지속성) commit 후 (데이터 조작 완료 후) 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이고 결과를 잃지 않는 경우를 의미 시스템이 비정상일 때도 성립해야함(os 이상종료 등의 시스템 장애에도 해당) MySQL과 같은 데이터베이스는 트랜잭션 조작을 하드 디스크에 로그 로 기록, 시스템 이상 발생 시 그 로그를 사용해 발생 전 상태로 복원함. 다른 커넥션에서 테이블을 보는 경우 DDL에 의한 테이블 작성과 , DML에 의한 데이터 저장은 트랜잭션 커밋 전까지 다른 커넥션에서 보이지 않지만 이와 별개로 보이는 경우가 있다. DDL에 의한 암묵적인 커밋 MySQL이나 Oracle에서 create table같은 DDL 실행시 암묵적인 커밋 발생. 따라서 한개의 커넥션에서 실행된 create table 성공시 다른 커넥션에서도 참조 가능 오토커밋 설정 트랜잭션의 개시(begin transaction, start transaction 등)가 명시적으로 지정되지 않았을 때 2가지 모드로 구분함 하나의 SQL문을 하나의 트랜잭션으로 사용자가 commit 또는 rollback을 실행할 때 까지가 하나의 트랜잭션 일반적인 dbms에서는 선택 가능. mysql, postgreSQL, SQL Server는 기본 설정이 2.오토커밋 이와 별개로 갱신을 수행하는 트랜잭션 자신은 트랜잭션 격리 수준, commit, rollback과 상관없이 자신이 수행한 갱신을 즉시 볼 수 있다. MVCC에 따른 MySQL(InnoDB)의 특성MVCC(Multi Versioning Concurrency Control): 다중 버전 동시성 제어 RDBMS는 공유 데이터를 사용하기 때문에 동시성 제어가 필요함 이를 Rock을 통해 상호배제를 해 컨트롤 했지만 이는 대기 현상이 발생하기 때문에 성능이 떨어짐 어떤 데이터에 여러 차례 수정이 가해진 경우 수정이 가해진 시점에 대해 버전 별로 데이터를 저장하고 읽기와 쓰기간 경합을 최소화해 동시성 제어 성능을 높임. 읽기를 수행할 경우 갱신 중이라도 블록되지 않는다(읽기←&gt;읽기는 서로 블록되지 않음) 읽기 내용은 격리 수준에 따라 내용이 바뀌는 경우가 있다. 반복 읽기의 경우 최초 쿼리 실행한 시점에 커밋된 데이터를 읽음. 따라서 같은 쿼리 복수 회 실행 시 사이에 다른 트랜잭션이 커밋해도 그 내용은 반영되지 않음 커밋된 읽기는 쿼리를 실행한 시점에서 커밋된 데이터를 읽는다. 같은 쿼리 복수 회 실행시 그 사이에 다른 트랜잭션에서 커밋시 최신 쿼리 실행 개시 시점의 커밋된 데이터를 읽음 갱신(데이터 쓰기) 시 배타적 잠금을 얻는다. 잠금은 기본적으로 행 단위이며 트랜잭션이 종료될 때까지 유지한다. 격리 수준이나 InnoDB 설정에 따라 실제로 잠금하는 행의 범위가 다를 수 있음. 갱신과 갱신은 나중에 온 트랜잭션이 잠금을 획득하려할 때 블록된다. 일정 시간을 기다리고, 그 안에 잠금을 얻을 수 없을 시 잠금 타임아웃(lock timeout)된다. 갱신하는 경우 갱신 전 데이터를 undo 로그로 ‘롤백 세그먼트’영역에 유지한다. undo 로그 용도 2가지 갱신하는 트랜잭션 롤백 시 갱신 전으로 되돌리는 것 복수의 트랜잭션에서 격리 수준에 따라 대응하는 갱신 데이터를 참조하는데 이용함. 같은 행 갱신할 때마다 undo로그가 작성되고 같은 행에 대한 복수 버전이 존재한다. 이에 의해 1,2가 실현된다. MVCC에서의 잠금(같은 행인 경우) 트랜잭션 A, B 둘다 읽기 &gt; O A 읽기, B 쓰기 &gt; O A 쓰기, B 쓰기 &gt; X A가 lock을 얻고 수행하는 동안 B는 block된다 지정된 시간안에 lock을 얻을 수 없는 경우 lock timeout 된다. MVCC에서의 커밋되지 않은 읽기 커밋되지 않은 읽기 격리 수준은 커밋되지 않은 경우, 읽기도 블록되는 경우 이를 허용하는 것. MVCC는 읽기가 블록되는 경우가 없어서 이 레벨이 필요하지 않다. 잠금 타임아웃과 교착 상태잠금 타임아웃 갱신과 갱신이 부딪칠 때 나중에 온 갱신이 잠금 대기 상태가 됨. 잠금을 건 쪽이 언제 잠금을 풀지 알 수 없어서 잠금 해제를 기다리는 쪽에서 기다리거나 기다리지 않거나 어느정도 기다릴지 를 설정할 수 있다. innodb_lock_wait_timeout 시스템 변수에 설정 MySQL에서는 잠금 대기로 타임아웃 발생 시 롤백되는 단위는 기본으로 오류가 발생한 쿼리임. 교착 상태 트랜잭션 A가 테이블 A의 lock을, 트랜잭션 B가 테이블 B의 lock을 가진 상태에서 서로 잠금한 테이블의 자원이 필요한 경우 아무리 기다려도 상황이 바뀌지 않음. 이를 교착상태(데드락)이라 함. 교착상태의 빈도를 낮추는 대책 잠금 타임 아웃과 달리 교착 상태를 기다려도 상황이 개선되지 않는다. 따라서 일반적으로 DBMS에서는 교착상태를 검출해 보고한다. MySQL의 경우 교착 상태가 일어나면 시스템 영향이 작은 쪽 트랜잭션을 트랜잭션 개시 시점까지 롤백한다. 교착 상태를 모두 없애는 것은 불가. 따라서 항상 트랜잭션이 교착 상태를 일으켜 롤백되는 경우 트랜잭션을 재실행할 수 있는 구조로 만들어야함. DBMS의 전반적인 대책 트랜잭션을 자주 커밋, 트랜잭션이 더 작은 단위가 되어 교착상태 가능성을 낮춤 정해진 순서로 테이블(과 행)에 액세스 하게 한다. ex) 트랜잭션 A가 테이블 a&gt;테이블b로 엑세스 하고 트랜잭션 B가 테이블 b&gt; 테이블 a로 액세스해 교착상태가 발생한 것이므로 어떤 트랜잭션도 테이블 a&gt;b순으로 엑세스 하도록함. 필요 없는 경우 읽기 잠금 획득(select ~ for update) 사용을 피한다 쿼리에 의한 잠금 범위를 좁히거나(테이블 &gt; 행 등), 잠금 정도를 더 작은 것으로 (격리 레벨 완화) 한다. 테이블 잠금보다 행 잠금을 사용 MySQL은 기본 설정인 반복 읽기가 아닌 커밋된 읽기로 설정 동시에 많은 연결에서 갱신 때문에 교착 상태가 자주 발생하는 경우 테이블 단위 잠금을 획득해 갱신을 직렬화 하면 동시성은 떨어져도 교착상태는 회피할 수 있어 전체 처리로 보면 좋을 수도 있다. (MySQL(InnoDB)의 대책) 테이블에 적절한 인덱스를 추가해 인덱스가 이를 이용하게 한다. 인덱스가 사용되지 않는 경우에는 필요한 행의 잠금이 아닌 스캔한 행 전체에 대해 잠금이 걸리게된다. …? 이해안됨 해서는 안 되는 트랜잭션 처리 오토커밋 MySQL의 새로운 연결은 모두 기본값으로 오토 커밋 오토 커밋은 쿼리 단위로 커밋하는 것. 테스트용으로는 좋지만 애플리케이션에 사용하기엔 부하가 너무 높음 긴 트랜잭션 긴 트랜잭션은 데이터베이스 트랜잭션의 동시성이나 자원의 효율성을 저하함. 갱신을 포함한 트랜잭션은 같은 데이터를 갱신하려는 다른 테이블을 블록하고 이에 타임아웃될 수 있음. 이 잠금과 블록 사이에 교차가 발생하면 교착상태도 발생, 이에 긴 트랜잭션 중 하나가 롤백됨 이를 위해 교착상태의 빈도를 낮추는 대책 에 나온 방법을 시행하는 것이 좋음. 그밖의 피해야할 것. 대량 처리를 한 개의 트랜잭션이 실행 대량의 갱신 처리를 한개의 트랜잭션으로 실행하면 트랜잭션으로 이 처리를 롤백하기 위해 대량의 undo 로그를 트랜잭션 종료 시까지 유지해야 한다. Undo 로그가 불필요해진 시점에 해당 영역은 해제되어 재사용되지만 os파일 시스템에서의 크기는 줄어들지 않는다 . 이 때문에 겉보기에 불필요하게 undo 로그가 큰 경우가 있음. 이를 막기 위해 대량 처리를 적당한 크기의 트랜잭션으로 나누어 처리하는 것이 좋다. 예를 들면 신규테이블에 데이터를 로드할 때 1만건당 커밋 아무것도 하지 않는 트랜잭션 유의 테이블을 select한 후 아무것도 하지 않고 트랜잭션을 열린 채로 두면 같은 테이블에 갱신을 실행할 때 이 테이블의 반복 읽기를 유지하기 위해 undo 로그가 계속 유지된다 .따라서 피하는 것이 좋다. 트랜잭션 중 대화 처리를 넣는 경우 dbms의 트랜잭션은 빡빡한 처리를 동시에 실행하는 구조 따라서 언제 끝날지 알 수 없는 불명확한 처리를 포함해선 안된다. 처리 능력 이상의 트랜잭션 수 트랜잭션에서 어떤 잠금이 있는 처리를 수행할 때 이 잠금이 다른 트랜잭션의 처리를 막지 않는 것이 좋지만, 트랜잭션 실행이 다른 트랜잭션 잠금 때문에 막힌다면 잠금 타임아웃이나 교착 상태 확률이 증가하고 성능 저하로 이어짐. 커넥션이 잘 작동하는 수나 동시 실행할 수 있는 수의 상한을 어느정도로 설정할 지는 시스템 요건(갱신이 많은지 검색이 많은지)나 하드웨어 성능에도 좌우되므로 최적의 트랜잭션 수는 부하 실행을 수행해 측정할 수 밖에 없다. MySQL은 데이터베이스 서버의 커넥션 수 상한을 설정하는 max_connections 라는 시스템 변수가 있어 이것으로 조절할 수 있다. Reference 데이터베이스 첫걸음","categories":[{"name":"CS","slug":"cs","permalink":"https://j2de.github.io/categories/cs/"},{"name":"DataBase","slug":"cs/database","permalink":"https://j2de.github.io/categories/cs/database/"}],"tags":[{"name":"MySQL","slug":"mysql","permalink":"https://j2de.github.io/tags/mysql/"}]},{"title":"🐥병아리 개발자가 IT 정보를 얻는 방법들","slug":"how-junior-developers-get-it-information","date":"2019-09-26T13:30:38.000Z","updated":"2020-03-20T15:44:39.465Z","comments":true,"path":"2019-09-26-how-junior-developers-get-it-information/","link":"","permalink":"https://j2de.github.io/2019-09-26-how-junior-developers-get-it-information/","excerpt":"","text":"개발을 처음 시작하거나, 잘 모르는 경우 IT/개발 정보를 어디에서 얻어야하는지부터 잘 모르는 경우가 있다.본인 또한 IT 정보를 얻고 커뮤니케이션을 하는 방법을 잘 몰랐기 때문에,과거의 나처럼 잘 모르는 병아리 개발자들에게 정보를 공유하고 싶어서 글을 적게되었다. 1. 페이스북개발자들이 가장 빠른 정보를 주고 받는 플랫폼은 페이스북인 것 같다.특히 세미나/컨퍼런스에 대한 정보를 실시간으로 얻기 좋다.그리고 IT 계에서 유명한 분들의 글 중 특히 양질의 글이 추천으로 올라오기도 한다.SNS를 하기 싫더라도 페이스북은 구독용 계정이라도 만드는 것을 추천한다.(본인 얘기)자신이 관심 있는 분야의 페이지를 구독하는 것이 좋지만, 정말 아무 것도 모른다면 생활코딩 페이지를 구독하자. 생활코딩 페이지에서 글을 보다보면 다른 페이지의 글을 공유해오기도 하고 다른 여러 IT 관련 페이지들이 추천으로 뜨는 편이다. 기본적으로 추천하는 페이지들 생활코딩 : 온갖 IT 글이 종류를 가리지 않고 올라온다. 출퇴근길 개발 읽기 : 개발에 관련된 양질의 포스팅이 올라온다. 좋은 지식 공유 Popit : Popit 사이트의 글이 올라온다. 초보 개발자 모임 우선 이 4개 페이지는 구독하고 시작하자 2. RSS좋은 개발자 블로그는 많은데, 블로그를 매번 찾아가서 신규 게시글을 읽는건 생각보다 엄청나게 힘든일이다. 그때 RSS 구독을 이용하는 것을 추천한다. 개발자들이라면 보통 블로그에 RSS 설정을 해둔 곳이 많다. (이 블로그도 되어있다..)Chrome Extension이나 Feedly 등의 App을 이용하면 이런 개발자들의 블로그들을 구독할 수 있다. 관심 있는 분야의 블로그를 구독해두고 짬짬히 글을 읽는 것을 추천한다.하지만 RSS 구독은 push가 오지 않기 때문에 버릇을 들이지 않으면 자주 안읽게 된다는 단점이 있다. 그래서 가급적이면 하루 1번은 들어가려고 노력 중이다.. 이런식으로 블로그글을 한번에 모아서 볼 수 있다.또한 인기 있는 글도 모아서 보여준다. 그 밖에도 좋은 개발 블로그들을 모아둔 awesome-blogs도 RSS 서비스를 제공하니 구독하는 것을 추천한다. 3. Slack관심 있는 IT 커뮤니티의 Slack에 참여하는 것도 정보를 얻는 좋은 방법이다.DjangoGirls나 9XD, 백준 알고리즘과 같이 관심 있는 IT 커뮤니티의 Slack에 가입해보자. 4. 메일링 서비스개인적으로 IT 정보를 얻을 때 메일링 서비스를 애용하는 편이 아니라 구독하는 경로는 잘모르지만 RSS보다 메일링 서비스를 선호하는 경우도 많다.Daily DevBlog에서 개발자 블로그를 메일링 해주며, 매일 프로그래밍은 매일 아침 알고리즘 문제를 보내준다. 그밖에 NewNeek은 간단한 시사이슈를 정리해 메일링해준다. 5. 기타 IT 커뮤니티가장 대중적으로 유명한 커뮤니티는 okky이다. 위의 모든 것들을 읽고 나면 커뮤니티까지 가기는 어려워서 자주 가진 않지만 좋은 글들이 많다. 6. 동료 개발자들가장 중요한 것은 열정적인 동료 개발자들(🐏🐑)이 주변에 있는 것이라 생각한다.1번부터 5번까지 현실적으로 모든 정보를 혼자서 다 얻기는 어려운 일이다.주변에 함께 개발을 하는 친구들과 개발에 대한 얘기를 나누다보면 서로의 관심사에 대해 알게되고,서로의 관심사에 대해 알게되면 관련된 IT 정보를 얻게 되었을 때 서로가 서로에게 알려주며 도움도 되고 자극 받으며 성장할 수 있는 것 같다. 개발을 할수록, 개발자의 문화에 익숙해질수록 개발자끼리의 커뮤니케이션이 굉장히 중요하다는 생각이 든다.다른 직업들도 그렇겠지만 개발자야말로 외골수가 아닌 커뮤니케이터가 필요하다는 것을 깨닫게 된다.","categories":[{"name":"Think","slug":"think","permalink":"https://j2de.github.io/categories/think/"}],"tags":[{"name":"Think","slug":"think","permalink":"https://j2de.github.io/tags/think/"}]},{"title":"Gradle로 빌드 시 현재 git branch 사용하기","slug":"using-gradle-build-current-git-branch","date":"2019-08-31T09:38:55.000Z","updated":"2020-03-20T15:44:39.475Z","comments":true,"path":"2019-08-31-using-gradle-build-current-git-branch/","link":"","permalink":"https://j2de.github.io/2019-08-31-using-gradle-build-current-git-branch/","excerpt":"","text":"현재 대외 IT 동아리인 YAPP에서 동아리 프로젝트 아카이빙 프로젝트를 진행하고 있다.기존에는 AWS를 이용해 프로젝트를 진행하고 배포까지 했으나 동아리에서 네이버 클라우드 플랫폼(Naver Cloud Platform, 이하 NCP)을 지원 받게 되어 서버 이전 작업을 진행중이다.AWS로 프로젝트를 진행할 때에는 Travis CI를 이용해 테스트와 CI를 하고 AWS S3,AWS CodeDeploy를 이용해 AWS EC2 프리티어 인스턴스에 자동으로 배포 되도록 설정을 해두었다.NCP에서 비슷한 기능을 찾아보니 유료로 제공되고 동아리 지원금을 마음대로 쓸 수 없어서 어쩔수 없이 자동으로 배포되는 것을 포기하고 수동으로 Shell Script를 짜서 배포를 하기로 결정했다. 배포를 진행하다 문제가 된 것은 현재 프로젝트에서 배포용 코드는 deploy branch에 분리해두었는데 스크립트로 빌드(gradle build)를 실행해 배포하는 경우 master branch 기준으로 빌드가 되는 것이었다. profile을 변경해 실행 하는 경우 아래의 java -jar 명령어를 사용하거나 1java -jar -Dspring.profiles.active=$&#123;profile&#125; $&#123;jarfile&#125; Gradle의 BootRun을 이용하는 경우 아래의 설정을 이용하면 된다. 1234bootRun &#123; String activeProfile = System.properties['spring.profiles.active'] systemProperty \"spring.profiles.active\", activeProfile&#125; 지금은 profile이 아닌 git branch으로 빌드가 되어야했기 때문에 구글에 검색해보니 비슷한 사례가 나왔다.gradle-git plugin을 사용하는 경우가 있고 플러그인 없이 사용하는 방법이 있다. 1234// gradle-git plugin 사용하는 경우 task getBranchName(type: GitBranchList) &lt;&lt; &#123; print getWorkingBranch().name&#125; 123456789// plugin 없이 사용하는 경우 def gitBranch() &#123; def branch = \"\" def proc = \"git rev-parse --abbrev-ref HEAD\".execute() proc.in.eachLine &#123; line -&gt; branch = line &#125; proc.err.eachLine &#123; line -&gt; println line &#125; proc.waitFor() branch&#125; Reference https://stackoverflow.com/questions/15061277/how-can-i-get-the-current-git-branch-in-gradle http://coders-kitchen.com/2013/11/01/gradle-git-how-to-map-your-branch-to-a-deployment-profile/","categories":[{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/categories/troubleshooting/"}],"tags":[{"name":"SpringBoot","slug":"springboot","permalink":"https://j2de.github.io/tags/springboot/"},{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/tags/troubleshooting/"},{"name":"Gradle","slug":"gradle","permalink":"https://j2de.github.io/tags/gradle/"}]},{"title":"OS - 동기화(Synchronization)와 임계 영역(Critical Section)","slug":"os-synchronization-and-critical-section","date":"2019-07-17T14:46:37.000Z","updated":"2020-03-20T15:44:39.464Z","comments":true,"path":"2019-07-17-os-synchronization-and-critical-section/","link":"","permalink":"https://j2de.github.io/2019-07-17-os-synchronization-and-critical-section/","excerpt":"","text":"병렬 프로그래밍에서 임계영역 까지의 흐름을 정리해보았다. 병렬 프로그래밍(Parallel Programming) 멀티코어(Multi-Core)가 등장한 이후 여러 개의 코어를 효과적으로 사용하기 위해 등장. 하나의 프로그램이 동시에 여러 일을 수행하게 만드는 방법을 통칭하는 용어이다. 여기서는 동시 프로그래밍(Concurrent Programming) 의미의 병렬프로그램이다. 다른 의미로 고성능 컴퓨팅(High Performance Computing)의 한 분야를 지칭하기도 한다. 규모가변성(Scalability)이 뛰어난 프로그램이라면 코어의 수를 늘렸을 때 프로그램의 성능이 향상된다. 규모가변성이 보장되면서 스레드 세이프(Thread-Safe)한 코드를 작성하는 것은 매우 어려운 편이다. 고전적인 병렬 프로그램 예시들 공통된 자원을 공유하고 락(Lock)과 컨디션 변수(Condition Variable)를 통해 공유 자원의 접근을 통제하는 멀티 스레드 프로그래밍(Multi-Thread Programming). OS 프로세스 여러개에 프로세스 간 통신(Inter-Process Communication)을 통해 데이터를 처리하는 경우. 등등… 멀티 스레드 프로그래밍 공유 자원(or 메모리)를 여러 개의 스레드가 동시에 프로그래밍을 수행하며 같은 자원에 데이터를 읽고 쓰며 통신하는 것. 일반적으로 운영체제나 시스템 SW에 사용됐지만 Java의 Monitor 개념에 도입되면서 일반 개발자들도 많이 사용한다. 멀티스레드 프로그래밍은 오류 없이 설계하기 어렵고 비결정적이며 테스트가 어렵고 버그도 재현이 어려워 디버깅이 거의 불가능하다. 즉 안정성과 규모가변성이 상충되기 때문에 적절한 프로그래밍을 하는 것이 어렵다. 참고 아래부터 언급하는 Process는 해당 개념이 사용되는 영역이 어떤 것이냐에 따라 Thread로 해석할 수 있다. ex) OS(ex Linux)에서는 Process 기준, Java에서는 Thread 기준이다. 동기화(Synchronization) 레이스 컨디션 상황을 막기 위해 프로세스/스레드들에 하나의 자원에 대한 처리 권한을 주거나 순서를 조정해주는 기법이다. 다중 스레드 환경에 공유되는 자원이 있다면 필수적으로 고려해야한다. 프로세스의 경우 OS 레벨에서 공유 자원 문제를 처리해주지만 한 프로세스 내에서 실행되는 여러 개의 스레드들은 공유 자원에 대해 동기화 문제를 고려해야한다. 경쟁 상황(레이스 컨디션, Race Condition) 공유 자원에 여러 프로세스/스레드가 동시에 접근하기 위해 경쟁하는 상태를 뜻한다. ex) OS에서 CPU 점유율 등 동기화 처리를 제대로 하지 않으면 의도하지 않은 잘못된 결과가 나올 수 있다. 임계 영역(Critical Section) 공유 자원에 접근하는 프로세스 내부의 코드 영역. 한 프로세스의 임계 영역이 수행 중일 때 다른 프로세스가 같은 공유 자원을 사용하는 임계 영역을 수행한다면 문제가 발생할 수 있다. 따라서 한 번에 한 프로세스만 접근해 사용한다. 임계 영역을 들어오는 진입 영역(entry section), 나가는 부분인 퇴출 영역(exit section), 나머지 영역(remainder section)으로 구분된다. 임계 영역의 조건상호 배제(Mutual Exclusion( == Mutex)) 한 프로세스가 자신의 임계 영역 내에서 실행되는 동안, 다른 프로세스가 같은 공유 자원을 사용하는 자신의 임계 영역에서 실행될 수 없는 것. 진행 (Progress) 임계 영역을 실행 중인 프로세스가 없고 자신의 임계 영역으로 진입하려는 프로세스가 있다면, 나머지 영역에서 실행 중이지 않은 프로세스들만 임계 영역으로 진입하기 위해 요청할 수 있다. 이는 무기한 연기될 수 없다. 한정된 대기 (Bounded waiting) 프로세스가 자신의 임계 영역에 진입하기 위해 요청을 한 뒤, 그 요청이 허가될 때까지 다른 프로세스들이 자신의 임계 영역에 진입하도록 허용하는 횟수의 제한이 있어야한다. 임계 영역 해결 방안(동기화) 하드웨어 기반 동기화와 소프트웨어 기반 동기화로 나뉜다. 대표적인 소프트웨어 기반 동기화 기법으로 상호 배제(Mutex), 세마포어(Semaphore), 모니터(Monitor) 등이 있다. 참고 소프트웨어 트랜잭션 메모리와 하스켈 프로세스 동기화의 필요성, 임계 영역 멀티 스레드와 동기화","categories":[{"name":"CS","slug":"cs","permalink":"https://j2de.github.io/categories/cs/"},{"name":"OS","slug":"cs/os","permalink":"https://j2de.github.io/categories/cs/os/"}],"tags":[{"name":"OS","slug":"os","permalink":"https://j2de.github.io/tags/os/"}]},{"title":"SpringBoot-ReactJS 프로젝트에서 OAuth 소셜 로그인 구현 중 마주친 CORS 문제","slug":"springboot-react-cors","date":"2019-06-15T15:00:00.000Z","updated":"2020-03-19T00:43:22.717Z","comments":true,"path":"2019-06-16-springboot-react-cors/","link":"","permalink":"https://j2de.github.io/2019-06-16-springboot-react-cors/","excerpt":"","text":"SpringBoot 프로젝트에 OAuth2 소셜 로그인을 구현하는 프로젝트에서 발생한 문제이다. 작은 규모의 프로젝트였기 때문에 SpringBoot와 View단의 ReactJS를 따로 호스팅하지 않고 SpringBoot의 정적 리소스에 React Build 파일을 포함해 배포를 하였다. 여기서 React에서 Login API를 호출하는데 CORS 에러가 발생하였다. CORS란? Cross Origin Resource Sharing의 약자로 현재 웹페이지가 이 페이지를 받은 서버가 아닌 다른 서버의 리소스를 호출하는 것을 의미한다. 우선 OAuth 로그인 프로세스를 살펴보면 여러가지 승인 타입이 있는데 이 중 권한 부여 코드 승인 타입(Authorization Code Grant Type)을 이용해 로그인을 구현하였다. 페이스북이나 구글, 카카오 등에서 위 타입의 방식으로 웹 서버 클라이언트를 지원한다. 권한 부여 코드 승인 타입(Authorization Code Grant Type) 이미지 출처 인증 과정을 살펴보면 처음에 client가 Authorization Code Request를 한뒤 Authorization Server에서 client_id와 redirect_uri, response_type을 확인한 뒤 Resource Owner가 로그인할 수 있도록 한다. 이후 Resource Owner가 로그인을 하면 뒤의 인증과정이 더 이루어지는 것이다. 여기서 Authorization Server 즉 소셜로그인을 하려는 대상인 서버(현 프로젝트에서는 Google)에서 필요한 조건들을 확인한 뒤 Login창으로 Redirect를 해주는데 현 프로젝트에서 CORS 에러가 발생한 부분이 이 부분이었다.즉 처음 Request를 보내고 정상적으로 동작한다면 302 code를 받고 로그인 창으로 이동하고, 유저가 로그인을 하면 내부적으로 인증 과정이 동작해야하는데 302 코드가 아닌 405 코드를 반환하면서 에러가 발생했다. 302, 405 Status Code 3으로 시작하는 코드는 Redirection을 의미한다. 그 중 302는 Found로 리퀘스트된 리소스에 새로운 URI가 할당되어 있고 그 URI를 참조하라는 의미이다. 301,302,303 코드가 되돌아오면 대부분 브라우저에서는 POST를 GET으로 바꾸어 리퀘스트의 엔티티 바디를 삭제하고 리퀘스트를 자동적으로 재송신하도록 되어있다. 405 코드는 Method Not Allowed. 허용되지 않은 메소드를 호출한 것을 의미한다. Error Message1234&gt; No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.&gt; OPTIONS https://LOGIN-ENDPOINT/login&amp;response_type=code&amp;scope=email%20profile&amp;state=6Zy6nR 405Access to XMLHttpRequest at &apos;https://accounts.google.com/o/oauth2/v2/auth?client_id=CLIENT_ID_VALUE&amp;redirect_uri=http://LOGIN-ENDPOINT/login&amp;response_type=code&amp;scope=email%20profile&amp;state=6Zy6nR&apos; from origin &apos;https://REQUESTER&apos; has been blocked by CORS policy: Response to preflight request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. 처음에 뜬 에러는 이 메세지가 아닐수도 있다. 어느 쪽 코드가 잘못된 것인지 많은 경우의 수가 있어서 Front 코드 하나 Server 코드 하나하나 수정해가면서 서버에 배포해서 확인하느라 하나하나 기록하지는 못했다. 우선 트러블슈팅 후반부(?)에 계속 참고한 에러 메세지는 이것이었다.(이외에도 request시 origin이 null이 된다는 등 다양한 에러가 계속 발생했었다.) Troubleshooting우선 서버에 문제가 있나 확인하기 위해서 curl 명령어로 확인을 해보았다 1234567curl \\ --verbose \\ --request GET \\ &apos;https://LOGIN-ENDPOINT/login&apos; \\ --header &apos;Origin: http://REQUESTER&apos; \\ --header &apos;Access-Control-Request-Headers: Origin, Accept, Content-Type&apos; \\ --header &apos;Access-Control-Request-Method: GET&apos; curl에서는 정상적으로 302 코드를 반환하였다. 즉 서버의 문제가 아닌 React와 합쳐서 배포하는 과정에서 생긴 이슈인 것을 알았다. CORS 동작과정 (참고링크) 브라우저는 다른 도메인으로 Ajax 등의 호출을 보내기 전에 다음과 같은 순서로 동작합니다. “preflight” 확인 요청을 OPTIONS method로 전송(요청 시 Http Header의 속성으로 “Origin”에 자신의 도메인을 전송) 이 요청을 받은 서버는 정상적인 요청인지 확인하여, 정상적인 요청이면 Response에 허용 가능한 도메인(Access-Control-Allow-Origin), Method(Access-Control-Allow-Methods), Header 속성(Access-Control-Allow-Headers) 등을 설정하여 응답 OPTIONS 요청에 대해 수신을 받은 브라우저는 Header의 “Access-Control-Allow-*” 정보를 이용하여 요청을 보낼 수 있는지 판단하여 권한이 없는 경우 위와 같은 에러 처리를 하고 요청을 보낼 수 있으면 요청 전송 위 에러 메세지를 기반으로 여러가지를 찾아봤는데 초기에는 Front 쪽에서 API를 호출할 때 Header에 CORS 허용을 하지 않아서(Access-Control-Allow-Origin 설정) 많은 시간을 허비했다. 하지만 이 이후에도 CORS 에러가 해결되지 않았다. 그리고 위 링크에서 Spring을 사용하는 경우 @CrossOrigin 어노테이션으로 쉽게 해결할 수 있다 했지만 OAuth Social Login Endpoint의 경우 컨트롤러를 직접 만드는 것이 아니기 때문에 위 문제로 해결할 수 없었다.(login / logout endpoint외에는 전부 Controller로 작성했기 때문에 CORS 관련 Config 설정을 하기 전에 임시로 @CrossOrigin 어노테이션을 붙여뒀다. 이 어노테이션을 붙이는 경우 Front에서 Access-Control-Allow-Origin 설정을 하지 않아도 API 호출에 CORS 에러가 발생하지 않는다. 이 부분 때문에 좀 더 헷갈렸던 것도 있다.) 405를 반환한다는 것은 허용되지 않은 메소드를 호출했다는 것인데 그래서 이후에는 preflight 확인 요청을 OPTIONS method로 보내는 과정에 문제가 있는지 찾아보았다. 이 링크를 참고해서 Spring Security Config에 PreFlightRequest를 허용해주었지만 이 코드도 동작하지 않았다. 혹시나해서 Front쪽에서 axios가 아닌 XMLHttpRequest를 직접 사용해봤지만 새로운 에러만 발생했다. 찾아본 바로는 오히려 OAuth 기반 서비스는 XHR이나 Fetch API를 사용하면 안된다고 한다. Spring Security Config에 OPTIONS를 전부 허용하고(permitAll), CORS Filter를 인증 필터 제일 앞단에 위치하도록 코드도 작성했지만 이 문제도 실패했다. 이쯤 되니 혹시 배포 서버에 설정한 Reverse Proxy Server의 Nginx 설정이 문제일까 의심이 들어서 설정을 몇개 수정해보았지만 감이 잡히지 않았다. (Avoid cors with nginx proxy pass 참고) (Nginx 설정은 지정한 도메인으로 http나 https 요청이 들어오면 https를 가리키도록 하는 것이 다였다.) 아무리 생각해도 코드 레벨에서 서버에서 할 수 있는 모든 설정을 다 한 것 같았다. 처음 get으로 login uri를 호출할 때는 Server 기준에서 호출하는데 이후 302 코드를 받고 자동으로 다시 리다이렉트 uri를 호출하는 과정에 Front 기준으로 호출해서 이런 에러가 발생한 것 같았다. 이후 찾아본 StackOverFlow 링크에서 힌트를 얻었다. 3xx의 상태코드를 받으면 브라우저가 자동으로 클라이언트를 대신해 반환된 위치로 get 요청을 보내는데 이를 Front에서 캐치해서 수동으로 redirection을 하라는 답변이었다.여기에 힌트를 얻어서 Front에서 window.locaion으로 새창을 띄워 login api를 호출하니 자동으로 redirect되며 문제가 해결되었다. 새로 띄운 창에서는 Front 코드의 영향을 받지 않아서 Server의 설정대로 잘 동작을 한 것 같다. 마치며이번 프로젝트로 CORS의 동작방식과 OPTIONS 메소드와 preflight에 대해 많이 알게되었다. 지금 해결한 방식이 완벽한 해결방식은 아니고 우회한 방법에 가깝다고 생각하지만 현재로써는 이 이상 해결하긴 어려울 것 같다. (2019.9 - CORS로 시작했지만 결과적으로 인증의 문제였던 것 같다.) 그리고 아예 MSA로 분리하면 분리했지 애매하게 붙여서 배포하는 것이 에러가 발생했을 때 더 확인하기 어렵다는 것을 알았다. Front와 Server를 분리해서 개발하면서 배포는 함께 하니까 이렇게 배포했을 때 어느 부분에서 에러가 발생했는지 조차 모르는 경우 에러를 추적하기가 어려웠다. 팀원과 함께 오류를 찾으며 느낀 것은 내가 개발한/맡은 부분이 잘못되었을 수 있다는 생각을 갖는게 중요하다는 점이었다. 만약 나 또는 상대 개발자가 서로 자신의 코드가 잘못되었을 수 있다는 가정을 하지 않았다면 이 문제를 해결하는데 더 오래걸렸을 것 같다. 이전 프로젝트에서도 자신의 코드가 무조건 옳다고 주장해서 팀원의 코드를 전부 뜯어보느라 해결하는데 오래 걸린 경우가 있었다.알고있는 분야가 서로 다르므로 서로 열린 마음으로 자신이 아는 부분, 고민하는 부분을 함께 교류하고 소통해야한다고 생각한다. 그리고 그렇게해서 이 문제를 해결할 수 있었던 것 같다. 개발자로써 좀 더 상대방과 소통할 수 있는 개발자가 되어야겠다는 생각이 든다. 참고한 링크들 https://www.popit.kr/corss-domain-api-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%84%B1/ https://oddpoet.net/blog/2017/04/27/cors-with-spring-security/ https://www.popit.kr/cors-preflight-인증-처리-관련-삽질/ https://homoefficio.github.io/2015/07/21/Cross-Origin-Resource-Sharing/ https://medium.com/@muiruri/spring-oauth2-and-cors-configuration-3529337525b4 http://oskarhane.com/avoid-cors-with-nginx-proxy_pass/ https://stackoverflow.com/questions/45602875/trying-to-redirect-client-to-google-oauth-getting-405-error","categories":[{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/categories/troubleshooting/"}],"tags":[{"name":"SpringBoot","slug":"springboot","permalink":"https://j2de.github.io/tags/springboot/"},{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/tags/troubleshooting/"},{"name":"OAuth2","slug":"oauth2","permalink":"https://j2de.github.io/tags/oauth2/"},{"name":"ReactJS","slug":"reactjs","permalink":"https://j2de.github.io/tags/reactjs/"}]},{"title":"IntelliJ에서 SpringBoot DevTools 사용하기","slug":"intellij-devtools","date":"2019-06-10T15:00:00.000Z","updated":"2020-03-19T00:43:22.692Z","comments":true,"path":"2019-06-11-intellij-devtools/","link":"","permalink":"https://j2de.github.io/2019-06-11-intellij-devtools/","excerpt":"","text":"SpringBoot의 경우 정적 리소스(html,css,js 등)들을 resource 폴더 하위에서 관리하기 때문에 정적 리소스를 갱신하기 위해 Tomcat을 재시작해야한다. DevTools 를 사용하면 자동으로 정적 리소스를 reload 할 수 있게 된다. 하지만 IntelliJ에서 사용시 DevTools을 추가해도 적용이 안되는 경우가 있다. intellij devtools not working 이 때 IntelliJ에서 추가적인 설정을 해주어야 한다. IntelliJ에서 DevTool 사용하기 cmd + shift + a : registry 검색","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Spring","slug":"server/spring","permalink":"https://j2de.github.io/categories/server/spring/"}],"tags":[{"name":"SpringBoot","slug":"springboot","permalink":"https://j2de.github.io/tags/springboot/"},{"name":"IntelliJ","slug":"intellij","permalink":"https://j2de.github.io/tags/intellij/"}]},{"title":"Java - Use overloading judiciously","slug":"java-use-overloading-judiciously","date":"2019-04-17T15:00:00.000Z","updated":"2020-03-19T01:05:56.007Z","comments":true,"path":"2019-04-18-java-use-overloading-judiciously/","link":"","permalink":"https://j2de.github.io/2019-04-18-java-use-overloading-judiciously/","excerpt":"","text":"Effective Java Item 52 다중정의(Overloading)는 신중히 사용하라 Overriding VS Overloading Overriding한 메소드는 동적으로 선택되고, Overloading한 메소드는 정적으로 선택된다. 따라서 Overloading의 경우 해당 객체의 타입이 어떤 메소드를 호출할지 기준이 된다. Overriding 예123456789101112131415161718Class Wine &#123; String name() &#123;return \"포도주\";&#125;&#125;Class SparklingWine extends Wine &#123; @Override String name() &#123;return \"발포성 포도주\"&#125;; // Overriding&#125;Class Champagne extends SparklingWine &#123; @Override String name() &#123;return \"샴페인\"&#125;; // Overriding&#125;public Class Overriding &#123; public static void main(String[] args) &#123; List&lt;Wine&gt; wineList = List.of( new Wine(), new SparklingWine(), new Champagne()); for(Wine wine : wineList) System.out.println(wine.name()); // Overriding한 메소드 호출 &#125;&#125; 출처 기대한 대로 “포도주, “발포성 포도주”, “샴페인”순으로 출력된다. 가장 하위에 정의한 재정의 메소드가 실행되기 때문 Overloading 예12345678910111213141516171819202122public class CollectionClassifier &#123; public static String classify(Set&lt;?&gt; s)&#123; // Overloading return \"집합\"; &#125; public static String classify(List&lt;?&gt; list)&#123; // Overloading return \"리스트\"; &#125; public static String classify(Collection&lt;?&gt; c)&#123; // Overloading return \"그 외\" &#125; public static void main(String[] args)&#123; Collection&lt;?&gt;[] collections = &#123; new HashSet&lt;String&gt;(), new ArrayList&lt;BigInteger&gt;(), new HashMap&lt;String, String&gt;().values() &#125;; for(Collection&lt;?&gt; c : collections) System.out.println(classify(c)); // Overloading한 메소드 호출 &#125;&#125; 출처 예상과는 다르게 “그 외”를 3회 출력한다. Overloading은 컴파일 타임에 타입이 결정되기 때문이다. 해당 코드에서는 컴파일 타임에 항상 Collection&lt;?&gt; 타입으로 받아 Overloading에 영향을 주지 못했다. 다중정의(Overloading)시 주의할 점 일반적으로 프로그래머가 기대하는 코드와 다른 결과를 보여주는 헷갈릴 수 있는 코드는 작성하지 않는 것이 좋다. 특히 공개 API의 경우 사용자가 매개변수를 넘길때 어떤 다중정의된 메소드가 동작할지 예측되지 않는다면 더 좋지 않다. 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아선 안된다. 그나마 안전하게 다중정의(Overloading) 하려면 매개변수 수가 같은 다중정의를 가급적 피한다. 가변인수를 사용하는 메소드는 절대 다중정의하지 않는다. 아이템 53 다중정의 대신 메소드 이름을 다르게 지어준다. ex) ObjectOutputStream Class의 write 메소드 들 &gt; writeBoolean(boolean), writeInt(int), … 1~3을 지키기 어려운 생성자의 경우 매개변수를 형변환해 정확한 메소드가 선택되도록 한다. 매개변수 수가 같은 다중정의 메소드가 많은 경우 그 매개변수 중 하나 이상이 “근본적으로 다르다(radically different)”면 괜찮다. “근본적으로 다르다”는 “두 타입이 (null 제외) 서로 어느 쪽으로도 형변환할 수 없다는 뜻” 5가 되지 않는다면 같은 객체를 입력받는 다중 메소드가 모두 같은 동작을 하도록한다. ex) 기존 클래스를 수정해 새로운 Interface를 implements 하는 경우 기존에 있던 String 클래스에 CharSequence 인터페이스 등장 후 기존에 있던 contentEquals(StringBuffer) 메소드가 contentEquals(CharSequence)로 다중 정의 되었지만 같은 동작을 하기 때문에 사용자 입장에서 문제가 없다. 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받지 않는다. 생성자 다중정의(Overloading) 생성자는 이름을 다르게 지을 수 없기 때문에 위의 1~3 규칙을 적용하기 어렵다. 이때는 정적 팩터리를 사용한다. 그래도 생성자는 재정의가 안되기 때문에 다중정의와 혼용될 가능성은 적다. 5의 규칙을 따라서 다중정의 한다면 다중정의 메소드 중 어떤 메소드를 선택해 호출할 지 매개변수의 런타임 타입으로 결정된다. 함수형 인터페이스의 다중정의 “암시적 타입 람다식이나 부정확한 메소드 참조 같은 표현식은 목표 타입이 선택되기 전까지 의미가 정해지지 않기 때문에 적용성 테스트 때 무시된다.” 고 책에서 말한다. 부정확한 메소드 참조 타입이란 메소드와 인자 모두 다중 정의된 경우를 뜻한다. 말이 어려운데, 간단히 말하자면 정확한 타입이 정해지기 전까지는 의도한대로 동작하지 않는다는 말이다. 따라서 함수형 인터페이스는 서로 다른 타입이어도 결과적으로 Overloading 때 같은 타입으로 인식한다. 결론 다중정의된 메소드 중 하나를 선택하는 규칙은 복잡하기 때문에 프로그래머가 모두 알고 프로그래밍하기는 어렵다. 따라서 매개변수가 같을 때는 가급적 다중정의를 피하거나 그것이 안된다면 안전하게 다중정의하는 규칙을 따라 만드는 것이 좋다. Reference Effective Java (3rd Edition) JVM 구조와 자바 런타임 메모리 구조","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Design method signatures carefully","slug":"java-design-method-signatures-carefully","date":"2019-04-16T15:00:00.000Z","updated":"2020-03-19T01:05:50.260Z","comments":true,"path":"2019-04-17-java-design-method-signatures-carefully/","link":"","permalink":"https://j2de.github.io/2019-04-17-java-design-method-signatures-carefully/","excerpt":"","text":"Effective Java Item 51 메서드 시그니처를 신중히 설계하라 API 설계 요령1. 메서드 이름을 신중히 표준 명명 규칙을 따른다 E.J의 아이템 68 참고 2. 지나친 편의 메서드 남발 금물 아주 자주 쓰일 때만 별도의 편의 메서드로 작성한다. 이 부분에 관점에 따라 상충되는 듯하다. 예를 들면 박재성(자바지기)님의 경우 Test를 위해 가급적 메소드를 잘게 쪼개는 것을 추천한다. 즉 한번에 한가지 기능만 갖고 있는 원자성을 띄는 메소드를 작성하는걸 추천한다. 이 책의 저자는 메소드가 너무 많은 경우 클래스를 익히고 사용하는게 어렵기 때문에 추천하지 않는다고 한다. 알아서 걸러듣자.. 3. 매개변수 목록은 가능한 짧게 4개 이하가 좋다고 한다. 특히 같은 타입의 매개변수가 여러개 나오는 경우가 좋지 않은 경우다. 왜냐하면 실수로 순서를 바꿔 입력해도 컴파일러가 눈치채지 못하기 때문. 4. 매개변수 타입은 클래스보단 인터페이스로 아이템 64 클래스를 인자로 받는다면 매개변수를 특정 구현체로 한정하기 때문에 좋지 않다. 5. Boolean 보다 원소 2개인 Enum 타입으로 의미상 Boolean이 더 나은경우가 아니라면 열거체를 사용하는게 좋다. 왜냐하면 코드상 의미가 더 명확하기 때문 또한 개별 열거타입별 의존성을 추가해주기도 좋다. (열거타입 내부 메소드로) 긴 매개변수를 짧게 줄이는 기술들1. 여러 메서드로 쪼갠다. API 설계 요령 2번과 상충되는 것 같지만, API를 공통점이 없는 기능으로 잘 분리한다면 결과적으로 매개변수의 길이가 줄어들 수 있다. 잘게 쪼개둘수록 여러가지로 조합할 수 있기 때문 2. 도우미 클래스를 만든다. 매개변수 여러개를 묶는 도우미 클래스를 만든다. 매개변수 몇 개를 독립된 하나의 단위로 볼 수 있는 경우 ex) 카드게임에서 카드를 의미하는 부분 3. 메서드에 빌더(Builder)패턴을 응용한다. 매개변수가 많은데, 그 중 일부는 생략해도 되는 경우 도움이 된다. Reference Effective Java (3rd Edition)","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Make defensive copies when needed","slug":"java-make-defensive-copies-when-needed","date":"2019-04-09T15:00:00.000Z","updated":"2020-03-19T01:05:44.230Z","comments":true,"path":"2019-04-10-java-make-defensive-copies-when-needed/","link":"","permalink":"https://j2de.github.io/2019-04-10-java-make-defensive-copies-when-needed/","excerpt":"","text":"Effective Java Item 50 적시에 방어적 복사본을 만들라 자바는 비교적 안전한 언어이지만, 불변식이 깨질 수 있다는 가정하에 최대한 방어적으로 프로그래밍해야한다. 어떤 객체든 허락없이 외부에서 내부를 수정하는 일은 불가해야한다. 가변 타입으로 작성된 코드도 불변식을 깨지지 않게 하기 위해 필요하다. 자기 자신 외에는 가변 필드에 접근할 수 없도록해야 완벽한 캡슐화이다. 가변 매개변수를 받는 경우 책의 Period 객체를 보면 불변 같아 보이지만 생성자로 받는 Date가 가변이기 때문에 불변식이 깨진다. 불변식을 유지하기 위해 간단하게는 대신할 수 있는 불변 아이템을 사용하거나 가변 매개변수를 각각 방어적으로 복사해야한다. 방어적 복사(defensive copy)12345678910public Period(Date start, Date end) &#123; // 생성자에서 방어적 복사 수행 // 가변 인자를 받아서 새 객체를 생성해 복사한다. this.start = new Date(start.getTime()); this.end = new Date(end.getTime()); // 방어적 복사를 진행한 뒤 유효성을 검사한다. if(this.start.compareTo(this.end) &gt; 0) throw new IllegalArgumentException(this.start + \" after \" + this.end);&#125; 반드시 매개변수 유효성 검사를 하기 전에 방어적 복사를 해야한다. TOCTOU(time-of-check/time-of-use) 공격. 즉, 유효성 검사 후 복사를 실행하는 사이에 원본 객체가 수정될 위험이 있기 때문이다. 생성자 뿐만 아니라 접근자(setter)에서도 Date 객체를 반환한다면 공격당할 수 있기 때문에 setter에서도 방어적 복사를 해주는 것이 좋다. 1234public Date start() &#123; // 접근자에서 방어적 복사 수행 return new Date(start.getTime());&#125; clone 사용 여부 매개 변수가 불변 객체가 아닐 경우 방어적 복사본을 만드는 데 clone을 사용하면 안된다. 악의 적인 하위 클래스가 clone을 정의한 경우 공격받을 수 있기 때문이다. 그 외에도 Item13의 이유로 clone 사용을 지양하는 것이 좋다. 그래서 방어적복사를 언제 해야하는데? 메서드나 생성자나 클라이언트가 제공한 객체의 참조를 내부에 저장하는 경우 객체가 변경될 가능성이 있는지 생각해야한다. 변경될 수 있는 객체라면 변경된 후 클래스가 문제 없이 동작할지 고려해본다. 이 때 확신할 수 없다면 복사본을 만들어 저장해라 반대로 내부 객체를 외부에 전달할 때 안심할 수 없다면 방어적 복사를 해야한다. 내부에서 사용하는 배열을 외부에 반환할 때는 항상 방어적 복사를 해라.(Item15 참고) 방어적 복사를 생략하는 경우 해당 클래스와 클라이언트가 상호 신뢰할 수 있을 때 통제권을 이전하기 위한 메서드나 생성자의 경우 호출 후 더이상 객체를 직접 수정하지 않는다고 문서에 명시한다. 불변식이 깨져도 그 영향이 호출한 클라이언트에만 그칠때 ex) Wrapper Class Reference Effective Java (3rd Edition)","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Prefer side-effect-free functions in streams","slug":"java-prefer-side-effect-free-functions-in-streams","date":"2019-03-22T15:00:00.000Z","updated":"2020-03-19T01:05:37.526Z","comments":true,"path":"2019-03-23-java-prefer-side-effect-free-functions-in-streams/","link":"","permalink":"https://j2de.github.io/2019-03-23-java-prefer-side-effect-free-functions-in-streams/","excerpt":"","text":"Effective Java Item 46 스트림에서는 부작용 없는 함수를 사용하라. 스트림 패러다임 스트림은 함수형 프로그래밍 패러다임이다. 스트림을 통해 표현력, 속도, 병렬성을 얻을 수 있다. 계산을 일련의 변환으로 재구성한다. 각 변환 단계를 가능한 이전 단계의 결과를 받아 처리하는 순수 함수여야한다. 순수 함수란 오직 입력만이 결과에 영향을 주는 함수이다. 가변 상태를 참조하지 않고 함수 스스로도 다른 상태를 변경하지 않는다. 즉 스트림 연산에 사용되는 함수 객체는 모두 side effect가 없어야한다. 스트림의 for each는 스트림 계산 결과를 보여주는 용도로만 사용하는 것이 좋다. 스트림의 수집기(Collector) java.util.stream.Collectors 수집기가 생성하는 객체는 일반적으로 컬렉션이다. Collector를 통해 스트림의 원소들을 쉽게 원소 하나(컬렉션)로 모을 수 있다. 수집기는 toList(), toSet(), toCollection(collectionFactory)로 리스트, 집합, 프로그래머가 지정한 컬렉션 타입을 반환한다. 123456Map&lt;String, Long&gt; freq;...List&lt;String&gt; topTen = freq.keySet().stream() // (1) .sorted(comparing(freq::get).reversed()) // (2) .limit(10) .collect(toList()); Map에서 key를 뽑아내 stream으로 만든다. sorted에 비교자 생성 메서드인 comparing으로 비교 기준을 넘긴다. 단어 10개까지 뽑아서 List로 변경해 반환한다. 나머지 메소드들은 대부분 스트림을 맵으로 취합하는 기능을 가진다. 스트림의 각 원소는 키 하나와 값 하나에 연관되어있지만 다수의 스트림 원소가 같은 키에 연관될 수 있다. 맵 수집기(Map Collector) 가장 간단한 맵 수집기는 toMap(keyMapper, valueMapper) 인자 2개를 받는 메소드이다. 스트림 원소를 키에 맵핑하는 함수와 값에 맵핑하는 함수를 인수로 받는다. 이 경우는 스트림의 각 원소가 고유한 키에 매핑되어 있을 때 적절하다. 더 복잡한 형태는 toMap(keyMapper, valueMapper, mergeMethod) 3가지를 인자로 받는 메소드로 처리한다. 병합 함수는 BinaryOperator&lt;T&gt;로 같은 &lt;T&gt; 형태의 두개의 파라미터를 받아서 람다식대로 계산하고 계산 후 결과 값도 &lt;T&gt; 형태로 반환한다. 123Map&lt;Artist, Album&gt; topHits = albums.collect( toMap(Album::artist, a-&gt;a, maxBy(comparing(Album::sales)));) 책에서는 병합 함수로 BinaryOperator에서 정적 임포트한 maxBy라는 정적 팩터리 메소드를 사용한다. maxBy는 Comparator&lt;T&gt;를 입력 받아 BinaryOperator&lt;T&gt;를 반환한다. comparing이 비교자 생성 메서드로 키 추출 함수로 Album::sales를 넘겨 비교자를 반환한다. 가장 복잡한 경우는 toMap(keyMapper,valueMapper, mergeMethod, MapFactory) 네가지 인자를 받는다. 네번째 인수로 받는 맵 팩터리는 특정 맵 구현체(TreeMap 등)를 직접 지정할 수 있다. groupingBy 인수로 분류 함수를 받고 입력받은 원소가 속한 카테고리를 반환한다. 그리고 이 카테고리가 맵의 키로 쓰인다. 가장 간단한 형태는 분류 함수 하나를 인수로 받아 맵을 생성하는 것이다. groupingBy(classifier) 이때 반환된 맵에는 각 값마다 해당 카테고리에 속한 원소들을 담은 리스트가 있다. Map&lt;CategoryType, List&lt;DataType&gt;&gt; 1words.collect(groupingBy(word -&gt; alp)) 반환되는 수집기가 리스트외에 특정 형태로 지정하고 싶다면(위의 반환형이 List가 아닌 다른 자료 형태이길 원한다면) 다운스트림(downstream) 수집기도 표기해야한다. groupingBy(classifier, downstream) toSet()을 사용하면 Set으로 toCollection(collectionFactory)을 사용하면 원하는 컬렉션 타입을 선택할 수 있다. counting()을 사용하는 경우 해당 카테고리에 속한 원소의 값과 매핑한 맵을 얻는다. 12Map&lt;String, Long&gt; freq = words .collect(groupingBy(String::toLowerCase, counting())); counting 메소드를 사용해 개수를 반환하기 때문에 Long으로 반환된다. joining CharSequence 인스턴스 스트림에만 적용이 가능한 메소드이다. 매개 변수 없는 joining()은 원소들을 연결(concatenate)하는 역할을 한다. 매개 변수 하나인 joining(delimiter)은 구분자를 받아 연결 부위에 구분자를 삽입한다. 매개변수 3개인 joining은 구분자와 접두문자(prefix)와 접미문자(suffix)도 지정할 수 있다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Prefer method references to lambdas","slug":"java-prefer-method-references-to-lambdas","date":"2019-02-20T15:00:00.000Z","updated":"2020-03-19T01:05:27.326Z","comments":true,"path":"2019-02-21-java-prefer-method-references-to-lambdas/","link":"","permalink":"https://j2de.github.io/2019-02-21-java-prefer-method-references-to-lambdas/","excerpt":"","text":"Effective Java Item 43 람다보다는 메소드 참조를 사용하라 lambda VS method reference 함수 객체를 람다보다 간결하게 표현할 수 있는 것이 method reference(메소드 참조)이다. 이 중 람다의 코드가 의미 없이 길다면 또는 이미 구현된 라이브러리로 메소드 참조를 할 수 있다면, 메소드 참조를 사용하는 것이 낫다. 그리고 메소드 참조를 사용하는 경우 매개변수를 제거하므로, 람다의 매개변수 이름이 있어야 코드의 의미가 명확해진다면 람다를 사용하는 것이 낫다. 12map.merge(key, 1, (count, incr) -&gt; count+incr); // lambdamap.merge(key, 1, Integer::sum); // method reference 항상 메소드 참조가 람다보다 간결한 것은 아니다. 메소드 참조의 경우 Class나 Obejct 이름을 항상 써야하기 때문에 같은 클래스에 있는 메소드를 사용한다면 람다 표현을 사용하는 것이 더 간결하다. 12service.execute(GoshThisClassNameIsHumongous::action); // method referenceservice.execute(()-&gt;action()); // lambda method reference의 사용 메소드 참조를 사용하는 경우 (1) 기존에 구현된 라이브러리를 사용하거나(ex-위의 Integer::sum은 Integer 클래스의 static sum 메소드를 사용한 것) lambda 표현이 길어지는 경우(보통 3줄을 넘어가지 않는 것이 좋다) (2) 따로 메소드를 작성해 람다 대신 메소드 참조를 사용한다. method reference의 유형 정적 메소드 참조 Class::staticMethod 형식으로 사용한다. ex) Integer::parseInt는 str-&gt;Integer.parseInt(str)과 같다 한정적 인스턴스 메소드 참조 object::instanceMethod (1)의 정적 메소드 참조와 비슷하다. 즉, 함수 객체가 받는 인수와 참조 되는 메소드가 받는 인수가 같다. ex) Instant.now()::isAfter은 Instant then = Instant.now(); \\n t-&gt;then.isAfter(t)와 같다. 비한정적 인스턴스 메소드 참조 수신 객체를 한정하지 않는 다는 의미해서 비한정적 메소드 참조이다. 따라서 함수 객체가 받는 인수와 참조되는 메소드가 받는 인수가 다르다. 그래서 함수 객체를 적용하는 시점에 수신 객체를 알려준다. ex) String::toLowerCase은 str-&gt;str.toLowerCase()와 같다. 클래스 생성자 메소드 참조 생성자 레퍼런스와 메소드 레퍼런스는 거의 흡사하다. 생성자 종류가 많을 경우 문맥으로 파악한다. 배열 생성자 메소드 참조 결과적으로 method reference를 사용하면 메소드의 모든 매개변수가 사라진다. 그러므로 lambda를 사용할 때와 같이 사용하려는 자바 라이브러리에 대한 정확한 이해가 필요하다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Use instance fields instead of ordinals","slug":"java-use-instance-fields-instead-of-ordinals","date":"2019-02-19T15:00:00.000Z","updated":"2020-03-19T01:05:22.629Z","comments":true,"path":"2019-02-20-java-use-instance-fields-instead-of-ordinals/","link":"","permalink":"https://j2de.github.io/2019-02-20-java-use-instance-fields-instead-of-ordinals/","excerpt":"","text":"Effective Java Item 35 ordinal 메서드 대신 인스턴스 필드를 사용하라 ordinal method enum 타입에 제공되는 메소드로 열거 타입에서 몇번째 위치인지를 반환한다. enum 타입과 연결된 정수가 필요할 때 이 메소드를 사용한다면 코드도 직관적이지 않고 쓰이지 않는 값도 많아질 것이다. ordinal 대신 인스턴스 필드에 저장 따라서 ordinal 대신 열거 타입 상수에 연결된 값은 인스턴스 필드에 저장하는 것이 좋다. 1234567891011public enum Ensemble &#123; SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5); private final int numberOfMusicians; Ensemble(int size) &#123; this.numverOfMusicials = size; &#125; // 생성자에서 인스턴스 필드에 초기화 한다. public int numberOfMusicians() &#123; return numberOfMusicians;&#125; // 메소드에서 인스턴스 필드에 저장된 값은 반환한다. // ordinal 메소드를 사용하지 않는다. &#125;","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Use bounded wildcards to increase API flexibility","slug":"java-use-bounded-wildcards-to-increase-api-flexibility","date":"2019-01-30T15:00:00.000Z","updated":"2020-03-19T01:05:10.839Z","comments":true,"path":"2019-01-31-java-use-bounded-wildcards-to-increase-api-flexibility/","link":"","permalink":"https://j2de.github.io/2019-01-31-java-use-bounded-wildcards-to-increase-api-flexibility/","excerpt":"","text":"Effective Java Item 31 한정적 와일드카드를 사용해 API 유연성을 높여라 한정적 와일드 카드가 필요한 이유는 제네릭의 매개변수화 타입(List&lt;String&gt;, List&lt;Integer&gt; 등)이 불공변이기 때문이다. 불공변이라는 얘기는 서로 상위 타입도 하위 타입도 아닌 각자 다른 타입이라는 의미이다. 따라서 책의 예시와 같이 Stact&lt;E&gt;에 Stact&lt;Number&gt;를 선언후 Integer 타입을 넣으면 incompatible types라는 에러가 발생한다. 보다 제네릭을 유연하게 사용하기 위해 한정적 와일드카드가 필요하다. &lt;? extends T&gt; T의 하위 타입을 허용한다는 의미이다. push 메소드와 같이 원소를 생산하는 메소드의 매개변수에 사용한다. ex) 위처럼 Number로 생성 후 Integer로 받는게 가능해진다. &lt;? super T&gt; T의 상위 타입을 허용한다는 의미이다. pop 메소드와 같이 원소를 소비하는 메소드의 매개변수에 사용한다. ex) Stack&lt;Number&gt; 원소를 Collection&lt;Object&gt;로 꺼내고 싶은 경우 한정적 와일드카드 사용 규칙 입력 매개변수가 생산자나 소비자의 역할만 한다면 입력 매개변수에 와일드카드 타입을 사용해 유연성을 높이는 것이 좋다. 입력 매개변수가 생산자와 소비자 역할을 동시에 한다면 정확한 타입을 지정하는 것이 좋다. PECS : producer-extends, consumer-super 생산자라면 &lt;? extends T&gt;, 소비자라면 &lt;? super T&gt;를 사용 메소드의 반환 타입은 한정적 와일드 카드 타입을 사용하면 안된다. 클라이언트 쪽에서도 와일드 카드 타입을 써야하기 때문. 사용자가 와일드 카드 타입을 신경써야한다면 그 메소드는 잘못 짜여진 메소드이다. 자바 7까지는 명시적 타입 인수를 사용해야한다. Comparator를 직접 구현하지 않은 경우의 한정적 와일드 카드1public static &lt;E extends Comparable&lt;E&gt;&gt; E max(List&lt;E&gt; list) 기존 코드를 PECS에 맞춰 변경해보면 1public static &lt;E extends Comparable&lt;? super E&gt;&gt; E max(List&lt;? extends E&gt; list) Comparable은 E 인스턴스를 소비해 natural ordering에 해당하는 정수를 생산한다. 따라서 Comparable은 소비자의 역할이므로 &lt;? super E&gt;로 인스턴스를 변경한다. 1List&lt;ScheduledFuture&lt;?&gt;&gt; scheduledFutures = ... ; 이렇게 복잡한 선언을 하는 이유는 위의 리스트와 같이 Comparable(or Comparator)를 직접 구현하지 않고 직접 구현한 다른 타입을 extends 한 경우를 지원하기 때문이다. ScheduledFuture는 직접 Comparator를 구현하지 않고 Comparator를 구현한 상위 타입을 extends 하고있다. Comparable&lt;? super E&gt;로 명시하지 않으면 ScheduledFuture 뿐 아니라 그 상위 클래스의 인스턴스와도 비교할 수 있기 때문에 에러가 발생한다. 타입 매개변수와 와일드카드 &lt;E&gt; vs &lt;?&gt;public static &lt;E&gt; void swap(List&lt;E&gt; list, int i, int j); // (1) public static void swap(List&lt;?&gt; list, int i, int j) // (2) 이 메서드를 정의할 때 &lt;E&gt;와 &lt;?&gt;는 parameter에서 같은 역할을 한다. 이 책의 필자는 public api인 경우 좀 더 깔끔한 선언을 위해 두번째 방식을 추천하고 있다. 하지만 두번째 방식의 경우 원소를 꺼낸 뒤 다시 넣을 때 에러가 날 수 있다. - List&lt;?&gt;는 null 외에 아무 값도 넣을 수 없기 때문 (parameter에서 모든 인자를 받는 역할을 함) 따라서 public api를 와일드카드(?)를 사용하고 내부적으로 값을 넣고 변경해야한다면, 와일드카드 타입의 실제 타입을 알려주는 도우미 메서드를 작성하는 것이 좋다. 도우미 메서드는 (1)의 메소드 선언과 같다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Don't use raw types","slug":"java-don't-use-raw-types","date":"2019-01-27T15:00:00.000Z","updated":"2020-03-19T01:04:56.335Z","comments":true,"path":"2019-01-28-java-don't-use-raw-types/","link":"","permalink":"https://j2de.github.io/2019-01-28-java-don't-use-raw-types/","excerpt":"","text":"Effective Java Item 26 로 타입은 사용하지 말라. 제네릭(Generic) 제네릭을 사용하는 이유는 컬렉션이 담을 수 있는 타입을 컴파일러에 알려주기 위한 것. 제네릭 지원 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야했고, 잘못된 객체를 넣은 경우 형변환 오류가 발생했다. 제네릭을 통해 컴파일러는 형변환 코드 추가 가능, 잘못된 객체 삽입 차단 등의 기능을 수행하며, 코드를 좀 더 명확하게 해준다. 용어 정리1234List&lt;T&gt; // (1)(3)T // (2)List&lt;String&gt; // (4)List // (5) (1) 제네릭 클래스 / 제네릭 인터페이스 : 클래스와 인터페이스 선언에 타입 매개 변수(type parameter)(2)가 쓰인 것. (3) 제네릭 타입(generic type) : (1)의 두가지를 합쳐서 일컫는 말 (4) 매개변수화 타입(parameterized type) : 이 제네릭 타입은 매개변수를 정의한다.고 책에 나와있는데 정확히 말하면 제네릭 타입에서 매개변수가 지정된 타입을 의미하는 것 같다. (4)는 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입. (5) 로 타입(raw type) : 제네릭 타입 정의 시 함께 정의되는 타입. 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않은 타입을 일컬음. 제네릭이 생기기 전(Java5 이전) 코드와 호환을 위해 사용됨. 제네릭 타입에 속하지 않는다. 로 타입의 문제점 잘못된 타입을 넣어도, 컴파일러 에러가 발생하지 않고 런타임 에러가 발생한다. 제네릭 타입이 아니기 때문에 제네릭의 안정성, 표현력을 사용할 수 없다. 매개변수화 타입을 지정했을 때 장점 잘못된 타입을 체크해 컴파일러에서 에러를 보여준다. 컬렉션에서 원소를 꺼내는 모든 곳에서 형변환을 추가하고, 절대 실패하지 않음을 보장한다. 로 타입을 사용하는 이유 Java5 이전 코드와의 호환성 때문 List vs List&lt;Object&gt; : 로 타입과 임의 객체 허용 오른쪽은 모든 타입을 허용한다고 컴파일러에 의사를 전달한 것. 12static void method1(List list)&#123; ... &#125;; // (1)static void method2(List&lt;Object&gt; list)&#123; ... &#125;; // (2) (1)에는 List&lt;String&gt; 매개변수를 넘길 수 있지만, (2)에는 넘길 수 없다. List&lt;String&gt;은 로타입인 List의 하위 타입이지만, List&lt;Object&gt;의 하위 타입이 아니기 때문에 불가능하다. 따라서 (2)와 달리 (1)을 사용하는 경우 타입 안정성을 잃게 된다. List vs List&lt;?&gt; : 로 타입과 비한정적 와일드 카드 타입 비한정적 와일드카드 타입(unbounded wildcard type)은 제네릭 타입을 쓰면서 실제 타입 매개변수를 지정하고 싶지 않은 경우에 사용한다. 왼쪽은 안전하지 않고 오른쪽은 안전하다. 로 타입의 경우 아무 원소를 넣을 수 있어 위험하고, 비한정적 와일드 카드 타입의 경우 null외에 어떤 원소도 넣을 수 없다. 비한정적 와일드 카드 타입 비한정적 와일드 카드 타입은 원소를 넣는 용도가 아닌 클래스나 메소드에서 어떤 제네릭 타입도 매개변수로 받기 위해 쓰이는 것 같다. 예를 들면 List&lt;String&gt;이 List&lt;Object&gt;의 하위 타입이 아니기 때문에 파라미터가 List&lt;Object&gt;일때 List&lt;String&gt;을 인자로 받는 것은 불가능하다. 이 때 비한정적 와일드 카드 타입(List&lt;?&gt;)을 쓰는 경우 가능하다. 그리고 특정 타입의 하위 타입으로만 제한하고 싶다면 한정적 와일드 카드를 사용한다. (List&lt;? extends parentClass&gt;) 로 타입을 쓰는 경우 class 리터럴에는 제네릭말고 로 타입으로 표기 ex) List&lt;String&gt;.class (X) / List.class (O) instanceof 연산자로 제네릭 타입을 비교할 때 ex) o instanceof Set&lt;String&gt; (X) / o instanceof Set (O) 둘다 가능하지만 런타임 제네릭 타입 정보를 확인할 수 없기 때문에 왼쪽의 코드는 의미없다. 클래스 리터럴 리터럴은 변수에 넣는 변하지 않는 데이터를 의미한다. ex) int i = 1; 에서 1 해당 String은 Class 클래스의 인스턴스 문자열 리터럴은 클래스 String의 인스턴스를 나타내는 표기 클래스 리터럴은 (Hashtable.class 등) 클래스 Class의 인스턴스를 나타내는 표기 참고 Java Generic Java 클래스 리터럴","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Limit source files to a single top-level class","slug":"java-limit-source-files-to-a-single-top-level-class","date":"2019-01-26T15:00:00.000Z","updated":"2020-03-19T01:04:48.623Z","comments":true,"path":"2019-01-27-java-limit-source-files-to-a-single-top-level-class/","link":"","permalink":"https://j2de.github.io/2019-01-27-java-limit-source-files-to-a-single-top-level-class/","excerpt":"","text":"Effective Java Item 25 톱 레벨 클래스는 한 파일에 하나만 담으라. 한 파일에 여러가지의 톱 레벨 클래스를 담아도 컴파일 에러가 발생하진 않는다. 하지만, 컴파일러에 따라 동작이 달라질 수 있다. 12345678910111213141516171819202122// Main.javapublic class Main &#123; public static void main(String[] args)&#123; System.out.println(A.NAME + B.NAME); &#125;&#125;// A.javaClass A &#123; static final String NAME = \"aaa\";&#125;Class B &#123; static final String NAME = \"bbb\";&#125;// B.javaClass A &#123; static final String NAME = \"ccc\";&#125;Class B &#123; static final String NAME = \"ddd\";&#125; 여기서 Main.java, B.java 순으로 컴파일 한다면 컴파일 오류를 Main.java A.java 순으로 컴파일 되면 “aaabbb” 출력을 B.java, Main.java 순으로 컴파일 되면 “cccddd”를 출력할 것이다. 차라리 오류가 발생하는 것이 운이 좋은 것이며, 상황에 따라 동작이 달라지는 것은 오류를 발견하기도 어렵다. 따라서 한 파일에 담긴 여러 개의 톱 레벨 클래스를 파일 별로 분리하거나 정 같은 파일에 담고 싶다면 정적 멤버 클래스로 선언하는 것이 좋다. 다른 클래스에 딸린 부차적인 클래스라면 정적 멤버 클래스 선언이 더 낫다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Prefer class hierarchies to tagged classes","slug":"java-prefer-class-hierarchies-to-tagged-classes","date":"2019-01-23T15:00:00.000Z","updated":"2020-03-19T01:04:40.943Z","comments":true,"path":"2019-01-24-java-prefer-class-hierarchies-to-tagged-classes/","link":"","permalink":"https://j2de.github.io/2019-01-24-java-prefer-class-hierarchies-to-tagged-classes/","excerpt":"","text":"Effective Java Item 23 태그 달린 클래스보다는 클래스 계층구조를 활용하라 태그 달린 클래스란 ? 이 책에서 말하는 태그 달린 클래스는 enum으로 타입을 결정하고, 타입별로 쓰이는 필드와 메소드가 다른데 한 클래스에 모든 코드가 있는 경우를 일컫는다. 즉, 한 클래스에서 태그(enum)에 따라 동작을 달리하는 코드를 의미한다. 태그 달린 클래스의 단점 열거타입, 태그 필드, switch문 등 필요 없는 코드가 많아 진다. 위의 이유로 메모리도 낭비하게 된다. 또한 여러 코드가 혼합되어 있어 가독성이 나쁘다. 프로그래머가 코드를 잘못 작성해도 런타임에서 에러를 확인할 수 있다. 새로운 타입을 추가하는 경우 코드를 전체적으로 수정해야한다. 태그 클래스를 클래스 계층 구조를 흉내낸 것이기 때문에 클래스 계층 구조로 변경해주는 것이 좋다. 태그 클래스를 클래스 계층 구조로 계층 구조의 루트가 될 추상 클래스를 정의한다. 태그 값에 따라 달라지는 부분을 추상 메소드로 선언한다. 그리고 태그 값과 상관 없이 동작이 일정한 메소드는 루트 클래스의 일반 메소드로 추가한다. 모든 하위 클래스에서 공통으로 사용되는 필드도 추상(루트) 클래스로 올린다. 그리고나서 루트 클래스를 extends한 구체 클래스를 의미별로 정의하면 된다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Minimize mutability","slug":"java-minimize-mutability","date":"2019-01-20T15:00:00.000Z","updated":"2020-03-19T01:04:33.128Z","comments":true,"path":"2019-01-21-java-minimize-mutability/","link":"","permalink":"https://j2de.github.io/2019-01-21-java-minimize-mutability/","excerpt":"","text":"Effective Java Item 17 변경가능성을 최소화하라. Immutable Class는 간단히 변경 불가능한 클래스를 의미한다.Immutable Class의 모든 정보는 객체의 생명 주기 동안 값이 고정되어야 한다. (자바 라이브러리의 String, BigInteger, BigDecimal 등) Five rules of immutable class Don’t provide method that modify the object’s state (known as mutators). 객체의 상체를 변경시키는 메소드(변경자)를 제공하지 않는다. Ensure that the class can’t be extended. 클래스를 확장할 수 없게 한다. Make all fields final. 모든 필드를 final로 한다. Make all fields private. 모든 필드를 private로 한다. Ensure exclusive access to any mutable components. 변경 가능한 모든 컴포넌트에 독점적으로 access하게 한다.즉, Immutable Class 자신만 접근 가능하도로 해야한다. mutable object가 있다면 클라이언트에서 참조할 수 없도록 해야한다. 접근자가 그 필드를 반환해서도 안된다. 기존에 객체 참조를 넘기던 생성자, 접근자, readObject에서는 방어적 복사를 사용해야한다. 함수형 프로그래밍 피연산자에 함수를 적용해 결과를 반환하지만, 피연산자 자체를 변경되지 않는 패턴 해당 메소드가 상태를 변경시키지 않는점을 강조하기 위해 이름을 동사(add) 대신 전치사(plus)를 사용해야한다. 불변 객체의 장점 함수형 프로그래밍을 하면 코드 내 불변 비율이 높아진다. 불변 객체가 더 단순하고 오류가 적고, 상태가 일정하다. 불변 객체는 기본적으로 thread-safe 하고 따로 동기화하지 않아도 된다. 따라서 안심하고 공유할 수 있다. 불변 객체의 단점 값이 다르면 항상 새로운 객체로 만들어야 한다. 불변 객체의 성능 문제 원하는 객체가 완성하기까지 단계가 많고, 중간 단계가 버려진다면 성능 문제가 생길 수 있다. 이에 대처하기 위해서는 불변 클래스에서 다단계 연산(multistep operation)을 예측해 기본 기능으로 제공하거나 가변 동반 클래스(companion class)를 package-private or public으로 제공한다. 2에 해당하는 것은 String과 StringBuilder가 있다. 더 유연한 방식의 불변 클래스 가장 쉬운 방법은 클래스에 final 선언 다른 방법으로는 모든 생성자를 private or package-private 하고 public 정적 팩토리 메소드를 제공하는 방법. 정리 클래스는 꼭 필요한 경우가 아니면 불변이어야 한다. 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분은 최소화하는 것이 좋다. 다른 이유가 있지 않다면 모든 필드는 private final이어야 한다. 생성자는 불변식 설정이 모두 완료된, 초기화가 완전히 끝난 상태의 객체를 생성해야 한다. 생성자와 정적 팩토리 메소드 외에 초기화 메소드를 public으로 제공하면 안됨. 객체를 재활용할 목적의 메소드도 안됨.(setter 등)","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Use interfaces only to define types","slug":"java-use-interfaces-only-to-define-types","date":"2019-01-17T15:00:00.000Z","updated":"2020-03-19T01:04:26.662Z","comments":true,"path":"2019-01-18-java-use-interfaces-only-to-define-types/","link":"","permalink":"https://j2de.github.io/2019-01-18-java-use-interfaces-only-to-define-types/","excerpt":"","text":"Effective Java Item 22 인터페이스는 타입을 정의하는 용도로만 사용하라 인터페이스를 implements 한다는 것은 해당 인터페이스의 기능을, 상속 받은 클래스에서 구현해 제공한다는 의미이다. 인터페이스는 (default method를 제외하고) 구체적인 로직이 없다. 따라서 인터페이스의 사용은 인터페이스에서 제공하는 기능을 사용할 수 있는 특정 타입을 지정하는 것과 같다. 인터페이스의 잘못된 사용은 상수 인터페이스를 사용하는 것이다. 상수 인터페이스 상수 인터페이스란 static final field만 있는 상수의 용도로 사용하는 인터페이스이다. 상수 인터페이스를 사용해 클래스의 상수를 대체한다면, 해당 인터페이스에 종속되는 결과를 낳는다. 또한 어떤 상수가 이 클래스에 사용하는지 불필요한 정보를 제공해 캡슐화를 해친다. 따라서 해당 클래스에서 필요한 상수라면 상수 인터페이스 구조보다는 클래스 내부 구현을 하는 것이 옳다. 그외에는 상수 인터페이스를 대체해 열거(enum)타입에 적합하다면 열거 타입을, 아니면 인스턴스화 할 수 없는 유틸리티 클래스로 구현하는 것이 좋다. 정적 임포트(static import) 유틸리티 클래스에 정의된 상수를 사용하려면 항상 클래스 이름까지 명시해야한다. 정적 임포트를 하면 클래스 이름을 생략할 수 있다. 1import static className;","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Design interfaces for posterity","slug":"java-design-interfaces-for-posterity","date":"2019-01-16T15:00:00.000Z","updated":"2020-03-19T01:04:19.628Z","comments":true,"path":"2019-01-17-java-design-interfaces-for-posterity/","link":"","permalink":"https://j2de.github.io/2019-01-17-java-design-interfaces-for-posterity/","excerpt":"","text":"Effective Java Item 21 인터페이스는 구현하는 쪽을 생각해 설계하라. 자바 8부터 default method가 추가되면서 기존 인터페이스에 기능을 추가하는 일이 가능해졌다. 하지만 디폴트 메소드를 추가하는 경우 기존 인터페이스 구현체와 오류 없이 연동되는 것을 기대하기 어렵다. 만약, 어쩔 수 없이 추가해야한다면 가능한 모든 상황에서 불변식을 해치지 않는 디폴트 메소드를 작성해야한다. 자바 플랫폼 라이브러리에서는 이런 문제를 예방하기 위한 조치들이 적용되었다. 예를 들면 구현한 인터페이스의 디폴트 메소드를 재정의하고, 다른 메소드에서는 디폴트 메소드를 호출하기 전에 필요한 수업을 수행하도록 하는 것이다. 자바 플랫폼에 속하지 않는 기존 컬렉션 구현체들은 위와 같이 언어 차원의 인터페이스 변화에 맞게 수정될 기회가 없었고 실제로 수정되지 않는 것도 있다. 따라서 디폴트 메소드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다. 문제는 여러가지로 발생할 수 있다. 구현된 디폴트 메소드가 불변식을 해치는 경우, 다른 하위 구현체와 연동되지 않는 경우(synchoronize를 고려하지 않았다던지), 이름이 겹치는 경우 등 기존 인터페이스에 디폴트 메소드로 새 메소드를 추가하는 일은 가급적 피해야한다. 인터페이스를 릴리즈한 후에 인터페이스를 수정하는 것이 위험하기 때문에 꼭 릴리즈 전에 테스트해야한다. 하지만 새로운 인터페이스를 만든다면 디폴트 메소드는 표준적인 메소드 구현을 제공하는 좋은 도구가 된다.(아이템 20 참고) 즉, 디폴트 메소드(default method)는 기존 인터페이스에 새로운 메소드를 추가하기 위한 기능이 아니라고 생각하는 것이 좋다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Favor composition over inheritance","slug":"java-favor-composition-over-inheritance","date":"2019-01-12T15:00:00.000Z","updated":"2020-03-19T01:04:12.668Z","comments":true,"path":"2019-01-13-java-favor-composition-over-inheritance/","link":"","permalink":"https://j2de.github.io/2019-01-13-java-favor-composition-over-inheritance/","excerpt":"","text":"Effective Java Item 18 상속보다는 컴포지션을 사용하라 상속(extends)을 목적으로 설계되고, 문서화가 잘 된 클래스가 아니라면 상속하지 않는 것이 좋다. 특히 다른 패키지의 구체 클래스를 상속하는 것은 위험하다. 상속의 문제점 상속은 상위 클래스의 구현에 따라 하위 클래스의 동작이 결정되기 때문에 캡슐화를 깨뜨린다. 위의 이유로 상위 클래스만 수정한 경우에 수정하지 않은 다른 클래스들의 오동작 할 수 있다. 따라서 상속을 고려한 설계와 문서화가 필요하다(아이템 19) 클래스 내에서 자신의 다른 부분을 사용하는 자기사용(self-use)은 클래스의 내부 구현 방식이다. 이런 방식은 다음에 코드가 그대로 유지될 지 알 수 없다. 따라서 이 방식에 의존한 상속은 위험하다. 구현하지 않고 상속 후 새 메소드만 추가하더라도 추후에 상위 클래스에 추가된 메소드와 겹치는 경우 문제가 발생할 수 있다. 상속 문제를 해결하기 위한 컴포지션(Composition) 컴포지션(Composition)은 기존 클래스를 extends 하는 대신 새로운 클래스를 만들고 새 클래스의 private 필드로 기존 클래스의 인스턴스를 참조하게 하는 구조이다. 즉 새로운 클래스가 기존 클래스의 구성요소로 쓰인다. 전달(Forwarding) 클래스/메소드 새 클래스에서 기존 클래스에 해당하는 메소드를 호출해 결과를 반환한다. 위의 방식은 해당 클래스의 내부 구현 방식의 영향에서 벗어날 수 있다. 이런 방식을 전달(forwarding)이라 하며 이런 메소드들을 전달 메소드(forwarding method)라 한다. 래퍼 클래스(Wrapper Class) 구현하려하는 클래스의 전달 클래스를 작성한 뒤 extends해서 새로운 기능을 덧씌울 수 있다. 이때 이런 클래스를 다른 인스턴스를 감싸고 있다는 의미에서 래퍼 클래스라고 한다. 또한 새로운 기능을 덧씌우기 때문에 데코레이터 패턴(Decorator pattern)이라고도 한다. 컴포지션과 전달을 함께 쓰고, 래퍼 객체가 내부 객체에 자신의 참조를 넘기는 경우를 위임(delegation)이라고도 한다. 래퍼 클래스는 콜백 프레임워크에서 주의해야한다. A 클래스를 B 클래스가 상속하기 전에, B가 정말 A가 아니라면(is-a) 상속하면 안된다. 즉 A 클래스는 B의 구성요소가 아니라 구현 방법 중 하나 인 것.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Prefer interfaces to abstract classes","slug":"java-prefer-interfaces-to-abstract-classes","date":"2019-01-11T15:00:00.000Z","updated":"2020-03-19T00:43:22.674Z","comments":true,"path":"2019-01-12-java-prefer-interfaces-to-abstract-classes/","link":"","permalink":"https://j2de.github.io/2019-01-12-java-prefer-interfaces-to-abstract-classes/","excerpt":"","text":"Effective Java Item 20 추상 클래스보다는 인터페이스를 우선하라 추상 클래스 vs 인터페이스 추상 클래스의 경우 추상 클래스가 정의한 타입을 구현하기 위해 해당 클래스의 하위 클래스가 되어야한다. 자바는 단일 상속만 제공하기 때문에 추상 클래스는 제약이 있다. 인터페이스를 사용하는 경우 기존 클래스에도 손쉽게 새로운 인터페이스를 추가할 수 있다. 계층 구조가 없는 타입 프레임워크를 만들 수 있다. 개념을 계층적으로 표현하기 어려운 경우 적합하다. Java 8부터 default method가 추가되어서 구현 방법이 명백한 경우 그것을 디폴트 메소드로 제공하는 것이 좋다. 디폴트 메소드 제공시 @implSpec JavaDoc 태그를 붙여 문서화해주는 것이 좋다. 디폴트 메소드는 Object 메소드를 제공해서는 안된다. (equals, hashcode 등) 추상 골격 구현 클래스 템플릿 메서드 패턴으로 인터페이스와 추상 클래스의 장점을 함께 사용하기도 한다. 이때 추상 클래스를 추상 골격 구현(skeletal implementation)이라 한다. 인터페이스의 이름 앞에 Abstract를 붙인다. (관례) 인터페이스는 타입과 디폴트 메소드를 정의하고 추상 골격 구현 클래스가 구체적인 나머지 메소드를 구현한다. 따라서 추상 골격 클래스를 extends 하는 것만으로 인터페이스를 구현하는 대다수의 일이 완료된다. 인터페이스 / 추상 골격 구현 클래스를 분리하는 구조는 상황에 따라 선택할 수 있어서 좋은 구조이다. 기본적으로 추상 클래스를 extends 하는 것만으로 인터페이스에 대한 구현이 끝나지만 클래스를 상속받을 수 없는 경우라도 인터페이스를 직접 구현할 수 있고 디폴트 메소드는 그대로 implements 할 수 있다. 또는 우회해서 인터페이스를 implements 한 클래스에서 골격 추상 클래스를 private 내부 클래스로 정의해 사용하는 방법이 있다. 골격 구현 클래스 작성 순서 인터페이스에서 다른 메소드 들의 구현에 사용되는 기반 메소드 선정 1의 기반 메소드를 사용해 직접 구현할 수 있는 경우 인터페이스 디폴트 메소드로 제공: Object 메소드는 제공해선 안된다. 기반 or 디폴트 메소드 외에 메소드로 만들 메소드가 있다면 골격 구현 클래스에 남은 메소드를 작성한다.: 모두 기반 or 디폴트 메소드라면 골격 구현 클래스를 만들 필요가 없다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - Design and document for inheritance or else prohibit it","slug":"java-design-and-document-for-inheritance","date":"2019-01-10T15:00:00.000Z","updated":"2020-03-19T00:43:22.672Z","comments":true,"path":"2019-01-11-java-design-and-document-for-inheritance/","link":"","permalink":"https://j2de.github.io/2019-01-11-java-design-and-document-for-inheritance/","excerpt":"","text":"Effective Java Item 19 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라 상속용 클래스 상속용 클래스는 재정의할 수 있는 메소드들을 내부적으로 어떻게 이용하는지 문서로 남겨야한다. public, protected 메소드 중 final이 아닌 모든 재정의 가능한 메소드는 재정의 가능 여부를 명시해 주어야 한다. API 문서 명시 API 문서 설명에 Implementation Requirements로 시작하는 절은 그 메소드의 내부 동작 방식을 설명한다. 메소드 주석에 @implSpec 태그를 붙이면 JavaDoc이 자동으로 생성해준다. @implSpec 태그는 커스텀 태그로 이름을 따로 지정할 수 있다. 상속을 고려한 클래스 설계 클래스 내부 동작 과정 중 끼어들 수 있는 hook 부분을 protected 메소드 형태로 공개하기도 한다. 또는 protected 필드로 공개하기도 한다. 예를 들면 java.util.AbstractList의 clear 메소드를 고성능으로 만들기 쉽게 하기 위해서 removeRange메소드를 제공해주는 것과 같다. protected 메소드의 공개 여부를 결정하는데 가장 좋은 방법은 클래스를 직접 만들고 사용해보는 것이다. 상속용 클래스의 생성자는 재정의 가능한 메소드를 호출하면 안된다. 상속 받은 하위 클래스에서 재정의 하기 전에 상위 클래스의 생성자가 먼저 실행되기 때문에 의도하지 않은 결과가 발생할 수 있다. Cloneable, Serializable 인터페이스를 상속한 경우에도 주의해야한다. clone, readObject 메소드의 경우에도 생성자와 비슷한 동작을 하기 때문에 재정의 가능 메소드를 호출해선 안된다. Serializable을 구현한 상속용 클래스가 readResolve나 writeReplace 메소드를 구현한다면 하위 클래스에서 무시되지 않도록 protected로 선언 해야한다. 상속용으로 설계되지 않았다면.. 상속용으로 설계되지 않은 클래스는 상속을 금하는 것이 좋다. (1) 클래스를 final로 선언하거나 (2) 모든 생성자를 private/package-private로 선언하고 public 정적 팩터리를 만드는 두가지 방법이 있다. 상속을 꼭 허가해야 한다면 재정의 가능 메소드를 클래스 내부에서 사용하지 않게 문서로 남겨두어야 한다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Test - Stub","slug":"test-stub","date":"2018-12-04T15:00:00.000Z","updated":"2020-03-19T00:43:22.694Z","comments":true,"path":"2018-12-05-test-stub/","link":"","permalink":"https://j2de.github.io/2018-12-05-test-stub/","excerpt":"","text":"스텁(Stub)이란?호출자를 실제 구현물로부터 격리시킬 목적으로 런타임에 실제 코드 대신 삽입되는 코드 조각이다. 실제 코드의 일부를 독립적으로 테스트하기 위해 쓰인다.스텁은 로직이 없고 값만을 반환하기 때문에, 테스트 시 무조건 정해진 값을 반환한다고 가정한 경우 사용할 수 있다.행위에 대한 검증은 mock을 이용한다. 스텁을 사용하는 경우 시스템이 너무 복잡하고 깨지기 쉬워 수정이 불가한 경우 하부 시스템 간의 통합 테스트처럼 포괄적인 테스트를 수행하는 경우 스텁을 이용한 테스트의 신뢰도는 높은 편이다. 왜냐하면 대상 객체를 수정할 필요가 없어 production용 제품과 동일하기 때문이다. 스텁의 단점 스텁은 대체하려는 코드와 동일한 로직을 갖추어야하므로 검증할 시스템이 복잡할수록 제작하기 어렵다. 제작이 복잡해 스텁 자체를 디버깅하는 상황도 발생한다. 복잡성 때문에 유지보수가 어려울 수 있다. 상세한(fine-grained) 테스트에 적합하지 않다. 상황에 따라 다른 스텁 정책이 요구된다. 일반적으로 포괄적인 코드 블록을 대체하는 것에 적합하다.파일 시스템, 서버와의 커넥션, 데이터베이스 등 외부 시스템 전체를 대체하는데 주로 사용한다.특정 메소드 하나를 대체하는 경우는 mock 객체로 상세한 테스트를 진행하는 것이 좋다.","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Test","slug":"server/test","permalink":"https://j2de.github.io/categories/server/test/"}],"tags":[{"name":"Test","slug":"test","permalink":"https://j2de.github.io/tags/test/"},{"name":"Stub","slug":"stub","permalink":"https://j2de.github.io/tags/stub/"}]},{"title":"Spring Data JPA - Query Method","slug":"spring-data-jpa-query","date":"2018-11-24T15:00:00.000Z","updated":"2020-03-19T00:43:22.691Z","comments":true,"path":"2018-11-25-spring-data-jpa-query/","link":"","permalink":"https://j2de.github.io/2018-11-25-spring-data-jpa-query/","excerpt":"","text":"쿼리 메소드 (Query Method) 메소드 이름만으로 쿼리를 생성하는 기능. 인터페이스에 메소드를 선언만 하면 해당 메소드 이름으로 적절한 JPQL 쿼리를 생성해 실행한다. 스프링 데이터 JPA가 제공하는 쿼리 메소드 기능 메소드 이름으로 쿼리 생성 메소드 이름으로 JPA NamedQuery 호출 @Query 어노테이션 사용해 리포지토리 인터페이스에 쿼리 직접 정의 이 세가지 기능들만으로도 필요한 대부분의 쿼리 기능을 개발할 수 있다. 1. 메소드 이름으로 쿼리 생성 예) 이메일과 이름으로 회원을 조회하려면123public interface MemberRepository extends Repository&lt;Memeber, Long&gt; &#123; List&lt;Member&gt; findByEmailAndName(String email, String name);&#125; 인터페이스에 정의한 findByEmailAndName를 실행하면 스프링 JPA가 메소드 이름을 분석해 JPQL을 생성하고 실행한다. 아래와 같은 SQL이 실행된다.1select m from Member m where m.email = ?1 and m.name = ?2 정해진 규칙에 따라 이름을 지어야한다. 참고 2. 메소드 이름으로 JPA NamedQuery 호출 스프링 데이터 JPA는 메소드 이름으로 JPA NamedQuery를 호출할 수 있다. JPA NamedQuery는 쿼리에 이름을 부여해 사용하는 방법을 칭한다. 1234567@Entity@NamedQuery( name=\"Member.findByUsername\", query=\"select m from Member m where m.username = :username\")public class Member &#123; ...&#125; 위와 같이 어노테이션에 쿼리를 정의할 수 있다. 또는 xml에 쿼리를 정의할 수 있다.1234567891011121314151617181920212223 &lt;named-query name=\"Member.findByUsername\"&gt; &lt;query&gt;&lt;CDATA[ select m from Member m where m.username = :username ]&gt;&lt;/query&gt; &lt;/named-query&gt; ``` - 위와 같은 방법들로 Named 네이티브 쿼리도 지원한다.&lt;br/&gt;- 정의한 NamedQuery를 직접 호출하려면 아래와 같이 작성한다. ```java pulic class MemberRepository &#123; public List&lt;Member&gt; findByUsername(String username) &#123; ... List&lt;Member&gt; resultList = em.createNamedQuery(\"Member.findByUsername\", Member.class) .setParameter(\"username\", \"회원1\") .getResultList(); &#125; &#125; 스프링 데이터 JPA를 사용하면 메소드 이름만으로 NamedQuery를 호출할 수 있다. 12345public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; &#123; // 여기 선언한 Member 도메인 클래스 List&lt;Member&gt; findByUsername(@Param(\"username\") String username);&#125; &quot;도메인 클래스 + . + 메소드 이름&quot;으로 NamedQuery를 찾기 때문에 Member.findByUsername이라는 NamedQuery를 찾아 실행하게 된다. 3. @Query 어노테이션 사용해 리포지토리 인터페이스에 쿼리 직접 정의 리포지토리 메소드에 직접 쿼리를 정의하는 경우 @Query 어노테이션 사용 1234public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; &#123; @Query(\"select m from Member m where m.username= ?1\") Member findByUsername(String username);&#125; 위 방법은 실행할 메소드에 정적 쿼리를 직접 작성해서 이름 없는 NamedQuery이다. Native SQL을 사용하려면 @Query 어노테이션에 nativeQuery = true 옵션을 준다.1234public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; &#123; @Query(value=\"SELECT * FROM MEMBER USERNAME = ?0\", nativeQuery = true) Member findByUsername(String username);&#125; 파라미터 바인딩스프링 데이터 JPA는 위치 기반 파라미터 바인딩과 이름 기반 파라미터 바인딩을 모두 지원한다. 12select m from Member m where m.username = ?1 // 위치 기반select m from Member m where m.username = :name // 이름 기반 이름 기반 파라미터 바인딩을 사용하려면 @Param(org.springframework.data.repository.query.Param) 어노테이션을 사용해야한다. 코드 가독성과 유지 보수를 위해 이름 기반 파라미터 바인딩을 사용하는 것이 좋다. 1234public interface MemberRepository extends JpaRepository&lt;Member, Long&gt; &#123; @Query(\"select m from Member m where m.username = :name\") Member findByUsername(@Param(\"name\") String username);&#125; 반환 타입스프링 데이터 JPA의 반환 타입은 유연해서, 결과가 한 건 이상이면 컬렉션 인터페이스를, 한 건이면 반환 타입을 지정해주면 된다. 12List&lt;Member&gt; findByName(String name); // Collection (1)Member findByEmail(String email); // return type (2) 만약 조회 결과가 없다면 (1)은 빈 컬렉션을, (2)는 null을 반환한다.(2)와 같이 작성하고 반환 결과가 2건 이상이면 javax.persistence.NonUniqueResultException 예외가 발생한다.그리고 한 건을 조회 했을 때 JPA 내부에서 Query.getSingleResult()를 호출하는데, 이 메소드는 조회 결과가 없으면 javax.persistence.NoResultException 예외가 발생한다. 이 예외가 발생했을 때 스프링 데이터 JPA는 예외를 무시하고 null을 반환한다.","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"ORM","slug":"server/orm","permalink":"https://j2de.github.io/categories/server/orm/"}],"tags":[{"name":"Hibernate","slug":"hibernate","permalink":"https://j2de.github.io/tags/hibernate/"},{"name":"Spring","slug":"spring","permalink":"https://j2de.github.io/tags/spring/"}]},{"title":"JPA - Cascade","slug":"jpa-cascade","date":"2018-11-15T15:00:00.000Z","updated":"2020-03-19T00:43:22.691Z","comments":true,"path":"2018-11-16-jpa-cascade/","link":"","permalink":"https://j2de.github.io/2018-11-16-jpa-cascade/","excerpt":"","text":"영속성 전이와 고아 객체 영속성 전이(Transitive Persistence) 연관된 객체를 함께 저장하거나 함께 삭제할 수 있는 JPA에서 제공하는 기능. 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶은 경우 사용. CASCADE 옵션 즉, 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 수 있다. CASCADE 설정이 없는 경우 123456789101112131415// save parentParent parent = new Parent();em.persist(parent);// save child1Child child1 = new Child();child1.setParent(parent); // child1 &gt; parent 연관관계 설정parent.getChildren().add(child1); // parent &gt; child1em.persist(child1);// save child2Child child2 = new Child();child2.setParent(parent); // child2 &gt; parentparent.getChildren().add(child2); // parent &gt; child2em.persist(child2); JPA에서 Entity를 저장할 때 연관된 모든 엔티티가 영속 상태여야 하기 때문에 관련된 모든 엔티티를 각각 영속화했다. 영속성 전이: 저장 CASCADE 설정 1234567@Entitypublic class Parent &#123; // ... @OneToMany(mappedBy = \"parent\", cascade = CascadeType.PERSIST) // (1) private List&lt;Child&gt; children = new ArrayList&lt;Child&gt;(); // ...&#125; (1) 부모를 영속화할 때 연관된 자식들도 함께 영속화 하는 옵션이다. 12345678910Child child1 = new Child();Child child2 = new Child();Parent parent = new Parent();child1.setParent(parent); // 연관관계 설정child2.setParent(parent); // 연관관계 설정parent.getChildren().add(child1);parent.getChildren().add(child2);em.persist(parent) // 부모, 자식 한번에 저장 영속성 전이: 삭제 CASCADE 설정이 없는 경우 1234567Parent findParent = em.find(Parent.class, 1l);Child findChild1 = em.find(Child.class, 1l);Child findChild2 = em.find(Child.class, 2l);em.remove(findChild1);em.remove(findChild2);em.remove(findParent); 각각 엔티티를 하나씩 제거해야한다. CASCADE 설정(CascadeType.REMOVE) 12Parent findParent = em.find(Parent.class, 1l);em.remove(findParent); 연관된 엔티티를 모두 삭제한다(내부적으로 DELETE SQL을 3번 호출한다) CascadeType.REMOVE를 설정하지 않고 위 코드를 실행하면 외래키 무결성 예외가 발생한다. CASCADE 종류12345678public enum CascadeType &#123; ALL, // 모두 적용 PERSIST, // 영속 MERGE, // 병합 REMOVE, // 삭제 REFRESH, // REFRESH DETACH // DETACH&#125; 여러 속성을 같이 사용할 수 있다. PERSIST, REMOVE는 em.persist(), em.remove()할 때 전이가 일어나는 것이 아닌 flush할 때 전이가 발생한다. 고아 객체(ORPHAN)부모 Entity와 연관관계가 끊어진 자식 Entity를 자동으로 삭제하는 기능을 고아 객체 제거라 한다.즉, 부모 Entity의 컬렉션에서 자식 Entity의 참조만 제거하면 자식 Entity가 자동으로 삭제된다. 123456789@Entitypublic class Parent &#123; @Id @GeneratedValue private Long id; @OneToMany(mappedBy = \"parent\", orphanRemoval = true) // (1) private List&lt;Child&gt; children = new ArrayList&lt;Child&gt;(); // ...&#125; 12Parent parent1 = em.find(Parent.class, id);parent1.getChildren().remove(0); // 자식 Entity를 컬렉션에서 제거 실행 결과 SQL 1delete from child where id=? 고아 객체 제거 기능은 flush 시점에 적용된다. 정리 참조가 제거된 엔티티는 다른 곳에서 참조하지 않으므로 삭제한다. 참조하는 곳이 하나일 때만 사용해야 한다. 따라서 @OneToOne, @OneToMany에서만 사용가능하다. 부모 객체를 제거하면 자식도 같이 제거된다. ( = CascadeType.REMOVE) 영속성 전이 + 고아 객체, 생명주기 CascadeType.All + orphanRemoval = true를 동시에 사용한다면 ? 부모 엔티티를 통해 자식 엔티티 생명주기를 관리할 수 있다. 자식을 저장하려면 부모에 등록만 하면 된다. 자식을 삭제하려면 부모에서 제거하면 된다. 참고 영속성 전이는 DDD의 Aggregate Root 구현시 편리하다.","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"ORM","slug":"server/orm","permalink":"https://j2de.github.io/categories/server/orm/"}],"tags":[{"name":"Hibernate","slug":"hibernate","permalink":"https://j2de.github.io/tags/hibernate/"}]},{"title":"JPA - Proxy / Eager & Lazy Loading","slug":"jpa-proxy","date":"2018-11-14T15:00:00.000Z","updated":"2020-03-19T00:43:22.690Z","comments":true,"path":"2018-11-15-jpa-proxy/","link":"","permalink":"https://j2de.github.io/2018-11-15-jpa-proxy/","excerpt":"","text":"프록시와 즉시로딩, 지연로딩 프록시(Proxy) 프록시를 사용하면 연관된 객체를 DB에서 처음부터 조회하는 것이 아니라, 실제 사용하는 시점에 DB에서 조최할 수 있다(Lazy Loading). 하지만 자주 함께 사용하는 객체들은 조인을 사용해서 함께 조회하는 것이 효과적이다(Eager Loading). 이를 즉시 로딩과 지연 로딩 두 가지 방식으로 사용할 수 있다. 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신 DB 조회를 지연할 수 있는 가짜 객체가 필요하다. 이를 프록시 객체라 한다. JPA 지연 로딩의 구현 방법을 JPA 구현체에 위임했기 때문에 JPA마다 다르다.참고하는 자료는 Hibernate 기준으로 작성되었다. 프록시 기초 JPA에서 식별자로 Entity 하나를 조회할 경우 EntityManager.find() 이렇게 엔티티를 조회하면 엔티티 사용여부와 상관없이 DB를 직접 조회하게 된다. 사용 시점까지 Entity 조회를 미루고 싶은 경우 EntityManager.getReference() 이 메소드를 호출하면 JPA가 DB를 바로 조회하지 않고 엔티티 객체를 생성하지도 않는다. 대신 DB 접근을 위임한 프록시 객체를 반환한다. Proxy { Entity target = null / getId() / getName()} 프록시의 특징프록시의 구조 프록시 클래스는 실제 클래스를 상속 받아 만들어지기 때문에 실제 클래스와 겉 모양이 같다. 따라서 사용자는 실제 객체인지 프록시 객체인지 구분하지 않고 사용할 수 있다. ex) Entity가 id, name, getId(), getName()으로 되어있다면 Proxy는 Entity target, getId(), getName()으로 되어있음 프록시 위임 프록시 객체는 실제 객체에 대한 참조(target)를 보관하고, 프록시 객체의 메소드를 호출할 때 프록시 객체가 실제 객체의 메소드를 호출한다. 프록시 객체의 초기화 프록시 객체는 실제 사용될 때(ex-member.getName() 등) DB를 조회해 실제 엔티티 객체를 생성하는데 이것이 프록시 객체의 초기화이다. 예제 1234// Entity// MemberProxy 반환Member member = em.getReference(Member.class, \"id\");member.getName(); // (1) getName(); 12345678910111213141516// Proxyclass MemberProxy extends Member &#123; Member target = null; // 실제 엔티티 참조 public String getName() &#123; if(target == null) &#123; // (2) 초기화 (영속성 컨텍스트로) 요청 // (3) DB 조회 // (4) 실제 엔티티 생성 및 참조 보관 this.target = ... ; &#125; // (5) target.getName(); return target.getName(); &#125;&#125; (2) 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 엔티티 생성을 요청하는데 이것을 프록시 초기화라 한다. (3) 영속성 컨텍스트가 DB를 조회해 실제 엔티티 객체를 생성한다. (4) 그리고 생성한 실제 엔티티 객체의 참조를 target 변수에 보관한다. 프록시의 특징 처음 사용할 때 한 번만 초기화 된다. 프록시 객체를 초기화한다고해서 프록시 객체가 실제 엔티티로 바뀌는 것은 아니고, 프록시 객체 초기화 후 프록시 객체를 통해 실제 엔티티에 접근할 수 있는 것이다. 프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시 주의해서 사용해야한다. 영속성 컨텍스트에 찾는 엔티티가 이미 있다면 DB를 조회할 필요가 없으므로 em.getReference()를 호출해도 실제 엔티티를 반환한다. 초기화는 영속성 컨텍스트의 도움을 받아야 가능하기 때문에, 준영속 상태의 프록시를 초기화하면 문제가 생긴다. org.hibernate.LazyInitializationException Hibernate의 예외 발생 준영속 상태와 초기화123456// MemberProxy 반환Member member = em.getReference(Member.class, \"id\");transaction.commit();em.close(); // 영속성 컨텍스트 종료member.getName(); // 준영속 상태 초기화 시도 &gt; 예외 발생 프록시와 식별자 Entity를 Proxy로 조회할 때 식별자(Primary Key)값을 파라미터로 전달한다. 이 때 프록시 객체는 이 식별자 값을 보관한다. 따라서 식별자 값을 조회하는 Entity.getId()를 호출해도 프록시를 초기화하지 않는다. 12Member member = em.getReference(Member.class, \"id\"); // 식별자 보관member.getId(); // 초기화되지 않는다. 엔티티 접근 방식을 @Access(AccessType.PROPERTY))로 설정한 경우에만 초기화하지 않는다. 엔티티 접근 방식을 @Access(AccessType.FIELD))로 설정하면 id만 조회하는지 아닌지 구분할 수 없어서 프록시 객체를 초기화한다. 123Member member = em.find(Member.class, \"member_id\");Team team = em.getReference(Team.class, \"team_id\"); // sql을 실행하지 않는다.member.setTeam(team); 프록시 확인 JPA의 PersistenceUnitUtil.isLoaded(Object entity) 메소드를 사용하면 프록시 인스턴스 초기화 여부를 알 수 있다. 결과는 boolean 값이다. 12345boolean isLoad = em.getEntityManager.Factory() .getPersistenceUnitUtil().isLoaded(entity);// Or boolean isLoad = emf.getPersistenceUnitUtil.isLoaded(entity);System.out.println(\"isLoad = \" + isLoad); // 초기화 여부 조회한 엔티티가 프록시인지 아닌지 확인하려면 클래스명을 출력해보면된다. 클래스 명 뒤에 ..javassist..가 있다면 프록시이다. 출력은 라이브러리에 따라 달라질 수 있다. 즉시 로딩과 지연 로딩 member1이 team1에 소속되어 있는 경우 즉시 로딩 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다. ex) em.find(Member.class, &quot;member1&quot;); 호출 시 회원 엔티티와 연관된 팀 엔티티도 함께 조회. 설정 : @ManyToOne(fetch = FetchType.EAGER) 12345678@Entitypublic class Member &#123; // ... @ManyToOne(fetch = FetchType.EAGER) @JoinColumn(name = \"TEAM_ID\") private Team team; // ...&#125; 12Member member = em.find(Member.class, \"member1\"); // (1)Team team = member.getTeam(); // (2) 객체 그래프 탐색 (1) 회원을 조회하는 순간 팀도 함께 조회한다. (1)(2) 쿼리를 여러번 실행하는 것이 아닌, 보통 최적화를 위해 join쿼리를 사용해 쿼리 한번에 두 엔티티를 조회한다. 1234567891011select m.memeber_id as member_id, m.team_id as team_id, m.username as username, t.team_id as team_id, t.name as namefrom member m left outer join team t -- (1) outer join on m.team_id = t.team_idwhere m.member_id = 'member1' Null 제약 조건 현재 회원 테이블의 team_id 외래키에 null값이 허용되어 있기 때문에 외부 조인(outer join)을 사용한다. 최적화를 위해 내부 조인(inner join)을 사용하려면 외래키에 not null 제약 조건을 걸어야 한다. 그리고 JPA에 알려주는 설정을 해야한다. @JoinColumn(nullable = true) : null 허용, 외부 조인 사용, 기본값 @JoinColumn(nullable = false) : null 허용하지 않음, 내부 조인 사용 @ManyToOne(fetch = FetchType.EAGER, optional = false) : 이 설정도 내부 조인을 사용한다. 선택적 관계면 외부 조인, 필수 관계면 내부 조인을 사용 지연로딩 연관된 엔티티를 실제 사용할 때 조회한다. ex) member.getTeam().getName()과 같이 조회한 팀 엔티티를 실제 사용하는 시점에 JPA가 SQL을 호출해 팀 엔티티를 조회한다. 설정 : @ManyToOne(fetch = FetchType.LAZY) 12345678@Entitypublic class Member &#123; // ... @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = \"team_id\") private Team team; // ...&#125; 123Member member = em.find(Member.class, \"member1\"); // (1)Team team = member.getTeam(); // (2) 객체 그래프 탐색team.getName(); // (3) 팀 객체 실제 사용 (1)에서 회원 조회시 회원만 조회하고 회원의 팀 변수에(Member.team)에 프록시 객체를 넣는다. (2)에서 반환하는 것은 프록시 객체이다. 이 프록시 객체가 실제 사용될 때(3)까지 데이터 로딩을 미룬다. 즉 데이터가 필요한 순간에 데이터베이스를 조회해서 프록시 객체를 초기화한다. (1) 호출 시 실행되는 SQL 12select * from memberwhere member_id = 'member1' (3) 호출 시 실행되는 SQL 12select * from teamwhere team_id = 'team1' 정리 지연 로딩(Lazy Loading) : 연관된 엔티티를 프록시로 조회. 프록시를 실제 사용할 때 초기화하면서 DB를 조회한다. 즉시 로딩(Eager Loading) : 연관된 엔티티를 즉시 조회, Hibernate라면 가능한 SQL join을 사용해 한번에 조회한다. 지연 로딩의 활용프록시와 컬렉션 래퍼123Member member = em.find(Member.class, \"member1\");List&lt;Order&gt; orders = member.getOrders(); // (1)System.out.println(\"orders = \" + orders.getClass().getName()); // (2) Hibernate는 Entity를 영속 상태로 만들 때 Entity에 컬렉션이 있으면 컬렉션을 추적, 관리할 목적으로 원본 컬렉션을 Hibernate가 제공하는 내장 컬렉션으로 변경한다. 이를 컬렉션 래퍼라 한다. (2)의 출력 결과는 org.hibernate.collection.internal.PersistentBag이다. Entity 지연 로딩할 때는 프록시 객체를 사용해 지연 로딩을 수행한다. 하지만 컬렉션은 컬렉션 래퍼가 지연 로딩을 수행한다. 컬랙션 래퍼는 컬렉션에 대한 프록시 역할을 한다. (1)을 호출해도 컬렉션이 초기화되지 않는다. member.getOrders.get(0)과 같이 실제 데이터를 조회할 때 DB에서 조회해서 초기화한다. JPA 기본 Fetch 전략 @ManyToOne, @OneToOne : FetchType.EAGER @OneToMany, @ManyToMany : FetchType.LAZY 기본적으로 연관된 엔티티가 하나면 즉시 로딩, 컬렉션이면 지연 로딩 개발 시 모든 연관관계에 지연 로딩을 사용하고, 앱 개발이 완료 단계가 되었을 때 실제 사용 상황을 보고 필요한 곳만 즉시 로딩을 사용하도록하는 것이 좋다. SQL을 직접 사용할 경우 이런식의 변경은 어렵다. 컬렉션에 FetchType.EAGER 사용 시 주의점 컬렉션을 하나 이상 즉시 로딩하는 것은 좋지 않다. 컬렉션 즉시 로딩은 항상 외부조인(outer join)을 사용한다. 기본 조인 전략 정리123456- @ManyToOne, @OneToOne - (optional = false) : inner join - (optional = true) : outer join- @OneToMany, @ManyToMany - (optional = false) : outer join - (optional = true) : outer join Reference 자바 ORM 표준 JPA 프로그래밍","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"ORM","slug":"server/orm","permalink":"https://j2de.github.io/categories/server/orm/"}],"tags":[{"name":"Hibernate","slug":"hibernate","permalink":"https://j2de.github.io/tags/hibernate/"}]},{"title":"JPA 테스트의 특징","slug":"jpa-junit-test","date":"2018-11-09T15:00:00.000Z","updated":"2020-03-19T00:43:22.693Z","comments":true,"path":"2018-11-10-jpa-junit-test/","link":"","permalink":"https://j2de.github.io/2018-11-10-jpa-junit-test/","excerpt":"","text":"JPA TESTJPA는 엔티티 매핑 / API 호출 두 부분으로 나뉜다. 처음에는 객체가 어떻게 DB 테이블에 매핑되는지 정의한다. 보통 자바 Annotation 이용 다음으로 EntityManager 객체를 이용해 이 객체들을 DB에 저장하거나 읽어온다. JPA 쿼리를 사용해 객체를 만들고 지우고 전달하는 등의 작업 따라서 위의 두가지를 독립적으로 테스트해야 한다. 121. 올바르게 매핑되었는지 검증하는 테스트.2. 영속 코드 자체(예-DAO 등)를 위한 단위 테스트. 임베디드 데이터베이스 임베디드 데이터베이스의 경우 애플리케이션이 사용할 데이터베이스와 100% 호환이 되지 않을 수있다는 단점이 있다. 하지만 JPA를 사용하면 일반적인 경우 호환성에 문제가 생기진 않는다. JPA 벤더가 SQL 코드를 생성하기 때문이다. 따라서 단위 테스트에 임베디드 데이터베이스(H2 등)을 사용하는 것이 좋다. 프로젝트는 기본적으로 임베디드 데이터베이스를 사용하고, 데이터베이스를 쉽게 변경 가능하도록 만드는 것이 좋다. 개발자는 임베디드데이터베이스를 이용하고 공식 빌드에서 실제 DB로 교체하는 등으로 사용한다. 위임 수준(commitment level)JPA 연산의 특징 트랜잭션 안에서 발생 보통 벤더별로 특화된 세션으로 전이됨 트랜잭션과 세션 생명주기 관리에 의존적임 객체는 캐싱되고, 새로운 SQL명령은 지연관계 설정 시마다 발행. 트랜잭션 커밋 방식 비용이 비쌈 DB를 영구적으로 변경시킴. 트랜잭션 롤백 방식 따라서 테스트 케이스의 tearDown 도중에 트랜잭션을 롤백한다. 많은 프레임워크가 이 방식을 따름(Spring의 TestContext 등) 하지만 임베디드 데이터베이스를 사용한다면 트랜잭션 커밋 방식을 사용해도 괜찮다. 임베디드 데이터 베이스는 속도가 빠르다. 매번 전체 DB를 새로 만들어도 괜찮을 정도. 필요하면 tearDown 중 데이터베이스를 정리할 수 있다. 임베디드 DB에선 저렴한 연산. 트랜잭션을 롤백하면 JPA 벤더가 DB 실제 SQL을 전송하지 않을 수 있다. 이 경우 테스트 케이스는 통과하지만 실제 환경에서 실패하게 된다. JPA 트랜잭션이나 세션 밖에서 영구 저장된 객체의 동작을 테스트해보길 원할경우 사용할 수 있다. 참고 Junit in Action","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Test","slug":"server/test","permalink":"https://j2de.github.io/categories/server/test/"}],"tags":[{"name":"Test","slug":"test","permalink":"https://j2de.github.io/tags/test/"},{"name":"JPA","slug":"jpa","permalink":"https://j2de.github.io/tags/jpa/"},{"name":"Junit","slug":"junit","permalink":"https://j2de.github.io/tags/junit/"}]},{"title":"Git - .gitignore 설정 후 적용되지 않는 경우","slug":"git-gitignore-setting","date":"2018-11-08T15:00:00.000Z","updated":"2020-03-19T00:43:22.717Z","comments":true,"path":"2018-11-09-git-gitignore-setting/","link":"","permalink":"https://j2de.github.io/2018-11-09-git-gitignore-setting/","excerpt":"","text":"git에 업로드 되는 파일을 막는 .gitignore를 설정한 후에도 설정이 적용되지 않는 경우 123&gt; git rm -r --cached .&gt; git add .&gt; git commit -m \"commit_message\" 위 코드 사용시 설정이 적용된다.","categories":[{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/categories/troubleshooting/"}],"tags":[{"name":"Git","slug":"git","permalink":"https://j2de.github.io/tags/git/"}]},{"title":"Java - Comparable / Comparator","slug":"java-comparable-comparator","date":"2018-11-03T15:00:00.000Z","updated":"2020-03-19T00:43:22.671Z","comments":true,"path":"2018-11-04-java-comparable-comparator/","link":"","permalink":"https://j2de.github.io/2018-11-04-java-comparable-comparator/","excerpt":"","text":"Effective Java 규칙 12 Comparable 구현을 고려하라 Comparable.compareTo Object의 equals와 비슷하지만, 단순 동치성 검사 외에 순서 비교가 가능하며, 좀 더 일반적이다. Comparable 인터페이스를 구현하는 클래스의 객체들은 자연적 순서(natural ordering)을 갖게된다. Arrays.sort(a); Comparable을 구현한 객체들은 정렬, 최대/최소 계산 등을 하기 쉽다. Comparable을 구현한 클래스는 Comparable 인터페이스를 이용하도록 작성된 컬렉션 구현체와 전부 연동이 가능하다. 이들은 자바 플랫폼 라이브러리에 포함된 거의 모든 값 클래스(value class)에 해당된다. 알파벳 순서, 값의 크기, 시간적 선후관계 등 명확한 자연적 순서를 따르는 값 클래스를 구현할 때는 Comparable 인터페이스 구현을 반드시 고려야해야한다. 123public interface Comparable&lt;T&gt;&#123; int compareTo(T t);&#125; compareTo의 일반 규약 compareTo의 일반 규약은 equals와 비슷하다. 이 메소드는 this 객체와 주어진 객체를 비교한다. Comparable.compareTo는 비교할 클래스에 implements한 뒤 override한다. this 객체의 값이 인자로 주어진 객체보다 작으면 음수, 크면 양수, 같으면 0을 반환. 인자로 전달된 객체의 자료형이 this 객체와 비교 불가능한 자료형인 경우에는 ClassCastException 예외를 던진다. equals와 마찬가지로 compareTo 규약을 만족하면서 클래스를 계승하여 새로운 값 컴포넌트를 추가할 방법은 없다. 우회 방법은 equals와 같이, 원래 클래스를 계승하는 것이 아닌 원래 클래스 객체를 필드로 포함하는 새로운 클래스를 만들고, 원래 클래스 객체를 반환하는 view 메소드를 추가한다. 보통 객체 사이에 자연적 순서가 존재하기만 하면 이 규약을 만족한다. compareTo를 구현시 모든 x와 y에 대해 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))가 만족되도록 해야한다. 반사성 객체 참조를 비교하는 방향을 뒤집어도 객체 간 대소 관계는 같아야한다. ex) 첫 번째 객체가 두 번째 객체보다 작다면 두 번째 객체는 첫 번째 객체보다 큰 객체여야함. (x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0) 이면, x.compareTo(z) &gt; 0를 성립한다. 대칭성 first 객체가 second 객체보다 크고, second 객체가 third 객체보다 클 경우, first 객체는 반드시 third 객체보다 커야한다. (x.compareTo(y) == 0) 이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))의 관계가 모든 z에 대해 성립하도록 해야한다. 추이성 비교 결과 같다고 판정된 모든 객체 각각을 다른 어떤 객체와 비교할 경우, 그 비교 결과는 전부 동일해야 한다. 필수는 아니지만 (x.compareTo(y) == 0) == (x.equals(y))를 만족하도록 구현해야하며, 그렇지 않은 클래스는 반드시 그 사실을 명시해주어야한다. 동치성 컬렉션 인터페이스(Collection, Set, Map)와 같은 인터페이스들은 일반 규약이 equals 기반으로 작성되었지만, 실제 동치성은 equals 대신 compareTo를 통해 검사하기 때문에 (4) 항목을 만족하지 않는 경우 오동작할 수 있다. 서로 다른 객체의 비교 equals와 달리 서로 다른 클래스에 적용될 필요가 없다. 비교 대상인 객체가 서로 다른 클래스인 경우 ClassCastException을 던지는 것이 허용된다는 의미이다. compareTo가 속한 클래스가 제네릭인 경우에도, 적절한 형인자가 선언되었다면 제대로 동작할 것이다. compareTo 규약에서 서로 다른 클래스의 비교를 금지하지는 않지만 버전 1.6 이상의 플랫폼 라이브러리에 속한 모든 클래스가 비교를 허용하지 않는다. Side EffecthashCode 규약을 따르지 않는 클래스는 해시를 써서 구현한 클래스를 오동작 시킬 수 있는 것처럼, compareTo 규약을 준수하지 않는 클래스는 비교 연산에 기반한 클래스들을 오동작시킬 수 있다. TreeSet, TreeMap와 같은 sorted collection Arrays, Collections 같은 유틸리티 클래스들이 해당. 탐색과 정렬 알고리즘을 포함하는 클래스 compareTo vs equals Comparable 인터페이스는 자료형을 인자로 받는 제네릭 인터페이스므로, compareTo 메소드의 인자 자료형은 컴파일 시간에 정적으로 결정된다. 따라서 인자로 받은 객체의 자료형을 검사하거나 형 변환할 필요가 없다. 잘못된 자료형 객체를 인자로 넘기면 아예 컴파일이 되지 않는다. null이 인자로 전달되는 경우에도 NullPointerException 예외를 발생시켜야하며, 실제로 자동으로 예외가 발생한다. compareTo의 비교방식 compareTo는 동치성 검사가 아닌 순서 비교. 객체 참조 필드는 compareTo 메소드를 재귀적으로 호출해 비교한다. 비교할 필드가 Comparable을 구현하지 않거나 특이한 순서 관계를 사용해야하는 경우 Comparator를 명시적으로 사용할 수 있다. Comparator를 직접 작성할 수도 있고, 작성된 Comparator를 사용할 수도 있다. 123456public final class CaseInsensitiveString implements Comparable&lt;CaseInsensitiveString&gt; &#123; public int compareTo(CaseInsensitiveString cis)&#123; return String.CASE_INSENSITIVE_ORDER.compare(s, cis.s); &#125; ...&#125; CaseInsensitiveString 클래스는 Comparable을 구현하고 있다. 따라서 CaseInsensitiveString 객체 참조만 비교할 수 있다. compareTo의 인자는 Object가 아닌 CaseInsensitiveString이다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// String.class// public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence// String Class가 Comparable을 implements한 후 compareTo를 Override한 것// 일반적인 순서를 비교하고 있다.// ex) s.compareTo(\"string\"); // s는 String 객체public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2;&#125;// String Class 내부에 static으로 선언된 Comparator// 인자가 String이라면 String.class의 Comparator.compare을 이용해 비교할 수 있다.// 특이한 순서 관계를 따로 구현한 것public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator();private static class CaseInsensitiveComparator implements Comparator&lt;String&gt;, java.io.Serializable &#123; .. public int compare(String s1, String s2) &#123; int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i &lt; min; i++) &#123; char c1 = s1.charAt(i); char c2 = s2.charAt(i); if (c1 != c2) &#123; c1 = Character.toUpperCase(c1); c2 = Character.toUpperCase(c2); if (c1 != c2) &#123; c1 = Character.toLowerCase(c1); c2 = Character.toLowerCase(c2); if (c1 != c2) &#123; // No overflow because of numeric promotion return c1 - c2; &#125; &#125; &#125; &#125; return n1 - n2; &#125; ... 123456789101112// Integer.class// public final class Integer extends Number implements Comparable&lt;Integer&gt;// Comparable.compareTopublic int compareTo(Integer anotherInteger) &#123; return compare(this.value, anotherInteger.value);&#125;// 이름이 compare인 것.public static int compare(int x, int y) &#123; return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);&#125; 정수형의 기본자료형 필드는 관계연산자 &lt;,&gt;를 이용해 비교한다. 부동소수점 필드는 Double.compare나 Float.compare를 사용한다. 배열 필드는 원소마다 적용해야한다. 클래스에 선언된 중요 필드가 여러 개인 경우, 가장 중요한 필드부터 차례로 비교하고, 비교결과가 0이 아닌 경우 비교를 중단하고 결과를 반환한다. 모든 필드가 같을 때 0을 반환한다. Comparable vs Comparator 일반적으로 Comparable의 compareTo는 비교 기준이 하나일 경우 비교할 대상인 클래스에 Comparable을 상속 받아 compareTo를 구현한다. compareTo 메소드는 같은 객체 타입 하나의 인자를 받아 비교한다. 따라서 여러 비교 기준을 적용할 수 없다. Comparator의 compare는 비교 기준이 여러개일 경우 적용할 수 있다. Comparator용 클래스를 생성한 뒤 Comparator를 implements 후 내부에 compare을 구현한다. 이때 compare 내부에 여러 비교 조건을 적용할 수 있다. 12345678910@Overridepublic int compare(Fruit o1, Fruit o2) &#123; switch(n)&#123; case 1: return o1.price - o2.price; // ASC Price case 2: return o2.price - o1.price; // DESC Price case 3: return o1.getName().compareTo(o2.getName()); // ASC Name case 4: return o2.getName().compareTo(o1.getName()); // DESC Name &#125; return 0;&#125; Comparator 객체를 생성할 때 받는 n값(1,2,3,4)을 통해 조건을 선택한다. 이때 enum 객체를 이용하면 코드를 좀 더 명확하게 작성할 수 있다. 123456789101112131415public enum Compare &#123;BY_NAME_ASC, BY_NAME_DESC, BY_PRICE_ASC, BY_PRICE_DESC&#125;;private Compare cp;...@Overridepublic int compare(Fruit o1, Fruit o2) &#123; switch(cp)&#123; case BY_PRICE_ASC: return o1.price - o2.price; // ASC Price case BY_PRICE_DESC: return o2.price - o1.price; // DESC Price case BY_NAME_ASC: return o1.getName().compareTo(o2.getName()); // ASC Name case BY_NAME_DESC: return o2.getName().compareTo(o1.getName()); // DESC Name &#125; return 0;&#125; 1234TestComparator cp = new TestComparator(1);// 코드가 명확하지 않음TestComparator cp2 = new TestComparator(Compare.BY_NAME_DESC);// 어떤 비교 기준인지 명시적으로 확인할 수 있다. 12Arrays.sort(비교할_객체); // 비교할 객체의 natural ordering의 따라 sort함Arrays.sort(비교할_객체, Comparator_객체); // 특정 기준으로 비교할 수 있음 Comparable.compareTo든 Comparator.compare든 모든 필드에 대한 조건을 넣어주는 것이 좋다. 한 가지 필드에 대한 조건만 구현하는 경우 나머지 조건에 대해 의도하지 않은 결과가 나올 수 있기 때문이다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - equals method 재정의","slug":"java-equals-method-override","date":"2018-10-25T15:00:00.000Z","updated":"2020-03-19T00:43:22.671Z","comments":true,"path":"2018-10-26-java-equals-method-override/","link":"","permalink":"https://j2de.github.io/2018-10-26-java-equals-method-override/","excerpt":"","text":"Effective Java 규칙 8 equals를 재정의할 때는 일반 규약을 따르라 모든 객체의 공통 메소드Object는 객체 생성이 가능한 클래스(concrete class)지만 기본적으로는 계승해서 사용하도록 설계된 클래스이다. Object에 정의된 비-final 메소드(equals, hashCode, toString, clone, finalize)에는 재정의(override)하도록 설계된 메소드이기 때문에, 명시적인 일반 규약(general contract)가 있다. 따라서 이 메소드들을 재정의하는 클래스는 그 규약을 따라주어야하며, 그렇지 않은 경우 HashMap, HashSet과 같이 해당 규약에 의존하는 클래스와 사용시 문제가 생긴다. equals 재정의가 필요 없는 경우 각각의 객체가 고유한 경우 값(value) 대신 활성 객체(active entity)를 나타내는 Thread 같은 경우. 클래스에 논리적 동일성(logical equality) 검사 방법이 있든 없든 상관 없는 경우 java.util.Random 클래스는 난수를 발생 시키는데 일반적으로 두 난수가 같은지 비교할 필요가 없기 때문에. 상위 클래스에서 재정의한 equals가 하위 클래스에서 사용하기 적합한 경우 대부분의 Set 클래스는 AbstractSet의 equals 메소드를 그대로 사용한다. Map 또한 마찬가지. 클래스가 private 또는 package-private으로 선언되고, equals 메소드를 호출할 일이 없는 경우 이런 경우 필요는 없지만, 실수로 equals를 호출할 경우를 대비해 재정의해준다. 123@Override public Boolean equals(Object o)&#123; throw new AssertionError(); // 호출되면 안되는 메소드를 호출했다는 뜻.&#125; equals 재정의가 필요한 경우 객체 동일성(object equality)가 아닌 논리적 동일성(logic equality)의 개념을 지원하는 클래스인 경우. 상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못할 때. 값 클래스(value class)가 대체로 해당됨 예) Integer, Date ,, equals 메소드를 재정의할 필요가 없는 값 클래스 개체 통제 기능을 사용해 값마다 최대 하나의 객체만 존재하도록 제한한 클래스 열거 자료형(enum) 해당 클래스들은 객체의 동일성이 곧 논리적 동일성이다. equals 메소드를 정의할 때 준수해야할 일반 규약(JavaSE6 기준) 반사성 : null 아닌 참조 x가 있을 때, x.equals(x)는 true를 반환. 모든 객체는 자기 자신과 같아야 한다. 대칭성 : null 아닌 참조 x와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일 때만 true를 반환. 두 객체에게 서로 같은지 물으면 같은 답이 나와야 한다. 추이성 : null 아닌 참조 x,y,z가 있을 때, x.equals(y)가 true고, y.equals(z)가 true면 x.equals(z)도 true. 일관성 : null 아닌 참조 x, y가 있을 때, equals를 통해 비교되는 정보에 아무 변화가 없다면, x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다. null 아닌 참조 x에 대해서, x.equals(null)은 항상 false이다. 대칭성 위반한 사례: 대칭성은 x.equals(y)가 true이면 y.equals(x)도 true인 것. 12345678910111213141516171819202122public final class CaseInsensitiveString &#123; private final String s; public CaseInsensitiveString(String s) &#123; if (s == null) throw new NullPointerException(); this.s = s; &#125; // 대칭성 위반 @Override public boolean equals(Object o)&#123; if(o instanceof CaseInsensitiveString) // (1) return s.equalsIgnoreCase( ((CaseInsensitiveString) o).s); if(o instanceof String) // (2) 이 방향으로만 정상 동작함. return s.equalsIgnoreCase((String) o); return false; &#125; ...&#125; 12345CaseInsensitiveString cis = new CaseInsensitiveString(\"Polish\");String s = \"polish\";cis.equals(s); // (3) trues.equals(cis); // (4) false CaseInsensitiveString 객체의 equals 메소드는 CaseInsensitiveString 객체(1)와 String 객체(2) 둘다 비교 할 수 있다.하지만 String의 equals는 String을 인자로만 받고 CaseInsensitiveString 클래스를 모르기 때문에 return값은 항상 false이다.(4) 추이성 위반한 사례: x,y,z가 있을 때 x와 y가 같고, y와 z가 같으면 x와 z도 같아야한다. 12345678910111213141516public class Point &#123; private final int x; private final int y; public Point(int x, int y) &#123; this.x = x; this.y = y; &#125; @Override public boolean equals(Object o) &#123; if(!(o instanceof Point)) return false; // (1) Point p = (Point) o; return p.x == x &amp;&amp; p.y == y; // (2) &#125; ...&#125; 위의 클래스를 계승(상속)해 필드를 추가하는 경우, equals를 재정의해야한다. 123456789public class ColorPoint extends Point &#123; private final Color color; pulbic ColorPoint(int x, int y, Color color) &#123; super(x, y); this.color = color; &#125; ...&#125; 12345// 대칭성 위반@Override public boolean equals(Object o) &#123; if(!(o instanceof ColorPoint)) return false; // (3) return super.equals(o) &amp;&amp; ((ColorPoint) o).color = color;&#125; 12Point p = new Point(1, 2);ColorPoint cp = new ColorPoint(1, 2, Color.RED); p.equals(cp)는 ColorPoint가 Point의 instance가 될 수 있어서 (1)은 통과하지만, Point 객체로 형변환 후, Point에 있는 필드만 비교하기 때문에 (2) true가 나온다.cp.equals(p)는 Point 객체가 ColorPoint의 instance가 될 수 없기 때문에(3) 항상 false가 반환된다. 12345678910// 추이성 위반@Override public boolean equals(Object o) &#123; if(!(o instanceof Point)) return false; // o가 Point객체면 color는 비교하지 않음 if (!(o instanceof ColorPoint)) return o.equals(this); // o가 ColorPoint면 모든 정보를 비교 return super.equals(o) &amp;&amp; ((ColorPoint)o).color == color;&#125; 위의 코드는 대칭성은 보존되지만 추이성이 깨진다. 1234567ColorPoint p1 = new ColorPoint(1,2,Color.RED);Point p2 = new Point(1,2);ColorPoint p3 = new ColorPoint(1,2,Color.BLUE);p1.equals(p2); // (1) truep2.equals(p3); // (2) truep1.equals(p3); // (3) false (1)과 (2)의 경우 color 필드를 무시해서 true가 되지만, (3)의 경우 color를 비교해서 false가 된다. 상위 클래스에 없는 새로운 값 컴포넌트를 하위 클래스에 추가하는 상황이라면, equals에게 비교할 새로운 정보가 추가되어야 한다. 이 때 상위 클래스가 변경 불가능(Immutable Class)한 객체라면, 객체 지향 언어에서 동치 관계를 구현할 때 발생하는 본질적 문제로, equals 규약을 어기지 않을 방법이 없다. getClass를 사용하는 경우 리스코프 대체 원칙이 적용되지 않아서 무조건 false가 출력된다. HashSet 같은 컬렉션은 객체 포함 여부를 판단할 때 equals를 사용하기 때문. CounterPoint 객체는 어떤 Point 객체와도 같은 수 없기 때문. equals 규약 위반하지 않으며 값 컴포넌트 추가 계승(상속)하는 대신 구성하라. Point를 계승해 ColorPoint를 만드는 것이 아닌, ColorPoint안에 private Point 필드를 두고 public view 메소드를 하나 만드는 것. 이 view 메소드는 ColorPoint가 가리키는 위치를 Point 객체로 반환한다. 1234567891011121314151617public class ColorPoint &#123; private final Point point; private final Color color; ... // ColorPoint의 Point 뷰 반환 public Point asPoint() &#123; return point; &#125; @Override public boolean equals(Object o) &#123; if(!(o instanceof ColorPoint)) return false; ColorPoint cp = (ColorPoint) o; return cp.point.equals(point) &amp;&amp; cp.color.equals(color); &#125; ...&#125; java.sql.Timestamp는 java.util.Date를 계승해 nanoseconds 필드를 추가한 것. Timestamp 클래스의 equals는 대칭성을 위반해 Timestamp와 Date객체를 같은 컬렉션에 보관하거나 섞어쓰면 문제가될 수 있다. 일관성 일단 같다고 판정된 객체들은 추후 변경되지 않는 한 계속 같아야 한다. 변경 가능한 객체들 간의 동치 관계는 시간에 따라 달라질 수 있지만, 변경 불가능한 객체들 간의 동치 관계는 시간에 따라 달라질 수 없다. 신뢰성이 보장되지 않는 자원들을 비교하는 equals 구현을 삼가라. 예를 들면 URL에 대한 equals equals 메소드는 메모리에 존재하는 객체들만 사용해서 결정적 계산을 수행하도록 구현되어야한다. Null에 대한 비 동치성(Non-nullity) 모든 객체는 null과 같아선 안된다. 예) o.equals(null) 의 결과가 true가 되면 안된다. equals 내부에서 null 조건을 명시적으로 검사해서 NullPointerException이 발생하지 않도록 한다. 인자와의 비교를 위해 equals 메소드는 인자를 먼저 형변환해야한다. 형변환 이전에 instanceof 연산자를 사용해 인자의 자료형을 먼저 검사해야한다. 좋은 equals 메소드를 구현하기 위해 따라야할 지침들 == 연산자를 사용해 equals 인자가 자기 자신인지 검사한다. 그렇다면 true를 반환한다. 성능 최적화가 이루어진다. instanceof 연산자를 사용해 인자의 자료형을 정확히 검사한다. 그렇지 않다면 false를 반환한다. equals 인자를 정확한 자료형으로 변환한다. 그 앞에 instanceof 연산자를 사용했으므로 형변환은 반드시 성공한다. “중요” 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다. 필드가 모두 일치하는 경우에만 true를 반환 인터페이스라면 인터페이스 메소드를 통해, 클래스라면 권한이 있다면 직접 접근도 가능 float나 double이외의 기본 자료형은 ==로 float는 Float.compare로 double은 Double.compare로 Null이 허용되는 객체의 경우 내부적으로 null check를 따로 해주어야 한다. equals 메소드 구현을 끝냈다면, 대칭성, 추이성, 일관성 세 속성이 만족되는지 검토하라. 단위 테스트(unit test)를 진행한다. null이 허용되는 객체의 경우equals 메소드는 내부에 NullPointerException이 발생하면 안되기 때문에, Null 여부를 검사를 따로 해주어야 한다. 1(field == null ? o.field == null : field.equals(o.field)) NullPointerException을 피하기 위해 null 여부를 확인하고 이 후에 값을 비교한다. equals 구현시 주의해야할 사항 몇 가지들 equals를 구현할 때는 hashCode도 재정의하라. equals 메소드의 인자형을 Object에서 다른 것으로 바꾸지 마라. Object equals의 인자는 Object이기 때문에 다른 타입의 인자를 쓰면 Override 하지 못한다. @Override 어노테이션을 사용하면 위와 같은 실수를 줄일 수 있다. 참고 instanceof https://programmers.co.kr/learn/questions/505","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - 종료자(finalizer)","slug":"java-finalizer","date":"2018-10-24T15:00:00.000Z","updated":"2020-03-19T00:43:22.670Z","comments":true,"path":"2018-10-25-java-finalizer/","link":"","permalink":"https://j2de.github.io/2018-10-25-java-finalizer/","excerpt":"","text":"Effective Java 규칙 7 종료자 사용을 피하라 종료자란 ?Object.finalize()객체를 생성 하고 사용한 뒤 JVM의 가비지 컬렉션이 자동으로 메모리를 정리할 때 호출되는 메소드프로그래머가 종료자를 직접 사용하는 것은 예측 불가능하고, 위험하고, 불필요하다. 종료자 사용시 단점들. 즉시 실행된다는 보장이 없다. 종료 시점이 JVM마다 다르다. 객체 메모리 반환이 오히려 지연된다. 자바는 프로그램 종료될 때까지 객체가 남은 상태로 종료되어도 괜찮다. 종료자 안에서 무점검 예외가 발생해도 경고 문구가 출력되지 않는다. 종료자 사용시 프로그램 성능이 오히려 떨어진다. 명시적 종료 메소드 (termination method) Q. 파일이나 스레드 처럼 명시적으로 반환하거나 삭제해야하는 자원을 포함하는 객체의 클래스는 어떻게 작성해야하는가?A. 명시적인 종료 메소드(termination method)를 정의하고. 더이상 필요하지 않은 객체라면 클라이언트가 해당 메소드를 호출하게 한다. 유효하지 않은 객체임을 표시하는 private 필드를 하나 두고, 모든 메소드 앞에 해당 필드를 검사하는 코드를 둬서, 이미 종료된 객체에 메소드를 호출하면 IllegalStateException이 던져지도록. 예) OutputSteam, InputStream, java.sql.Connection에 정의된 close 메소드 java.util.Timer의 cancle 메소드 java.awt의 Graphics.dispose, Window.dispose 123456789101112131415161718192021222324publicclass FileInputStream extends InputStream&#123; private final Object closeLock = new Object(); private volatile boolean closed = false; public void close() throws IOException &#123; synchronized (closeLock) &#123; if (closed) &#123; return; &#125; closed = true; &#125; if (channel != null) &#123; channel.close(); &#125; fd.closeAll(new Closeable() &#123; public void close() throws IOException &#123; close0(); &#125; &#125;); &#125;&#125; 명시적 종료 메소드는 보통 try-finally 문과 함께 쓰이지만 자바 7에 try with resource문이 생겨서 이를 보통 쓴다. 리소스가 자동으로 해제된다. 종료자를 정말 써야하는 경우 명시적 종료 메소드 호출을 잊을 경우에 대비하는 안전망의 역할 이런 경우 자원 반환이 늦어지더라도 어쨌든 반환이 되는 것이 더 좋기 때문에. 종료자가 언제 호출될지 모르는 것은 마찬가지이다. 종료자가 반환되지 않은 자원을 발견하게 될 경우 반드시 경로 메세지를 로그로 남겨야한다. 종료자로 이런 안전망을 구현하려하는 경우 추가적인 비용을 감당하면서 구현할 가치가 있는 일인지 신중하게 생각해보아야 함. 네이티브 피어(native peer)와 연결된 객체를 다룰 때. 네이티브 피어란?JNI와 같이 일반적인 자바 객체가 아닌 경우, 가비지 콜렉터가 알 수 없고, 자바측 피어 객체(Java peer)가 반환될 때 같이 반환할 수도 없다. 네이티브 피어가 중요한 자원을 점유하고 있는 것이 아니라면 종료자를 사용하는 것이 적합하다. 즉시 종료해야하는 경우 명시적인 종료 메소드를 클래스에 추가해야한다. 이때 종료자 연결이 자동으로 이루지지 않으므로, 수동 종료자 연결을 해주어야한다. 수동 종료자 연결Object 아닌 어떤 클래스가 종료자를 갖고 있고 하위 클래스가 해당 메소드를 재정의하는 경우, 하위 클래스 종료자는 상위 클래스 종료자를 명시적으로 호출해야한다. 그렇지 않으면 상위 클래스 종료자는 절대 호출되지 않는다.하위 클래스 종료자는 try문 상위 클래스 종료자는 finally문에서 사용한다. 12345678// 수동 종료자 연결(Manual finalizer chaining@Override protected void finalize() throws Throwable &#123; try &#123; .. // 하위 클래스의 상태 종료 &#125; finally &#123; super.finalize(); &#125;&#125; 종료 보호자 패턴(finalizer guardian)종료되어야 하는 객체의 클래스 안에 종료자를 정의하는 대신, 익명 클래스 안에 종료자를 정의한다. 이 익명 클래스로 만든 객체를 종료 보호자라한다. 종료되어야 하는 객체 안에 하나씩 넣는다.종료 보호자 바깥 객체에는 종료 보호자를 참조하는 private 필드가 있고, 따라서 바깥 객체에 대한 모든 참조가 사라지면 종료 보호자의 종료자도 실행 가능한 상태가 된다. 객체에 대한 모든 참조가 사라지면 GC이 객체를 삭제하려고 finalize()를 실행하기 때문 123456789// 종료 보호자 숙어(Finallaizer Guardian idiom)public class Foo &#123; // 이 객체를 바깥 객체(Foo)를 종료 시키는 역할만 수행 private final Object finalizerGuardian = new Object() &#123; @Override protected void finalize() throws Throwable &#123; ... // 바깥 Foo 객체를 종료 시킴 &#125; &#125;&#125; 이 기법은 종료자가 있는 비-final 클래스를 구현할 때 반드시 고려해야한다. 정리 자원 반환에 대한 최종적 안정장치를 구현하거나, 중요하지 않은 네이티브 자원을 종료시키려는 것이 아니라면 종료자는 사용하지 말아라. 굳이 종료자를 사용하게 되었다면 super, finalize 호출을 하라. 자원 반환 안전망을 구현하는 경우 종료자가 호출될 때마다 클라이언트 코드가 잘못되었음을 알리는 로그를 남겨라. 하위 클래스 정의가 가능한 public 클래스에 종료자를 추가해야한다면, 하위 클래스에서 실수로 super.finalize 호출을 잊어도 문제가 없도록 종료 보호자 패턴을 도입할지 고려해보자. 참고 종료자 http://plposer.tistory.com/72 https://wedul.tistory.com/262?category=648587 try with resource http://javacan.tistory.com/entry/my-interesting-java7-five-features","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Fish Shell - Alias 설정","slug":"fish-shell-alias","date":"2018-10-23T15:00:00.000Z","updated":"2020-03-19T00:43:22.696Z","comments":true,"path":"2018-10-24-fish-shell-alias/","link":"","permalink":"https://j2de.github.io/2018-10-24-fish-shell-alias/","excerpt":"","text":"일반적으로 bash와 같은 쉘들은 alias 명령을 통해 alias를 지정해준다. 123#!/usr/bin/env bash# ~/.bashrcalias name=\"#statement\" fish shell은 alias가 따로 존재하지 않고 함수(function)로 이를 처리한다. 1234#!/usr/bin/env fish&gt; function name #statements end fish의 인수는 숫자가 매겨진 변수($1)가 아닌 $argv 단일 목록으로 전달된다. function을 영구적으로 저장하고 싶다면 ~/.config/fish/functions/경로에 function_name.fish 파일을 생성해야한다. 전체 함수의 목록은 아래 명령어로 확인할 수 있다. 12#!/usr/bin/env fish&gt; functions","categories":[{"name":"System","slug":"system","permalink":"https://j2de.github.io/categories/system/"},{"name":"Shell","slug":"system/shell","permalink":"https://j2de.github.io/categories/system/shell/"}],"tags":[{"name":"Fish Shell","slug":"fish-shell","permalink":"https://j2de.github.io/tags/fish-shell/"},{"name":"Shell","slug":"shell","permalink":"https://j2de.github.io/tags/shell/"}]},{"title":"토크ON세미나 - OAuth2.0","slug":"talkonseminar-oauth2","date":"2018-10-23T15:00:00.000Z","updated":"2020-03-19T00:43:22.770Z","comments":true,"path":"2018-10-24-talkonseminar-oauth2/","link":"","permalink":"https://j2de.github.io/2018-10-24-talkonseminar-oauth2/","excerpt":"","text":"Date 2018.10.24 Wed / Time PM 1:00~6:00 / Place SK플래닛 T아카데미 페이스북. 구글 로그인 하기로 배우는 OAuthOAuth는 인터넷 사용자들이 비밀번호를 제공하지 않고, 웹사이트 상의 자신들의 정보에 대한 접근권한을 특정 웹사이트나 애플리케이션에 제한적으로 부여할 수 있는 개방형 표준 인증기술. 이번 세미나는 OAuth의 동작순서 및 원리에 대해 알아보고, 서버쪽 기술 없이 자바스크립트만을 가지고 페이스북, 구글로 로그인하기 기능 구현, 이렇게 수집된 인증을 바탕으로 API 호출 등 OAuth 활용 방법에 대해 살펴 본다. 자세한 내용 링크 참고 세미나 목표 OAuth의 본질적인 원리를 이해 후 이를 바탕으로 Low Level로 구현. Facebook과 Google의 SDK를 이용해 실 서비스를 구현해본다. OAuth의 구조: User / My / Their 3자가 필요하다. My : 내가 구현하고자 하는 서비스 User : 내 서비스를 사용하는 사용자 // 기본적으로 My-User의 양자 관계 Their : facebook, google 같은 기존 서비스 OAuth를 사용하는 목적가장 큰 문제는 보안(인증)의 문제 가장 쉬운 방법은 Their의 ID/PW를 아는 것. My에 Their의 정보를 제공한다. // 좋지 않은 방법 모든 서비스에 권한 부여 무기한 사용 가능 ID/PW가 아닌 임시 비밀번호를 발급 받아서 진행 임시 비밀번호를 Their가 랜덤하게 복잡하게 만들 수 있다. Their의 기능이 A,B,C.. 여러개일 때, 일부 기능에 대해서만 사용할 수 있도록 제어가 가능하다. 기간을 부여해 일시적으로 사용하도록 제어할 수 있다. 이 임시 비밀번호를 access token이라 한다. 이걸 얻어내면 OAuth를 할 줄 아는 것 !! My가 access token을 제출함으로써 Their의 일부 기능을 일정 기간동안 권한을 받아 사용할 수 있는 것. OAuth의 용어 My : Client User : Resource Owner (정보의 소유자) Their : Resource Server (정보의 제공자) 원래 하나가 더 있지만 우선 세 개로 설명할 예정. OAuth를 얻기 위한 절차 My Service를 Their Service에 등록(register)하는 절차가 필요 양자가 교환하는 정보가 있다. 출처 : 생활코딩 이고잉님 (1) Resource Server는 Client id를 생성 // 공개되어도 괜찮다.(2) Resource Server는 Client secret를 생성 // 공개되면 안된다.(3) Client에게 Resource Server가 Client id/secret을 알려준다(4)-1 Client는 access token을 어디로 배달해줄 것인가? 배송지를 알려준다. (redirect uri : 배송지 정보) (My가 redirect uri를 구현해 Server에게 알려주어야함)(4)-2 Resource Server에 redirect uri를 등록해준다.(5) Resource Owner가 client에 접속했을 때 Resource Owner에게 로그인 요청을 준다. (권한 승인 요청) // 사용자에게 링크를 제공(6) Resource Owner가 승인하면, Resource Server에게 client_id를 전송하고 승인 여부를 물어본다.(7) Resource Server는 user_id에 Resource Owner 정보를 등록하고 Resource Owner에 access_token을 발급해준다.(8) client는 발급받은 access_token을 이용해 Resource Server의 API를 이용한다. My = Client = CUser = Resource Owner = ROTheir = Resource Server = RS Facebook으로 로그인Facebook OAuth 기본 설정 facebook developer 사이트 접속 내 앱 생성 &gt; 로그인하기 &gt; 웹 선택 대시보드 &gt; 기본설정에서 App id와 secret이 발급된 것을 확인할 수 있다. 오늘 세미나는 server-side가 아닌 javascript를 이용해 client-side에서 제어하는 것을 중점으로 실습할 것.따라서 secret code는 현재 실습에서는 사용하지 않는다.server-side를 이용한 서비스를 구축할 때 사용할 것. Q. User가 access token을 발급 받나요?A. User가 클릭만 하면 발급을 받지만, User가 알게 되는 것은 아니다. 개발 환경 Node.js npm local-web-server : 경량화된 웹 서버, 손쉽게 https 개발 환경을 구축할 수 있음. 12345npm -vnpm install -g local-web-server // 전역으로 npm 설치ws --https // https로 웹 서버 실행, facebook이 개발환경에서도 https를 강제하기 때문// https://localhost:8000 접속 가능// 이것을 facebook에 redirect uri 값으로 등록한다. Facebook Login 요청 구현 keyword : facebook developer login : Login 요청을 구현한다는 것은, User(Resource Owner)에게 승인 받는 버튼, 링크를 만든다는 것이다. 구현 방법 3가지1231. 위젯을 이용한다. (간단한 방식)2. SDK(Software Development Kit)3. 직접 구현 &gt; 로그인 flow 직접 빌드 우리는 원리를 이해하기 위해 3번으로 진행하지만 보안상의 이슈가 발생할 수 있기 때문에 실 서버환경에서는 SDK를 이용해 개발해야한다. Facebook Login Flow 직접 빌드 참고 링크 : facebook for developer - 로그인 플로 직접 빌드 1234567https://www.facebook.com/v3.2/dialog/oauth? client_id=&#123;app-id&#125; &amp;redirect_uri=&#123;redirect-uri&#125; &amp;state=&#123;state-param&#125; &amp;response_type=token // 바로 access_token으로 받기위한 설정 // 설정하지 않는 경우 code로 받게 된다. redirect-uri를 직접 등록하면 문제가 생길 수 있다. uri encode 도구를 이용해 인코딩해 넣는다. state-param은 보안 관련, 우선 넘어간다. 설정을 끝낸 뒤 링크를 누르면 인증 팝업 창이 뜬다. 위의 과정은 내부적으로 이렇게 동작한다.12345671. client가 웹사이트를 방문한 User(RO)에게 (인증) 주소를 준다.2. Client가 주소를 누르면 해당 Request는 RS에게 전달된다.2-1. Request에는 client_id는 ~고 redirect_uri는 ~라는 정보를 담아 전송한다.2-2. 이때 RS에서 redirect_uri를 확인하고, 등록하지 않은 redirect_uri는 RS가 거절한다.3. 이후 RS가 access_token을 랜덤하게 생성한다.4. RS에서 user_id가 ~인 사람의 access_token이라 저장한다. (어떤 user에 token을 발급했는지 저장)5. 이 후 access_token을 RO(정확히 말하면 사용자라기 보다는 사용하고 있는 웹페이지)를 통해 Client에게 전달한다. 로그인에 성공하면 아래와 같은 리디렉션 URI가 호출된다. 1https://localhost:8000/fb-low.html?#state=1234&amp;access_token=&#123;access_token_value&#125;&amp;expires_in=&#123;value&#125;&amp;reauthorize_required_in=&#123;value&#125;&amp;data_access_expiration_time=&#123;value&#125; uri의 access_token을 알게되면 facebook api를 호출할 수 있다. state는 보안과 관련 있는 필드이다. facebook 서버에게 access_token을 요청하는 링크를 만들어서 사용자가 클릭하면 페이스북 서버로 갔다가 준 결과가 위의 링크인데, 이때 내가 요청한 것이 온게 맞는지 확인하기 위해서 state를 통해 확인한다. 응답하는 RS는 state 값을 똑같이 돌려주도록 약속되어 있기 때문에 내가 설정한 값과 다른 값이 오면 잘못된 것이다. (SDK는 자동으로 처리해준다) expires_in : 유효기간 Facebook API 사용 access_token을 얻는다 (SDK를 이용하지 않고) access_token으로 Facebook API를 가져와서 현재 사용자의 이름을 출력한다. 우선 uri에서 access_token 값만을 추출해야한다. [검사]-console 1location.href.match('access_token=([^&amp;]*)'); location.href : 현재 열어놓은 웹페이지의 주소를 가져온다. .match : 매칭되는 문자열(value)을 추출 ^$ : and가 아니다(부정) 1location.href.match('access_token=([^&amp;]*)')[1]; 2번째 값임을 확인한 뒤 출력해본다 1234if(atr)&#123; // js의 null은 false, 값이 있으면 true var access_token = atr[1]; console.log('access_token :', access_token);&#125; access_token을 가져온 것을 확인하였다. - access_token 획득 후 Facebook API 서버에 접속해 유저 이름을 가져와야한다. keyword : facebook user graph api Facebook에서 제공하는 그래프 API 탐색기를 통해 손쉽게 시뮬레이션 할 수 있다. 참고 링크 : facebook for developer - 그래프 API 탐색기 : 내가 생성한 앱의 토큰을 받아서 API를 적용해볼 수 있다.어떤 정보를 가져오고 싶은지 구체적인 필드를 적용해 볼 수 있다. 받아오고 싶은 정보의 필드를 설정한 뒤 하단의 [코드 받기]-[cURL]를 참고한다. 해당 URL에 접속하면 설정한 정보를 받아올 수 있다. // 모든 필드를 여기서 선택한다고 정보를 가져올 수 있는 것은 아니다. 추가적인 권한이나 설정같은 것이 필요한 경우가 많다. ajax를 이용해 정보를 가져와보자. fetch().then(){}을 이용한다. 1231. 웹브라우저는 fetch의 url에 접속한다.2. 이후 then의 함수를 호출한다.3. 이때 첫번째 인자로 어떤 값을 인자로 넘긴다. 이 인자는 여러가지가 될 수 있다. 그 정보를 받아서 사용하기 쉽도록 가공하는 코드를 function 내부에 작성하면 된다. 1234567891011121314if(atr)&#123; var access_token = atr[1]; console.log('access_token :', access_token); fetch(\"&#123;https://graph.facebook.com/을 통해 알아낸 URI&#125;\") .then(function(raw)&#123; return raw.json(); &#125;) .then(function(result)&#123; console.log(result.name, result.id); document.querySelector('#welcome').innerHTML = 'Welcome, '+result.name; // #welcome : id값이 welcome인 태그를 선택. &#125;);&#125; 받아온 정보를 json으로 가공해서 현재 로그인한 사용자의 이름을 출력하는 코드이다. 위의 코드는 연습용 코드로 보안상의 문제가 있다. Facebook SDK를 이용한 구현 keyword : facebook sdk javascript참고링크 : 빠른 시작: Javascript용 Facebook SDK SDK란 ? (Software Development Kit)Application이 제공하는 도구.API를 직접 호출하지 않고 도구를 통해 간접적으로 API를 제어하는 것. 우선 SDK를 사용하기 위해서는 웹페이지에 로드시켜야한다. - 기본 설정 123456789101112131415161718&lt;script&gt; window.fbAsyncInit = function() &#123; FB.init(&#123; appId : 'your-app-id', autoLogAppEvents : true, xfbml : true, version : 'v3.2' &#125;); &#125;; (function(d, s, id)&#123; var js, fjs = d.getElementsByTagName(s)[0]; if (d.getElementById(id)) &#123;return;&#125; js = d.createElement(s); js.id = id; js.src = \"https://connect.facebook.net/en_US/sdk.js\"; fjs.parentNode.insertBefore(js, fjs); &#125;(document, 'script', 'facebook-jssdk'));&lt;/script&gt; : 직접 만든 Facebook 앱의 ID를 your-app-id에 대체해야 한다. - 위와 같이 로그인 후 로그인한 사용자의 이름을 출력하는 기능을 SDK로 구현. 1234567891011121314151617181920212223// 로그인 상태를 체크해서 동작하는 함수FB.getLoginStatus(function(response) &#123;console.log(\"response.state : \"+response.status);// statusChangeCallback(response);if(response.status == 'connected')&#123; // 로그인되었을 때 처리 document.querySelector('#authBtn').value = \"Logout\"; // Welcome message 출력 FB.api( '/me/', 'GET', &#123;\"fields\":\"id,name,email\"&#125;, function(response) &#123; // Insert your code here console.log('API : ', response); document.querySelector('#welcome').innerHTML = 'Welcome, '+response.name; &#125; );&#125;else &#123; // 로그인되지 않았을 때 처리 document.querySelector('#authBtn').value = \"Login\"; &#125;&#125;) 참고 링크 : facebook for developer - Javascript SDK - Examples scope어떤 기능에 대해 유효한가를 나타낸다.페이스북은 기본적으로 ID와 이름 권한을 획득할 수 있다.만약 사용자의 email 정보를 가져오고싶다면 scope를 추가해아한다. 1234FB.login(function(response) &#123; alert('Welcome'); location.reload();&#125;), &#123;scope: 'public_profile,email'&#125;; 로그인 시 scope 옵션을 통해 권한을 추가 요청한다. 그래프 API 탐색기를 통해 추가한 scope 기능을 받아오는 법을 확인한다. 증분 권한 ?권한을 한번에 추가하는 것이 아니라 필요할 때마다 하나씩 추가하도록 하는 것. 증분 권한을 사용하는 것이 권장사항. 위와 같이 필요한 기능을 그때그때 승인을 받는다. Google로 로그인Google SDK 사용 설정 keyword : google cloud console Google Cloud Console에서 프로젝트를 생성한다. Google API 서비스를 사용하려면 프로젝트에서 해당 기능을 활성화 시켜야한다. OAuth 클라이언트 아이디 생성 API 및 서비스 &gt; 사용자 인증 정보 &gt; OAuth 클라이언트 ID consent screen(동의 화면) 설정 애플리케이션 이름, 로고 등을 설정한다. (3)이후 (2)를 진행한다. Domain과 리디렉션 URI를 입력한다. Google SDK API를 이용한 Login 구현 keyword : google login web SDK 12345678910&lt;script&gt; function init() &#123; console.log('init'); gapi.load('auth2', function() &#123; // oauth2가 로드된 후 실행되는 함수 console.log('auth2 loaded'); &#125;); &#125; &lt;/script&gt;&lt;script src=\"https://apis.google.com/js/platform.js?onload=init\" async defer&gt;&lt;/script&gt;// 앞의 .js 파일 로딩이 끝나면 init 함수를 호출한다는 의미 위 코드를 실행시키면 init이 출력된다. 12345678910111213141516171819202122232425&lt;script&gt; function init() &#123; console.log('init'); gapi.load('auth2', function() &#123; // oauth2가 로드된 후 실행되는 함수 console.log('auth2 loaded'); &#125;); var gauth = gapi.auth2.init(&#123; // Auth setup, GoogleAuth object restores the user's sign-in state from the previous session. client_id: '&#123;내가 생성한 project id&#125;' &#125;); gauth.then(function()&#123; // 성공한다면 앞의 파라매터, 실패한다면 뒤의 파라매터 호출 console.log('init success'); var isLogined = gauth.isSignedIn.get(); console.log('isLogined : ', isLogined); if(isLogined)&#123; // 로그인 됨 document.querySelector('#authBtn').value = 'Logout'; &#125; else &#123; // 로그인 안됨 document.querySelector('#authBtn').value = 'Login'; &#125; &#125;, function()&#123; console.log('init fail'); &#125;)&#125; &lt;/script&gt; Q. 실 서비스중 에러가 발생하면 어떡해야하는가?A. 예를 들어 access_token이 만료가 되었다면, 다시 요청하는 UI를 만든다던지.. 실제 서비스할 때는 추가적으로 작업할 것들이 많다. Google의 다른 기능을 사용하고 싶다면 해당 기능의 페이지로 가서 활성화 시킨다. google drive keyword로 검색 (scope), 사용 방법을 찾아보자. 마무리: 이번 세미나에서는 client-side로 OAuth 기능을 구현하였다. 이는 보안 문제가 발생할 수 있다. server-side로 구현한다면 실습 내용에서 조금 더 추가되는 과정이 있다. RO가 RS에 접속해서, C에게 ~기능을 달라고 요청(권한 허용 링크 클릭)하면 server-side에서 구현시 client-side처럼 access_token을 바로 주지 않는다. RS가 RO에게 authorization code값을 준다. 그리고 어떤 client에게 발급했는지 기록한다. RO는 authorization code를 받아서 client로 보낸다. client는 authorization code를 알게 된다. Client는 RS에 직접 접속해서 client_id와 client_secret, authorization_code 세 값을 RS에게 보내면서 access_token을 요청한다. RS는 authorization_code를 발급했는지 확인하고 어떤 client_id에 발급했는지 확인한다. 이후 access_token을 발행하고 authorization_code를 지운다. 이후 client에게 access_token을 응답한다. 이후 Client(Server) 쪽에 access_token을 보관하고(DB 등) 여러가지 작업을 처리하게된다. RS에서 RO의 아이디를 저장해서 Client에 넘겨줄 수도 있다.: RS에서 access_token을 통해 user_id를 얻었다는 것은 우리 서버에서 식별자로 사용할 수 있다는 의미이다. (만약 Client에 저장한다면 id 그대로 저장하지 않고 facebook_id 등 변조해서 저장하는 것이 좋다): 이 아이디를 얻어냈다는 것 자체가 페이스북 인증에 성공했다는 것이기 때문에 해당 식별자의 주인이라는 것을 확인할 수 있다.: 이를 이용하는 것이 ~로 로그인하기 기능이다. access_token을 발급한 뒤 만료됐을 때 refresh를 해야한다. keyword : refresh token: access_token을 발급 받을 때 보통 refresh_token을 함께 준다.access_token이 만료 되었을 때 refresh_token을 RS에 주면서 access_token을 재발급 받는다. 이는 시스템마다 다를 수 있다. 여기서 추가적으로 공부하고 싶다면,생활코딩에서 Cookie -&gt; Session -&gt; Passport -&gt; Multi user -&gt; google, facebook 로그인 순으로 공부를 추천. 참고 실습 코드 repository","categories":[{"name":"Web","slug":"web","permalink":"https://j2de.github.io/categories/web/"}],"tags":[{"name":"Web","slug":"web","permalink":"https://j2de.github.io/tags/web/"},{"name":"OAuth2","slug":"oauth2","permalink":"https://j2de.github.io/tags/oauth2/"},{"name":"Authrization","slug":"authrization","permalink":"https://j2de.github.io/tags/authrization/"},{"name":"Tacademy","slug":"tacademy","permalink":"https://j2de.github.io/tags/tacademy/"}]},{"title":"Java - Private 생성자","slug":"java-private-constructor","date":"2018-10-14T15:00:00.000Z","updated":"2020-03-19T01:14:24.132Z","comments":true,"path":"2018-10-15-java-private-constructor/","link":"","permalink":"https://j2de.github.io/2018-10-15-java-private-constructor/","excerpt":"","text":"Effective Java 규칙 4 객체 생성을 막을 때는 private 생성자를 사용하라. 유틸리티 클래스 (Utility Class) 정적 메서드나 필드만 모은 클래스로 객체를 생성할 필요가 없는 구조로 이루어진 클래스. 객체 지향적이지 않다는 비판이 있지만 필요한 특정 경우가 존재한다. 유틸리티 클래스를 만드는 경우 자바의 기본 자료형 값에 적용되는 메소드를 모아둘 때 (예 - java.lang.Math) 배열에 적용되는 메소드를 모아둘 때 (예 - java.util.Arrays) 특정 인터페이스를 구현하는 객체를 만드는 팩토리 메소드 (예 - java.util.Collections) final 클래스에 적용할 메소드를 모아놓을 때 (final 클래스는 계승할 수 없다. ) private 생성자의 사용이런 유틸리티 클래스는 객체를 만들지 않고 사용하지만, 생성자를 생략하면 컴파일러가 자동으로 public 기본 생성자(default constructor)를 만든다. 이런 상황을 막기 위해 클래스를 abstract로 선언한다면, 하위 클래스를 정의하는 순간 객체 생성이 가능해진다. 따라서 기본 생성자의 생성을 막고 객체 생성을 막기 위해서는 private 생성자를 사용한다. 1234567public class UtilityClass &#123; // 기본 생성자가 자동 생성되지 못하게하여 객체 생성을 방지 private UtilityClass ()&#123; throw new AssertionError(); &#125; ...&#125; private이므로 클래스 외부에서 객체를 생성하지 못한다. AssertionError는 필수는 아니지만 클래스 내에서 실수로 생성자를 호출하는 것을 알 수 있기 위해 삽입한다. 코드 내에서 명시적으로 확인할 수 없으니 주석으로 표시해주는 것이 바람직하다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java - 싱글턴 패턴(Singleton Pattern)","slug":"java-singleton-pattern","date":"2018-10-13T15:00:00.000Z","updated":"2020-03-19T01:14:07.525Z","comments":true,"path":"2018-10-14-java-singleton-pattern/","link":"","permalink":"https://j2de.github.io/2018-10-14-java-singleton-pattern/","excerpt":"","text":"Effective Java 규칙 3 private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라 Singleton 이란 ? 객체를 하나만 만들 수 있는 클래스보통 유일할 수 밖에 없는 시스템 컴포넌트를 나타낸다. Singleton을 구현하는 방법 private 생성자의 이용 정적 팩터리 메소드 이용 // JDK 1.5 이전의 구현 방식 enum 자료형의 사용 // Effective Java의 추천 방식 Initialization on demand holder idiom // 현재 많이 쓰이는 방식 1. private 생성자 이용12345public class Elvis &#123; public static final Elvis INSTANCE = new Elvis(); // (1) private Elvis() &#123;...&#125; // (2) ...&#125; (2) private 생성자는 (1)의 Elvis.INSTANCE를 초기화할 때 한번 호출 된다. 생성자가 private이므로 한번 생성된 후에는 다시 객체가 생성되지 않는다. 2. static factory method 이용12345public class Elvis &#123; private static final Elvis INSTANCE = new Elvis(); // (1) private Elvis() &#123;...&#125; // (2) public static Elvis getInstance() &#123; return INSTACE; &#125; // (3)&#125; (1)에서 객체를 생성 한 뒤 (3)의 getInstance에서 항상 같은 참조를 반환한다. (2) 생성자가 private이므로 외부에서 new 연산자로 객체를 생성하지 못한다. 1과 2 방식 모두 Eagar Initialization으로 객체가 사용되기 전에 미리 생성한다. 항상 싱글톤 객체가 필요하거나 객체 생성비용이 크지 않을 때 사용한다. 이 방식들은 thread safe하지 않다. 또한 Java의 reflection 기능을 통해 private 생성자를 호출하여 싱글톤 패턴을 깨드릴 수 있다. Lazy Initialization12345678910public class LazyInitialization &#123; private static fianl LazyInitialization INSTANCE; // (1) private LazyInitialization () &#123;&#125; // (2) public static LazyInitialization getInstance ()&#123; // (3) if (INSTACE == null) return new LazyInitialization(); return INSTACE; &#125;&#125; LazyInitialization 방식은 객체가 사용되는 시점에 (3) 객체를 만들어서 반환한다. 이 방식 또한 thread safe하지 않으며 reflection 으로 패턴을 깨뜨릴 수 있다. Thread Safe Initialization12345678910public class ThreadSafeInitialization &#123; private static final ThreadSafeInitialization instance; // (1) private ThreadSafeInitialization () &#123;&#125; // (2) public static synchronized ThreadSafeInitialization getInstance () &#123; // (3) if (instance == null) return new ThreadSafeInitialization(); return instance; &#125;&#125; thread safe하기 위해 (3)synchronized를 사용했다. multi thread 문제는 해소됐지만, 수많은 스레드들이 getInstance를 호출한다면 프로그램의 성능 저하가 일어날 수 있다. 3. enum 자료형의 사용1234567public enum EnumInitialization &#123; INSTACE; public static EnumInitialization getInstance() &#123; return INSTACE; &#125;&#125; enum 자료형을 사용하는 경우 직렬화(Serializable) 클래스를 만들어도 문제가 없으며, reflection 공격에도 안전하다. 또한 instance가 생성될 때 multi thread에도 안전하다. 4. Initialization on demand holder idiom1234567891011public class InitializationOnDemandHolderIdom &#123; private InitializationOnDemandHolderIdom () &#123;&#125; // (1) private static class singletonHolder &#123; // (2) private static final InitializationOnDemandHolderIdom instance = new InitializationOnDemandHolderIdom(); // (3) &#125; public static InitializationOnDemandHolderIdom getInstance()&#123; // (4) return singletonHolder.instance; &#125;&#125; holder를 이용한 초기화 방식으로 클래스 내부에 (2) 내부 클래스에 instance를 생성한다. (4)의 getInstance가 호출될 때 내부 클래스가 참조되며 instance가 (3) static final로 선언되어 있어서 처음 클래스가 로드될 때 최초 한번 객체가 생성된다. 클래스가 생성되는 순간은 thread safe하기 때문에 multi thread 문제에도 안전하다. 현재 Java의 singleton은 이 방식을 많이 사용한다. 참고 자료 java singleton pattern [Design_Pattern] Singleton(싱글톤)의 고도화","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Effective Java","slug":"effective-java","permalink":"https://j2de.github.io/tags/effective-java/"},{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"},{"name":"Design Pattern","slug":"design-pattern","permalink":"https://j2de.github.io/tags/design-pattern/"}]},{"title":"STS - The selection cannot be run on any server.","slug":"sts-cannot-be-run-on-server","date":"2018-09-28T15:00:00.000Z","updated":"2020-03-19T01:36:46.386Z","comments":true,"path":"2018-09-29-sts-cannot-be-run-on-server/","link":"","permalink":"https://j2de.github.io/2018-09-29-sts-cannot-be-run-on-server/","excerpt":"","text":"STS(Eclipse)로 Gradle 프로젝트 생성 후 서버를 찾을 수 없을 경우 에러 화면 The selection cannot be run on any server. 프로젝트 설정 변경 프로젝트 우클릭-&gt;[Properties]-&gt;[Project Facets] Dynamic Web Module과 Java 버전에 맞춰서 추가 이후 서버 실행 시 에러 발생한 경우 Project facet Cloud Foundry Standalone Application version 1.0 is not supported. 위와 같은 [Project Facets]에 들어가서Cloud Foundry Standalone Application을 체크 해제한다.","categories":[{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/categories/troubleshooting/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://j2de.github.io/tags/spring/"},{"name":"STS","slug":"sts","permalink":"https://j2de.github.io/tags/sts/"},{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/tags/troubleshooting/"}]},{"title":"Refactoring과 Test/TDD","slug":"refactoring-and-tdd","date":"2018-09-23T15:00:00.000Z","updated":"2020-03-19T01:34:09.436Z","comments":true,"path":"2018-09-24-refactoring-and-tdd/","link":"","permalink":"https://j2de.github.io/2018-09-24-refactoring-and-tdd/","excerpt":"","text":"리팩토링이란 ?중복을 제거하고 읽기 좋은 코드를 구현하기 위해 구조를 변경하는 것.소스코드의 가독성을 높이고 유지보수를 편하게 하기 위해서 소스코드의 구조를 변경하는 것. 기능상의 결과가 변경되는 것은 아니다. 3원칙을 생각하면서 리팩토링을 연습하자1231. 메소드는 한 가지 책임만 가지도록 구현2. 인덴트 깊이를 1단계로 유지3. else를 사용하지 마라 복잡도가 쉽게 증가하는 원인 : 요구사항의 복잡도가 높은 것이 가장 큰 원인. 리팩토링을 통해 소스코드를 깔끔하게 구현하는 연습을 함으로써 낮춘다. 리팩토링 과정1231. 요구사항을 작은 단위로 나누어 구현가능한 상태로 만드는 작업2. 하나의 요구사항을 완료한 뒤 리팩토링을 하고 넘어갈 것. - 구현 -&gt; 테스트를 통한 결과 확인 -&gt; 리팩토링 테스트 테스트 코드가 있다면, 리팩토링을 통해 프로덕션 코드를 변경하더라도 테스트 코드를 통해 바로 검증할 수 있다. 따라서 리팩토링을 통해 소스코드를 개선하려면 테스트코드가 있어야한다. 테스트와 리팩토링을 함께 연습하는 것이 중요하다. 추가 학습 TDD를 바로 연습하는 것도 좋지만, 우선 JUnit으로 테스트를 검증하는 방식으로 진행하다가 도전해보자. TDD와 리팩토링을 연습할 때 외부 의존관계가 많은 코드(웹 UI, DB 연결된 코드 등)부터 하기보다는 이전에 구현해봤던 기능이나, 외부 의존관계가 없는 코드부터 시작하는 것이 좋다. 연습하기 가장 좋은 코드는 알고리즘이나 유틸리티 성격의 코드이다.","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Test","slug":"server/test","permalink":"https://j2de.github.io/categories/server/test/"}],"tags":[{"name":"Test","slug":"test","permalink":"https://j2de.github.io/tags/test/"},{"name":"TDD","slug":"tdd","permalink":"https://j2de.github.io/tags/tdd/"},{"name":"Refactoring","slug":"refactoring","permalink":"https://j2de.github.io/tags/refactoring/"}]},{"title":"WEB - HTTP","slug":"web-http","date":"2018-09-20T15:00:00.000Z","updated":"2020-03-19T01:37:32.510Z","comments":true,"path":"2018-09-21-web-http/","link":"","permalink":"https://j2de.github.io/2018-09-21-web-http/","excerpt":"","text":"WEB의 구성 요소중 하나인 HTTP의 기본 개념 HTTP (HyperText Trasfer Protocol) 웹의 구성 요소 HTML URL &amp; URI Web Browser &amp; Web Server HTTP 이 때 Client가 Server에게 HTML을 달라고 요청하는 것을 Request,Server가 HTML을 주면서 응답하는 것을 Response라 한다. 사용하고 있는 인터넷 브라우저의 [검사]- [Network] 탭을 통해 웹 브라우저와 웹 서버가 주고받은 http 코드를 볼 수 있다.[Headers]를 통해 Request Headers/Response Headers를 확인할 수 있다. 웹 브라우저가 웹 서버에게 요청한 데이터와 웹서버가 응답한 데이터이다. Request Headers : 방식(GET/POST 등), HTTP 버전, 접속 HOST 등 Response Headers : HTTP 버전, 응답(200,400 등), Content-Length, Content-Type 등 을 표시 1231. 웹브라우저는 사용자가 요청한 정보를 Header라는 텍스트 정보를 만들어서 웹 서버에게 대신 물어보는 역할을 한다. 2. 웹 서버는 자신이 가진 정보를 보내주면서 응답 헤더를 보낸다. 3. 그리고 웹 브라우저는 서버에게 받는 정보를 그려주는 역할을 한다. Request Message Request Header 형식에 대해 검색한다면&gt; http request header format Request Header의 구성 요소 Request Line + Request Headers = Request Message Header Blank Line 으로 구분 실제 전송하는 내용 = Body(= Payload) Request Line전송 방식을 나타낸다. 123- GET : 데이터를 웹서버로부터 가져올 때- POST : 데이터 전송할 때... HTTP/1.1 메소드 GET : 리소스 획득리퀘스트 URI로 식별된 리소드를 가져올 수 있도록 요구한다. 소스가 텍스트면 그대로 반환, GGI같은 프로그램이면 실행해서 출력된 내용을 반환한다. POST : 엔티티 전송GET으로도 엔티티를 전송할 수 있지만 일반적으로 POST를 사용한다. PUT : 파일 전송파일을 전송하기 위해 사용된다. 하지만 HTTP/1.1 PUT자체에는 인증 기능이 없어서 누구든지 파일 업로드가 가능해 보안 상의 문제가 있다. 웹 애플리케이션 등의 인증 기능과 함께 쓰거나 REST와 같은 웹끼리 연계하는 설계 방식을 사용할 때 이용하는 경우가 있다. HEAD : 메세지 헤더 취득GET과 같은 기능이지만 메세지 바디를 돌려주지 않는다. URI 유효성과 리소스 갱신 시간등을 확인하는 목적 등으로 사용된다. DELETE : 파일 삭제파일을 삭제하기 위해 사용된다. PUT 메소드와 반대로 동작하며 리퀘스트 URI로 지정된 리소스의 삭제를 요구한다. 단점과 이용또한 PUT과 마찬가지로 인증 기능이 없다. OPTIONS : 제공하고 있는 메소드의 문의리퀘스트 URI로 지정한 메소드가 제공하고 있는 메소드를 조사하기 위해 사용한다. TRACE : 경로 조사WEB 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백(loop-back)을 발생시킨다. 리퀘스트를 보낼 때 Max-Forward라는 헤더 필드에 수치를 포함시켜 서버를 통과할 때마다 수치를 줄여간다. 0이 된 곳을 끝이로 리퀘스트를 수신한 측해서 상태 코드 200 OK response를 돌려준다.클라이언트는 TRACE 메소드를 사용함으로써 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있다.하지만 TRACE 메소드는 XST와 같은 보안상의 문제가 있기 때문에 보통 사용되지 않는다. CONNECT : 프록시에 터널링 요구TCP 통신을 터널링 시키기 위해 사용된다. 주로 SSL이나 TLS 등의 프로토콜로 암호화된 것을 터널링 시키기 위해서 사용된다. CONNECT 메소드 양식1CONNECT 프록시 서버 : 포트 HTTP 버전 Request Headers Host : 요청하는 웹서버의 주소로 필수로 기입되어있어야 한다. 웹 호스팅 서비스(Web hosting service) : 인터넷 호스팅 서비스의 일종으로 개인과 단체가 월드 와이드 웹을 통하여 웹사이트를 제공하는 것을 뜻한다. 가상 호스트 : 하나의 웹서버가 여러개의 도메인을 서비스할 수 있는데, 그런 경우에 A라는 웹서버가 A.com B.com C.com 호스팅을 하고, 각 주소별로 다른 웹사이트라면 HOST에 적힌 주소에 따라서 다른 정보를 보내줄 수 있다. Post : 한대의 컴퓨터에 여러개의 서버가 설치될 수 있는데 포트번호로 구분한다. User-Agent : 웹 브라우저의 다른 표현. 사용자의 OS 환경도 확인할 수 있다. 사용자 정보를 수집하거나 bot을 확인 후 차단할 수 있다. Accept-Encoding : 전송하는 데이터 양이 많은 경우 압축해서 보내고 받아서 풀어서 사용한다. 웹 브라우저가 어떤 압축 방식을 지원하는지 알려준다. If-Modified-Since : 데이터를 요청할 때마다 다운로드 받는 것은 비효율적이으로 데이터를 요청할 때마다 항상 다운 받지 않는다. 따라서 내가 갖고 있는 파일을 마지막으로 언제 다운로드받은 것인지 웹서버에게 알려주고 웹 서버가 응답할 때 최신 여부를 비교해서 전송 또는 비전송 여부를 결정한다. Response Message HTTP 응답 메세지 형식에 대해 검색한다면&gt; http response header format status: HTTP version, status code(응답 결과), phrase(응답 결과를 풀어쓴 것)를 보여준다. 예) HTTP/1.1 200 OK Http status code 1xx : Information // 리퀘스트를 받아들여 처리중 2xx : Success // 리퀘스트를 정상적으로 처리했음 200 OK: 클라이언트가 보낸 리퀘스트를 서버가 정상 처리 했음 201 Created 204 No Content: 서버가 리퀘스트를 받아서 처리하는데 성공했지만 돌려줄 리소스가 없는 경우 206 Partial Content: Range에 의해서 범위가 지정된 리퀘스트에 의해 서버가 부분적으로 GET 리퀘스트를 받았음을 나타낸다.리스폰스에는 Content-Range로 지정된 범위의 엔티티가 포함된다. 3xx : Redirection // 리퀘스트를 완료하기 위해서 추가동작이 필요 4xx : Client Errors // 서버는 리퀘스트 이해 불가능 400 Bad Request: 리퀘스트 구문이 잘못되었음. 브라우저는 이것을 200 OK와 같은 취급을 한다. 401 Unauthorized: 송신한 리퀘스트에 HTTP인증 정보가 필요한다는 것을 나타낸다. 403 Forbidden: 접속하면 안되는 곳을 접속했을 때 404 Not Found: 어떤 주소를 요청했는데 서버에 없는 경우 5xx : Server Errors // 서버의 리퀘스트 처리 실패 500 Internel Server Error: 서버에서 리퀘스트를 처리하는 도중에 에러가 발생함. 503 Service Unavaliable: 일시적으로 서버가 과부하 상태이거나 점검 중이기때문에 현재 리퀘스트를 처리할 수 없음을 나타냄. headers Content-Type : text/HTML 웹 브라우저가 Content-Type을 보고 HTML로 해석해서 보여준다. Content-Length : 전체 크기(Byte) Content-Encoding : 압축 방식을 알려준다. Last-Modified : 이 정보가 마지막으로 수정된 날짜를 보여준다. 웹브라우저와 웹 서버의 커뮤니케이션 과정 웹 브라우저가 Request Headers를 생성하고 추가로(POST인 경우 등) 한줄 띄우고 웹서버로 전송할 정보를 담아서 메세지를 만든 다음에 인터넷을 통해 웹서버로 보낸다. 웹서버는 메세지를 해석해서 응답메세지를 만든다.(Response Headers) 그리고 한줄 띄우고 실제 HTML코드를 합쳐서 인터넷을 통해 요청한 컴퓨터로 보낸다. 웹브라우저는 이를 통해 헤더와 본문을 참조해서 사용자에게 화면을 보여준다. 앞으로 공부할 주제 HTTP와 HTTPS(Http Secure)의 차이(SSL) Cache(저장) : 데이터를 항상 새로 받아오지 않고 따로 저장해둠으로써 속도를 향상시킨다. 문제점 : 내용이 갱신되었을 때 웹 브라우저가 알아채지 못한다.(F5가 캐시 갱신) 해결하기 위한 테크닉 : cache-control / pragma / application cache 등 - 성능 향상에 관심이 있다면 살펴볼 문제 개인화 : 이전 로그인 기록을 웹사이트 / 웹브라우저가 기억하고 있는 것 Cookie 이용 Cookie : 쿠키값을 웹 브라우저에 설정하면 접속할때마다 설정된 쿠키값을 서버에 전송 함으로써 사용자의 상태를 유지, 식별할 수 있다. web storage : 쿠키보다 발전되고 안전한 기술. proxy server : 웹 브라우저와 웹 서버 사이에 중계 서버를 두어서 중간에 있는 서버가 캐시를 대신해주거나 보안과 관련된 공격을 막아주거나 사용자의 요청을 여러대로 분산하는 경우 등의 역할을 한다. Network Monitoring : 가장 간단한 툴은 웹 브라우저에 개발자 도구의 [네트워크] 모니터링 기능. 또는 Wireshark. 컴퓨터의 모든 네트워크 트래픽을 볼 수 있다. 출처 : 생활코딩 - HTTP","categories":[{"name":"Web","slug":"web","permalink":"https://j2de.github.io/categories/web/"}],"tags":[{"name":"생활코딩","slug":"생활코딩","permalink":"https://j2de.github.io/tags/생활코딩/"},{"name":"Web","slug":"web","permalink":"https://j2de.github.io/tags/web/"},{"name":"HTTP","slug":"http","permalink":"https://j2de.github.io/tags/http/"}]},{"title":"WEB - OAuth2.0","slug":"web-oauth2","date":"2018-09-19T15:00:00.000Z","updated":"2020-03-19T01:37:36.214Z","comments":true,"path":"2018-09-20-web-oauth2/","link":"","permalink":"https://j2de.github.io/2018-09-20-web-oauth2/","excerpt":"","text":"OAuth2.0 인증 시스템의 원리 OAuth2OAuth에는 세 개의 참여자가 등장한다. mine : 내 서비스 User : 1의 사용자 Thier : 연동하려는 서비스 (1)이 (2)를 통해 (3) 서비스를 사용한다면, (3)의 서비스에 접근할 수 있도록 허가를 받아야한다. (2)에게 ID, PW를 전달 받아서 저장해서 (1)에서 (3) 접속할 때 사용한다면 간단하지만 위험할 것이다. 따라서 OAuth를 이용해야한다. OAuth는 accessToken이라는 일종의 비밀번호를 발급해 사용하기 때문에 안전하게 내 서비스와 외부 서비스를 상호작용할 수 있다. 장점 전달하는 것이 아이디와 비밀번호가 아니다. (3)의 서비스의 필요한 부분만 부분적으로 허가를 받아서 사용할 수 있음 액세스 토큰을 통해 (3)에 접근해서 CRUD 작업을 할 수 있음 accessToken을 얻어내는 핵심 원리에 대해Role mine -&gt; Client User -&gt; Resource Owner Thier -&gt; Resource Server : 데이터를 가지고 있는 서버+ Authrization Server : 인증 관련 서버 Resource Server와 Authorization Server는 다르지만 우선 여기서는 Resource Server와 같이 설명한다. 등록하는 절차Client가 RS를 이용하기 위해서는 RS서버의 승인을 사전에 받아놓아야 한다.이를 등록(register)이라 한다. RS마다 각각 다르지만 일반적으로 아래 세개는 동일하다. Client ID: (1)을 식별하는 식별자 아이디 Client Secret: (1)의 비밀번호, 외부에 노출되면 안된다. Authorized redirect URIs: RS가 권한을 부여하는 과정에서 Authorized Code를 주는데 이 주소로 전달하게 된다. 해당 주소가 아닌 곳에서 요청이 들어오면 무시한다. Resource Owner의 승인등록하게 되면 RS는 Client Id/ Client Secret / redirect URL을 알게 되고,Client는 Client Id/ Client Secret을 알게 된다. 이때 Client는 redirect URL에 해당하는 페이지는 구현해놓고 있어야한다. RS의 기능이 4개라면, (A,B,C,D)Client는 B와 C의 기능만 필요하다면, 최소한의 기능만 인증받는 것이 좋다. 이하 Resource Server = RSResource Owner = ROClient = C 또는 Client로 표기 인증 과정 RO는 C에 접속한다. 접속하는 과정에서 RS에 접속이 필요하다면 12(예)페이스북으로 로그인하기..or 페이스북의 어떤 기능이 필요하다는 화면 을 통해 사용자의 동의를 구한다.이때 보이는 로그인 버튼은 단순히 Resource Server, Client Id, 사용하려는 기능(scope), redirect id값을 링크로 제공해주면 된다. (2)를 통해 RO가 RS에 접속하면로그인 되어있지 않은 경우 로그인 요청을 한다. 로그인이 되어 있다면 client id/redirect id를 확인해서, 같다면 scope에 해당하는 권한을 C에게 줄것인지 확인하는 메세지를 RO에게 보내게 된다. RO가 확인 후 허용한다면 허용 정보를 RS에게 보낸다. 그러면 특정 유저가 어떤 기능을 허용하는데 동의한다는 정보를 RS에 저장하게된다. (DB 등) Resource Server의 승인 위의 과정 이후 accessToken을 발급하기 전에 임시 비밀번호인 Authrization Code를 RS가 RO에게 보낸다. RO는 RS가 보낸 패킷의 Location 헤더 값에 의해서 C의 주소로 이동하게 된다(redirect). 이때 C에게 Authrization Code를 알려준다. 이제 Client는 Authrization Code로 RS에 직접 접속하게 된다. 이때 Authrization Code, redirect id, client secret 정보를 RS에게 보낸다. RS는 Authrization Code를 보고 Client를 식별한다. accessToken 발급 RS는 accessToken을 발급한다. 그리고 accessToken을 C에 응답한다. 이 accessToken을 C는 내부적으로 저장한다. API 호출= Resource Server 핸들링 Client가 Resource Server url에 접속하면 데이터를 보여준다.즉 URL이 API처럼 되는 것.-&gt; 이 URL은 accessToken이 있어야 제대로 출력된다.따라서 accessToken은 절대 남에게 공개하면 안된다. API 핸들링 방식은 RS마다 다르므로 공식 문서를 찾아봐야한다. 구글 api 사용 방법을 검색 google api accessToken oauth 구글은 accessToken을 Query Parameter로 보내거나 헤더의 Authorization에 Bearer로 보내는 두가지 방식을 사용한다. 두가지 방식 중 헤더 값으로 Bearer를 보내는 방식이 더 선호된다. 이 때 curl을 통해 좀 더 손쉽게 보낼 수 있음. curl은 웹페이지를 다운로드 받는 프로그램 Refresh TokenaccessToken은 수명이 존재한다. 일반적으로 1~2시간, 길면 60~90일 등 수명이 끝나면 api가 정보를 주지 않는다. 수명이 끝나면 accessToken을 다시 발급 받아야 하는데 그때마다 사용자에게 인증을 받기 힘들다면 refresh token을 사용하면 된다. refresh token에 대해 검색 oauth 2.0 rfcrfc: 인터넷 관련된 표준안 위의 문서에서 Oauth-&gt;refresh token 항목을 참고하자. 보통 accessToken을 발급할 때 refresh token도 발급 받는 경우가 많다.만료 됐을 때 refresh token을 보내면서 accessToken을 다시 발급 받는다. 이때 refresh token을 같이 다시 발급 받는 경우도 있다. 리소스 서버마다 refreshing 방법이 다르기 때문에 메뉴얼을 참고해야한다. 기타Federated Identity : Login with Google과 같은 기술. OAuth를 사용한다. 출처: 생활코딩 - OAuth","categories":[{"name":"Web","slug":"web","permalink":"https://j2de.github.io/categories/web/"}],"tags":[{"name":"생활코딩","slug":"생활코딩","permalink":"https://j2de.github.io/tags/생활코딩/"},{"name":"Web","slug":"web","permalink":"https://j2de.github.io/tags/web/"},{"name":"OAuth2","slug":"oauth2","permalink":"https://j2de.github.io/tags/oauth2/"},{"name":"Authrization","slug":"authrization","permalink":"https://j2de.github.io/tags/authrization/"}]},{"title":"STS - CLI 환경에서 git pull/clone 후 STS에서 프로젝트 import 하기","slug":"import-project-from-sts-after-git-pull-clone-in-cli","date":"2018-09-10T15:00:00.000Z","updated":"2020-03-19T01:33:57.374Z","comments":true,"path":"2018-09-11-import-project-from-sts-after-git-pull-clone-in-cli/","link":"","permalink":"https://j2de.github.io/2018-09-11-import-project-from-sts-after-git-pull-clone-in-cli/","excerpt":"","text":"Mac Terminal에서 기존 프로젝트 git Clone 이후 STS에서 프로젝트 import 프로젝트 import 이후 프로젝트 실행 안되는 경우 CLI 환경에서 Git Clone 후 STS에서 프로젝트 import 하기clone 한 프로젝트 상위 폴더에서 STS 실행 -&gt; [Package Explorer] 우클릭 -&gt; [import] -&gt; [General]-[Projects from Folder or Archive] -&gt; 프로젝트 폴더 선택 import 후 Server에서 프로젝트 인식이 안되는 경우 Server 우클릭 -&gt; [Add and Remove] -&gt; [there are no resources that can be added or removed from the server] error 프로젝트가 웹 프로젝트가 아니기 때문, 따라서 프로젝트 설정을 변경해주어야 함. 프로젝트 우클릭 -&gt; [Properties] -&gt; [Project Facets] -&gt; Dynamic Web Module, Java, Javascript 선택 -&gt; aplly","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Spring","slug":"server/spring","permalink":"https://j2de.github.io/categories/server/spring/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://j2de.github.io/tags/spring/"},{"name":"STS","slug":"sts","permalink":"https://j2de.github.io/tags/sts/"},{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/tags/troubleshooting/"}]},{"title":"Java equals method, instanceof, @Override","slug":"java-equals-method-instanceof-override","date":"2018-08-27T15:00:00.000Z","updated":"2020-03-19T01:06:31.211Z","comments":true,"path":"2018-08-28-java-equals-method-instanceof-override/","link":"","permalink":"https://j2de.github.io/2018-08-28-java-equals-method-instanceof-override/","excerpt":"","text":"equals method instanceof @Override equals methodObject 클래스는 모든 Java 클래스의 최고 상위 부모 클래스이다.따라서 Object 클래스의 메소드는 모든 Java 클래스가 상속 받는다. Object 클래스에 equals 메소드가 정의 되어 있는데,equals 메소드는 기본적으로 객체의 내부 값이 동일한지 비교할 때 사용한다.객체를 == 연산자로 비교한다면 객체 내부 값이 동일한지 비교하는 것이 아닌 두 참조가 같은 객체를 가리키고 있는지 검사한다. 12345String s1 = \"hello\";String s2 = \"hello\";s1.equals(s2); // (1) trues1 == s2; // (2) false 참조 변수 s1, s2 변수가 참조하는 객체의 내부 값이 동일하기 때문에 (1)은 true가 된다.하지만 == 연산자는 같은 참조를 가리키고 있는지 검사하는 것이므로 false가 된다. equality / identityequality : 두 객체의 내부 값이 같은지 비교identity : 하나의 객체인지 비교 equals method를 재정의 해야하는 이유자주 사용하는 클래스의 경우 equals method가 재정의 되어 있지만, 새 클래스를 구현하는 경우 equals method를 재정의해야 의도한대로(equality 비교) equals를 사용할 수 있다.Object 클래스에서 상속되는 equals 메소드는 identity를 비교하는 방식으로 구현되어 있기 때문이다.따라서 모든 멤버 변수 값이 같은지 비교하는 형태로 equals 메소드를 재정의 해야한다. instanceof 연산자객체가 속한 클래스를 확인할 때 instanceof 연산자를 사용한다. 12String s = \"hello\";System.out.println(s instanceof String); // true 참조 변수 s가 String 클래스 객체를 가리키므로 true 12Object s = \"hello\";System.out.println(s instanceof String); // true Java에서는 부모 클래스 타입의 참조 변수가 자식 클래스 객체를 가리킬 수 있다.위 코드에서는 참조 변수 s가 String 클래스 객체를 가리키므로 결과는 true이다. @Override Annotation부모 클래스의 메소드를 자식 클래스에서 재정의(Override)할 때 이 어노테이션을 붙여준다. 생략가능하지만 붙여주는 것이 좋다. @Override Annotation의 장점(1) 부모 클래스의 메소드와 재정의하는 메소드를 자동으로 검사한다.부모 클래스의 메소드를 자식 클래스에서 재정의 하는 경우, 메소드 이름, 파라미터 수와 타입, 리턴 타입이 일치해야한다. 어노테이션을 붙이면 이 부분을 자동으로 검사해준다.(2) 부모 클래스의 메소드를 재정의하는 것을 명시적으로 확인이 가능해서 코드 코드 읽는데 편리하다. equals method 재정의1234567891011Class Person&#123; // 사용자가 정의한 클래스 String name; int age;&#125;...@Overridepublic boolean equals(Object obj)&#123; // (1) if((obj instanceof Person) == false) return false; // (2) Person p = (Person)obj; return this.name.equals(p.name) &amp;&amp; this.age == p.age; // (3)&#125; (1) 부모 클래스의 파라미터 타입과 일치해야하기 때문에 Object 객체를 받는다.(2) instanceof 메소드로 Person 객체가 아니라면 false를 리턴한다.(3) 해당 줄의 this.name이 null일 경우 NullPointerException이 발생할 수 있기 때문에 수정이 필요하다. 1return (this.name == null ? p.name == null : this.name.equals(p.name)) &amp;&amp; this.age == p.age; 첫번째로 null 값을 한번 더 체크 하는 방식으로 수정할 수 있다. 123import java.util.Objects;...return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age; 두번째로 Object 클래스의 equals 메소드를 활용해 구현한다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"Java 기본 자료형과 참조형 / String Class","slug":"java-primary-refference-type","date":"2018-08-26T15:00:00.000Z","updated":"2020-03-19T01:06:21.176Z","comments":true,"path":"2018-08-27-java-primary-refference-type/","link":"","permalink":"https://j2de.github.io/2018-08-27-java-primary-refference-type/","excerpt":"","text":"reference type vs value type String Class Java 소스 파일과 패키지 규칙 자바 소스 파일하나에 public 클래스는 한개만 들어있어야 한다 public 클래스 이름과 소스 코드 파일명이 정확히 일치해야함. 클래스가 속한 패키지 이름과 소스코드 파일이 위치한 폴더 이름이 대소문자까지 일치해야함. JSP프로젝트 에서는 클래스는 반드시 어떤 패키지 아래 있어야 한다. String Class Java 문자열은 대표적인 String 클래스 String 객체는 생성된 후 문자열 값이 수정될 수 없다. (Immutable Object) String Class의 문자열 수정 메소드는 문자열을 수정하는 것이 아닌, 새 문자열을 만들어 수정된 새 문자열 객체를 리턴한다. String Class 알아야 할 필수 메소드 char charAt(int index) int compareTo(String s) int compareToIgnoreCase(String s) boolean contains(CharSequence s) boolean endWith(String s) boolean equals(Object s) boolean equalsIgnoreCase(Object s) static String format(String format, Object … args) int indexOf(String s) boolean isEmpty() int lastIndexOf(String s) int length boolean matches(String regex) String replace(CharSequence s1, CharSequence s2) String replaceAll(String regex, String s2) String[] split(String regex) boolean startsWith(String s) String substring(int beginIndex) String substring(int beginIndex, int endIndex) String toLowerCase() String toUpperCase() String trim() static String valueOf(int i) static String valueOf(Double d) 참고 : Java7 Reference Immutable Object 대표적으로 String 객체. String 객체는 생성된 뒤 문자열 값을 수정할 수 없다. String의 수정 메소드는 this 문자열을 수정하는 것이 아니라 수정한 내용으로 새 문자열 객체를 만들어서 return 한다. Value Object 기본 자료형과 같은 방식으로 사용할 수 있도록 만들어진 객체. ex) int -&gt; Integer Object Class Java 언어에서 모든 클래스의 부모 클래스 Object Class 알아야할 필수 메소드 protected Object clone() boolean equals(Object obj) protected void finalize() Class&lt;?&gt; getClass() int hashCode() String toString() value type1int i = 1; 변수에 값이 대입되는 자료형을 값 타입(value type)이라 함.java의 기본 자료형은 모두 value type이다. reference type1String s = \"hello world\"; 객체를 가리키는 주소같은 것을 참조(reference)라 하며,변수에 값이 아닌 참조가 대입되는 자료형을 참조 타입(reference type)이라 한다. Java 클래스의 객체는 모두 참조 타입이다.Java의 문자열은 String Class에 속해서 참조 타입이다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Java","slug":"programming/java","permalink":"https://j2de.github.io/categories/programming/java/"}],"tags":[{"name":"Java","slug":"java","permalink":"https://j2de.github.io/tags/java/"}]},{"title":"코딩야학 Javascript 12일차","slug":"codingyahac-javascript-12","date":"2018-08-24T15:00:00.000Z","updated":"2020-03-19T01:09:18.125Z","comments":true,"path":"2018-08-25-codingyahac-javascript-12/","link":"","permalink":"https://j2de.github.io/2018-08-25-codingyahac-javascript-12/","excerpt":"","text":"스터디에서 다룬 내용생활코딩 WEB2 Javascript ~라이브러리와 프래임워크 파일로 쪼개서 정리script 코드를 여러 html에 적용하는 경우공통된 script 코드를 .js 파일로 만들어 분리한 뒤 해당 html의 script 태그에 적용한다. 1&lt;script src=\"colors.js\"&gt;&lt;/script&gt; 웹브라우저 검사의 [Network] 탭을 보면 웹페이지를 로딩하기 위해 필요한 파일 목록이 보이는데 여기에 colors.js가 있는 것을 확인할 수 있다. .js로 파일을 추가해 정리하면, 작성한 코드를 재사용할 수 있으며, 변화를 동시에 반영할 수 있다. 따라서 유지보수가 편리해진다. 또한 코드의 의미를 파일의 이름을 통해 확인할 수 있다. js 파일을 분리하는 경우 브라우저에 어플리케이션을 로드할 때 웹서버에 추가로 접근하게 된다. (html과 js 파일 각각 받아오기 때문)비효율적이게 보이지만 이런 방식을 사용하는 것이 훨씬 효율적이다. 왜냐하면 cache를 이용해 파일을 다운로드해 두기 때문이다. Library &amp; Framework (라이브러리와 프레임워크)소프트웨어를 혼자 다 만드는 경우는 거의 없다.타인이 만들어 둔 기능을 가져다 쓰는 경우가 대부분이다. Library내가 만들고자 하는 부품들을 재사용 하기 쉽도록 정리정돈 해둔 것. 부품을 가져오는 느낌. Framework만들고자하는 것이 있을 때 그것이 무엇이냐에 따라서(게임, 웹, 채팅 …) 그것을 만들기 위해 언제나 필요한 공통적인 것을 프레임워크가 제공하고 필요한 달라지는 부분만 우리가 수정해 제작할 수 있도록 하는 반제품과 같은 것. = 다른 사람과 협력하기 위한 모델들이라는 면에서 Library와 Framework는 같다. jQuery직접 JS를 사용하는 것보다 생산성이 훨씬 올라간다. jQuery를 사용하는 방법 12341. 파일을 직접 다운로드 해 프로젝트 폴더에 포함시킨다. : 따로 서버에 파일을 올리는 등 추가 작업이 필요.2. CDN 이용 (Content Delivery Network) : 자기들의 서버에 파일을 보관하고 우리는 src 태그를 이용해 가져다 사용할 수 있다. 처리해야할 태그들이 여러개 있을 때 반복문을 이용하지만,jQuery를 이용하면 반복문을 쓰지않고 할 수 있다. jQuery css 검색 12345678var alist = document.querySelectorAll('a');var i = 0;while(i&lt;alist.length)&#123; alist[i].style.color = color; i = i+1;&#125;...$('a').css('color',color); $라는 이름의 함수를 이용한다. 해당 웹페이지의 모든 a 태그를 jquery로 제어한다는 의미이다.검색 결과를 바탕으로 jquery로 css를 사용하기 위해 .css를 이용한다. 첫번째 인자로 a 태그의 color값을, 두번째 인자로 파라매터로 들어온 color를 받는다. 위의 javascript 코드와 같은 동작을 한다. UI vs APIUI(User Interface)사용자가 시스템을 조작하기 위해 사용하는 인터페이스를 UI라 한다. API(Application programming Interface)Application을 만들기 위해서 프로그래밍을 할 때 사용하는 조작장치를 의미. 수업을 마치며이제 필요한 것은 공부보다는 실습, 실습보다는 프로젝트.시작이 늦어질수록 공부를 많이할 수록 자신의 코드를 긍정하기 어렵다. 자신의 프로젝트를 시작할 때 모든 개념을 총동원하려고 하지 말아라. 필수불가결한 최소한의 도구 만을 이용해 문제를 해결하도록 해보자. (는 프로그래밍을 처음 시작한 사람에게 해당하는 말인 것 같다.) 최소한의 것으로 해결되지 않는 순간이 올 때 조건문, 함수, 객체 등을 신중하게 도입해가며 사용해봐라. 또 다시 한계를 만났을 때 실습을 멈추고 공부를 시작해라. 추천 검색어 document웹페이지의 어떤 태그를 삭제하거나 자식 태그를 추가하고 싶다면, document 객체를 살펴보자 DOM(Document Object Model)document에서도 찾을 수 없다면 DOM으로 수색범위를 넓혀보자. document 객체는 DOM의 일부이다. window웹브라우저 자체를 제어해야한다면 window 객체를 찾아보자. 현재 열려있는 웹페이지의 주소, 새창을 연다면, 웹브라우저의 화면 크기를 자바스크립트를 통해 알아야한다면. ajax웹페이지를 리로드하지 않고 정보를 변경하고 싶다면. 현대적인 웹앱의 필수 기술. cookie웹페이지가 리로드 되어도 현재 상태를 유지하고 싶다면 cookie를 학습. cookie를 통해 사용자를 위한 개인화된 서비스를 제공할 수 있다. offline web application인터넷이 끊겨도 동작하는 웹페이지를 만들고 싶다면, 이 키워드를 찾아보자. webRTC화상통신 웹앱을 만들고 싶으면, speech사용자의 음성을 인식하고 음성으로 정보를 전달하고 싶다면 speech API를 찾아보자. webGL3차원 그래픽으로 게임과 같은 것을 만들고 싶으면 찾아보라. webVR가상현실에 관심이 많다면,…","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Javascript","slug":"programming/javascript","permalink":"https://j2de.github.io/categories/programming/javascript/"}],"tags":[{"name":"Javascript","slug":"javascript","permalink":"https://j2de.github.io/tags/javascript/"},{"name":"생활코딩","slug":"생활코딩","permalink":"https://j2de.github.io/tags/생활코딩/"}]},{"title":"코딩야학 Javascript 11일차","slug":"codingyahac-javascript-11","date":"2018-08-23T15:00:00.000Z","updated":"2020-03-19T01:09:12.677Z","comments":true,"path":"2018-08-24-codingyahac-javascript-11/","link":"","permalink":"https://j2de.github.io/2018-08-24-codingyahac-javascript-11/","excerpt":"","text":"스터디에서 다룬 내용생활코딩 WEB2 Javascript ~객체 객체 간단히 정의하면, 정리정돈의 수단 함수를 통해 로직의 이름을 부여하는 것도 좋은 전략이다. document도 객체이다. querySelector 또한 document에 속해있는 함수이다. 객체에 속해 있는 함수는 메소드라 한다. 배열은 정보를 담는 그릇, 정보가 순서대로 정보가 저장된다. 객체는 순서 없이 정보를 저장하는 그릇이다. 객체 쓰기와 읽기 객체 생성 및 가져오기 12345var coworkers = &#123; \"programmer\":\"koda\", \"designer\":\"sso\" &#125;;document.write(\"programmer : \"+coworkers.programmer); 객체에 데이터 추가 12coworkers[\"data scientist\"] = \"yangpa\";document.write(\"data scientist : \"+coworkers[\"data scientist\"]+\"&lt;br&gt;\"); 위와 같이 띄어쓰기가 있는 데이터도 추가가 가능하다. 객체와 반복문 생성된 객체에 어떤 데이터가 있는지 모조리 가져와야할 때 검색어 javascript object iterate 123for(var key in coworkers)&#123; document.write(key+'&lt;br&gt;');&#125; coworkers에 있는 key 값을 가져오는 코드이며 순서를 보장하지 않는다.&quot;programmer&quot;:&quot;koda&quot;의 programmer가 key에 해당한다. (배열은 인덱스라 표현 - 순서가 있음) 123for(var key in coworkers)&#123; document.write(coworkers[key]+'&lt;br&gt;');&#125; 객체를 생성할 때 배열의 형식을 이용하지만 인덱스의 자리에 키값을 넣는다. 따라서 접근할 때 key로 접근한다. 객체 프로퍼티와 메소드객체는 데이터를 담을 수 있다. 문자, 배열, 숫자 등객체는 함수도 담을 수 있다. 123456coworkers.showAll = function()&#123; for(var key in this)&#123; document.write(key+' : '+this[key]+'&lt;br&gt;'); &#125;&#125;coworkers.showAll(); 객체에 소속된 함수를 만들 수 있다. 이를 메소드라 한다.객체에 소속된 변수는 프로퍼티라 한다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Javascript","slug":"programming/javascript","permalink":"https://j2de.github.io/categories/programming/javascript/"}],"tags":[{"name":"Javascript","slug":"javascript","permalink":"https://j2de.github.io/tags/javascript/"},{"name":"생활코딩","slug":"생활코딩","permalink":"https://j2de.github.io/tags/생활코딩/"}]},{"title":"코딩야학 Javascript 10일차","slug":"codingyahac-javascript-10","date":"2018-08-22T15:00:00.000Z","updated":"2020-03-19T01:09:07.336Z","comments":true,"path":"2018-08-23-codingyahac-javascript-10/","link":"","permalink":"https://j2de.github.io/2018-08-23-codingyahac-javascript-10/","excerpt":"","text":"스터디에서 다룬 내용생활코딩 WEB2 Javascript ~함수의 활용 학습할 내용 함수의 기본 문법 Parameter, Argument return 함수의 기본 문법반복문을 사용할 수 없는 경우 (연속적이지 않다면)함수가 필요하다. 1234function two()&#123; document.write('&lt;li&gt;2-1&lt;/li&gt;'); document.write('&lt;li&gt;2-2&lt;/li&gt;');&#125; Parameter &amp; Argument (매개변수와 인자)자판기, 수학적인 함수 입력과 출력이 존재. 프로그래밍의 함수또한 마찬가지이다. 입력값에 따라 다른 값을 출력하고 싶다면 매개변수와 인자를 이용 한다. 1234567891011&lt;script&gt; function onePlusOne()&#123; document.write(1+1+'&lt;br&gt;'); &#125; onePlusOne(); function sum(left, right) &#123; // left, right는 Parameter document.write(left+right+'&lt;br&gt;'); &#125; sum(2,3); // 5, 2와 3은 Argument sum(3,4); // 7&lt;/script&gt; Return (출력) 표현식이란 ? 1+1의 결과 값 2 : 1+1은 2에 대한 표현식 1===1의 결과 값 true : true는 1===1에 대한 표현식 return을 이용해 표현식을 이용함으로써 함수의 활용도를 높일 수 있다. 123456function sum2(left, right)&#123; // 5에 대한 표현식이 되도록. return left+right; &#125; document.write(sum2(2,3)+'&lt;br/&gt;'); document.write('&lt;div style=\"color:red\"&gt;'+sum2(2,3)+'&lt;/div&gt;&lt;br/&gt;'); document.write('&lt;div style=\"font-size:3rem;\"&gt;'+sum2(2,3)+'&lt;/div&gt;'); 함수의 활용onclick안의 this는 이벤트 안의 태그를 가르키도록 되어있다독립된 함수의 this는 해당 태그가 아닌 전역 객체를 가리키게 되어 있다. 웹브라우저 전역 객체는 window이다. 따라서 태그에서 함수를 실행시킬때 this 매개변수를 주고함수에서 (관례적으로)self라는 이름으로 받는다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Javascript","slug":"programming/javascript","permalink":"https://j2de.github.io/categories/programming/javascript/"}],"tags":[{"name":"Javascript","slug":"javascript","permalink":"https://j2de.github.io/tags/javascript/"},{"name":"생활코딩","slug":"생활코딩","permalink":"https://j2de.github.io/tags/생활코딩/"}]},{"title":"코딩야학 Javascript 9일차","slug":"codingyahac-javascript-9","date":"2018-08-21T15:00:00.000Z","updated":"2020-03-19T01:09:01.879Z","comments":true,"path":"2018-08-22-codingyahac-javascript-9/","link":"","permalink":"https://j2de.github.io/2018-08-22-codingyahac-javascript-9/","excerpt":"","text":"스터디에서 다룬 내용생활코딩 WEB2 Javascript ~함수예고 7~8일차 내용은 생략함. 배열과 반복문의 활용 Document.querySelector(&#39;a&#39;) : a 태그에 대한 쿼리를 하나만 가져온다. 검색 Javascript get element by css selector multiple 검색 결과 : Document.querySelectorAll(&#39;a&#39;) : 결과에 대해 배열로 가져온다. 위 코드를 이용해 반복문으로 태그를 하나하나 꺼내서 스타일 속성을 지정할 수 있다. 123456var alist = document.querySelectorAll('a');var i = 0;while(i&lt;alist.length)&#123; alist[i].style.color = 'powderblue'; i = i+1;&#125; 함수를 활용한 리팩토링1234567891011121314151617181920212223242526272829303132&lt;script&gt; function nightDayHandler(self)&#123; var target = document.querySelector('body'); if(self.value === 'night')&#123; target.style.backgroundColor = 'black'; target.style.color = 'white'; self.value = 'day'; var alist = document.querySelectorAll('a'); var i = 0; while(i&lt;alist.length)&#123; alist[i].style.color = 'powderblue'; i = i+1; &#125; &#125;else&#123; target.style.backgroundColor = 'white'; target.style.color = 'black'; self.value = 'night'; var alist = document.querySelectorAll('a'); var i = 0; while(i&lt;alist.length)&#123; alist[i].style.color = 'blue'; i = i+1; &#125; &#125; &#125; &lt;/script&gt; ... &lt;input type=\"button\" value=\"night\" onclick=\"nightDayHandler(this);\"&gt;","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Javascript","slug":"programming/javascript","permalink":"https://j2de.github.io/categories/programming/javascript/"}],"tags":[{"name":"Javascript","slug":"javascript","permalink":"https://j2de.github.io/tags/javascript/"},{"name":"생활코딩","slug":"생활코딩","permalink":"https://j2de.github.io/tags/생활코딩/"}]},{"title":"코딩야학 Javascript 5,6일차","slug":"codingyahac-javascript-5-6","date":"2018-08-16T15:00:00.000Z","updated":"2020-03-19T01:08:57.915Z","comments":true,"path":"2018-08-17-codingyahac-javascript-5-6/","link":"","permalink":"https://j2de.github.io/2018-08-17-codingyahac-javascript-5-6/","excerpt":"","text":"스터디에서 다룬 내용생활코딩 WEB2 Javascript ~조건문의 활용 비교 연산자와 블리언document.write() : 화면에 출력 === : 동등 비교 연산자, 이항 연산자 좌항과 우항이 같으면 True, 아니면 False 출력. Boolean : True와 False를 묶어서 Boolean이라 함. 데이터 타입의 종류 :Number, 문자열 String, Boolean Number는 많다. String도 많다. Boolean은 단 두개로 이루어진 데이터 타입 123456789101112131415161718&lt;script&gt; document.write(1===1);&lt;/script&gt;&lt;h3&gt;1===2&lt;/h3&gt;&lt;script&gt; document.write(1===2);&lt;/script&gt;&lt;h3&gt;1&amp;lt;2&lt;/h3&gt;&lt;script&gt; document.write(1&lt;2);&lt;/script&gt;&lt;h3&gt;1&amp;lt;1&lt;/h3&gt;&lt;script&gt; document.write(1&lt;1);&lt;/script&gt; 결과 12345678910111===1true1===2false1&lt;2true1&lt;1false 1&lt;2html에서 &lt;가 문법이기 때문에 &amp;lt;이 &lt;와 같다. 조건문if문의 뒤에 따라오는 괄호 안에 Boolean타입이 오면 true나 false가 온다.Boolean값에 따라 실행되는 코드가 바뀐다. 조건문의 활용Q. 현재 이 버튼의 value 값이 무엇인지 어떻게 알아내는가 ? Console 이용 Q. value에 접근하려면 어떻게 해야할까 ? 키워드 : Javascript element get value 검색 결과 : .value property 이용 조건문을 이용해 night 버튼 수정 1234567891011&lt;input id=\"night_day\" type=\"button\" value=\"night\" onclick=\"if(document.querySelector('#night_day').value === 'night')&#123; document.querySelector('body').style.backgroundColor = 'black'; document.querySelector('body').style.color = 'white'; document.querySelector('#night_day').value = 'day';&#125;else&#123; document.querySelector('body').style .backgroundColor = 'white'; document.querySelector('body').style.color = 'black'; document.querySelector('#night_day').value = 'night';&#125;\"&gt; : night 버튼을 누르면 배경이 검정색, 글씨가 하얀색이 되고 value는 day로 바뀐다. day 버튼을 누르면 반대로 동작한다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Javascript","slug":"programming/javascript","permalink":"https://j2de.github.io/categories/programming/javascript/"}],"tags":[{"name":"Javascript","slug":"javascript","permalink":"https://j2de.github.io/tags/javascript/"},{"name":"생활코딩","slug":"생활코딩","permalink":"https://j2de.github.io/tags/생활코딩/"}]},{"title":"코딩야학 Javascript 4일차","slug":"codingyahac-javascript-4","date":"2018-08-15T15:00:00.000Z","updated":"2020-03-19T01:08:52.846Z","comments":true,"path":"2018-08-16-codingyahac-javascript-4/","link":"","permalink":"https://j2de.github.io/2018-08-16-codingyahac-javascript-4/","excerpt":"","text":"스터디에서 다룬 내용생활코딩 WEB2 Javascript ~프로그램, 프로그래밍, 프로그래머 제어할 태그 선택하기night 버튼을 누르면 검정색 배경, day 버튼을 누르면 흰색 배경으로 돌아오도록 코드를 작성해보자. 12&lt;input type =\"button\" value=\"night\" onclick=\"\"&gt;&lt;input type =\"button\" value=\"day\" onclick=\"\"&gt; 버튼을 클릭했을때 body 태그에 스타일 속성을 동적으로 동작하도록 넣으려고 한다. Q. Javascript로 body 태그를 선택하도록 하려면 어떻게 해야할까 ? 키워드 : Javascript select tag by css selector 검색 결과 123456&lt;body id=\"target\"&gt;&lt;h1&gt;&lt;a href=\"index.html\"&gt;WEB&lt;/a&gt;&lt;/h1&gt; &lt;input type=\"button\" value=\"night\" onclick=\" document.querySelector('#target') \"&gt;... 123456&lt;body&gt;&lt;h1&gt;&lt;a href=\"index.html\"&gt;WEB&lt;/a&gt;&lt;/h1&gt; &lt;input type=\"button\" value=\"night\" onclick=\" document.querySelector('body') \"&gt;... document.querySelector를 이용해 선택한다. class 선택자는 .선택자이름 id 선택자는 #선택자 이름, body 태그와 같이 전체 태그를 지정할 때는 태그 명을 입력한다. Q. body 태그에 style 속성을 어떻게 넣을 수 있을까 ? 키워드 : Javascript element style 1&lt;body style=\"background-color:black;\"&gt; Q. 위의 스타일 속성을 자바스크립트로 넣으려면 ? Javascript style background color 1document.querySelector('body').style.backgroundColor = 'black'; 완성 코드 1234&lt;input type=\"button\" value=\"night\" onclick=\" document.querySelector('body').style.backgroundColor = 'black'; document.querySelector('body').style.color = 'white';\"&gt; night 버튼을 누르면, html/CSS를 동적으로 변경시킨다. 프로그램, 프로그래밍, 프로그래머Javascript라는 프로그래밍 언어는 무엇인가.JS는 컴퓨터 언어 이면서 컴퓨터 프로그래밍 언어이다.HTML은 컴퓨터 프로그래밍 언어라 하지는 않는다. 프로그래밍 언어의 보편적인 의미Q. 프로그램이란?순서가 중심이 되는 것.12순서를 만드는 행위 -&gt; 프로그래밍순서를 만드는 사람 -&gt; 프로그래머 : SW가 아니어도 많이 사용되는 단어이다. 순서대로 여러 기능을 작동시키는 것이 컴퓨터를 작동시키는 일반적인 방법이다.순서가 반복되고 그 과정중에 오래 걸리고 자주 반복하고 실수를 한다면,그 문제를 어떻게 극복할 것인가 고민하면서 프로그래밍 언어를 만들었다. 시간의 순서에 따라서 실행되어야 할 기능을 프로그래밍 언어의 문법에 맞게 글로 적어두는 방식을 고안한 것.그 작업이 필요할 때 그 글을 주고 기능을 수행하도록 하는 것이 바로 프로그램이다. html은 웹페이지를 묘사하는 목적으로 사용되고, 시간의 순서에 따라 실행되지 않는다.js는 사용자와 상호작용하기 위해 고안된 컴퓨터 언어이고,따라서 시간의 순서에 따라 웹 브라우저의 여러 기능이 실행되어야 하기 때문에 프로그래밍 언어이다. 지금까지는 단순히 시간을 나열하는 것으로 만족했지만, 조건에 따라 다른 기능이 실행되도록,또는 반복해서 어떤 기능이 실행되도록,코드가 복잡해짐에 따라서 복잡해진 순서를 단순하게 정리정돈하는 방법도 필요해졌다. JS뿐만 아니라 컴퓨터 프로그래밍 언어들의 핵심적인 기능들에 해당하는 조건문 반복문 등을 이제 배워보자.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Javascript","slug":"programming/javascript","permalink":"https://j2de.github.io/categories/programming/javascript/"}],"tags":[{"name":"Javascript","slug":"javascript","permalink":"https://j2de.github.io/tags/javascript/"},{"name":"생활코딩","slug":"생활코딩","permalink":"https://j2de.github.io/tags/생활코딩/"}]},{"title":"코딩야학 Javascript 3일차","slug":"codingyahac-javascript-3","date":"2018-08-14T15:00:00.000Z","updated":"2020-03-19T01:08:48.721Z","comments":true,"path":"2018-08-15-codingyahac-javascript-3/","link":"","permalink":"https://j2de.github.io/2018-08-15-codingyahac-javascript-3/","excerpt":"","text":"스터디에서 다룬 내용생활코딩 WEB2 Javascript ~CSS 기초 웹 브라우저를 제어하는 방법에 대한 테크닉들JS 이용해 할 수 있는 것들 중 한가지인 웹 브라우저 제어에 대해 알아보자. 예를 들면 처음부터 배경이 검정색인 것이 아닌, night 버튼 클릭시 배경을 검정색으로 하고 싶으면 JavaScript를 이용 하면 된다. &lt;body&gt; 태그는 전체를 감싸는 큰 태그이며body에 style속성을 사용한다. style 속성의 속성 값은 CSS만 사용 가능하고CSS는 디자인을 위한 언어이다. 1&lt;body style=\"background-color:black;color:white;\"&gt; 배경은 검정색, 글자색은 하얀색으로 지정하는 코드night 버튼을 클릭했을 때 웹페이지의 style 태그의 속성이 위의 코드로 바뀔 수 있다면, 우리가 원하는 동작을 할 수 있을 것이다. 코드를 직접 수정한다면(HTML) 항상 검정색 배경으로 할 수 있다.(HTML은 한번 화면에 출력되면 자신이 바꿀 수 없는 정적인 언어이기 때문)우리가 원하는 것은 버튼을 클릭했을 때만 변경되는 것이므로 HTML만 사용할 수는 없다. 앞으로 알아야할 것. CSS에 대한 기본 지식style에 들어가는 속성의 값은 CSS이므로 기본적인 문법을 알아야 함. JS를 통해 제어하고자 하는 태그를 선택하는 방법style 속성을 주기 위해서는 속성을 주고자하는 태그가 누구인가를 (body 태그라는 것을) 웹브라우저에게 알려주는 방법을 JS문법으로 어떻게 하는지 알아야함. CSS 기초 : style 속성(property)웹 사이트의 디자인을 바꾸고 싶은 태그에 style 속성을 사용하면 된다.onclick안에 JS가 오는 것과 마찬가지로 style 속성안에는 CSS가 온다. 1&lt;h2 style=\"color:powderblue\"&gt;JavaScript&lt;/h2&gt; html 문법인 style을 통해 웹브라우저에게 이 코드가 CSS라고 알려주는 것. 만약 해당 부분의 배경색도 바꾸고 싶다면, 찾아보자 키워드 추천 : CSS background color property style이라는 속성에 CSS를 넣으면 디자인을 할 수있다속성이라는 문법의 구조를 알고 있다면 검색을 통해 문제를 해결할 수 있다. 1특정 태그를 CSS라는 언어로 디자인하고 싶다면 style을 사용해라 CSS 기초 : style 태그 div 태그 : 어떤 의미,기능도 없는데 CSS나 JS를 통해 어떤 정보를 제어하고 싶을 때 감싸주는 역할을 함. 사용시 줄바꿈이 된다. span 태그 : div와 같은 용도 이지만 전체를 쓰지 않아서 줄바꿈이 되지 않는다. font-weight:bold; : 글씨를 굵게 표기 함. style 태그 : 스크립트 태그 처럼 웹브라우저에게 CSS를 알려주는 태그. JavaScript를 굵은 글씨로 강조하기 위해서 태그 하나하나 style 속성을 넣어도 되지만, class를 이용하면 더 간단히 할 수 있다.class 명을 지정하고 &lt;style&gt;&lt;/style&gt; 태그 사이에 .클래스명{}을 표기하면된다. 1234567&lt;style&gt;.js&#123; font-weight: bold;&#125;&lt;/style&gt;...&lt;span class=\"js\"&gt;JavaScript&lt;/span&gt; 클래스명이 js인 모든 태그에 bold가 적용된다. 클래스 명을 가리킬 때는 앞에 .을 붙인다. CSS 기초 : 선택자선택자를 이용하면 태그를 쉽게 지정해 CSS를 적용할 수 있다. 12345678910&lt;style&gt;.js&#123; font-weight: bold; color: red;&#125;#first&#123; color:green;&#125;&lt;/style&gt;&lt;span id=\"first\" class=\"js\"&gt;JavaScript&lt;/span&gt; .은 클래스 #은 id를 의미한다. 위의 태그는 &lt;span&gt;태그의 JavaScript가 초록색으로 출력된다. 위의 &lt;span&gt; 태그는 .js와 #first의 영향을 받는다. class는 무언가를 그룹핑하는 것, id는 한가지 대상을 식별하는 용도로 사용한다.class라는 속성은 그룹핑하고 싶은 것을 같은 이름의 클래스로 지정을 하며 반면 id는 한 페이지에서 유일하게 사용해야한다. first가 한번 등장했다면 다시는 동일한 페이지에서 중복해서 사용하지 않아야한다. 동작은 정상적으로 되지만 ‘구분’하기 위한 용도라는 규약에 어긋난다. Q. id 선택자와 class 선택자 중에 무엇이 포괄적인가요? A. class 선택자. id 선택자는 무엇인가를 정확히 타겟팅 하는 것 class 선택자로 광범위한 효과 처리를 하고,그중에 예외 처리하고 싶은 태그들을 id선택자를 통해 예외적으로 디자인을 변경한다. 1즉, class 위에 id를 얹어서 디자인하는 것. Q. 웹페이지에 대한 모든 span에 파란색을 하고 싶다면 ? 123span &#123; color:blue;&#125; 앞에 .이나 #등 아무것도 붙이지 않는다면 해당 페이지의 모든 ~태그에 대해 적용된다. 각 선택자의 우선순위 : id 선택자 &gt; class 선택자 &gt; 일반 선택자 속성을 누구에게 적용할 것인가를 정확히 타겟팅하는 것이 중요하다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Javascript","slug":"programming/javascript","permalink":"https://j2de.github.io/categories/programming/javascript/"}],"tags":[{"name":"Javascript","slug":"javascript","permalink":"https://j2de.github.io/tags/javascript/"},{"name":"생활코딩","slug":"생활코딩","permalink":"https://j2de.github.io/tags/생활코딩/"}]},{"title":"코딩야학 Javascript 2일차","slug":"codingyahac-javascript-2","date":"2018-08-13T15:00:00.000Z","updated":"2020-03-19T01:08:45.135Z","comments":true,"path":"2018-08-14-codingyahac-javascript-2/","link":"","permalink":"https://j2de.github.io/2018-08-14-codingyahac-javascript-2/","excerpt":"","text":"스터디에서 다룬 내용생활코딩 WEB2 Javascript ~변수와 대입연산자 Javascript의 데이터 타입(자료형)Javascript의 데이터 타입은 대표적으로 숫자와 문자가 있다. 숫자에 사용되는 산술 연산자 : + - / * 문자는 “ “(큰 따옴표) 또는 ‘ ‘(작은 따옴표)를 사용해 표기한다. .length를 사용하면 문자 갯수를 알려줌.이러한 Properties를 찾아서 쓸 줄 아는 것이 중요하다. Javascript Properties 검색 키워드: Javascript string: Javascript의 string에 대한 Properties를 찾고싶은 경우 Javascript MethodProperties외에 Method도 존재한다. str.toUpperCase()소문자였던 문자열이 대문자가 된다. str.indexof(‘w’)찾으려고 하는 문자열을 입력하면 인덱스 번호를 알려준다. str.trim()문자열의 공백을 잘라서 출력한다. 종류가 많기 때문에 외우기보다는 필요한 기능을 잘 찾아서 쓰는 것이 중요하다. 1231+1은 2&quot;1&quot;+&quot;1&quot;은 &quot;11&quot;숫자와 문자열을 주의해서 사용해야한다. 변수와 대입 연산자 웹브라우저의 Console을 통해 실습 진행 변수 : 대입연산자를 통해 값을 바꿀 수 있는 것 1x = 1 여기서 x가 변수(variable)이며, = 가 대입연산자이다.대입연산자는 오른쪽에 있는 항을 왼쪽에 대입한다. =(대입연산자) : 대입 연산자에 의해서 왼쪽 항의 변수의 값을 변경한다. 11=2; 위의 코드는 에러가 발생한다.1은 값이 바뀔 수 없기 때문에 대입연산자로 값을 변경할 수 없다. 이러한 것을 상수(constant)라 한다. 변수를 사용할 때 가급적 var을 붙이고 선언하는 것이 좋다.var을 사용한 장,단점이 있지만 우선 var을 붙이고 사용하자.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Javascript","slug":"programming/javascript","permalink":"https://j2de.github.io/categories/programming/javascript/"}],"tags":[{"name":"Javascript","slug":"javascript","permalink":"https://j2de.github.io/tags/javascript/"},{"name":"생활코딩","slug":"생활코딩","permalink":"https://j2de.github.io/tags/생활코딩/"}]},{"title":"코딩야학 Javascript 1일차","slug":"codingyahac-javascript-1","date":"2018-08-12T15:00:00.000Z","updated":"2020-03-19T01:08:32.013Z","comments":true,"path":"2018-08-13-codingyahac-javascript-1/","link":"","permalink":"https://j2de.github.io/2018-08-13-codingyahac-javascript-1/","excerpt":"","text":"스터디에서 다룬 내용생활코딩 WEB2 Javascript ~HTML과 Javascript의 만남(Console) HTML과 JavascriptHTML은 웹페이지의 정적인 요소만을 표현할 수 있다.Javascript를 이용하면 사용자와 상호작용해 웹페이지를 동적으로 표현할 수 있다. 일반적으로 HTML을 기반으로 웹 페이지를 만든 뒤Javascript를 이용해 사용자와 상호작용하는 웹으로 제작한다. 웹 브라우저는 한번 출력이 되면 바꿀 수 없다. 크롬의 경우 마우스 오른쪽 클릭 [검사]-[Elements]로 웹페이지 소스코드 확인이 가능하다.Javascript가 동작하면 해당하는 부분의 소스코드가 변경된다. input tag의 type을 button으로 하면 버튼이 만들어진다. value 속성에 지정한 값이 이름이 된다.onclick 속성은 반드시 Javascript를 넣어주어야한다. 사용자가 onclick 버튼을 클릭했을 때 해당 JS 코드를 실행시킨다.document.queryselector로 body 태그를 선택하고 그때 backgroundColor를 변경한다.style 속성에는 반드시 CSS 코드가 와야한다. 정리 1231. JS는 사용자와 상호작용할 수 있다.2. HTML은 한번 출력되면 바꿀 수 없다.3. JS를 이용하면 화면 출력을 변경할 수 있다. 즉, Javascript는 HTML을 제어하는 언어이다. HTML과 JS의 만남 : Script 태그HTML과 JS를 사용하기 위해서는 JS를 사용한다는 표시를 해주어야 한다.&lt;script&gt; &lt;/script&gt; 태그로 표기한다. HTML의 경우 입력한 내용 그대로 정적으로 출력하지만JS 내부에서는 예를 들면 1+1의 경우 더해서 출력한다. HTML과 JS의 만남 : 이벤트이벤트는 JS가 사용자와 상호작용하는 핵심 요소이다. 예시1&lt;input type=\"button\" value=\"hi\" onclick=\"alert('hi')\"&gt; : 사용자가 버튼 클릭 시 경고창(alert)이 출력된다. onclick : onclick 속성의 값으로 반드시 JS가 와야한다.onclick 속성의 속성 값(위의 alert(&#39;hi&#39;))은 웹 브라우저가 기억하고 있다가. onclick 속성이 위치하고 있는 태그를 사용자가 클릭 했을 때 속성 값대로 동작한다. 웹브라우저 위에서 일어나는 일을 이벤트라 한다. = 어떤 이벤트가 실행됐을 때 어떤 자바스크립트가 실행되는 것. 웹브라우저에서 사용되는 이벤트의 종류 무언가를 클릭하는 경우 텍스트 박스에 내용이 수정 되었을 때 1&lt;input type=\"text\" onchange=\"alert('changed')\"&gt; 주로 쓰이는 이벤트는 총 10~20개 정도 된다. ! 외우는 것보다 잘 검색하는 것이 중요 Q. 어떤 키를 눌렀을 때 이벤트가 발생하도록 하고 싶다. 검색 키워드 예시 : Javascript keydown event attribute 정리 on으로 시작하는 속성들 = event = 웹브라우저 위에서 일어나는 사건들 HTML과 JS의 만남 : 콘솔Javascript를 실행하는 또다른 방법.파일이 아니어도 가볍게 코드를 실행하고 싶은 경우 사용하면 좋다 웹브라우저에서 (크롬기준)[검사]-[Console]을 이용하면 파일을 만들지 않고 JS를 즉석으로 사용할 수 있다. JS의 length 패키지는 문자열의 단어 갯수를 알려준다. 콘솔에서 실행시키는 JS는 웹페이지 안에 삽입된 JS처럼 동작한다.열려있는 웹페이지를 대상으로 동작한다. Elements에서 ESC키를 누르면 Console 창이 하단에 뜬다.한번 실행한 코드는 위쪽 화살표 키를 누르면 다시 실행할 수 있다. 정리 간단한 Javascript 코드는 꼭 파일을 만들지 않아도Console 창을 통해 간단하게 실행해볼 수 있다.","categories":[{"name":"Programming","slug":"programming","permalink":"https://j2de.github.io/categories/programming/"},{"name":"Javascript","slug":"programming/javascript","permalink":"https://j2de.github.io/categories/programming/javascript/"}],"tags":[{"name":"Javascript","slug":"javascript","permalink":"https://j2de.github.io/tags/javascript/"},{"name":"생활코딩","slug":"생활코딩","permalink":"https://j2de.github.io/tags/생활코딩/"}]},{"title":"Docker 스터디 3차","slug":"docker-study-3","date":"2018-07-16T15:00:00.000Z","updated":"2020-03-19T01:34:36.481Z","comments":true,"path":"2018-07-17-docker-study-3/","link":"","permalink":"https://j2de.github.io/2018-07-17-docker-study-3/","excerpt":"","text":"Date 2018.07.17 / Time PM 6:30~8:30 / Place 일만관 2B201 이번주 스터디 내용: 가장 빨리 만나는 Docker 6장~7장 내용 진행 Docker 개인 저장소 구축: Docker 서버 = Docker Registry Server일반적으로 Docker Hub에서 Docker 파일을 공유하고 다운 받을 수 있지만 개인 저장소를 따로 구축할 수 있다. Docker Hub에서 제공하는 Docker 레지스트리 이미지를 받아서 진행할 수 있다. 이를 컨테이너로 실행해 사용한다. 기존의 Docker 명령어와 같이 push/pull로 이미지를 업로드하고 받을 수 있다. 아마존 S3를 이용해서도 저장소를 구축할 수 있다. 보통의 경우 저장소를 따로 구축할 일은 거의 없다. Docker 컨테이너 연결: Docker 컨테이너를 여러개 만들어 다른 컨테이너끼리 연결하는 경우. Docker에 여러가지 환경 설정을 하는 경우 Docker 하나에 전부 하기 보다는 DB면 DB, 웹서버면 웹서버 등 각각 컨테이너를 만들어 연결해 합친다. 분리해서 설정하는 것이 유지 보수에도 좋다. —link 옵션을 사용하거나 따로 network를 만들어 연결할 수 있다. —link 옵션의 경우 레거시 코드로 network를 만드는 방식으로 하는 것이 더 좋다. 또한 연결이 늘어날 수록 —link옵션보다는 network를 생성하는 것이 관리에 편리하다. 자세한 내용은 링크를 참고 위 링크와 다르게 sudo docker ps에 연결상태가 출력되지않는다. —link옵션 사용시 해당 컨테이너에, network 생성시 해당 네트워크에 inspect명령어 사용시 연결 상황을 확인할 수 있다. Docker 데이터 볼륨: Docker의 볼륨은 호스트에서 관리한다. 볼륨 내의 파일은 호스트에 저장되지만 컨테이너에서 접근할 수 있다.DB 등 파일의 변동사항이 많은 경우 볼륨에 따로 빼서 관리를 한다. Docker는 변동사항이 있을 경우 수정하기보다는 부시고 새로 만든다. 따라서 변화할 가능성이 많은 파일 등은 데이터 볼륨에 따로 빼서 관리를 하는 것이 좋다.가상 머신의 공유 폴더와 비슷하다고 생각하면 된다. DockerfileCMD와 ENTRYPOINT의 차이점 CMD The main purpose of a CMD is to provide defaults for an execting container ENTRYPOINT An ENTRYPOINT helps you to configure a container that you can run as an executable. 두 명령어 다 컨테이너가 실행될 때(run 등) 실행되는 명령어이다. ENTRYPOINT와 CMD를 설정한 Dockerfile 123FROM debian:wheezyENTRYPOINT [&quot;/bin/ping&quot;]CMD [&quot;localhost&quot;] 매개 변수 없이 이미지 실행 12345678$ docker run -it testPING localhost (127.0.0.1): 48 data bytes56 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.096 ms56 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.088 ms56 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.088 ms^C--- localhost ping statistics ---3 packets transmitted, 3 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.088/0.091/0.096/0.000 ms : CMD를 인자로 받아 ENTRYPOINT를 실행한다. 매개 변수 있는 이미지 실행 12345678$ docker run -it test google.comPING google.com (173.194.45.70): 48 data bytes56 bytes from 173.194.45.70: icmp_seq=0 ttl=55 time=32.583 ms56 bytes from 173.194.45.70: icmp_seq=2 ttl=55 time=30.327 ms56 bytes from 173.194.45.70: icmp_seq=4 ttl=55 time=46.379 ms^C--- google.com ping statistics ---5 packets transmitted, 3 packets received, 40% packet lossround-trip min/avg/max/stddev = 30.327/36.430/46.379/7.095 ms : 매개변수를 인자로 받아서 CMD를 대체한 뒤 ENTRYPOINT를 실행한다. CMD만 설정한 Dockerfile 12FROM debian:wheezyCMD [&quot;/bin/ping&quot;, &quot;localhost&quot;] 매개변수 없이 이미지 실행 12345678$ docker run -it testPING localhost (127.0.0.1): 48 data bytes56 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.076 ms56 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.087 ms56 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.090 ms^C--- localhost ping statistics ---3 packets transmitted, 3 packets received, 0% packet lossround-trip min/avg/max/stddev = 0.076/0.084/0.090/0.000 ms : CMD에 설정한 실행파일, 매개변수를 그대로 실행한다. 매개변수 있는 이미지 실행 12$ docker run -it test bashroot@e8bb7249b843:/# : run 명령어를 사용하면 CMD 옵션이 무시된다. 즉 매개변수를 변경할 수 없다. 출처 : StackOverFlow Dockerfile에 CMD만 설정한 경우 실행파일과 매개변수를 변경할 수 없고 그대로 실행한다. (실행시 run 옵션을 사용하면 명령어 전체를 대체할 수 있다.) ENTRYPOINT와 CMD를 함께 사용하는 경우 ENTRYPOINT가 실행파일, CMD가 디폴트 매개변수와 같게 사용된다. CMD에 입력된 매개변수를 사용하고 싶지 않은 경우 Dockerfile 실행시 매개변수를 따로 입력해주면 ENTRYPOINT에 입력된 실행파일은 그대로 실행되지만 CMD의 매개변수만 변경되어 실행된다. ENTRYPOINT만 사용하는 경우 매개변수 없이 입력했을 때 ENTRYPOINT 그대로 실행된다. 그리고 매개변수를 같이 입력했을 때 ENTRYPOINT+입력한 매개변수가 실행된다. VOLUME 데이터 볼륨 설정. 보통 당장 사용하지 않더라도 데이터 볼륨은 설정해주는 것이 좋다.USER 보통은 root 권한으로 다 사용한다.WORKDIR 리눅의 cd명령과 같은 것ONBUILD 최초 실행시 실행되는 것이 아니라 이 Dockerfile을 나중에 FROM에서 사용할 때 그 때 실행된다. 예를 들면 apt-get update와 같이 기본적인 명령어 들을 여기에 설정해준다.","categories":[{"name":"System","slug":"system","permalink":"https://j2de.github.io/categories/system/"},{"name":"Docker","slug":"system/docker","permalink":"https://j2de.github.io/categories/system/docker/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://j2de.github.io/tags/docker/"},{"name":"Study","slug":"study","permalink":"https://j2de.github.io/tags/study/"}]},{"title":"Docker 스터디 2차","slug":"docker-study-2","date":"2018-07-09T15:00:00.000Z","updated":"2020-03-19T01:34:31.858Z","comments":true,"path":"2018-07-10-docker-study-2/","link":"","permalink":"https://j2de.github.io/2018-07-10-docker-study-2/","excerpt":"","text":"Date 2018.07.10 / Time PM 6:30~8:00 / Place 일만관 2B201 이번주 스터디 내용: 가장 빨리 만나는 Docker 3장~5장 내용 진행Docker 기본 명령어, Dockerfile Docker 기본 명령어 Docker는 항상 root 권한으로 실행해야하기 때문에 sudo를 붙여서 사용한다. 아래 명령어에서는 생략함. docker search &lt;name&gt;도커는 Docker Hub을 통해 이미지를 공유하는데 여기의 이미지를 검색할 수 있는 명령어이다. docker pull &lt;image&gt;:&lt;tag&gt;이미지 다운로드 받는 명령어. latest 설정시 최신 버전을 받을 수 있다. docker images다운받은 이미지 목록을 전부 출력한다. docker run 다운받은 이미지로 컨테이너를 생성한다.-i(interactive), -t(Peudo-tty)옵션 사용하면 실행된 셸에 입출력을 할 수 있다. –name 옵션으로 이름 설정이 가능하다. docker ps실행 중인 컨테이너 목록을 출력한다. -a 옵션을 사용하면 정지된 컨테이너까지 모두 출력한다. docker start 컨테이너를 시작하는 명령어이다. 컨테이너 이름이나 ID를 사용할 수 있다. docker restart 컨테이너 재시작하는 명령어이다. docker attach 컨테이너에 접속하는 명령. 명령어를 입력할 수는 있지만 외부 애플리케이션을 실행하면 입력할 수 없고 출력만 볼 수 있다. docker exec 외부에서 컨테이너 안에 명령을 실행. 컨테이너가 실행되고 있는 상태에서만 사용가능하다. docker stop 컨테이너 정지하는 명령어이다. docker rm 컨테이너를 삭제하는 명령어이다. docker rmi &lt;image&gt;:&lt;tags&gt;컨테이너 이미지를 삭제하는 명령어이다. 태그를 따로 지정하지 않으면 image 이름에 해당하는 모든 이미지가 삭제된다. Docekerfile 파일명 Dockerfile로 생성. FROM, MAINTAINER, RUN, CMD, WORKDIR, EXPOSE 등의 명령어 사용 docker builddocker build &lt;option&gt; &lt;Dockerfile path&gt; 형식. Dockerfile 작성 후 이미지 생성. –tag 옵션으로 태그 지정 가능. docker history &lt;image&gt;Docker 이미지 히스토리 조회 docker cp &lt;container&gt;:&lt;path&gt; &lt;host path&gt;컨테이너에서 파일 복사해 꺼내기 docker commit &lt;option&gt; &lt;container&gt; &lt;image&gt;:&lt;tag&gt;컨테이너의 변경 사항을 이미지 파일로 생성 docker diff &lt;container&gt;컨테이너에서 변경된 파일 확인 docker inspect &lt;image or container&gt;Docker 이미지와 컨테이너의 세부 정보 확인. 이름 또는 ID를 사용해도 됨.","categories":[{"name":"System","slug":"system","permalink":"https://j2de.github.io/categories/system/"},{"name":"Docker","slug":"system/docker","permalink":"https://j2de.github.io/categories/system/docker/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://j2de.github.io/tags/docker/"},{"name":"Study","slug":"study","permalink":"https://j2de.github.io/tags/study/"}]},{"title":"Docker 스터디 개요, 1차","slug":"docker-study-1","date":"2018-07-08T15:00:00.000Z","updated":"2020-03-19T01:34:25.652Z","comments":true,"path":"2018-07-09-docker-study-1/","link":"","permalink":"https://j2de.github.io/2018-07-09-docker-study-1/","excerpt":"","text":"Date 2018.07.03 / Time PM 6:30~8:30 / Place 일만관 2B201 Docker란? 오픈 소스 컨테이너 프로젝트. 클라우드 환경에서의 설치와 배포에 용이하다. 스터디 개요 2018년 7월 3일부터 약 6~7주간 진행 매주 화요일 오후 6시 ~ 8시 스터디 진행 가장 빨리 만나는 Docker 교재 사용 동아리 랩실에서 스터디 진행 스터디 방식 각자 미리 주차별로 예습해온다. 매주 돌아가면서 해당 주차 범위를 공부 후 발표 매주 돌아가면서 발표자가 아닌 사람이 동아리 위키에 스터디 내용을 기록 스터디 진도 1주차 : 스터디 개요 안내, 1~2장 2주차 : 3~5장 3주차 : 6~7장 4주차 : 8~9장 5주차 : 10~14장 6주차 : 16~19장 7주차(미정) : 20~21장 이번주 스터디 내용 Docker 소개 가상머신 개념 가상머신과 Docker의 차이 가상머신 이미지와 Immutable Infrastructure Docker 이미지와 컨테이너 Docker의 이미지 구조 Docker 설치하기 Docker 사용 사례 참고 동아리 위키에 보다 상세한 내용 기록","categories":[{"name":"System","slug":"system","permalink":"https://j2de.github.io/categories/system/"},{"name":"Docker","slug":"system/docker","permalink":"https://j2de.github.io/categories/system/docker/"}],"tags":[{"name":"Docker","slug":"docker","permalink":"https://j2de.github.io/tags/docker/"},{"name":"Study","slug":"study","permalink":"https://j2de.github.io/tags/study/"}]},{"title":"Netty EmbeddedChannel 이용한 단위 테스트","slug":"netty-embeddedchannel-unittest","date":"2018-05-31T15:00:00.000Z","updated":"2020-03-19T01:13:13.342Z","comments":true,"path":"2018-06-01-netty-embeddedchannel-unittest/","link":"","permalink":"https://j2de.github.io/2018-06-01-netty-embeddedchannel-unittest/","excerpt":"","text":"단위 테스트란? 다른 모듈이나 데이터베이스 및 네트워크 등 런타임 의존성으로부터 최대한 격리된 가능한 작은 크기의 코드로 테스트하는 것. 테스트를 통해 모든 단위가 정상적으로 작동하는 것을 확인하면 문제가 생겼을 때 원인을 찾기가 수월해진다. Netty에서는 ChannelHandler가 아주 중요한 요소이다. 네티에서는 EmbeddedChannel을 통해 ChannelHandler의 단위 테스트를 제공한다. 테스트하는 코드 모듈이나 단위를 보통 런타임 환경 밖에서 실행되므로 이를 실행하기 위한 프레임 워크나 도구가 필요하다. 여기서는 JUnit을 통해 테스트 해본다. EmbeddedChannelEmbeddedChannel은 인바운드 또는 아웃바운드 데이터를 EmbeddedChannel에 기록하고 ChannelPipeline 끝에 도달하는 항목이 있는지 확인한다. 이를 통해 메세지가 인코딩 또는 디코딩 됐는지 확인할 수 있고 트리거 된 ChannelHandler 작업이 있는지 여부도 알 수 있다. EmbeddedChannel 주요 메소드 이름 역할 writeInbound(Object… msgs) EmbeddedChannel에 인바운드 메세지를 기록한다. EmbeddedChannel에서 readInbound()를 통해 데이터를 읽을 수 있는 경우 true 반환 readInbound() EmbeddedChannel에서 인바운드 메세지 읽는다. 반환되는 항목은 전체 ChannelPipeline을 통과한 것. 읽을 데이터가 없으면 null 반환 writeOutbound(Object… msgs) EmbeddedChannel에 아웃바운드 메세지를 기록한다. EmbeddedChannel에서 readOutbound()를 통해 데이터를 읽을 수 있는 경우 true를 반환 writeInbound() EmbeddedChannel에서 아웃바운드 메세지를 읽음 반환되는 항목은 전체 ChannelPipeline을 통과한 것. 읽을 항목이 없으면 null 반환 finish EmbeddedChannel을 완료로 표시하고 전체 인바운드 또는 아웃바운드 데이터를 읽을 수 있는 경우 true를 반환한다. 이 메소드는 EmbeddedChannel의 close()를 호출함 EmbeddedChannel 데이터 흐름 인바운드 데이터는 ChannelInboundHandler에 의해 처리되고 원격 피어에서 읽은 데이터를 나타낸다. 아웃바운드 데이터는 ChannelOutboundHandler에 의해 처리되고 원격 피어에 기록된 데이터를 나타낸다. 테스트하는 ChannelHandler를 어떻게 구성하느냐에 따라 구체적인 코드는 달라질 수 있다. [그림]은 EmbeddedChannel의 메소드를 이용해 ChannelPipeline에서의 데이터 흐름을 보여준다. 메세지를 Channel에 기록하고 아웃바운드 방향으로 ChannelPipeline을 통과시키는데 writeOutbound()를 이용한다. 그리고 다음 처리된 메세지를 읽고 예상한 결과가 나왔는지 확인하는 데는 readOutbound()를 이용한다. 인바운드 데이터를 테스트할 때는 반대로 사용하면 된다. (xxxInboud) 메세지는 ChannelPipeline을 통과하고 해당하는 ChannelInboundHandler나 ChannelOutboundHandler를 통해 처리되는데 메세지가 소비되지 않은 경우 메세지가 처리된 후 readInbound()나 readOutbound()를 통해 이용해 Channel에서 읽을 수 있다. EmbeddedChannel을 이용한 ChannelHandler 테스트JUnit과 EmbeddedChannel을 이용해 ChannelHandler를 테스트 해보자 Junit Assert org.junit.Assert 클래스에는 테스트에 이용되는 여러 정적 메소드가 들어있다. 어설션이 실패하면 예외가 발생하고 현재 실행중인 테스트가 종료된다. 다음 import 문으로 사용할 수 있다. import static org.junit.Assert.*; 그리고 다음부터는 직접 Assert 메소드를 호출할 수 있다. assertEquals(buf.readSlice(3), read); 인바운드 메세지 테스트1234567891011121314151617181920212223242526public class FixedLengthFrameDecoder extends ByteToMessageDecoder &#123; // 인바운드 바이트를 처리하고 이를 메세지로 디코딩하기 위해서 // ByteToMessageDecoder를 상속 받음 private final int frameLength; public FixedLengthFrameDecoder(int frameLength) &#123; // 생성할 프레임의 길이 지정 if(frameLength &lt;= 0)&#123; throw new IllegalArgumentException( \"frameLength must be a positive integer:\"+frameLength); &#125; this.frameLength = frameLength; &#125; @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; // 다음 프레임을 처리하는 데 충분하게 바이트를 읽을 수 있는지 확인 while (in.readableBytes() &gt;= frameLength) &#123; ByteBuf buf = in.readBytes(frameLength); // ByteBuf에서 새로운 프레임을 읽음 out.add(buf); // 디코딩 된 메세지의 List에 프레임을 추가함 &#125; &#125;&#125; ByteToMessageDecoder는 고정된 3바이트의 프레임을 생성한다. 이 코드는 데이터가 충분히 있는 경우 고정 크기의 프레임을 생성한다. 반면에 읽을 데이터가 충분하지 않으면 다음 데이터를 기다린다. 123456789101112131415161718192021222324252627282930313233343536public class FixedLengthFrameDecoderTest&#123; @Test //JUnit이 메소드를 실행하도록 @Test 어노테이션을 지정해줌 public void testFrameDecoded()&#123; ByteBuf buf = Unpooled.buffer(); // ByteBuf를 생성하고 9바이트 저장 for(int i=0; i&lt;9; i++)&#123; buf.writeByte(i); &#125; ByteBuf input = buf.duplicate(); EmbeddedChannel channel = new EmbeddedChannel( new FixedLengthFrameDecoder(3)); // EmbeddedChannel을 생성하고 3바이트 길이의 프레임으로 테스트할 // FixedLengthFrameDecoder를 추가함 assertTrue(channel.writeInbound(input.retain())); // EmbeddedChannel에 바이트를 기록 assertTrue(channel.finish()); // Channel을 완료로 표시 // 처리된 메세지를 읽고 각각 3바이트 프레임이 3개인지 확인함 ByteBuf read = (ByteBuf) channel.readInbound(); assertEquals(buf.readSlice(3), read); read.release(); read (ByteBuf) channel.readInbound(); assertEquals(buf.readSlice(3),read); read.release(); read = (ByteBuf) channel.readInbound(); assertEquals(buf.readSlice(3), read); read.release(); assertNull(channel.readInbound()); buf.release(); &#125;&#125; testFrameDecoded() 메소드는 읽을 수 있는 9바이트를 포함하는 ByteBuf 1개가 3바이트를 포함하는 ByteBuf 3개로 디코딩되는지 확인한다. 그리고 writeInbound()를 한번 호출해 ByteBuf는 읽기 가능한 9바이트로 채운다. 그 다음에 finish()를 실행해 EmbeddedChannel을 완료로 표시하고 마지막으로 readInbound()를 호출해 EmbeddedChannel에서 프레임 3개와 null 1개를 읽었다. 아웃바운드 메세지 테스트아웃바운드 메세지 테스트도 인바운드와 비슷하다. ChannelOutboundHandler는 메세지를 다른 포맷으로 변환하는 컴포넌트인 인코더 역할을 한다. 아래의 코드로 테스트 해보자. 12345678910111213public class AbsIntegerEncoder extends MessageToMessageEncoder&lt;ByteBuf&gt; &#123; // MessageToMessageEncoder를 상속받아 메세지를 다른 포맷으로 인코딩 함 @Override protected void encode(ChannelHandlerContext channelHandlerContext, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; while(in.readableBytes() &gt;= 4) &#123; // 인코딩할 바이트가 충분한지 확인 int value = Math.abs(in.readint()); // ByteBuf에서 다음 int를 읽고 절대값을 계산 out.add(value); &#125; &#125;&#125; 123456789101112131415161718192021222324public class AbsIntegerEncoderTest &#123; @Test public void testEncoded() &#123; ByteBuf buf = Unpooled.buffer(); // ByteBuf를 생성하고 음의 정수 9개 기록 for (int i=1; i&lt;10; i++)&#123; buf.writeInd(i * -1); &#125; EmbeddedChannel channel = new EmbeddedChannel( new AbsIntegerEncoder()); // EmbeddedChannel을 생성하고 테스트할 AbsIntegerEncoder를 추가 assertTrue(channel.writeOutbound(buf)); // ByteBuf를 기록하고 readOutbound()가 데이터를 생성하는지 확인 assertTrue(channel.finish()); // Channel을 완료로 표시 // 생성된 값을 읽고 절댓 값을 포함하는지 확인 for(int i=1; i&lt;10; i++)&#123; assertEquals(i, channel.readOutbound()); &#125; assertNull(channel.readOutbound()); &#125;&#125; ByteBuf에 4바이트 음의 정수를 기록한다. EmbeddedChannel을 생성하고 여기에 AbsIntegerEncoder를 할당한다. EmbeddedChannel의 writeOutbound()를 호출해 ByteBuf를 기록한다. Channel을 완료로 표시한다. EmbeddedChannel의 아웃바운드 쪽에서 모든 정수를 읽고 절대값만 생성됐는지 확인한다. 예외 처리 테스트데이터 변환외에도 입력이 잘못되거나 데이터가 너무 많은 경우 적절하게 처리해야할 필요가 있다 이런 경우 예외 처리를 따로 해줄 수 있다. 123456789101112131415161718192021222324public class FrameChunkDecoder extends ByteToMessageDecoder &#123; // 인바운드 바이트를 메세지로 디코딩하기 위해 ByteToMessageDecoder를 상속 받음 private final int maxFrameSize; public FrameChunkDecoder(int maxFrameSize)&#123; this.maxFrameSize = maxFrameSize; &#125; @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; int readableBytes = in.readableBytes(); // 생성할 프레임의 최대 허용 길이를 지정 if (readableBytes &gt; maxFrameSize) &#123; // 프레임이 너무 큰 경우 폐기하고 TooLongFrameException을 생성함 in.clear(); throw new TooLongFrameException(); &#125; ByteBuf buf = in.readBytes(readableBytes); // 그렇지 않은 경우 ByteBuf로부터 새 프레임을 읽음 out.add(buf); // 디코딩된 메세지의 List에 프레임을 추가 &#125;&#125; 생성할 프레임의 최대 허용 길이를 설정하고 프레임의 크기가 이것을 넘어갈 경우 초과하는 바이트가 폐기되고 TooLongFrameException이 발생한다. 이 예외는 파이프라인의 다른 ChannelHandler에서 exceptionCaught()를 이용해 처리하거나 무시할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041public class FrameChunkDecoderTest &#123; @Test public void testFrameDecoded()&#123; ByteBuf buf = Unpooled.buffer(); // ByteBuf를 생성하고 9바이트를 기록 for(int i=0; i&lt;9; i++)&#123; buf.writeByte(i); &#125; ByteBuf input = buf.duplicate(); EmbeddedChannel channel = new EmbeddedChannel( new FrameChunkDecoder(3)); // EmbeddedChannel을 생성하고 프레임 크기가 3인 // FixedLengthFrameDecoder를 추가 assertTrue(channel.writeInbound(input.readBytes(2))); // 2바이트를 기록한 후 새로운 프레임이 생성되는지 확인 try &#123; channel.writeInbound(input.readBytes(4)); // 4바이트 프레임을 기록하고 예상되는 TooLongFrameException을 포착 Assert.fail(); // 예외가 발생하지 않은 경우 이 메소드가 적용되고 테스트가 실패함 &#125; catch (TooLongFrameException e)&#123; // 예상된 예외 &#125; assertTrue(channel.writeInbound(input.readBytes(3))); // 남은 2바이트를 기록하고 프레임이 올바른지 확인 assertTrue(channel.finish()); // Channel을 완료로 표시 // 생성된 메세지를 읽고 값을 확인함 ByteBuf read = (ByteBuf) channel.readInbound(); assertEquals(buf.readSlice(2), read); read.release(); read = (ByteBuf) channel.readInbound(); assertEquals(buf.skipBytes(4).readSlice(3), read); read.release(); buf.release(); &#125;&#125; 위 코드의 try/catch 블록은 EmbeddedChannel에서 특수하게 작용한다. wrtie* 메소드 중 하나에서 확인된 Exception이 발생하는 경우 이 Exception이 RuntimeException에 래핑된다. 이 방법을 데이터를 처리하는 동안 Exception이 처리됐는지 여부를 쉽게 테스트 할 수 있다. 그리고 이 테스트 방법은 Exception을 생성하는 모든 ChannelHandler 구현에 이용할 수 있다. 참고 서적 네티 인 액션","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Netty","slug":"server/netty","permalink":"https://j2de.github.io/categories/server/netty/"}],"tags":[{"name":"Network","slug":"network","permalink":"https://j2de.github.io/tags/network/"},{"name":"Netty","slug":"netty","permalink":"https://j2de.github.io/tags/netty/"}]},{"title":"Netty Codec Framework","slug":"netty-codec-framework","date":"2018-05-31T15:00:00.000Z","updated":"2020-03-19T01:13:24.547Z","comments":true,"path":"2018-06-01-netty-codec-framework/","link":"","permalink":"https://j2de.github.io/2018-06-01-netty-codec-framework/","excerpt":"","text":"코덱이란? 모든 어플리케이션은 네트워크 상에 원시 바이트를 주고 받는다. 바이트 형태의 데이터를 대상 어플리케이션에 맞는 데이터 포맷으로 분석하고 변환하는 것이 필요하다. 이러한 데이터 변환은 인코더와 디코더로 구성된 코덱에 의해 처리된다. 일반적으로 동영상 압축 알고리즘을 코덱이라고 부른다. 예를 들면 MPEG 알고리즘으로 압축된 동영상을 재생한다면, 원본 동영상을 MPEG 알고리즘으로 압축하고 시청자는 다시 MPEG 디코더로 압축 해제한 뒤 시청을 할 것 이다. 디코더(Decoder)디코더는 네트워크 스트림을 프로그램의 메세지 포맷으로 변환한다. 즉 인바운드 데이터를 처리한다. 디코더는 인바운드 데이터를 다른 포맷으로 변환하는 일을 하므로 ChannelInboundHandler를 상속받는다. Netty의 디코더 클래스 ByteToMessageDecoder / ReplayingDecoder : 바이트 스트림을 메세지로 디코딩 MessageToMessageDecoder : 메세지를 다른 메세지 유형으로 디코딩 메세지란 ? 특정 어플리케이션에서 의미가 있는 바이트의 시퀀스 구조를 메세지라고 한다. 인코더의 경우 이 메세지를 전송하기에 적합한 (보통 바이트 스트림) 형식으로 변환하고, 디코더는 네트워크 스트림을 다시 프로그램의 메세지 포맷으로 변환한다. 디코더는 인바운드 데이터를 ChannelPipeline의 다음 ChannelInboundHandler를 위해 변환할 때 이용한다. ChannelPipeline은 설계 방식이 체인 형태이기 때문에 복잡한 논리도 여러 디코더를 체인으로 연결해서 쉽게 구현할 수 있다. ByteToMessageDecoder바이트 스트림을 메세지(또는 다른 바이트의 시퀀스)로 디코딩 하는 일반적인 작업을 지원하는 추상 기본 클래스. 원격 피어가 완성된 메세지를 한번에 보낼지 알 수 없으므로 이 클래스는 인바운드 데이터가 처리할 만큼 모일 때까지 버퍼에 저장한다. ByteToMessageDecoder API 메소드 설명 decode(ChannelHandlerContext ctx, ByteBuf in, List out) decode()는 구현해야하는 유일한 추상 메소드로 들어오는 데이터가 포함된 ByteBuf와 디코딩된 메세지가 추가될 List를 받는다. 이 호출은 더 이상 List에 추가할 항목이 없거나 ByteBuf에 읽을 바이트가 없을 때까지 반복된다. 그 이후 List가 비어있지 않은 경우 그 내용이 파이프라인의 다음 핸들러로 전달된다. decodeLast(ChannelHandlerContext ctx, ByteBuf in, List out) 네티가 제공하는 기본 구현은 단순히 decode()를 호출한다. 이 메소드는 Channel이 비활성화될 때 한번 호출된다. 특별한 처리가 필요한 경우 이 메소드를 재정의한다. ByteToMessageDecoder를 상속받은 ToIntegerDecoder 클래스 123456789101112public class ToIntegerDecoder extends ByteToMessageDecoder &#123; // 바이트를 특정 포맷으로 디코딩하기 위해서 ByteToMessageDecoder를 상속받음 @Override public void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; if(in.readableBytes() &gt;= 4)&#123; // 최소 4바이트(int 길이)를 읽을 수 있는지 확인 out.add(in.readInt()); // 인바운드 ByteBuf에서 int 하나를 읽고 이를 디코딩된 메세지의 List에 추가 &#125; &#125;&#125; int를 포함하는 바이트 스트림을 받고 각각 별도로 처리하는 경우, 인바운드 ByteBuf에서 각 int를 읽고 이를 파이프라인의 다음 ChannelInboundHandler로 전달해야한다. 위의 예제는 인바운드 ByteBuf에서 4바이트씩 읽고 이를 int로 디코딩한 후 List로 추가한다. 그리고 List에 추가할 항목이 더 이상 없는 경우 그 내용을 다음 ChannelInboundHandler로 전달한다. 위의 예제는 readableBytes 메소드로 ByteBuf에 읽을 데이터가 있는지 확인하는 과정이 필요하다. ReplayingDecoder1public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder ReplayingDecoder는 ByteToMessageDecoder를 상속받으며 위의 예제와 다르게 약간의 오버헤드를 감수하고 readableBytes를 호출할 필요를 없애준다. 이를 위해 들어오는 ByteBuf를 커스텀 ByteBuf 구현인 ReplayingDecoderBuffer로 래핑하는데 이 동작은 내부적으로 호출이 수행된다. ReplayingDecoder를 상속받은 ToIntegerDecoder 클래스 12345678910public class ToIntegerDecoder extends ReplayingDecoder&lt;Void&gt; &#123; // 바이트 스트림을 메세지로 디코딩하기 위해 ReplayingDecoder&lt;Void&gt;를 상속받음 @Override public void decode(ChannelHandlerContext ctx, ByteBuf in, // 들어오는 ByteBuf는 ReplayingDecoderBuffer이다. List&lt;Object&gt; out) throws Exception &#123; out.add(in.readInt()); // 인바운드 ByteBuf에서 int 하나를 읽고 이를 디코딩된 메세지의 List에 추가함 &#125;&#125; ReplayingDecoder의 특징 모든 ByteBuf 작업이 지원되는 것은 아니다.지원되지 않는 메소드를 호출하면 UnsupportedOperationException이 발생한다. ReplayingDecoder는 ByteToMessageDecoder보다 약간 느리다 MessageToMessageDecoder12public abstract class MessageToMessageDecoder&lt;I&gt; extends ChannelInboundHandlerAdapter 메세지 포맷을 변환하는 클래스이다. 예를 들면 POJO의 한 형식에서 다른 형식으로 바꾸는 등에 이용할 수 있다. 위의 형태에서 매개변수 I는 구현해야하는 유일한 메소드인 decode()에 입력 msg 인수의 형식을 알려준다. MessageToMessageDecoder API 메소드 설명 decode(ChannelHandlerContext ctx, I msg, List out) 인바운드 메세지를 다른 포맷으로 디코딩할 때마다 호출된다. 디코딩된 메세지는 파이프라인의 다음 ChannelInboundHandler로 전달된다. IntegerToStringDecoder 클래스 12345678public class IntegerToStringDecoder extends MessageToMessageDecoder&lt;Integer&gt; &#123; @Override public void decode(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out) throws Exception &#123; out.add(String.valueOf(msg)); //Integer 메세지를 String 표현으로 변환한 후 출력 List에 추가 &#125;&#125; TooLongFrameException네티는 비동기 프레임워크이므로 디코딩할 수 있을 때까지 바이트를 메모리 버퍼에 저장해야한다. 또한 디코더가 메모리를 소진할 만큼 많은 데이터를 저장해서는 안된다. 이 문제를 해결하기 위해서 프레임이 지정한 크기를 초과하면 발생하는 TooLongFrameException 예외를 제공한다. 이 예외는 ChannelHandler.exceptionCaught()로 포착할 수 있다. 예외를 처리하는 방법은 디코더의 이용자가 결정할 수 있다. HTTP 같은 특정 프로토콜을 이용할 때는 특수한 응답을 반환할 수 있지만 그 밖의 경우에는 연결을 닫는 것이 유일한 방법이다. TooLongFrameException 예제 1234567891011121314151617181920public class SafeByteToMessageDecoder extends ByteToMessageDecoder &#123; // 인바운드 바이트를 메세지로 디코딩하기 위해 ByteToMessageDecoder를 상속받음 private static final int MAX_FRAME_SIZE = 1024; // 최대 바이트 수의 임계값을 설정한다. @Override public void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; int readable = in.readableBytes(); if (readable &gt; MAX_FRAME_SIZE)&#123; // 버퍼의 바이트 수가 MAX_FRAME_SIZE를 초과하는 지 확인 // 읽을 수 있는 바이트를 모두 건너뛰고 // TooLongFrameException을 생성한 후 // 다른 ChannelHandler에 알림 in.skipBytes(readable); throw new TooLongFrameException(\"Frame Too big\"); &#125; // 필요한 작업을 수행 ... &#125;&#125; ByteToMessageDecoder가 TooLongFrameException을 이용해 ChannelPipeline 내의 다른 ChannelHandler에 프레임 초과를 알리는 코드이다. 이러한 예방책은 프레임 크기가 가변적인 프로토콜을 이용할 때 특히 중요하다. 인코더(Encoder)인코더는 아웃바운드 데이터를 한 포맷에서 다른 포맷으로 변환한다. 즉 아웃바운드 데이터를 처리하므로 ChannelOutboundHandler를 상속받는다. Netty의 인코더 클래스 MessageToByteEncoder : 메세지를 바이트로 인코딩 MessageToMessageDecoder : 메세지를 다른 메세지로 인코딩 MessageToByteEncoder앞의 ByteToMessageDecoder와 반대로 메세지를 바이트로 변환하는 클래스이다. MessageToByteEncoder API 메소드 설명 encode(ChannelHandlerContext ctx, I msg, ByteBuf out) encode 메소드는 구현해야하는 유일한 추상 메소드이다. ByteBuf로 인코딩할 아웃바운드 메세지(I 형식)을 전달하고 호출한다. 그런 다음 ByteBuf는 파이프라인의 다음 ChannelOutboundHandler로 전달된다. 디코더에는 메소드가 두개이지만 인코더인 이 클래스는 메소드가 하나이다. 디코더의 메소드가 두 개인 이유는 Channel이 닫힌 후 마지막 메세지를 생성해야하는 일이 자주 있기 때문이다.(decodeLast() 메소드). 인코더는 연결이 닫힌 후 메세지를 생성할 필요가 없기 때문에 메소드가 하나이다. ShortToByteEncoder 클래스 12345678public class ShortToByteEncoder extends MessageToByteEncoder&lt;Short&gt; &#123; @Override public void encode(ChannelHandlerContext ctx, Short msg, ByteBuf out) throws Exception &#123; out.writeShort(msg); // Short를 ByteBuf에 기록함 &#125;&#125; Short 인스턴스를 메세지로 받고 이를 Short 기본형으로 인코딩한 후 ByteBuf에 저장하고 이를 파이프라인 내의 다음 ChannelOutboundHandler로 전달한다. 나가는 Short는 ByteBuf에서 2바이트를 차지한다. MessageToMessageEncoder메세지를 아웃바운드 데이터로 인코딩하는 클래스이다. MessageToMessageEncoder API 이름 설명 encode(ChannelHandlerContext ctx, I msg, List out) encode()는 구현해야하는 유일한 메소드이다. write()로 기록한 각 메세지는 encode()로 전달된 후 하나 이상의 아웃바운드 메세지로 인코딩된다. 그런다음 파이프라인의 다음 ChannelOutboundHandler로 전달된다. IntegerToStringEncoder 클래스 12345678public class IntegerToStringEncoder extends MessageToMessageEncoder&lt;Integer&gt; &#123; @Override public void encode(ChannelHandlerContext ctx, Integer msg, List&lt;Object&gt; out) throws Exception &#123; out.add(String.valueOf(msg)); // Integer를 String으로 변환하고 List에 추가 &#125;&#125; 추상 코덱 클래스지금까지 인코더와 디코더를 별개로 다뤘지만 인바운드/아웃바운드 데이터와 메세지 변환을 한 클래스에서 관리할 수 있다. 네티의 추상 코덱 클래스는 디코더와 인코더의 작업을 함께 처리할 수 있다. 이 클래스는 ChannelInboundHandler와 ChannelOutboundHandler를 둘 다 구현한다. 이렇게 구현하는 경우 코드의 재사용성과 확장성은 떨어진다. ByteToMessageCodec바이트를 일종의 메세지(ex-POJO)로 디코딩한 후 다시 인코딩해야하는 경우, ByteToMessageDecoder와 반대 작업을 하는 MessageToByteEncoder를 결합하는 ByteToMessageCodec을 이용하면 된다. ByteToMessageCodec API 메소드 설명 decode(ChannelHanlder ctx, ByteBuf in, List out) 이 메소드는 읽을 바이트가 있을 때 호출되고, 인바운드 ByteBuf를 지정한 메세지 포맷으로 변환하고 파이프라인 내의 다음 ChannelInboundHandler로 전달한다. decodeLast(ChannelHandlerContext ctx, ByteBuf in, List out) 이 메소드의 기본 구현은 decode()로 위임하는 것이다. 이 메소드는 Channel이 비활성화될 때 한번 호출된다. 특별한 처리가 필요한 경우 이 메소드를 재정의한다. encode(ChannelHanlderContext ctx, I msg, ByteBuf out) 이 메소드를 I 형식의 각 메소드를 인코딩하고 아웃바운드 ByteBuf에 기록한다. MessageToMessageCodec1public abstract class MessageToMessageCodec&lt;INBOUND_IN, OUTBOUND_IN&gt; MessageToMessageCodec의 메소드 메소드 설명 protected abstract decode(ChannelHandlerContext ctx, INBOUND_IN msg, List out) 이 메소드는 INBOUND_IN 형식의 메세지를 받으면 이를 OUTBOUND_IN 형식의 메세지로 디코딩한다. 메세지는 ChannelPipeline 내의 다음 ChannelInboundHandler로 전달된다. protected abstract encode(ChannelHandlerContext ctx, OUTBOUND_IN msg, List out) 이 메소드는 OUTBOUND_IN 형식의 각 메세지를 처리할 때마다 호출한다. 처리된 메세지는 INBOUND_IN 형식의 메세지로 인코딩된 후 파이프라인 내의 다음 ChannelOutboundHandler로 전달된다. INBOUND_IN 메세지는 전송을 위한 형식이고 OUTBOUND_IN 메세지는 어플리케이션에서 처리하는 형식으로 생각하면 된다. 해당 코덱은 서로 다른 메세징 API 간에 메세지를 변환하는 경우 사용된다. 이런 패턴은 레거시 메세지 포맷이나 특정 기업의 메세지 포맷을 이용하는 API와 상호운용해야하는 경우에 사용된다. CombinedChannelDuplexHandler디코더와 인코더를 결합해 사용하면 재사용성이 떨어지지만 CombinedChannelDuplexHandler를 이용하면 디코더와 인코더를 단일 유닛으로 배포하면서 재사용성 저하를 방지할 수 있다. 123public class CombinedChannelDuplexHandler &lt;I extends ChannelInboundHandler, O extends ChannelOutboundHandler&gt; 이 클래스는 ChannelInboundHandler와 ChannelOutboundHandler의 컨테이너 역할을 한다. ByteToCharDecoder 클래스 12345678910public class ByteToCharDecoder extends ByteToMessageDecoder&#123; @Override public void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123; while(in.readableBytes() &gt;= 2)&#123; out.add(in.readChar()); // 나가는 List에 Character 객체를 한 개 이상 추가 &#125; &#125;&#125; 위의 decode()는 ByteBuf에서 한번에 2바이트씩 읽고 Character 객체로 자동 박싱되는 char로 List에 기록한다. CharToByteEncoder 클래스 12345678public class CharToByteEncoder extends MessageToByteEncoder&lt;Character&gt;&#123; @Override public void encode(ChannelHandlerContext ctx, Character msg, ByteBuf out) throws Exception &#123; out.writeChar(msg); // Character를 char로 디코딩하고 아웃바운드 ByteBuf로 기록 &#125;&#125; CharToByteEncoder는 Character를 다시 바이트로 변환한다. 이 클래스는 char 메세지를 ByteBuf로 인코딩해야하므로 MessageToByteEncoder를 상속받으며, ByteBuf에 직접 기록하는 방법으로 인코딩한다. CombinedChannelDuplexHandler&lt;I,O&gt; 1234567public class CombinedByteCharCodec extends CombinedChannelDuplexHandler&lt;ByteToCharDecoder, CharToByteEncoder&gt; &#123; public CombinedByteCharCodec() &#123; super(new ByteToCharDecoder(), new CharToByteEncoder()); // 인스턴스를 부모로 전달 &#125;&#125; 위의 인코더와 디코더를 이용해 결합해 코덱을 만들 수 있다. 이처럼 코덱 클래스 중 하나를 이용해 구현하거나 구현한 코덱을 결합할 수도 있다. 참고 서적 네티 인 액션 자바 네트워크 소녀 네티","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Netty","slug":"server/netty","permalink":"https://j2de.github.io/categories/server/netty/"}],"tags":[{"name":"Network","slug":"network","permalink":"https://j2de.github.io/tags/network/"},{"name":"Netty","slug":"netty","permalink":"https://j2de.github.io/tags/netty/"}]},{"title":"Netty 채널 이벤트와 이벤트핸들러, 그리고 파이프라인","slug":"netty-channel-event-and-eventhandler-and-pipeline","date":"2018-05-24T15:00:00.000Z","updated":"2020-03-19T01:12:26.932Z","comments":true,"path":"2018-05-25-netty-channel-event-and-eventhandler-and-pipeline/","link":"","permalink":"https://j2de.github.io/2018-05-25-netty-channel-event-and-eventhandler-and-pipeline/","excerpt":"","text":"Netty의 ChannelPipeline은 Channel에서 발생한 이벤트가 이동하는 통로이다. 이 통로를 통해 이동하는 이벤트를 처리하는 클래스가 이벤트 핸들러이다. 네티의 이벤트 메소드는 데이터가 수신되면 네티가 자동으로 호출한다. Netty의 전체적인 구조는 이 게시글을 참고 자바를 이용한 기존의 서버 프로그래밍은 소켓을 이용하고 데이터가 수신하기를 기다린다. 이와 같은 상황일때 프로세스는 아래와 같다. 기존 자바 네트워크 프로그래밍 12341. 소켓에 데이터가 있는지 확인한다.2. (1)에서 데이터가 존재하면 데이터를 읽어들이는 메소드를 호출한다.3. 읽어들일 데이터가 존재하지 않으면 데이터가 도착할 때까지 기다린다.(blocking)4. 데이터를 기다리는 중에 네트워크가 끊어지면 에러 처리를 위한 메소드를 호출한다. Netty로 네트워크 프로그래밍을 하면 채널 파이프라인과 이벤트 핸들러로 추상화했기 때문에, 데이터의 수신 여부, 소켓의 연결 여부에 대한 예외 상황에서 메소드 호출에 관여할 필요가 없다. Netty 네트워크 프로그래밍 12341. 부트스트랩으로 네트워크 애플리케이션에 필요한 설정을 지정한다.2. 부트스트랩에 이벤트 핸들러를 사용하여 채널 파이프라인을 구성한다.3. 이벤트 핸들러의 데이터 수신 이벤트 메소드에서 데이터를 읽어들인다.4. 이벤트 핸들러의 네트워크 끊김 이벤트 메소드에서 에러 처리를 한다. 위 처럼 네티의 이벤트 루프가 소켓 채널에서 발생한 이벤트에 해당하는 이벤트 메소드를 자동으로 실행한다. 소켓 채널에 데이터가 수신된 경우 아래와 같은 프로세스로 동작한다. 123451. 네티의 이벤트 루프가 채널 파이프라인에 등록된 첫 번째 이벤트 핸들러를 가져온다.2. 이벤트 핸들러에 데이터 수신 이벤트가 구현되어 있으면 실행한다.3. 데이터 수신 이벤트 메소드가 구현되어 있지 않으면 다음 이벤트 핸들러를 가져온다.4. (2)를 수행한다.5. 채널 파이프라인에 등록된 마지막 이벤트 핸들러에 도달할 때까지 (1)을 반복한다. 데이터를 처리하는 입출력은 네티가 이벤트로 관리하므로 해당 이벤트에 해당하는 코드만 구현하면 된다. ChannelPipeline 인터페이스Netty의 ChannelPipeline은 Channel과 EventHandler 사이에서 연결 통로 역할을 한다. Channel은 일반적인 소켓 프로그래밍의 소켓과 같다. 이 소켓에서 발생한 이벤트는 채널 파이프라인을 따라 흐른다. 그리고 이 이벤트 핸들러가 이벤트들을 수신하고 처리하는 기능을 한다. 하나의 채널 파이프라인에 여러 이벤트 핸들러를 등록할 수 있다. 종합하면 ChannelPipeline은 소켓 채널에서 발생한 이벤트 처리를 위한 추상화 모델이다. ChannelPipeline 구성 1231. 클라이언트 연결에 대응하는 소켓 객체를 생성하고 빈 채널 파이프라인 객체를 생성해서 소켓 채널에 할당한다.2. 소켓 채널에 등록된 ChannelInitializer 인터페이스 구현체를 가져와서 initChannel 메소드를 호출한다.3. 소켓 채널 참조로부터 (1)에서 등록한 파이프라인 객체를 가져오고 채널 파이프라인에 입력된 이벤트 핸들러 객체를 등록한다. 위의 세 단계가 완료되면 채널이 등록됐다는 이벤트가 발생하고 이때부터 클라이언트와 서버간의 데이터 송수신을 위한 이벤트 처리가 시작된다. ChannelPipeline은 ChannelInboundHandler와 ChannelOutboundHandler가 모두 들어있는 ChannelHandler의 연속이다. 인바운드 이벤트가 트리거 되는 경우 ChannelPipeline의 시작부터 끝까지 전달된다. ChannelPipeline에는 ChannelPipeline 자체를 통해 전파되는 이벤트도 있다. 인바운드와 아웃바운드의 기준은 상대적이며 시작점을 어디로 기준으로 하느냐에 따라 다르다. 파이프라인은 이벤트를 전파하는 동안 파이프라인의 다음 ChannelHandler가 같은 이동 방향인지 확인한다. 그리고 이동방향이 다르면 ChannelPipeline은 방향이 일치하는 항목이 나올 때까지 ChannelHandler를 건너뛴다. ChannelHandler는 ChannelPipeline에 다른 ChannelHandler를 추가 또는 제거하는 방법으로 ChannelPipeline을 실시간으로 수정할 수 있다. 심지어 자기 자신을 ChannelPipeline에서 제거할 수도 있다. ChannelPipeline을 수정하는 ChannelHandler 메소드 이름 설명 addFirst ChannelHandler를 ChannelPipeline에 추가한다 addBefore addAfter addLast remove ChannelHandler를 ChannelPipeline에서 제거한다. replace ChannelPipeline 내의 ChannelHandler를 다른 ChannelHandler로 대체한다. ChannelPipeline 수정 예제 1234567891011121314151617181920ChannelPipeline pipeline = ..;FirstHandler firstHandler = new FirstHandler();// FirstHandler 인스턴스 생성pipeline.addLast(\"handler1\", firstHandler);// 생성한 인스턴스를 ChannelPipeline에// \"handler1\"이라는 이름으로 추가함pipeline.addFirst(\"handler2\", new SecondHandler());// SecondHandler 인스턴스를 ChannelPipeline의// 첫번째 슬록에 \"handler2\"라는 이름으로 추가해// 기존의 \"handler1\"보다 앞에 배치pipeline.addLast(\"handler3\", new ThirdHandler());// ThirdHandler 인스턴스를 ChannelPipeline의// 마지막 슬롯에 \"handler3\"라는 이름으로 추가...pipeline.remove(\"handler3\");// 인스턴스 이름으로 지정해 제거pipeline.remove(firstHandler);// FirstHandler를 참조해 제거(고유)pipeline.replace(\"handler2\", \"handler4\", new FourthHandler());// SecondHandler를 FourthHandler로 대체 반면에 ChannelPipeline에서도 ChannelHandler에 접근이 가능하다. ChannelHandler에 접근하는 ChannelPipeline 메소드 이름 설명 get 지정한 형식이나 이름에 해당하는 ChannelHandler를 반환한다. context ChannelHandler에 바인딩된 ChannelHandlerContext를 반환한다. names ChannelPipeline에 포함된 모든 ChannelHandler의 이름을 반환한다. ChannelPipeline의 인바운드 작업 메소드 이름 설명 fireChannelRegistered ChannelPipeline의 다음 ChannelInboundHandler에서 channelRegistered(ChannelHandlerContext)를 호출한다 fireChannelUnregistered ChannelPipeline의 다음 ChannelInboundHandler에서 channelUnregistered(ChannelHandlerContext)를 호출한다. fireChannelActive ChannelPipeline의 다음 ChannelInboundHandler에서 channelActive(ChannelHandlerContext)를 호출한다. fireChannelInactive ChannelPipeline의 다음 ChannelInboundHandler에서 channelInactive(ChannelHandlerContext)를 호출한다. fireExceptionCaught ChannelPipeline의 다음 ChannelInboundHandler에서 exceptionCaught(ChannelHandlerContext, Throwable)를 호출한다. fireUserEventTriggered ChannelPipeline의 다음 ChannelInboundHandler에서 userEventTriggered(ChannelHandlerContext, Object)를 호출한다. fireChannelRead ChannelPipeline의 다음 ChannelInboundHandler에서 channelRead(ChannelHandlerContext, Object msg)를 호출한다. fireChannelReadComplete ChannelPipeline의 다음 ChannelInboundHandler에서 channelReadComplete(ChannelHandlerContext)를 호출한다. ChannelPipeline의 아웃바운드 작업 메소드 이름 설명 bind Channel을 로컬 주소로 바인딩한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 bind(ChannelHandlerContext, SocketAddress, ChannelPromise)를 호출한다. connect Channel을 원격 주소로 연결한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 connect(ChannelHandlerContext, SocketAddress, ChannelPromise)를 호출한다. disconnect Channel 연결을 해제한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 disconnect(ChannelHandlerContext, ChannelPromise)를 호출한다. close Channel을 닫는다. ChannelPipeline의 다음 ChannelOutboundHandler에서 close(ChannelHandlerContext, ChannelPromise)를 호출한다. deregister 이전에 할당한 EventExcutor(EventLoop)에서 Channel 등록을 해제한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 deregister(ChannelHandlerContext, ChannelPromise)를 호출한다. flush Channel의 대기 중인 기록을 모두 플러시한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 flush(ChannelHandlerContext)를 호출한다. write Channel에 메세지를 기록한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 write(ChannelHandlerContext, Objectmsg, ChannelPromise)를 호출한다. (기록을 요청하는 것이며 기반 Socket에 바로 메세지를 기록하는 것은 아니다. Socket으로 기록하려면 flush()나 writeAndFlush()를 호출한다.) writeAndFlush write()를 호출한 뒤 flush()를 호출하는 편의 메소드 read Channel에서 데이터 읽기를 요청한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 read(ChannelHandlerContext)를 호출한다. ChannelHandler 인터페이스이벤트 핸들러는 네티의 소캣 채널에서 발생한 이벤트를 처리하는 인터페이스다. 소켓 채널의 이벤트를 인터페이스로 정의하고 이 인터페이스를 상속 받은 이벤트 핸들러를 작성해서 채널 파이프라인에 등록한다. 채널 파이프라인으로 입력되는 이벤트를 이벤트 루프가 가로채어 이벤트에 해당하는 메소드를 수행하는 구조다. 그러므로 네티가 제공하는 이벤트의 종류나 발생 시기를 아는 것이 중요하다. Channel 수명주기 상태 설명 ChannelUnregistered Channel이 생성됐지만 EventLoop에 등록되지 않음 ChannelRegistered Channel이 EventLoop에 등록됨 ChannelActive Channel이 활성화됨(원격 피어로 연결됨). 이제 데이터 주고받기 가능 ChannelInactive Channel이 원격 피어로 연결되지 않음 일반적인 수명주기는 ChannelRegistered -&gt; ChannelActive -&gt; ChannelInactive -&gt; ChannelUnregistered 순으로 이뤄진다.수명주기 상태 변경이 수행될 때 해당하는 이벤트가 생성된다. 이런 이벤트는 ChannelPipeline에 있는 ChannelHandler로 전달된다. ChannelHandler 수명주기 메소드 설명 handlerAdded ChannelHandler가 ChannelPipeline에 추가될 때 호출 handlerRemoved ChannelHandler가 ChannelPipeline에서 제거될 때 호출 exceptionCaught ChannelPipeline에서 처리 중에 오류가 발생하면 호출 위 메소드는 ChannelHandler가 ChannelPipeline에 추가 또는 제거된 후 호출된다. 각 메소드는 ChannelHandlerContext 인수를 받는다. ChannelHandler는 하위 인터페이스 ChannelInboundHandler와 ChannelOutboundHandler로 나뉜다. ChannelInboundHandler : 모든 유형의 인바운드 데이터와 상태 변경을 처리 ChannelOutboundHandler : 아웃 바운드 데이터를 처리하고 모든 작업의 가로채기를 허용함 ChannelInboundHandler 인터페이스클라이언트가 서버에 접속한 상태에서 서버로 데이터를 보내는 경우, 서버 측에서는 네티가 소켓에 읽을 데이터가 있다는 이벤트를 채널 파이프라인으로 보내게된다. 그러면 채널 파이프라인에 등록된 이벤트 핸들러 중에서 인바운드 이벤트 핸들러가 해당 이벤트에 해당하는 메소드를 수행한다. 인바운드 이벤트 발생 순서 1234561. 이벤트 루프에 채널 등록(channelRegistered)2. 채널 활성화(channelActive)3. 데이터 수신(channelRead)4. 데이터 수신 완료(channelReadComplete)5. 채널 비활성화(channelInactive)6. 이벤트 루프에서 채널 제거(channelUnregistered) 메소드 설명 channelRegistered channel이 EventLoop에 등록되고 입출력을 처리할 수 있으면 호출됨 channelUnregistered channel이 EventLoop에서 등록 해제되고 입출력을 처리할 수 없으면 호출됨 channelActive channel의 연결과 바인딩이 완료되어 활성화되면 호출됨 channelInactive channel이 활성 상태에서 벗어나 로컬 피어에 대한 연결이 해제되면 호출됨 channelReadComplete channel에서 읽기 작업이 완료되면 호출됨 channelRead channel에서 데이터를 읽을 때 호출 됨 channelWritabilityChanged channel의 기록 가능 상태가 변경되면 호출된다. OutOfMemoryError를 방지하기 위해서 너무 빠르게 기록되지 않게 하거나 channel이 기록 가능한 상태가 되면 기록을 재개할 수 없다. Channel의 isWritable() 메소드를 호출해 해당 채널의 기록 가능 여부를 감지할 수 있다. 기록 가능 여부를 결정하는 임계값은 Channel.config().setWriteHighWaterMark()와 Channel.config().setWriteLowWaterMark() 메소드로 설정한다. userEventTriggered POJO가 ChannelPipeline을 통해 전달돼서 ChannelInboundHandler.fireUserEventTriggered()가 트리거되면 호출된다. 위의 메소드들은 데이터가 수신되거나 연결된 Channel의 상태가 변경될 때 호출된다. 이런 메소드들은 Channel의 수명 주기와 관련이 깊다. 이 중 channelRead 메소드를 Override하는 경우 풀링된 ByteBuf 인스턴스의 메모리를 release() 메소드를 사용해 해제 해야한다. 매번 리소스 관리하기가 번거로운 경우 SimpleChannelInboundHandler를 상속받아 channelRead0 메소드를 사용하면 리소스를 해제 할 필요가 없다. 대신 메세지를 참조해 활용하는 경우 이 클래스를 사용하면 안된다. ChannelInboundHandlerAdapter 상속 12345678@Sharablepublic class DiscardHandler extends ChannelInboundHandlerAdapter&#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg)&#123; ReferenceCountUtil.release(msg); // 리소스 해제를 필수적으로 해줘야함 &#125;&#125; SimpleChannelInboundHandler 상속 1234567@Sharablepublic class SimpleDiscardHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123; @Override public void channelRead0(ChannelHandlerContext ctx, Object msg)&#123; // 리소스를 해제할 필요 없음 &#125;&#125; 서버와 클라이언트의 channelRegistered 발생 위치 네티 서버 네티 클라이언트 connect() 호출 생성 및 이벤트 루프 호출 생성 및 이벤트 루프 등록 [서버 소켓 채널] [클라이언트 소켓 채널] ↓ ↓ (1)channelRegistered 이벤트 (2)channelRegistered 이벤트 ↓ ↓ 연결 요청 [서버 소켓 채널]&lt;—– —–[클라이언트 소켓 채널] ↓ accept() 생성 및 이벤트 루프 등록 [클라이언트 소켓 채널] (3)channelRegistered 이벤트 channelRegistered 이벤트는 (1)과 같은 처음 서버 소켓 채널을 생성할 때, (3)과 같이 새로운 클라이언트가 서버에 접속해 클라이언트 소켓 채널이 생성될 때 발생한다. 즉, 서버 소켓 채널에서 발생한 channelRegistered 이벤트와 서버에 연결된 클라이언트 소켓 채널에서 발생한 channelRegistered 이벤트 2가지다. 클라이언트에서는 (2)와 같이 서버 접속을 위한 connect 메소드를 수행할 때 channelRegistered 이벤트가 발생한다. 즉 channelRegistered 이벤트는 서버 클라이언트 상관 없이 새로운 채널이 생성되는 시점에 발생한다. channelActive 이벤트channelActive 이벤트는 channelRegistered 이벤트 이후에 발생한다. 채널이 생성되고 이벤트 루프에 등록된 후 네티 API를 통해 채널 입출력 상태가 가능하다는 것을 알려준다. 1234- 서버 어플리케이션에 연결된 클라이언트 갯수 세기- 서버 애플리케이션에 연결된 클라이언트에게 최초 연결에 대한 메세지 전송- 클라이언트 어플리케이션이 연결된 서버에 최초 메세지를 전달할 때- 클라이언트 어플리케이션이 서버에 연결된 상태에 대한 작업이 필요할 때 위의 상황 같이 channelActive 이벤트를 서버 또는 클라이언트가 상대방에 연결한 직후 한번 수행하는 작업을 처리하기에 적합하다. ChannelOutboundHandler 인터페이스아웃바운드 이벤트는 소켓 채널에서 발생한 이벤트 중에서 네티 사용자가 요청한 동작에 해당하는 이벤트를 말한다. 연결 요청, 데이터 전송, 소켓 닫기 등이 해당한다. 아웃바운드 이벤트는 ChannelOutboundHandler 인터페이스로 제공되고 모든 ChannelOutboundHandler 이벤트는 ChannelOutboundHandlerContext 객체를 인수로 받는다. ChannelOutboundHandler는 작업이나 이벤트를 지연하는 기능이 있어 정교하게 요청을 처리할 수 있다. 예를 들면 원격 피어에 대한 기록이 일시 중단된 경우 플러시 작업을 지연하고 나중에 재개할 수 있다. 메소드 설명 bind(ChannelHandlerContext, SocketAddress, ChannelPromise) Channel을 로컬 주소로 바인딩 요청, 서버 소켓 채널이 클라이언트의 연결을 대기하는 IP와 포트가 설정되었을 때 발생. 즉 bind 이벤트에서는 서버 소켓 채널이 사용중인 SocketAddress 객체가 인수로 입력된다. connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise) Channel을 원격 피어로 연결 요청 시 호출 됨. 원격지의 SocketAddress 정보와 로컬 SocketAddress 정보가 인수로 입력된다. disconnect(ChannelHandlerContext, ChannelPromise) Channel을 원격 피어로부터 연결 해제 요청시 호출 됨. close(ChannelHandlerContext, ChannelPromise) Channel을 닫는 요청 시 호출 됨 deregister(ChannelHandlerContext, ChannelPromise) Channel을 EventLoop에서 등록 해제 요청시 호출됨 read(ChannelHandlerContext) Channel에서 데이터 읽기 요청시 호출됨 flush(ChannelHandlerContext) Channel을 통해 원격 피어로 큐에 있는 데이터의 플러시 요청시 호출 write(ChannelHandlerContext, Object, ChannelPromise) Channel을 통해 원격 피어로 데이터 기록 요청 시 호출됨. 소켓 채널에 기록된 데이터 버퍼가 인수로 입력된다. ChannelPromise ? ChannelFuture ? ChannelOutboundHandler에 있는 대부분 메소드는 작업이 완료되면 알림을 전달받을 ChannelPromise 인수가 있다. ChannelPromise는 ChannelFuture의 하위 인터페이스로 setSuccess()나 setFailure()와 같은 기록 가능 메소드를 정의해서 ChannelFuture을 읽기전용으로 만든다. 리소스 관리ChannelInboundHandler.channelRead() 또는 ChannelOutboundHandler.write()를 호출해 데이터를 작업한 경우 리소스 누출이 발생하지 않게 관리해아한다. 네티는 참조 카운팅을 이용해 풀링된 ByteBuf를 관리한다. 따라서 ByteBuf 사용 후 참조 카운트를 조정하는 것이 필요하다.네티가 제공하는 ResourceLeakDetector 클래스를 이용한다. 리소스 누출 감지 수준 수준 설명 DISABLED 누출 감지를 비활성화한다. 이 설정은 포괄적인 테스트를 거친 후에만 이용한다. SIMPLE 기본 샘플링 비율 1%를 이용해 발견된 누출을 보고한다. 기본 샘플링 비율은 대부분의 경우에 적합하다 ADVANCED 발견된 누출과 메세지에 접근한 위치를 보고한다. 기본 샘플링 비율을 이용한다 PARANOID ADVANCED와 비슷하지만 모든 접근을 샘플링한다. 성능에 큰 영향을 미쳐서 디버깅 단계에서만 사용해야한다. 자바 시스템 속성을 표에 있는 값 중에 하나로 변경하면 설정할 수 있다. 1java -Dio.netty.leakDetectionLevel=ADVANCED ChannelHandlerContext 인터페이스ChannelHandlerContext는 ChannelHandler와 ChannelPipeline간의 연결을 나타내며 ChannelHandler는 ChannelPipeline에 추가할 때마다 생성된다. ChannelHandlerContext에는 다양한 메소드가 있다. ChannelHandlerContext는 두 가지 네티 객체의 상호작용을 도와주는 인터페이스다. 첫번째는 채널에 대한 입출력 처리이며 두번째는 채널 파이프라인에 대한 상호작용이다. 첫째 채널에 대한 입출력의 경우 ChannelHandlerContext의 writeAndFlush메소드로 채널에 데이터를 기록하고 close 메소드로 채널의 연결을 종료할 수 있다. 두번째 파이프라인에 대한 상호작용은 사용자에 의한 이벤트 발생과 채널 파이프라인에 등록된 이벤트 핸들러의 상태가 변경되는 것 두가지가 있다. 파이프라인에는 여러 이벤트 핸들러는 등록할 수 있고 채널이 초기화될 때 채널 파이프라인의 이벤트 핸들러가 설정된다. ChannelHandlerContext는 채널이 초기화될 때 설정된 채널 파이프라인을 가져오는 메소드를 제공한다. 그래서 ChannelHandlerContext를 통해 설정된 채널 파이프라인을 수정할 수 있다. 예외 처리인바운드 예외 처리인바운드 이벤트가 처리되는 동안 예외가 발생하면 실행된 ChannelInboundHandler부터 시작해 예외가 ChannelPipeline을 통과하기 시작한다. 이런 인바운드 예외를 처리하기 위해 exceptionCaught 메소드를 재정의한다. 12public void exceptionCaught( ChannelHandlerContext ctx, Throwable cause) throws Exception 기본 인바운드 예외 처리1234567public class InboundExceptionHandler extends ChannelInboundHandlerAdapter &#123; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)&#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 모든 인바운드 이벤트는 인바운드 방향으로 진행된다. 예외 또한 마찬가지이다. 따라서 예외 처리 루틴을 채널 파이프라인의 끝부분에 배치하면 채널 파이프라인에 어느 위치에서 예외가 발생하더라도 모두 처리할 수 있다. 예외 대응 방식은 애플리케이션에 따라 다르지만 Channel을 닫거나 복구를 시도하며, 예외처리를 구현하지 않는 경우 관련 내용을 알리는 로깅을 할 수 있다. ChannelHandler.exceptionCaught()의 기본 구현은 현재 예외를 다음 파이프라인의 예외로 전달한다. 예외가 파이프라인 끝에 도달하면 예외가 처리되지 않았음을 알리는 항목이 로깅된다. 예외를 처리하는 방식을 원하는대로 하고 싶다면 exceptionCaught()를 재정의한다. 예외를 외부로 전파할지 말지 여부는 개발자가 결정할 수 있다. 아웃바운드 예외 처리아웃바운드 작업에서 정상적인 완료와 예외 처리하는 옵션은 ChannelFuture를 이용한다. 모든 아웃바운드 작업은 ChannelFuture를 반환한다. 작업이 완료되면 ChannelFuture에 등록된 ChannelFutureListener에 성공이나 오류에 대한 알림이 제공된다. ChannelOutboundHandler의 거의 모든 메소드에는 ChannelPromise가 전달된다. ChannelFuture의 하위 클래스인 ChannelPromise에도 비동기 알림을 위한 수신기를 할당할 수 있다. 그리고 ChannelPromise에도 즉시 알림을 지원하는 쓰기 가능 메소드가 있다. 12ChannelPromise setSuccess();ChannelPromise setFailure(Throwable cause); 여기서 ChannelFutureListener를 추가하려면 ChannelFuture 인스턴스의 addListener(Channel)을 호출해야하는데 두가지 호출 방법이 있다. (1) 아웃바운드 작업(write() 등)이 반환하는 ChannelFuture의 addListener()를 호출 12345678910ChannelFuture future = channel.write(someMessage);future.addListener(new ChannelFutureListener()&#123; @Override public void operationComplete(ChannelFuture f)&#123; if(!f.isSuccess())&#123; f.cause().printStackTrace(); f.channel().close(); &#125; &#125;&#125;); (2) ChannelOutboundHandler 메소드에 인수로 전달되는 ChannelPromise에 ChannelListener를 추가 1234567891011121314public class OutboundExceptionHandler extends ChannelOutboundHandlerAdapter&#123; @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)&#123; promise.addListener(new ChannelFutureListener()&#123; @Override public void operationComplete(ChannelFuture f)&#123; if(!f.isSuccess())&#123; f.cause().printStackTrace(); f.channel().close(); &#125; &#125; &#125;) &#125;&#125; 예외를 세부적으로 처리하고 싶은 경우 (1)을, 간단하게 예외를 처리하고 싶다면 (2) 구현을 사용하는 것이 좋다. 이벤트 실행 흐름위의 내용들을 종합해 ChannelPipeline과 ChannelHandler를 통해 이벤트가 실행되는 과정을 알아보자. ChannelPipeline에 여러개의 핸들러 등록 12345678910111213141516public class EchoServer&#123; public static void main(String[] args) throws Exception&#123; ... b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;()&#123; @Override public void initChannel(SocketChannel ch)&#123; ChannelPipeline p = ch.pipeline(); p.addLast(new EchoServerFirstHandler()); p.addLast(new EchoServerSecondHandler()); &#125; &#125;); ... &#125;&#125; ChannelPipeline에 두개의 이벤트 핸들러를 등록했다. FirstHandler 이벤트 핸들러 12345678public class EchoServerFirstHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg)&#123; ByteBuf readMessage = (ByteBuf)msg; System.out.println(\"channelRead:\"+readMessage.toString(Charset.defaultCharset())); ctx.write(msg); &#125;&#125; 채널 파이프라인에 첫번째로 등록된 이벤트 핸들러. channelRead 이벤트 메소드만 구현했다. SecondHandler 이벤트 핸들러 12345678910111213public class EchoServerSecondHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelReadComplete(ChannelHandlerContext ctx)&#123; System.out.println(\"channelReadComplete 발생\"); ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)&#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 채널 파이프라인에 두번째로 등록한 이벤트 핸들러. channelReadComplete 이벤트 메소드와 exceptionCaught 이벤트 메소드를 구현했다. EchoServer에서 클라이언트 채널이 생성되고 해당 채널의 파이프라인에 ChannelActive 이벤트 발생 등록된 2개의 이벤트 핸들러에 ChannelActive 이벤트 메소드가 없어서 ChannelActive 이벤트는 무시됨. 다음으로 channelRead 이벤트가 발생 채널 파이프라인에 등록된 EchoServerFirstHandler의 channelRead 이벤트 메소드가 수행된다. 마지막으로 channelReadComplete 이벤트가 발생하고 EchoServerSecondHandler에 구현된 channelReadComplete 이벤트 메소드가 수행된다. 즉 여러개의 이벤트 핸들러가 등록되어 있을 때 이벤트에 해당하는 이벤트 메소드만 수행된다. 만약에 여러개의 핸들러가 같은 이벤트를 처리한다면 ? EchoServerSecondHandler 수정 123456@Override channelRead(ChannelHandlerContext ctx, Object msg)&#123; ByteBuf readMessage = (ByteBuf) msg; System.out.println(\"SecondHandler channelRead:\" +readMessage.toString(Charset.defaultCharset())); // channelRead 이벤트 메소드를 추가&#125; EchoServerSecondHandler에 EchoServerFirstHandler와 같은 이벤트 메소드인 channelRead를 구현해본 뒤 실행하면 두번째 이벤트 핸들러는 실행되지 않는다. 왜냐하면 이벤트에 해당하는 이벤트 메소드가 첫번째 핸들러에서 수행되면서 이벤트가 사라졌기 때문. 즉 하나의 이벤트는 하나의 이벤트 메소드만 수행한다. 만약에 두번째 이벤트 핸들러의 channelRead 메소드도 수행하고 싶다면 ? EchoServerFirstHandler 수정 123456@Override channelRead(ChannelHandlerContext ctx, Object msg)&#123; ByteBuf readMessage = (ByteBuf) msg; System.out.println(\"channelRead:\"+readMessage.toString(Charset.defaultCharset())); ctx.write(msg); ctx.fireChannelRead(msg); // 이 부분을 추가한다.&#125; 다음 이벤트 핸들러로 이벤트를 넘겨주기 위해서 ChannelHandlerContext인터페이스를 사용해서 fireChannelRead 메소드를 이용하였다. 이는 채널 파이프라인에 이벤트를 발생시킨다. 참고 서적 네티 인 액션 자바 네트워크 소녀 네티","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Netty","slug":"server/netty","permalink":"https://j2de.github.io/categories/server/netty/"}],"tags":[{"name":"Network","slug":"network","permalink":"https://j2de.github.io/tags/network/"},{"name":"Netty","slug":"netty","permalink":"https://j2de.github.io/tags/netty/"}]},{"title":"Netty의 데이터 컨테이너(ByteBuf)","slug":"netty-datacontainer-bytebuf","date":"2018-05-22T15:00:00.000Z","updated":"2020-03-19T01:11:35.332Z","comments":true,"path":"2018-05-23-netty-datacontainer-bytebuf/","link":"","permalink":"https://j2de.github.io/2018-05-23-netty-datacontainer-bytebuf/","excerpt":"","text":"네트워크 데이터의 기본 단위는 항상 바이트다. Java의 ByteBuffer보다 사용하기 쉬운 Netty의 데이터 컨테이너 ByteBuf에 대해 알아보자. Java NIO ByteBuffer자바 NIO 바이트 버퍼는 바이트 데이터를 저장하고 읽는 저장소다. 배열을 멤버 변수로 가지고 배열에 대한 읽고 쓰기 메소드를 제공한다. xxxBuffer 형태의 각 데이터별로 버퍼를 제공한다. ByteBuffer는 capacity / position / limit 세가지 속성을 가진다. capacity : 버퍼에 저장할 수 있는 데이터의 최대 크기. 한번 정하면 바꿀 수 없다. 버퍼를 생성할 때 생성자의 인수로 입력된 값이다. position : 읽기 또는 쓰기 작업 중인 위치를 나타낸다. 버퍼 객체가 생성되면 0으로 초기화되고 쓰기(put) 또는 읽기(get) 작업이 수행되면 자동으로 증가한다. limit : 읽고 쓸 수 있는 버퍼 공간의 최대치. limit 메소드로 값을 조절할 수 있지만 capacity보다 크게 설정할 수 없다. Java ByteBuffer 생성 및 종류자바의 ByteBuffer는 생성자가 아닌 추상 클래스의 메소드를 통해 생성한다. 아래의 메소드를 이용한다. allocate : JVM 힙 영역에 바이트 버퍼를 생성. 이를 보통 힙 버퍼라고 한다. 인수는 앞에서 설명한 capacity 값에 해당하는 버퍼의 크기이다. 바이트 버퍼의 값은 모두 0으로 초기화된다. 힙 버퍼는 풀링이 사용되지 않는 경우 빠른 할당과 해제 속도를 보여준다. allocateDirect : JVM 힙 영역이 아닌 OS의 커널 영역에 바이트 버퍼를 생성한다. 이를 다이렉트 버퍼라고 한다. allocateDirect 메소드는 ByteBuffer 추상 클래스만 사용할 수 있다. 즉 Direct Buffer는 ByteBuffer로만 생성할 수 있다. 다이렉트 버퍼는 힙 버퍼에 비해 생성 시간은 길지만 더 빠른 IO 성능을 제공한다. 전송할 데이터가 힙에 할당된 버퍼에 있는 경우 JVM은 소켓을 통해 데이터를 전송하기 전에 내부적으로 버퍼를 다이렉트 버퍼로 복사한다. 다이렉트 버퍼를 사용하면 이런 오버헤드를 줄일 수 있다. 하지만 다이렉트 버퍼의 데이터에 접근하려면 복사본을 만들어야 접근할 수 있다는 단점이 있다. wrap : 입력된 바이트 배열을 이용해 바이트 버퍼를 생성한다. 입력에 사용된 바이트 배열이 변경되면 wrap을 사용해 생성한 바이트 배열의 값도 변경된다. 그외 Java NIO ByteBuffer의 특징 Java ByteBuffer는 읽기 / 쓰기 작업시 같은 position의 값이 바뀐다. 읽기 / 쓰기 인덱스가 분리되어 있지 않아서 작업 전환시 flip() 메소드를 사용해야한다. 그리고 다중 스레드 환경에서 바이트 버퍼를 공유하지 않아야한다. Netty Architecture Overview Netty ByteBuf 특징 별도의 Read Index / Write Index가 있다. 위의 이유로 flip() 메소드를 사용하지 않아도 된다. 가변 바이트 버퍼를 사용할 수 있다. 바이트 버퍼 풀 기능을 제공한다. 복합 버퍼 사용이 가능하다.(Heap + Direct) Java의 ByteBuffer와 Netty의 ByteBuf의 상호 변환이 가능하다. Netty의 ByteBuf 생성네티의 바이트 버퍼는 자바의 바이트 버퍼와 다르게 프레임워크 레벨의 바이트 버퍼 풀을 제공하고 이를 통해 생성된 바이트 버퍼를 재사용한다. Netty의 바이트 버퍼를 바이트 버퍼 풀에 할당하려면 ByteBufAllocator 인터페이스를 사용한다. ByteBufAllocator의 하위 추상 구현체인 PooledByteBufAllocator 클래스로 각 바이트 버퍼를 생성한다. Pooled / Unpooled ByteBuf자바의 바이트 버퍼는 데이터 형에 따른 ByteBuffer 생성을 지원했지만 네티는 풀링 여부로 ByteBuf를 구분한다. Unpooled 클래스와 PooledByteBufAllocator 사용해 생성하고 다이렉트 버퍼와 힙 버퍼를 생성하기 위해 directBuffer 메소드와 heapBuffer 메소드를 사용한다. ByteBuf 종류 풀링 함 풀링 안 함 힙 버퍼 PooledHeapByteBuf UnpooledHeapByteBuf 다이렉트 버퍼 PooledDirectByteBuf UnpooledDirectByteBuf PooledByteBufAllocator는 ByteBuf 인스턴스를 풀링해 성능을 개선하고 메모리 단편화를 최소화한다. UnpooledByteBufAllocator는 ByteBuf 인스턴스를 풀링하지 않고 호출될 때마다 새로운 인스턴스를 반환한다. 생성 방법 풀링 함 풀링 안 함 힙 버퍼 ByteBufAllocator.DEFAULT.heapBuffer() Unpooled.buffer() 다이렉트 버퍼 ByteBufAllocator.DEFAULT.directBuffer() Unpooled.directBuffer() ByteBuf 생성 예 12345678ByteBuf buf = Unpooled.buffer(11);// 바이트 버퍼 풀을 사용하지 않는 11바이트 크기의 힙 버퍼 생성ByteBuf buf = Unpooled.directBuffer(11);// 바이트 버퍼 풀을 사용하지 않는 11바이트 크기의 다이렉트 버퍼를 생성ByteBuf buf = PooledByteBufAllocator.DEFAULT.heapBuffer(11);// 풀링된 11바이트 크기의 힙 버퍼 생성ByteBuf buf = PooledByteBufAllocator.DEFAULT.directBuffer(11);// 풀링된 11바이트 크기의 다이렉트 버퍼 생성 크기를 지정하지 않으면 Netty에 지정된 기본 값인 256바이트 크기의 바이트 버퍼가 생성된다. Read / WriteByteBuf의 읽을 수 있는 바이트 세그먼트에 실제 데이터가 저장된다. 이때 새로 할당, 래핑, 복사된 버퍼에서 readerIndex의 기본값은 0이다. read나 skip으로 시작하는 모든 메소드는 현재 readerIndex 위치에 있는 데이터를 읽거나 건너 뛰고 읽은 바이트 수 만큼 readerIndex를 증가시킨다. ByteBuf의 기록할 수 있는 바이트 세그먼트는 정의되지 않은 내용이 들어 있고 기록할 수 있는 영역이다. 새로 할당된 버퍼의 writerIndex 기본값은 0이고 write로 시작하는 모든 메소드는 현재 writerIndex 위치부터 데이터를 기록하고 기록한 만큼 writerIndex를 증가시킨다. readBytes(ByteBuf dest) 인수의 ByteBuf만큼 읽는다 writeBytes(ByteBuf dest) 인수의 ByteBuf만큼 쓴다. 모든 데이터 읽기 1234ByteBuf buffer = ...;while(buffer.isReadable())&#123; System.out.println(buffer.readByte());&#125; 데이터 기록 12345// 버퍼의 기록할 수 있는 바이트를 임의의 정수로 채움ByteBuf buffer = ...;while(buffer.writableBytes() &gt;= 4) &#123; buffer.writeInt(random.nextInt());&#125; 읽기 / 쓰기 작업Netty ByteBuf의 읽기, 쓰기 작업은 두가지로 나뉜다. get(), set() 작업은 저장한 인덱스에서 시작하고 인덱스를 변경하지 않는다. read(), write() 작업은 지정한 인덱스에서 시작하고 접근한 바이트 수만큼 인덱스를 증가시킨다. 자주 쓰이는 get() 작업 이름 설명 getBoolean(int) 지정한 인덱스의 Boolean 값을 반환 getByte(int) 지정한 인덱스의 바이트를 반환 getUnsignedByte(int) 지정한 인덱스의 부호 없는 바이트 값을 short로 반환 getMedium(int) 지정한 인덱스의 24비트 미디엄 int값을 반환 getUnsignedMedium(int) 지정한 인덱스의 부호 없는 24비트 미디엄 int 값을 반환 getInt(int) 지정한 인덱스의 int값을 반환 getUnsignedInt(int) 지정한 인덱스의 부호 없는 int값을 long으로 반환 getLong(int) 지정한 인덱스의 long 값을 반환 자주 쓰이는 set() 작업 이름 설명 setBoolean(int, boolean) 지정한 인덱스의 Boolean 값을 설정 setByte(int index, int value) 지정한 인덱스의 바이트 값을 설정 setMedium(int index, int value) 지정한 인덱스의 24비트 미디엄 값을 설정 setInt(int index, int value) 지정한 인덱스의 int 값을 설정 setLong(int index, long value) 지정한 인덱스의 long 값을 설정 setShort(int index, int value) 지정한 인덱스의 short 값을 설정 get()/set() 예제1234567891011121314Charset utf8 = Charset.forName(\"UTF-8\");ByteBuf buf = Unpooled.copiedBuffer(\"Netty !\", utf8);System.out.println((char)buf.getByte(0));// 첫번째 문자 'N' 출력int readerIndex = buf.readerIndex();int writerIndex = buf.writerIndex();// 현재 인덱스들을 저장buf.setByte(0, (byte)'B');// 인덱스 0에 있는 바이트를 문자'B'로 변경System.out.println((char)buf.getByte(0));// 첫번째 문자 'B'를 출력assert readerIndex = buf.readerIndex();assert writerIndex = buf.writerIndex();// 인덱스가 바뀌지 않았으므로 성공 자주 쓰이는 read() 작업 이름 설명 readBoolean() 현재 readerIndex 위치의 Boolean 값을 반환하고 readerIndex를 1만큼 증가시킨다 readByte() 현재 readerIndex 위치의 바이트 값을 반환하고 readerIndex를 1만큼 증가시킨다 readUnsignedByte() 현재 readerIndex 위치의 short 값을 반환하고 readerIndex를 1만큼 증가시킨다 readMedium() 현재 readerIndex 위치의 24비트 미디엄 값을 반환하고 readerIndex를 3만큼 증가시킨다 readUnsignedMedium() 현재 readerIndex 위치의 부호 없는 24비트 미디엄 값을 반환하고 readerIndex를 3만큼 증가시킨다 readInt() 현재 readerIndex 위치의 int값을 반환하고 readerIndex를 4만큼 증가시킨다 readUnsignedInt() 현재 readerIndex 위치의 부호 없는 int값을 long으로 반환하고 readerIndex를 4만큼 증가시킨다 readLong() 현재 readerIndex 위치의 long 값을 반환하고 readerIndex를 8만큼 증가시킨다 readShort() 현재 readerIndex 위치의 short 값을 반환하고 readerIndex를 2만큼 증가시킨다 readUnsignedShort() 현재 readerIndex 위치의 부호 없는 short값을 int로 반환하고 readerIndex를 2만큼 증가시킨다 readBytes(ByteBuf | byte[] destination, int dstIndex [,int length]) 현재 ByteBuf의 현재 readerIndex로부터 시작하는 바이트를 (length가 지정된 경우 length 바이트 만큼) 대상 ByteBuf또는 byte[]의 대상 dstIndex로부터 전송한다. 로컬 readerIndex는 전송된 바이트 수만큼 증가한다. 자주 쓰이는 write() 작업 이름 설명 writeBoolean(boolean) 현재 writerIndex 위치에 Boolean값을 기록하고 writerIndex를 1만큼 증가시킨다 writeByte(int) 현재 writerIndex 위치에 바이트 값을 기록하고 writerIndex를 1만큼 증가시킨다 writeMedium(int) 현재 writerIndex 위치에 미디엄 값을 기록하고 writerIndex를 3만큼 증가시킨다 writeInt(int) 현재 writerIndex 위치에 int 값을 기록하고 writerIndex를 4만큼 증가시킨다 writeLong(long) 현재 writerIndex 위치에 long값을 기록하고 writerIndex를 8만큼 증가시킨다 writeShort(int) 현재 writerIndex 위치에 short값을 기록하고 writerIndex를 2만큼 증가시킨다 writeBytes(source ByteBuf | byte[] [, int srcIndex, int length]) 지정된 원본(ByteBuf 또는 byte[])의 현재 writerIndex부터 데이터 전송을 시작한다. srcIndex와 length가 지정된 경우 srcIndex부터 시작해 length 바이트 만큼 읽는다. 현재 writerIndex는 기록된 바이트 수만큼 증가한다 read()/write() 예제123456789101112Charset utf8 = Charset.forName(\"UTF-8\");ByteBuf buf = Unpooled.copiedBuffer(\"Netty !\", utf8);// 지정한 문자열의 바이트를 저장하는 ByteBuf 생성System.out.println((char)buf.readByte());// 첫번째 문자 'N'을 출력int readerIndex = buf.readerIndex();int writerIndex = buf.writerIndex();// 현재 readerIndex/writerIndex 를 저장buf.writeByte((byte)'?');// 버퍼에 '?'를 추가assert readerIndex == buf.readerIndex();assert writerIndex != buf.writerIndex(); 기타 유용한 메소드 이름 설명 isReadable() 읽을 수 있는 바이트가 하나 이상이면 true를 반환 isWritable() 기록할 수 있는 바이트가 하나 이상이면 true를 반환 readableBytes() 읽을 수 있는 바이트 수를 반환 writableBytes() 기록할 수 있는 바이트 수를 반환 capacity() ByteBuf가 저장할 수 있는 바이트 수를 반환한다. 이 수를 초과하면 maxCapacity()에 도달할 때까지 용량이 확장된다. maxCapacity() ByteBuf가 저장할 수 있는 최대 바이트 수를 반환 hasArray() ByteBuf에 힙 버퍼가 있는 경우 true를 반환 array() ByteBuf에 힙 버퍼가 있는 경우 해당 바이트 배열을 반환하며, 그렇지 않으면 UnsupportedOperationException을 발생시킨다. ByteBufAllocator자바 바이트 버퍼는 언어 자체에서 제공하는 버퍼 풀이 없다. 따라서 바이트 버퍼 풀을 이용하려면 객체 풀링을 제공하는 서드파티 라이브러리를 사용하거나 직접 구현해야한다. 네티는 프레임 워크에서 바이트 버퍼 풀을 제공하고 있으며 다이렉트 버퍼와 힙 버퍼를 모두 풀링할 수 있다. 네티의 바이트 버퍼 풀링은 ByteBufAllocator를 사용해 바이트 버퍼를 생성할 때 자동으로 수행된다. ByteBufAllocator의 참조는 Channel에서 얻거나 ChannelHandler에 바인딩 된 ChannelHandlerContext를 통해 얻을 수 있다. 12345678910111213141516Channel channel = ...;ByteBufAllocator allocator = channel.alloc()// Channel에서 ByteBufAllocator를 얻음...ChannelHandlerContext ctx = ...;ByteBufAllocator allocator2 = ctx.alloc();// ChannelHandlerContext에서 ByteBufAllocator를 얻음...ByteBuf newBuffer = ByteBufAllocator.buffer();// ByteBufAllocator의 buffer 메소드를 사용해 생성된 바이트 버퍼// 똑같이 ByteBufAllocator에서 관리된다.// 바이트 버퍼를 채널에 기록하거나 명시적으로 release 호출 시 바이트 버퍼 풀로 돌아간다....// new Buffer 사용ctx.write(msg);// write 메소드 인수로 바이트 버퍼가 입력되면 데이터를 채널에 기록하고 난 뒤 버퍼 풀로 돌아간다. 풀링되지 않은 버퍼ByteBufAllocator의 참조가 없는 경우, 네티는 풀링되지 않는 ByteBuf 인스턴스를 생성하는 정적 도우미 메서드 Unpooled 클래스를 제공한다. 이름 설명 buffer 풀링되지 않은 힙 기반 ByteBuf 반환 directBuffer 풀링되지 않은 다이렉트 ByteBuf 반환 wrappedBuffer 지정한 데이터를 래핑하는 ByteBuf 반환 copiedBuffer 지정한 데이터를 복사하는 ByteBuf 반환 Unpooled 클래스는 다른 네티 컴포넌트가 필요 없는 네트워킹과 무관한 프로젝트에 ByteBuf를 제공해 확정성 높은 고성능 버퍼 API를 이용할 수 있게 해준다. 참조 카운팅네티는 바이트 버퍼를 풀링하기 위해 바이트 버퍼에 참조수를 기록한다. ReferenceCountUtil 클래스에 정의된 retain 메소드와 release 메소드를 사용할 수 있다 retain 메소드는 참조 수를 증가시키고 release 메소드는 참조 수를 감소 시키고 할당된 메모리가 해제 된다. 123456789101112Channel channel = ...;ByteBufAllocator allocator = channel.alloc();// channel에서 ByteBufAllocator를 얻음....ByteBuf buffer = allocator.directBuffer();// ByteBufAllocator로부터 ByteBuf를 할당assert buffer.refCnt() = 1;// 참조 카운트가 1인지 확인...boolean released = buffer.release();// 객체에 대한 참조 카운트를 감소 시킴// 참조 카운트가 0이 되면 객체가 해제되고 메소드가 true를 반환한다. 참조 카운트가 0일 때 release()를 호출하면 IllegalReferenceCountException이 발생한다.참조 해제는 각 객체가 새로 정의할 수 있다. 예를 들면 클래스의 release() 구현에서 참조 카운트를 현재 값과 상관 없이 0으로 설정하면 모든 활성 참조를 일시에 해제할 수 있다. 기타 작업부호 없는 값 읽기자바는 부호 없는 데이터 형이 없어서 네티에서는 부호 없는 데이터를 처리하기 위한 메소드를 제공한다. 네티에서는 부호 없는 데이터를 읽을 때 읽을 데이터보다 큰 데이터 형에 할당한다. 123456789ByteBuf = Unpooled.buffer(11);buf.writeShort(-1);// 빈 바이트 버퍼에 음수 -1 기록 (2byte)assertEquals(65535, buf.getUnsignedShort(0));// -1은 16진수 표기법으로 0xFFFF이고 이를 부호 없는 정수로 표현하면 65535가 된다.// 이를 4byte로 저장한다.// getUnsignedShort 메소드로 바이트 버퍼에 저장된 0번째 바이트부터 2바이트 읽어서// 4바이트 데이터인 int로 읽어들이면 65535가 된다. 부호 없는 데이터 지원 메소드 메소드 원본 데이터형 리턴 데이터형 getUnsignedByte byte short getUnsignedShort short int getUnsignedMedium medium int getUnsignedInt int long 엔디안 변환네티의 바이트 버퍼의 기본 엔디안은 자바와 동일하게 빅엔디안이다. 리틀 엔디안 바이트 버퍼가 필요한 경우를 order 메소드로 엔디안을 변환할 수 있다. 123ByteBuf buf = Unpooled.buffer();...ByteBuf lettleEndianBuf = buf.order(ByteOrder.LITTLE_ENDIAN); order 메소드로 생성한 바이트 버퍼는 새로운 바이트 버퍼가 아닌 주어진 바이트 버퍼의 내용을 공유하는 파생 버퍼이다. 기존 바이트 버퍼의 배열과 인덱스들을 공유한다. 즉 내용은 같지만 리틀 엔디안으로 접근하는 바이트 버퍼를 생성한다. 참고 서적 네티 인 액션 자바 네트워크 소녀 Netty","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Netty","slug":"server/netty","permalink":"https://j2de.github.io/categories/server/netty/"}],"tags":[{"name":"Network","slug":"network","permalink":"https://j2de.github.io/tags/network/"},{"name":"Netty","slug":"netty","permalink":"https://j2de.github.io/tags/netty/"}]},{"title":"Netty Network Transport API","slug":"netty-network-transport-api","date":"2018-05-21T15:00:00.000Z","updated":"2020-03-19T01:11:19.939Z","comments":true,"path":"2018-05-22-netty-network-transport-api/","link":"","permalink":"https://j2de.github.io/2018-05-22-netty-network-transport-api/","excerpt":"","text":"Netty가 기본 제공하는 Network Transport API 구현과 사용법에 대해 알아보자. 실제 네트워크 프로그래밍을 하다보면 예상보다 많은 동시 접속을 지원해야하는데, 이때 blocking 프로그래밍을 했다면 non-blocking으로 바꿔야하는 상황이 생긴다. 기존 자바를 이용한 네트워크 프로그래밍은 블로킹 전송과 논블로킹 전송의 API 차이가 있어서 변경이 쉽지 않았다. 반면에 네티는 공통 API를 사용하기 때문에 변환이 훨씬 간단하다. Netty OIO 블로킹 전송123456789101112131415161718192021222324252627282930313233343536373839public class OioServer &#123; public void server(int port) throws Exception &#123; final ByteBuf buf = Unpooled.unreleasableBuffer( Unpooled.copiedBuffer(\"Hi!\\r\\n\", Charset.forName(\"UTF-8\"))); EventLoopGroup group = new OioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); // ServerBootstrap 생성 b.group(group).channel(OioServerSocketChannel.class) // OioEventLoopGroup을 이용해 블로킹 모드를 허용함(OIO) .localAddress(new InetSocketAddress(port)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; // 연결이 수락될 때마다 호출 ChannelIntializer를 지정 @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123; // 이벤트를 가로채고 처리할 ChannelInboundHandlerAdapter를 추가 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; ctx.writeAndFlush(buf.duplicate()) .addListener(ChannelFutureListener.CLOSE); // 클라이언트로 메세지를 출력하고 ChannelFutureListener를 추가해 // 메세지가 출력되면 연결을 닫음 &#125; &#125;); &#125; &#125;); ChannelFuture f = b.bind().sync(); // 서버를 바인딩해 연결을 수락 f.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully().sync(); // 모든 리소스를 해제 &#125; &#125;&#125; 이전 게시글의 start() 메소드 부분이다. Netty NIO 비동기 전송123456789101112131415161718192021222324252627282930313233343536public class NioServer &#123; public void server(int port) throws Exception &#123; final ByteBuf buf = Unpooled.copiedBuffer(\"Hi!\\r\\n\", Charset.forName(\"UTF-8\")); EventLoopGroup group = new NioEventLoopGroup(); // 논블로킹 모드를 위해 NioEventLoopGroup을 사용 try &#123; ServerBootstrap b = new ServerBootstrap(); // ServerBootstrap 생성 b.group(group).channel(NioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; // 연결이 수락될 때마다 호출 ChannelIntializer를 지정 @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123; // 이벤트를 가로채고 처리할 ChannelInboundHandlerAdapter를 추가 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; ctx.writeAndFlush(buf.duplicate()) .addListener(ChannelFutureListener.CLOSE); // 클라이언트로 메세지를 출력하고 ChannelFutureListener를 추가해 // 메세지가 출력되면 연결을 닫음 &#125; &#125;); &#125; &#125;); ChannelFuture f = b.bind().sync(); // 서버를 바인딩해 연결을 수락 f.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully().sync(); // 모든 리소스를 해제 &#125; &#125;&#125; 123EventLoopGroup group = new NioEventLoopGroup();...b.group(group).channel(NioServerSocketChannel.class) ... 위 두줄을 제외하면 NioServer는 OioServer와 흡사하다. Netty는 어떤 방식을 선택해도 모든 Network Transport의 구현에 동일한 API를 사용하므로 전송 형식을 변경해도 코드는 거의 영향을 받지 않는다. 즉, 모든 구현이 Channel, ChannelPipeline, ChannelHandler 인터페이스 기준으로 정의된다. Network Transport API Channel 인터페이스는 모든 입출력 작업에 이용되는 전송 API의 핵심이다. Channel은 Network Socket 또는 read, write, connect, bind와 같은 I/O 작업에 대한 연결고리이다. Channel 인터페이스는 AttributeMap과 java.lang.Comparable을 SuperInterface로 둔다. 그리고 하위 인터페이스로 ServerChannel, AbstractChannel 등이 있다. 이는 Channel의 고유한 정렬 순서를 보장하기 위해서이며, AbstractChannel의 compareTo() 메소드로 두 Channel 인스턴스를 비교할 수 있다. Channel 인터페이스는 채널의 현재 상태, 채널의 구성 파라미터(ChannelConfig), 채널이 지원하는 I/O작업, I/O 이벤트 및 요청을 처리하는 ChannelPipeline을 제공한다. (자세한 내용은 이 곳 참고) ChannelPipeline은 인바운드와 아웃바운드 데이터와 이벤트에 적용될 ChannelHandler 인스턴스를 포함한다. 이런 ChannelHandler는 애플리케이션의 상태 변경과 데이터 처리를 담당한다. ChannelHandler의 일반적인 용도 데이터를 다른 포맷으로 변환 예외 알림 제공 Channel의 활성화 또는 비활성화에 대한 알림 제공 Channel을 EventLoop에 등록/해제할 때 알림 제공 사용자 정의 이벤트에 대해 알림 제공 Pipeline은 유닉스 파이프와 같이 Intercepting Filter 구조이며, 여러 명령이 체인으로 연결되고 한 명령의 출력이 다음 명령의 입력이 된다. Channel의 메소드 이름 설명 eventLoop Channel에 할당된 EventLoop를 반환 pipeline Channel에 할당된 ChannelPipeline을 반환 isActive Channel이 활성 상태일 때 true 반환. 활성의 의미는 기본 전송에 따라 달라진다. 예를 들어 Socket은 원격 피어로 연결되면 활성 상태지만, Datagram 전송은 열리면 활성 상태다. localAddress 로컬 SocketAddress를 반환 remoteAddress 원격 SocketAddress를 반환 write 데이터를 원격 피어로 출력. 이 때 데이터는 ChannelPipeline으로 전달되고, flush 되기 전까지 큐에 저장된다. flush 기반 전송으로 이전에 출력된 데이터를 flush 한다. writeAndFlush write()와 flush()를 모두 호출 Netty가 제공하는 기능들은 소수의 인터페이스를 통해 사용이 가능하기 때문에 코드를 전반적으로 리팩토링하지 않아도 애플리케이션 리팩토링을 쉽게 할 수 있다. 네티가 제공하는 전송Netty는 바로 사용할 수 있는 여러 전송을 기본적으로 제공하는데, 이런 전송이 모든 프로토콜을 지원하는 것은 아니다. 따라서 애플리케이션에서 이용하는 프로토콜과 호환되는 전송을 선택해야한다. 이름 패키지 설명 NIO io.netty.channel.socket.io java.nio.channels 패키지를 기반으로 이용(셀렉터 기반 방식) Epoll io.netty.channel.epoll epoll()과 논블로킹 입출력을 위해 JNI를 이용함. 이 전송은 SO_REUSEPORT와 마찬가지로 리눅스에서만 이용 가능하며, NIO 전송보다 빠르고 완전한 논블로킹. OIO io.netty.channel.socket.oio java.net 패키지를 기반으로 이용(블로킹 스트림 이용) 로컬(Local) io.netty.channel.local VM에서 파이프를 통해 통신하는데 이용되는 로컬 전송 임베디드(Embedded) io.netty.channel.embedded 실제 네트워크 전송 없이 ChannelHandler를 이용할 수 있게 해주는 임베디드 전송. ChannelHandler 구현을 테스트하는데 유용하다. NIO 논블로킹 입출력NIO는 모든 입출력 작업에서 완전한 비동기 구현을 제공한다. Netty의 NIO는 JDK의 Selector 기반 API를 사용한다. Selector는 아래와 같은 Channel의 상태가 변경되면 알림을 받을 수 있는 역할을 한다. 새로운 Channel이 수락되고 준비됨 Channel 연결이 완료됨 Channel에 읽을 데이터가 있음 Channel을 이용해 데이터를 기록할 수 있음 java.nio.channels.SelectionKey 클래스에 정의된 상수 패턴으로 애플리케이션의 상태 변경을 지정할 수 있다. 이름 설명 OP_ACCEPT 새로운 연결이 수락되고 Channel이 생성되면 알림 OP_CONNECT 연결되면 알림 OP_READ Channel에서 데이터를 읽을 수 있으면 알림 OP_WRITE Channel로 데이터를 기록할 수 있으면 알림. 소켓 버퍼가 완전히 차는 상황을 처리한다. 이런 상황은 원격 피어의 능력보다 데이터가 더 자주 전송될 때 흔히 발생함 NIO의 내부 흐름은 아래와 같다. 새로운 채널을 셀렉터에 등록 셀렉터가 상태 변경을 알림(등록) 셀렉터에는 이전에 등록한 채널들이 존재함 상태 변경이 수신되거나 제한 시간이 경과할 때까지 Selector.select()가 차단 상태 변경이 있는지 검사 상태 변경이 있으면 모든 상태 변경을 처리 (5)에서 상태 변경이 없거나 (6)이 완료된 후셀렉터가 실행되는 동일한 스레드에서 다른 작업을 실행 이러한 과정은 Netty의 사용자 수준 API에 숨겨진다. Epoll 리눅스용 네이티브 논블로킹 전송고성능 네트워킹 플랫폼으로써 성능 향상을 위해 리눅스 기반의 Epoll API가 발전하였다. 고부하 조건에서 JDK의 NIO구현보다 성능이 훨씬 우수하다. 사용법은 NIO 대신 epoll로 바꾸면 된다. 제로 카피(Zero-copy) 제로 카피는 NIO와 Epoll 전송에서만 이용가능한 기능이다. 파일 시스템의 데이터를 커널 공간에서 사용자 공간으로 복사하는 과정을 생략해 빠르고 효과적으로 네트워크로 이동할 수 있게 해준다. 모든 운영체제에서 이 기능을 지원하는 것은 아니다. OIO 기존 블로킹 입출력Netty의 OIO는 java.net의 블로킹 구현에 기반을 두어서 비동기 방식은 아니지만 블로킹 방식의 레거시 코드를 이식해야하는 경우 쓰인다. 우선 Netty의 OIO 전송을 이용하고 다음에 NIO 전송으로 바꿀 수 있다. 로컬 전송Netty는 동일한 JVM 내에서 실행되는 클라이언트와 서버간 비동기 통신을 위한 로컬 전송을 제공한다.이 전송에서 서버 Channel과 연결되는 SocketAddress는 실제 네트워크 주소에 바인딩되지 않고 서버가 실행되는 동안 레지스트리에 저장되고, Channel이 닫히면 레지스트리에서 등록이 해제된다. 임베디드 전송(ChannelHandler 테스트)Netty는 ChannelHandler를 다른 ChannelHandler 안에 도우미 클래스로 넣을 수 있는 임베디드 전송을 제공한다. 이 방식을 이용하면 내부 코드를 수정하지 않고 ChannelHandler의 기능을 확장할 수 있다. 이 기능을 통해 단위 테스트를 진행할 수 있다. 참고 Java NIO는 생각만큼 non-blocking 하지 않다 왜 Java NIO는 사용하기 힘든가?","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Netty","slug":"server/netty","permalink":"https://j2de.github.io/categories/server/netty/"}],"tags":[{"name":"Network","slug":"network","permalink":"https://j2de.github.io/tags/network/"},{"name":"Netty","slug":"netty","permalink":"https://j2de.github.io/tags/netty/"}]},{"title":"Netty 컴포넌트(Component)","slug":"netty-component","date":"2018-05-20T15:00:00.000Z","updated":"2020-03-19T01:11:04.400Z","comments":true,"path":"2018-05-21-netty-component/","link":"","permalink":"https://j2de.github.io/2018-05-21-netty-component/","excerpt":"","text":"Netty의 Component Channel, EventLoop, ChannelFuture, ChannelHandler, ChannelPipeline, Bootstrap에 대해 알아보자. Q 컴포넌트(Component)란? 독립적인 소프트웨어 모듈을 의미하며, 간단히 말하면 유저가 사용하는 시스템에 대한 조작 장치를 의미한다. Netty Architecture Overview 위 다이어그램의 Extensible Event Model / Universal Communication API 에 해당하는 Netty Component를 알아보자. Channel / EventLoop / ChannelFuture: Netty의 네트워킹 추상화를 담당한 컴포넌트 Channel 인터페이스Channel은 간단히 말하면 소켓(Socket)을 컨트롤 하는 인터페이스. 자바 기반 네트워크는 기본적으로 Socket 클래스를 사용한다. 기본 입출력 작업인 bind(), connect(), read(), write()는 자바의 기본형을 이용하지만 Netty의 API를 통해 덜 복잡하게 작업할 수 있다. Channel은 Netty의 비동기 I/O 인터페이스이다. 그 외에도 Channel은 다수의 미리 정의된 특수한 구현을 포함한 광범위한 클래스 계층의 루트이다. EmbeddedChannel LocalServerChannel NioDatagramChannel NioSctpChannel NioSocketChannel … EventLoop 인터페이스제어 흐름, 멀티스레딩, 동시성 제어를 담당한 인터페이스. 연결의 수명주기 중 발생하는 이벤트를 처리 하는 Netty의 핵심 추상화이다. EventLoop, Thread, EventLoopGroup의 관계는 다음과 같다. 한 EventLoopGroup은 하나 이상의 EventLoop를 포함한다. 한 EventLoop는 수명주기 동안 한 Thread로 바인딩된다. 한 EventLoop에서 처리되는 모든 입출력 이벤트는 전용 Thread에서 처리한다. 한 Channel은 수명주기 동안 한 EventLoop에 등록할 수 있다. 한 EventLoop를 하나 이상의 Channel로 할당할 수 있다. ChannelFuture 인터페이스비동기 알림을 담당하는 인터페이스. Netty는 모든 입출력 작업이 비동기적이다. 즉 작업이 바로 반환되지 않아서 나중에 결과를 확인하는 방법이 필요하다. ChannelFuture의 addListener()는 작업이 완료되면 알림을 받을 ChannelFutureListener를 하나 등록한다. ChannelHandler / ChannelPipeline: 데이터 흐름을 관리하고 애플리케이션 처리 논리를 실행하는 컴포넌트. ChannelHandler 인터페이스인바운드와 아웃바운드 데이터의 처리에 적용되는 모든 애플리케이션 논리의 컨테이너 역할을 담당. ChannelHandler의 메소드는 네트워크 이벤트(광범위한 의미)에 의해 트리거되는데, 그때 거의 모든 종류의 작업 에 활용할 수 있다. ChannelPipeline을 통해 오가는 이벤트(데이터 포함)를 처리하는 모든 코드를 위한 범용 컨테이너이다. 이전 게시글에서 사용한 ChannelInboundHandler는 ChannelHandler로부터 파생된 것이다. ChannelPipeline 인터페이스ChannelHandler 체인을 위한 컨테이너를 제공하며, 체인 상에서 인바운드와 아웃바운드 이벤트를 전파하는 API를 정의한다. Channel이 생성되면 여기에 자동으로 자체적인 ChannelPipeline이 할당된다. ChannelHandler는 ChannelPipeline 안에 설치된다. ChannelInitializer 구현은 ServerBootstrap에 등록된다. ChannelInitializer.initChannel()이 호출되면 ChannelInitializer가 ChannelHandler의 커스텀 집합을 파이프라인에 설치한다. ChannelInitializer는 ChannelPipeline에서 자신을 제거한다. 파이프라인을 통해 이벤트를 이동하는 역할은 애플리케이션의 부트스트랩 단계나 초기화 중에 설치된 ChannelHandler가 담당한다. ChannelHandler들은 이벤트를 수신하고, 구현된 처리 논리를 실행하고 체인 상의 다음 핸들러로 데이터를 전달한다. 실행되는 순서는 추가된 순서에 의해 결정된다. 인바운드와 아웃바운드 핸들러를 동일한 파이프라인에 설치할 수 있으며, 메세지나 다른 인바운드 이벤트를 읽을 때 파이프라인 앞쪽부터 시작해 첫번째 ChannelInboundHandler로 전달된다. 데이터를 처리한 후 체인 상의 다음 ChannelInboundHandler로 데이터를 전달한다. 최종적으로 데이터가 파이프라인의 뒤쪽에 도착하면 모든 처리가 종료된다. 아웃바운드의 경우도 동일하고, 데이터가 네트워크 전송에 도달하면 끝난다. ChannelHandler의 하위 클래스ChannelHandler는 다양한 작업에 사용되기 때문에 종류가 많으며, 각 기능은 상위 클래스가 무엇이냐에 따라 달려있다. Netty는 어댑터 클래스 형태로 여러 기본 핸들러 구현을 제공한다. 이러한 어댑터 클래스 및 해당 상위 클래스가 기본적인 작업을 자동으로 해주므로 특수한 동작이 필요한 메소드와 이벤트만 재정의해서 사용하면된다. 이런식으로 커스텀 ChannelHandler를 쉽게 작성할 수 있다. 커스텀 ChannelHandler를 만들 때 자주 사용할 어댑터 클래스 ChannelHandlerAdapter ChannelInboundHandlerAdapter ChannelOutboundHandlerAdapter ChannelDuplexHandlerAdapter Encoder / Decoder네트워크 데이터는 반드시 연속된 바이트 형태여야 하기 때문에 네트워크로 데이터를 송신/수신하는 경우 데이터를 변환해야한다. 인바운드 메세지는 바이트에서 다른 포맷(보통 자바 객체)으로 변환되는 디코딩을 거치며, 아웃바운드 메세지는 반대로 현재 포맷에서 바이트로 인코딩 된다. Netty가 제공하는 모든 인코더/디코더 어댑터 클래스는 ChannelInboundHandler나 ChannelInboundHandler를 implements 한다. 인바운드 데이터의 경우 인바운드 Channel에서 읽는 각 메세지에 대해 호출되는 channelRead 메소드/이벤트를 재정의하고, 이 메소드는 제공된 디코더의 decode() 메소드를 호출한 뒤 디코딩된 바이트를 파이프라인의 다음 ChannelInboundHandler로 전달한다. 아웃바인드 데이터는 반대이다. Bootstrap: Netty의 Bootstrap 클래스는 애플리케이션의 네트워크 레이어를 구성하는 컨테이너이다. 프로세스를 지정한 포트로 바인딩하거나 프로세스를 지정된 호스트의 지정된 포트에서 실행 중인 다른 호스트로 연결하는 등의 일을 한다. Bootstrap은 클라이언트용(Bootstrap)과 서버용(ServerBootstrap) 두가지가 있다. 애플리케이션이 사용하는 프로토콜, 데이터 처리 유형과는 상관없이 수행하는 기능에 따라 어떤 클래스를 사용할지 결정한다. 범주 Bootstrap ServerBootstrap 네트워크 기능 원격 호스트와 포트로 연결 로컬 포트로 바인딩 EventLoopGroup의 수 1 2 서버는 연결 요청을 수신해야 하므로 포트로 바인딩하는 ServerBootstrap을 이용하지만, 클라이언트는 원격 피어로 연결해야 하므로 Bootstrap을 이용한다. 서버를 부트스트랩할 때는 EventLoopGroup이 두개 필요하다. 하나는 서버의 수신 소켓을 나타내는 ServerChannel이 포함되어있다. 두번째는 서버가 수락한 연결마다 하나씩 들어오는 클라이언트 연결을 처리하기 위해 생성된 모든 Channel을 포함한다. ServerChannel과 연결된 EventLoopGroup은 들어오는 연결 요청에 대해 Channel을 생성해 EventLoop에 하나 할당한다. 연결이 수락되면 두 번째 EventLoopGroup이 해당 Channel에 EventLoop를 할당한다.","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Netty","slug":"server/netty","permalink":"https://j2de.github.io/categories/server/netty/"}],"tags":[{"name":"Network","slug":"network","permalink":"https://j2de.github.io/tags/network/"},{"name":"Netty","slug":"netty","permalink":"https://j2de.github.io/tags/netty/"}]},{"title":"Spring MVC - Neither BindingResult nor plain target object for bean name.. Error","slug":"springmvc-neither-bindingresult-nor-plain-target-object-for-bean-name-error","date":"2018-05-19T15:00:00.000Z","updated":"2020-03-19T01:36:40.953Z","comments":true,"path":"2018-05-20-springmvc-neither-bindingresult-nor-plain-target-object-for-bean-name-error/","link":"","permalink":"https://j2de.github.io/2018-05-20-springmvc-neither-bindingresult-nor-plain-target-object-for-bean-name-error/","excerpt":"","text":"Neither BindingResult nor plain target object for bean name ‘command’ available as request attribute … commandName을 지정한 객체와 연결이 안되서 나오는 에러. 객체와 연결이 되었는데 에러가 발생하는 경우 오타 여부를 확인 해보자. Controller 부분 1234...CommandName commandName = new CommandName();model.addAttribute(\"commandName\", commandName); // 객체 정보 넘겨줌... 나같은 경우 view에서 form 태그의 attribute를 받는 부분에서 오타가 있어서 에러가 발생했다. View 부분 1234...&lt;form:form method=\"post\" modelAttribute=\"commandName\"&gt;// 객체 정보 받아옴...","categories":[{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/categories/troubleshooting/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://j2de.github.io/tags/spring/"},{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/tags/troubleshooting/"}]},{"title":"Spring MVC - Server 강제 종료 후 실행 오류(for Mac)","slug":"springmvc-server-shutdown-and-execution-error-for-mac","date":"2018-05-18T15:00:00.000Z","updated":"2020-03-19T01:36:02.119Z","comments":true,"path":"2018-05-19-springmvc-server-shutdown-and-execution-error-for-mac/","link":"","permalink":"https://j2de.github.io/2018-05-19-springmvc-server-shutdown-and-execution-error-for-mac/","excerpt":"","text":"‘Starting Tomcat v9.0 Server at localhost’ has encountered a problem.Port 8080 required by Tomcat v9.0 Server at localhost is already in use. … Spring 서버가 비정상 종료 된 후 해당 에러가 발생하는 경우, was 재시작을 위한 port가 이미 사용 중이어서 실행을 할 수 없다. 따라서 port를 사용하고 있는 PID를 확인한 뒤 종료해주고 서버를 재시작하면 된다. 12sudo lsof -i -P | grep -i &quot;listen&quot;sudo lsof -i :`port_number` listen 중인 프로세스 확인 포트 번호로 실행중인 프로세스 확인 1sudo kill -15 &quot;PID&quot; 해당 명령어를 입력해주면 프로세스가 종료된다. 이후 서버를 재시작하자.","categories":[{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/categories/troubleshooting/"}],"tags":[{"name":"Spring","slug":"spring","permalink":"https://j2de.github.io/tags/spring/"},{"name":"Troubleshooting","slug":"troubleshooting","permalink":"https://j2de.github.io/tags/troubleshooting/"}]},{"title":"MySQL 터미널에서 SQL파일 import/export 하기(for Mac)","slug":"mysql-file-import-for-mac","date":"2018-05-11T15:00:00.000Z","updated":"2020-03-20T15:44:39.458Z","comments":true,"path":"2018-05-12-mysql-file-import-for-mac/","link":"","permalink":"https://j2de.github.io/2018-05-12-mysql-file-import-for-mac/","excerpt":"","text":"MySQL Workbench를 사용하지 않고 터미널을 통해 데이터베이스에 SQL 파일을 import/export해보자. SQL 파일 Import 1. sql 파일을 추가할 데이터베이스를 만든다. 12mysql&gt; create database &apos;db_name&apos;;mysql&gt; use &apos;db_name&apos;; 2. sql 파일에 대해 source 명령을 실행한다. 1mysql&gt; source &apos;db_path.sql&apos;; Query OK가 출력되면 성공한 것. 12mysql&gt; use db_name;mysql&gt; show tables; 명령어로 확인해보면 DB가 잘 추가된 것을 확인할 수 있다. 3. 사용자(Account)에게 DB 사용권한을 부여한다. 12mysql&gt; grant all privileges on dbname.table to userid@localhost identified by &apos;password&apos;;mysql&gt; grant select on dbname.* to userid@&apos;192.168.%&apos; identified by &apos;password&apos;; 특정 권한(select, insert 등)만 부여하거나, 원격 접속을 허용할 수도 있다. 1mysql&gt; flush privileges; 변경된 권한을 적용한다. 1mysql&gt; show grants for userid@host; 사용자에게 부여된 권한을 확인한다. 4. 사용자(Account)가 없다면 생성해준 뒤 3번을 진행한다. 1mysql&gt; create user userid@localhost identified by &apos;password&apos;; localhost 부분을 %로 한다면 외부 접근이 허용된다. SQL 파일 export mysqldump 이용 1&gt; mysqldump -u&#123;user&#125; -p&#123;password&#125; &#123;db_name&#125; &gt; &#123;db_name&#125;.sql","categories":[{"name":"CS","slug":"cs","permalink":"https://j2de.github.io/categories/cs/"},{"name":"DataBase","slug":"cs/database","permalink":"https://j2de.github.io/categories/cs/database/"}],"tags":[{"name":"MySQL","slug":"mysql","permalink":"https://j2de.github.io/tags/mysql/"}]},{"title":"Maven으로 Netty 프로젝트 시작하기","slug":"start-a-netty-project-with-maven","date":"2018-05-10T15:00:00.000Z","updated":"2020-03-19T01:12:49.194Z","comments":true,"path":"2018-05-11-start-a-netty-project-with-maven/","link":"","permalink":"https://j2de.github.io/2018-05-11-start-a-netty-project-with-maven/","excerpt":"","text":"Netty 프로젝트를 시작하려면 우선 Netty 라이브러리를 설치해야한다. 직접 .jar 파일을 다운받아 추가하는 방법이 있고 Maven을 이용해 라이브러리를 받을 수 있다. 여기서는 Maven을 통해 라이브러리를 설치해 프로젝트를 시작해본다. Maven Maven은 아파치에서 개발된 소프트웨어 프로젝트 관리 도구이다. 소스 코드 관리, 라이브러리 의존성, 빌드, 테스트, 리포트, 프로젝트 배포 같은 소프트웨어 생명주기를 관리한다. 프로젝트를 진행하는데 라이브러리 갯수가 수십개가 넘어가면 코드 작성보다 설정 변경이 어렵게 되는데 이런 작업들을 자동화해준다. Maven을 따로 설치해 CLI 환경에서 프로젝트를 진행할 수 있지만 우선은 따로 설치하지 않고 Maven이 내장된 STS(Spring Tool Suite)을 이용하였다. Maven 프로젝트를 생성해준다. groupId와 artifactId를 입력해 프로젝트를 생성한다. groupId :메이븐 프로젝트를 생성한 조직이나 회사 등을 나타내는 유일한 이름. 주로 자바 패키지명 작성하는 형식과 동일하게 작성하고 필수항목이다. artifactId :여기서 입력한 값이 프로젝트 명이 된다. 소스 코드가 포함된 프로젝트의 루트 폴더명이 된다. 메이븐 설정파일인 pom.xml을 수정해 Netty를 설치한다. 메이븐 설정파일을 수정하면 해당하는 라이브러리를 자동으로 설치한다. 메이븐 설정에 사용되는 의존성 설정은 메이븐 레포지터리 홈페이지에 라이브러리 버전별로 기술되어 있다. 12345&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.0.28.Final&lt;/version&gt;&lt;/dependency&gt; Netty가 Maven Dependencies에 추가되었다. EchoServerHandler.java12@Sharablepublic class EchoServerHandler extends ChannelInboundHandlerAdapter @Sharable : ChannelHandler를 여러 채널간에 안전하게 공유할 수 있음을 나타냄 ChannelInboundHandlerAdapter : 간단한 프로젝트이므로 ChannelInboundHandler의 기본 구현을 제공하는 하위클래스 ChannelInboundHandlerAdapter로 구현한다. 해당 API는 손쉽게 각 메소드를 재정의해 이벤트 수명기에서 원하는 시점을 후크할 수 있다. 12345678@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg)&#123; ByteBuf in = (ByteBuf) msg; System.out.println(\"Server received: \" + in.toString(CharsetUtil.UTF_8)); // 메세지 콘솔 로깅 ctx.write(in); // 아웃바운드 메세지를 플러시하지 않은 채로 받은 메세지를 발신자로 출력&#125; channelRead() : 메시지가 들어올 때마다 호출되는 함수. 여기서는 수신한 데이터를 모두 처리하기위해 재정의했다. 이 서버는 받은 데이터를 발신자에게 다시 보낸다. 123456@Overridepublic void channelReadComplete(ChannelHandlerContext ctx)&#123; ctx.writeAndFlush(Unpooled.EMPTY_BUFFER) .addListener(ChannelFutureListener.CLOSE); // 대기 중인 메세지를 원격 피어로 플러시하고 채널을 닫음&#125; channelReadComplete() : channelRead()의 마지막 호출에서 현재 일괄 처리의 마지막 메세지를 처리했음을 알려준다. 12345@Overridepublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)&#123; cause.printStackTrace(); // 예외 스택 추적을 출력 ctx.close(); // 채널 닫음&#125; exceptionCaught() : 읽기 작업 중 예외 발생하면 호출된다. EchoServer.java123456789public static void main(String[] args) throws Exception &#123; if(args.length != 1)&#123; System.err.println(\"Usage: \"+ EchoServer.class.getSimpleName() + \"&lt;port&gt;\"); &#125; int port = Integer.parseInt(args[0]); // port 값을 설정 new EchoServer(port).start(); // 서버의 start() 메소드 호출&#125; &lt;port&gt;를 받은 뒤 서버의 start()를 호출한다. 12345678910111213141516171819202122232425262728public void start() throws Exception &#123; final EchoServerHandler serverHandler = new EchoServerHandler(); EventLoopGroup group = new NioEventLoopGroup(); // EventLoopGroup 생성 try &#123; ServerBootstrap b = new ServerBootstrap(); // ServerBootstrap 생성 b.group(group) .channel(NioServerSocketChannel.class) // NIO 전송 채널 이용 .localAddress(new InetSocketAddress(port)) // 지정된 포트를 이용해 소켓 주소 설정 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;()&#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(serverHandler); // @Shareble 이므로 EchoServerHandler 이용 가능 &#125; &#125;); ChannelFuture f = b.bind().sync(); // 서버를 비동기 식으로 바인딩, sync()는 바인딩이 완료되기를 대기 // sync()로 인해 블로킹 된다. f.channel().closeFuture().sync(); // 채널의 CloseFuture를 얻고 완료될 때까지 현재 스레드를 블로킹 &#125; finally &#123; group.shutdownGracefully().sync(); // EventLoopGroup을 종료하고 모든 리소스 해제&#125; ChannelInitializer를 이용해 새로운 연결을 수락한 후 새로운 자식 Channel을 생성한다. ChannelInitializer가 EchoServerHandler의 하나를 Channel의 ChannelPipeline으로 추가한다. 이 핸들러는 인바인드 메세지에 대한 알림을 받는다. EchoServerHandler는 비즈니스 논리를 구현 main() 메소드는 서버를 부트스트랩 함 부트스트랩 ? 서버를 구성하는 시동 코드를 의미. 최소한 서버가 연결 요청을 수신하는 포트를 서버와 바인딩하는 코드가 있어야함. 서버를 부트스트랩하고 바인딩하는데 이용할 ServerBootstrap 인스턴스 생성 새로운 연결 수락 및 데이터 R/W와 같은 이벤트 처리를 수행할 NioEventLoopGroup 인스턴스를 생성하고 할당한다. 서버가 바인딩하는 로컬 InetSocketAddress를 지정. EchoServerHandler 인스턴스를 이용해 새로운 각 Channel을 초기화한다. ServerBootstrap.bind()를 호출해 서버를 바인딩 client도 똑같이 Maven 프로젝트 생성 후 pom.xml 설정을 해준다. EchoClientHanlder.java12@Sharablepublic class EchoClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; 데이터를 처리하는 ChannelInboundHandler의 하위 클래스인 SimpleChannelInboundHandler를 상속받아 작업을 처리한다. 12345@Overridepublic void channelActive(ChannelHandlerContext ctx)&#123; // 채널 활성화 알림을 받으면 메세지를 전송 ctx.writeAndFlush(Unpooled.copiedBuffer(\"Netty Start!\", CharsetUtil.UTF_8));&#125; channelActive(): 서버에 대한 연결이 만들어지면 호출된다. 12345@Overridepublic void channelRead0(ChannelHandlerContext ctx, ByteBuf in)&#123; // 수신한 메세지의 덤프를 로깅 System.out.println(\"Client received: \" + in.toString(CharsetUtil.UTF_8));&#125; channelRead0(): 서버로부터 메세지를 수신하면 호출된다. 123456@Overridepublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)&#123; // 예외 시 오류를 로깅하고 채널을 닫음 cause.printStackTrace(); ctx.close();&#125; exceptionCaught: 처리 중 예외가 발생하면 호출된다. EchoClient.java클라이언트 부트스트랩 코드 123456789101112131415161718192021222324252627public void start() throws Exception&#123; EventLoopGroup group = new NioEventLoopGroup(); try&#123; Bootstrap b = new Bootstrap(); // bootstrap을 생성 b.group(group) // 클라이언트 이벤트를 처리할 EventLoopGroup 지정, NIO 구현 .channel(NioSocketChannel.class) // 채널 유형으로 NIO 지정 .remoteAddress(new InetSocketAddress(host, port)) // 서버의 InitSocketAddress 설정 .handler(new ChannelInitializer&lt;SocketChannel&gt;()&#123; // 채널이 생성될 때 파이프라인에 EchoClientHandler 하나를 추가 @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new EchoClientHandler()); &#125; &#125;); ChannelFuture f = b.connect().sync(); // 원격 피어로 연결하고 연결이 완료되기를 기다림 f.channel().closeFuture().sync(); // 채널이 닫힐 때 까지 블로킹 &#125; finally &#123; group.shutdownGracefully().sync(); // 스레드 풀을 종료하고 모든 리소스 해제 &#125;&#125; 클라이언트를 초기화하기 위한 Bootstrap 인스턴스를 생성한다. 새로운 연결을 생성하고 인바운드와 아웃바운드 데이터를 처리하는 것을 포함하는 이벤트 처리를 제어할 NioEventLoopGroup 인스턴스를 만들고 할당한다. 서버로 연결하기 위한 InetSocketAddress를 생성한다. 연결이 만들어지면 파이프라인에 EchoClientHandler 하나를 추가한다. 모든 준비가 완료되면 Bootstrap.connect()를 호출해 원격 서버로 연결한다. 1234567891011public static void main(String[] args) throws Exception &#123; if(args.length != 2)&#123; System.err.println( \"Usage: \" + EchoClient.class.getSimpleName() + \" &lt;host&gt; &lt;port&gt;\"); return; &#125; String host = args[0]; int port = Integer.parseInt(args[1]); new EchoClient(host, port).start();&#125; 실행하기 전 [Maven install]을 진행한다. [Run Configuration]에서 서버 실행시 &lt;Port&gt;를 전달해준다. 서버 실행 후 클라이언트는 &lt;Host&gt; &lt;Port&gt; 번호를 전달한다. 클라이언트가 실행되면 서버로 메세지를 보내고, 서버는 받은 메세지를 그대로 출력한 뒤 다시 클라이언트로 메세지를 보낸다. 클라이언트는 channelRead0 메소드를 통해 메세지를 받아서 다시 출력한다. Server Console 출력 Client Console 출력 자세한 소스코드는 여기를 참조","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Netty","slug":"server/netty","permalink":"https://j2de.github.io/categories/server/netty/"}],"tags":[{"name":"Network","slug":"network","permalink":"https://j2de.github.io/tags/network/"},{"name":"Netty","slug":"netty","permalink":"https://j2de.github.io/tags/netty/"},{"name":"Maven","slug":"maven","permalink":"https://j2de.github.io/tags/maven/"}]},{"title":"Netty 특징과 아키텍처","slug":"netty-features-architecture","date":"2018-05-08T15:00:00.000Z","updated":"2020-03-19T01:10:10.144Z","comments":true,"path":"2018-05-09-netty-features-architecture/","link":"","permalink":"https://j2de.github.io/2018-05-09-netty-features-architecture/","excerpt":"","text":"Netty 네티는 유지 관리가 용이한 고성능 프로토콜 서버와 클라이언트를 신속하게 개발하기 위한 비동기식 이벤트 기반 네트워크 애플리케이션 프레임워크이다. 자바의 네트워킹 최초의 자바 API(java.net)은 블로킹 함수(accept())만 지원했다. 따라서 다수의 클라이언트를 관리하려면 새로운 클라이언트 Socket마다 새로운 Thread를 할당해야 한다. 여러 스레드가 입,출력을 기다리며 무한정 대기 상태가 되는 경우 리소스 낭비가 될 수 있다. 또한 각 스레드가 스택 메모리를 할당해야하는데 스택 메모리를 차지하며, JVM의 컨텍스트 전환에 따른 오버헤드 문제가 생길 수 있다. 10만명 이상의 동시 연결을 지원해야할 때는 이런 방식으로는 불가능 하다. Java NIO블로킹 시스템 호출 방식 외에 네이티브 소켓 라이브러리에는 논블로킹(non-blocking) 호출이 포함되 있다. setsocket()을 이용하면 데이터가 없을 때 읽기/쓰기 호출이 즉시 반환된다. 시스템 이벤트 통지 API를 이용해 논블로킹 소켓을 등록하면 읽기/쓰기할 데이터가 준비됐는지 여부를 알 수 있다. 셀렉터(Selector)java.nio.channels.Selector 클래스는 논블로킹 Socket의 집합에서 입출력 상태를 확인할 수 있어서 기존의 블로킹 방식과 다르게 한 스레드로 여러 동시 연결을 처리할 수 있다. 직접 Java NIO API를 통해 제작하는 애플리케이션이 많지만 부하가 높은 상황에서 안정적으로 하기는 어렵다.따라서 Netty와 같은 프레임 워크를 이용하는 것이 좋다. Netty의 비동기성과 확장성 논 블로킹 네트워크 연결은 작업 완료를 기다릴 필요가 없다. 완전 비동기 입출력은 이 특징에 하나 더 추가되는데, 비동기 메소드는 즉시 반환하며 작업이 완료되면 직접 또는 나중에 이를 통지한다. 셀렉터는 적은 수의 스레드로 여러 연결에서 이벤트를 모니터링 할 수 있게 해준다. Netty의 핵심 컴포넌트Channel하나 이상의 입출력 작업을 수행할 수 있는 HW 장치, 파일, Socket 등에 대한 열린 연결을 의미 CallBack네티는 이벤트를 처리할 때 내부적으로 콜백을 이용한다. 콜백이 트리거 되면 ChannelHanlder 인터페이스의 구현을 통해 이벤트를 처리한다. Future작업이 완료되면 애플리케이션에 알린다. Future 객체는 비동기 작업의 결과를 담는 자리표시자(placeholder)의 역할을 하고, 미래의 어떤 시점에 작업이 완료되면 그 결과에 접근할 수 있게 해준다. JDK가 java.util.concurrent.Future 인터페이스를 제공하지만 수동으로 작업을 해야했다. 그래서 Netty는 자체 구현 ChannelFuture를 제공한다. Event &amp; HandlerNetty는 작업의 상태 변화를 알리기 위해 고유한 이벤트를 이용하고, 발생한 이벤트를 기준으로 적절한 동작을 트리거한다. 로깅 데이터 변환 흐름 제어 애플리케이션 논리 인바운드 이벤트 연결 활성화 또는 비활성화 데이터 읽기 사용자 이벤트 오류 이벤트 아웃바운드 트리거 이벤트 원격 피어로 연결 열기 또는 닫기 소켓으로 데이터 쓰기 또는 플러시 각 채널의 EventLoop 관심 이벤트 등록 이벤트를 ChannelHanlder로 발송 추가 동작 스케쥴링 기타Netty를 도입한 기업 목록","categories":[{"name":"Server","slug":"server","permalink":"https://j2de.github.io/categories/server/"},{"name":"Netty","slug":"server/netty","permalink":"https://j2de.github.io/categories/server/netty/"}],"tags":[{"name":"Network","slug":"network","permalink":"https://j2de.github.io/tags/network/"},{"name":"Netty","slug":"netty","permalink":"https://j2de.github.io/tags/netty/"}]}]}