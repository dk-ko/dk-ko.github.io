<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    

    
    <title>Netty 채널 이벤트와 이벤트핸들러, 그리고 파이프라인 | Jade&#39;s Blog</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="Network,Netty">
    
    <meta name="description" content="Netty의 ChannelPipeline은 Channel에서 발생한 이벤트가 이동하는 통로이다. 이 통로를 통해 이동하는 이벤트를 처리하는 클래스가 이벤트 핸들러이다. 네티의 이벤트 메소드는 데이터가 수신되면 네티가 자동으로 호출한다.  Netty의 전체적인 구조는 이 게시글을 참고  자바를 이용한 기존의 서버 프로그래밍은 소켓을 이용하고 데이터가 수신하기">
<meta name="keywords" content="Network,Netty">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty 채널 이벤트와 이벤트핸들러, 그리고 파이프라인">
<meta property="og:url" content="https://kodakyung.github.io/2018/05/25/server-netty-2018-05-25-netty-channel-event-and-eventhandler-and-pipeline/index.html">
<meta property="og:site_name" content="Jade&#39;s Blog">
<meta property="og:description" content="Netty의 ChannelPipeline은 Channel에서 발생한 이벤트가 이동하는 통로이다. 이 통로를 통해 이동하는 이벤트를 처리하는 클래스가 이벤트 핸들러이다. 네티의 이벤트 메소드는 데이터가 수신되면 네티가 자동으로 호출한다.  Netty의 전체적인 구조는 이 게시글을 참고  자바를 이용한 기존의 서버 프로그래밍은 소켓을 이용하고 데이터가 수신하기">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://kodakyung.github.io/images/2018-05-25/01.jpeg">
<meta property="og:updated_time" content="2020-03-19T01:12:26.932Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Netty 채널 이벤트와 이벤트핸들러, 그리고 파이프라인">
<meta name="twitter:description" content="Netty의 ChannelPipeline은 Channel에서 발생한 이벤트가 이동하는 통로이다. 이 통로를 통해 이동하는 이벤트를 처리하는 클래스가 이벤트 핸들러이다. 네티의 이벤트 메소드는 데이터가 수신되면 네티가 자동으로 호출한다.  Netty의 전체적인 구조는 이 게시글을 참고  자바를 이용한 기존의 서버 프로그래밍은 소켓을 이용하고 데이터가 수신하기">
<meta name="twitter:image" content="https://kodakyung.github.io/images/2018-05-25/01.jpeg">
    
    <link rel="canonical" href="https://kodakyung.github.io/2018/05/25/server-netty-2018-05-25-netty-channel-event-and-eventhandler-and-pipeline/">

    
        <link rel="alternate" href="https://kodakyung.github.io/feed.xml" title="Jade&#39;s Blog" type="application/atom+xml">
    

    
        <link rel="icon" href="/images/favicions/floppy_disk.ico">
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/3.3.1/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-146445480-1', 'auto');
ga('send', 'pageview');

</script>

    
    



    <link rel="stylesheet" href="https://cdn.rawgit.com/innks/NanumSquareRound/master/nanumsquareround.css">
</head>
</html>
<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">An archive for daily discovery</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">Home</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/cs/">CS</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/cs/database/">DataBase</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/cs/os/">OS</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/programming/">Programming</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/programming/common/">Common</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/programming/java/">Java</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/programming/javascript/">Javascript</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/server/">Server</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/server/netty/">Netty</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/server/orm/">ORM</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/server/spring/">Spring</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/server/test/">Test</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/system/">System</a><ul class="main-nav-list-child"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/system/docker/">Docker</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/system/shell/">Shell</a></li></ul></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/think/">Think</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/troubleshooting/">Troubleshooting</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/web/">Web</a></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/server/">Server</a><i class="icon fa fa-angle-right"></i><a class="page-title-link" href="/categories/server/netty/">Netty</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-server-netty-2018-05-25-netty-channel-event-and-eventhandler-and-pipeline" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        Netty 채널 이벤트와 이벤트핸들러, 그리고 파이프라인
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2018/05/25/server-netty-2018-05-25-netty-channel-event-and-eventhandler-and-pipeline/" class="article-date">
            <time datetime="2018-05-24T15:00:00.000Z" itemprop="datePublished">2018-05-25</time>
        </a>
    </div>

		

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/netty/">Netty</a>, <a class="tag-link" href="/tags/network/">Network</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <p>Netty의 <code>ChannelPipeline</code>은 <code>Channel</code>에서 발생한 <code>이벤트</code>가 이동하는 통로이다. 이 통로를 통해 이동하는 이벤트를 처리하는 클래스가 <code>이벤트 핸들러</code>이다. 네티의 <code>이벤트 메소드</code>는 데이터가 수신되면 네티가 자동으로 호출한다.</p>
<blockquote>
<p>Netty의 전체적인 구조는 <a href="https://kodakyung.github.io/2018/05/21/old-post-Netty-2018-05-21-Netty-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-Component/">이 게시글</a>을 참고</p>
</blockquote>
<p>자바를 이용한 기존의 서버 프로그래밍은 소켓을 이용하고 데이터가 수신하기를 기다린다. 이와 같은 상황일때 프로세스는 아래와 같다.</p>
<ul>
<li><strong>기존 자바 네트워크 프로그래밍</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 소켓에 데이터가 있는지 확인한다.</span><br><span class="line">2. (1)에서 데이터가 존재하면 데이터를 읽어들이는 메소드를 호출한다.</span><br><span class="line">3. 읽어들일 데이터가 존재하지 않으면 데이터가 도착할 때까지 기다린다.(blocking)</span><br><span class="line">4. 데이터를 기다리는 중에 네트워크가 끊어지면 에러 처리를 위한 메소드를 호출한다.</span><br></pre></td></tr></table></figure>

<p>Netty로 네트워크 프로그래밍을 하면 <code>채널 파이프라인</code>과 <code>이벤트 핸들러</code>로 추상화했기 때문에, <em>데이터의 수신 여부, 소켓의 연결 여부에 대한 예외 상황에서 메소드 호출에 관여할 필요가 없다.</em></p>
<ul>
<li><strong>Netty 네트워크 프로그래밍</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 부트스트랩으로 네트워크 애플리케이션에 필요한 설정을 지정한다.</span><br><span class="line">2. 부트스트랩에 이벤트 핸들러를 사용하여 채널 파이프라인을 구성한다.</span><br><span class="line">3. 이벤트 핸들러의 데이터 수신 이벤트 메소드에서 데이터를 읽어들인다.</span><br><span class="line">4. 이벤트 핸들러의 네트워크 끊김 이벤트 메소드에서 에러 처리를 한다.</span><br></pre></td></tr></table></figure>

<p>위 처럼 네티의 <strong>이벤트 루프가 소켓 채널에서 발생한 이벤트에 해당하는 이벤트 메소드를 자동으로 실행한다.</strong> 소켓 채널에 데이터가 수신된 경우 아래와 같은 프로세스로 동작한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 네티의 이벤트 루프가 채널 파이프라인에 등록된 첫 번째 이벤트 핸들러를 가져온다.</span><br><span class="line">2. 이벤트 핸들러에 데이터 수신 이벤트가 구현되어 있으면 실행한다.</span><br><span class="line">3. 데이터 수신 이벤트 메소드가 구현되어 있지 않으면 다음 이벤트 핸들러를 가져온다.</span><br><span class="line">4. (2)를 수행한다.</span><br><span class="line">5. 채널 파이프라인에 등록된 마지막 이벤트 핸들러에 도달할 때까지 (1)을 반복한다.</span><br></pre></td></tr></table></figure>

<p>데이터를 처리하는 입출력은 네티가 이벤트로 관리하므로 <strong>해당 이벤트에 해당하는 코드만 구현하면 된다.</strong></p>
<br>

<h1 id="ChannelPipeline-인터페이스"><a href="#ChannelPipeline-인터페이스" class="headerlink" title="ChannelPipeline 인터페이스"></a>ChannelPipeline 인터페이스</h1><p>Netty의 <code>ChannelPipeline</code>은 <code>Channel</code>과 <code>EventHandler</code> 사이에서 연결 통로 역할을 한다. Channel은 일반적인 소켓 프로그래밍의 <code>소켓</code>과 같다. 이 소켓에서 발생한 <code>이벤트</code>는 <code>채널 파이프라인</code>을 따라 흐른다. 그리고 이 <code>이벤트 핸들러</code>가 이벤트들을 수신하고 처리하는 기능을 한다. 하나의 채널 파이프라인에 여러 이벤트 핸들러를 등록할 수 있다. 종합하면 ChannelPipeline은 소켓 채널에서 발생한 이벤트 처리를 위한 추상화 모델이다.</p>
<br>

<h2 id="ChannelPipeline-구성"><a href="#ChannelPipeline-구성" class="headerlink" title="ChannelPipeline 구성"></a>ChannelPipeline 구성</h2><img alt="channelpipline" src="/images/2018-05-25/01.jpeg">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 클라이언트 연결에 대응하는 소켓 객체를 생성하고 빈 채널 파이프라인 객체를 생성해서 소켓 채널에 할당한다.</span><br><span class="line">2. 소켓 채널에 등록된 ChannelInitializer 인터페이스 구현체를 가져와서 initChannel 메소드를 호출한다.</span><br><span class="line">3. 소켓 채널 참조로부터 (1)에서 등록한 파이프라인 객체를 가져오고 채널 파이프라인에 입력된 이벤트 핸들러 객체를 등록한다.</span><br></pre></td></tr></table></figure>

<p>위의 세 단계가 완료되면 채널이 등록됐다는 이벤트가 발생하고 이때부터 클라이언트와 서버간의 데이터 송수신을 위한 이벤트 처리가 시작된다.</p>
<p><code>ChannelPipeline</code>은 <code>ChannelInboundHandler</code>와 <code>ChannelOutboundHandler</code>가 모두 들어있는 <code>ChannelHandler</code>의 연속이다. 인바운드 이벤트가 트리거 되는 경우 <code>ChannelPipeline</code>의 시작부터 끝까지 전달된다. ChannelPipeline에는 ChannelPipeline 자체를 통해 전파되는 이벤트도 있다.</p>
<p>인바운드와 아웃바운드의 기준은 상대적이며 시작점을 어디로 기준으로 하느냐에 따라 다르다. 파이프라인은 이벤트를 전파하는 동안 파이프라인의 다음 <code>ChannelHandler</code>가 같은 이동 방향인지 확인한다. 그리고 이동방향이 다르면 <code>ChannelPipeline</code>은 방향이 일치하는 항목이 나올 때까지 <code>ChannelHandler</code>를 건너뛴다.</p>
<p>ChannelHandler는 ChannelPipeline에 다른 ChannelHandler를 추가 또는 제거하는 방법으로 ChannelPipeline을 실시간으로 수정할 수 있다. 심지어 자기 자신을 ChannelPipeline에서 제거할 수도 있다.</p>
<ul>
<li><strong>ChannelPipeline을 수정하는 ChannelHandler 메소드</strong></li>
</ul>
<table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>addFirst</td>
<td>ChannelHandler를 ChannelPipeline에 추가한다</td>
</tr>
<tr>
<td>addBefore</td>
<td></td>
</tr>
<tr>
<td>addAfter</td>
<td></td>
</tr>
<tr>
<td>addLast</td>
<td></td>
</tr>
<tr>
<td>remove</td>
<td>ChannelHandler를 ChannelPipeline에서 제거한다.</td>
</tr>
<tr>
<td>replace</td>
<td>ChannelPipeline 내의 ChannelHandler를 다른 ChannelHandler로 대체한다.</td>
</tr>
</tbody></table>
<ul>
<li>ChannelPipeline 수정 예제</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = ..;</span><br><span class="line">FirstHandler firstHandler = <span class="keyword">new</span> FirstHandler();</span><br><span class="line"><span class="comment">// FirstHandler 인스턴스 생성</span></span><br><span class="line">pipeline.addLast(<span class="string">"handler1"</span>, firstHandler);</span><br><span class="line"><span class="comment">// 생성한 인스턴스를 ChannelPipeline에</span></span><br><span class="line"><span class="comment">// "handler1"이라는 이름으로 추가함</span></span><br><span class="line">pipeline.addFirst(<span class="string">"handler2"</span>, <span class="keyword">new</span> SecondHandler());</span><br><span class="line"><span class="comment">// SecondHandler 인스턴스를 ChannelPipeline의</span></span><br><span class="line"><span class="comment">// 첫번째 슬록에 "handler2"라는 이름으로 추가해</span></span><br><span class="line"><span class="comment">// 기존의 "handler1"보다 앞에 배치</span></span><br><span class="line">pipeline.addLast(<span class="string">"handler3"</span>, <span class="keyword">new</span> ThirdHandler());</span><br><span class="line"><span class="comment">// ThirdHandler 인스턴스를 ChannelPipeline의</span></span><br><span class="line"><span class="comment">// 마지막 슬롯에 "handler3"라는 이름으로 추가</span></span><br><span class="line">...</span><br><span class="line">pipeline.remove(<span class="string">"handler3"</span>);</span><br><span class="line"><span class="comment">// 인스턴스 이름으로 지정해 제거</span></span><br><span class="line">pipeline.remove(firstHandler);</span><br><span class="line"><span class="comment">// FirstHandler를 참조해 제거(고유)</span></span><br><span class="line">pipeline.replace(<span class="string">"handler2"</span>, <span class="string">"handler4"</span>, <span class="keyword">new</span> FourthHandler());</span><br><span class="line"><span class="comment">// SecondHandler를 FourthHandler로 대체</span></span><br></pre></td></tr></table></figure>

<p>반면에 ChannelPipeline에서도 ChannelHandler에 접근이 가능하다.</p>
<ul>
<li><strong>ChannelHandler에 접근하는 ChannelPipeline 메소드</strong></li>
</ul>
<table>
<thead>
<tr>
<th>이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>get</td>
<td>지정한 형식이나 이름에 해당하는 ChannelHandler를 반환한다.</td>
</tr>
<tr>
<td>context</td>
<td>ChannelHandler에 바인딩된 ChannelHandlerContext를 반환한다.</td>
</tr>
<tr>
<td>names</td>
<td>ChannelPipeline에 포함된 모든 ChannelHandler의 이름을 반환한다.</td>
</tr>
</tbody></table>
<ul>
<li><strong>ChannelPipeline의 인바운드 작업</strong>  </li>
</ul>
<table>
<thead>
<tr>
<th>메소드 이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>fireChannelRegistered</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelRegistered(ChannelHandlerContext)를 호출한다</td>
</tr>
<tr>
<td>fireChannelUnregistered</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelUnregistered(ChannelHandlerContext)를 호출한다.</td>
</tr>
<tr>
<td>fireChannelActive</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelActive(ChannelHandlerContext)를 호출한다.</td>
</tr>
<tr>
<td>fireChannelInactive</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelInactive(ChannelHandlerContext)를 호출한다.</td>
</tr>
<tr>
<td>fireExceptionCaught</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 exceptionCaught(ChannelHandlerContext, Throwable)를 호출한다.</td>
</tr>
<tr>
<td>fireUserEventTriggered</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 userEventTriggered(ChannelHandlerContext, Object)를 호출한다.</td>
</tr>
<tr>
<td>fireChannelRead</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelRead(ChannelHandlerContext, Object msg)를 호출한다.</td>
</tr>
<tr>
<td>fireChannelReadComplete</td>
<td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelReadComplete(ChannelHandlerContext)를 호출한다.</td>
</tr>
</tbody></table>
<ul>
<li><strong>ChannelPipeline의 아웃바운드 작업</strong>  </li>
</ul>
<table>
<thead>
<tr>
<th>메소드 이름</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>bind</td>
<td>Channel을 로컬 주소로 바인딩한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 bind(ChannelHandlerContext, SocketAddress, ChannelPromise)를 호출한다.</td>
</tr>
<tr>
<td>connect</td>
<td>Channel을 원격 주소로 연결한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 connect(ChannelHandlerContext, SocketAddress, ChannelPromise)를 호출한다.</td>
</tr>
<tr>
<td>disconnect</td>
<td>Channel 연결을 해제한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 disconnect(ChannelHandlerContext, ChannelPromise)를 호출한다.</td>
</tr>
<tr>
<td>close</td>
<td>Channel을 닫는다. ChannelPipeline의 다음 ChannelOutboundHandler에서 close(ChannelHandlerContext, ChannelPromise)를 호출한다.</td>
</tr>
<tr>
<td>deregister</td>
<td>이전에 할당한 EventExcutor(EventLoop)에서 Channel 등록을 해제한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 deregister(ChannelHandlerContext, ChannelPromise)를 호출한다.</td>
</tr>
<tr>
<td>flush</td>
<td>Channel의 대기 중인 기록을 모두 플러시한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 flush(ChannelHandlerContext)를 호출한다.</td>
</tr>
<tr>
<td>write</td>
<td>Channel에 메세지를 기록한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 write(ChannelHandlerContext, Objectmsg, ChannelPromise)를 호출한다. (기록을 요청하는 것이며 기반 Socket에 바로 메세지를 기록하는 것은 아니다. Socket으로 기록하려면 flush()나 writeAndFlush()를 호출한다.)</td>
</tr>
<tr>
<td>writeAndFlush</td>
<td>write()를 호출한 뒤 flush()를 호출하는 편의 메소드</td>
</tr>
<tr>
<td>read</td>
<td>Channel에서 데이터 읽기를 요청한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 read(ChannelHandlerContext)를 호출한다.</td>
</tr>
</tbody></table>
<br>

<h1 id="ChannelHandler-인터페이스"><a href="#ChannelHandler-인터페이스" class="headerlink" title="ChannelHandler 인터페이스"></a>ChannelHandler 인터페이스</h1><p><strong>이벤트 핸들러는 네티의 소캣 채널에서 발생한 이벤트를 처리하는 인터페이스다.</strong> 소켓 채널의 이벤트를 인터페이스로 정의하고 이 인터페이스를 상속 받은 이벤트 핸들러를 작성해서 채널 파이프라인에 등록한다. 채널 파이프라인으로 입력되는 이벤트를 이벤트 루프가 가로채어 이벤트에 해당하는 메소드를 수행하는 구조다. 그러므로 <em>네티가 제공하는 이벤트의 종류나 발생 시기를 아는 것이 중요하다.</em></p>
<h2 id="Channel-수명주기"><a href="#Channel-수명주기" class="headerlink" title="Channel 수명주기"></a>Channel 수명주기</h2><table>
<thead>
<tr>
<th>상태</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>ChannelUnregistered</td>
<td>Channel이 생성됐지만 EventLoop에 등록되지 않음</td>
</tr>
<tr>
<td>ChannelRegistered</td>
<td>Channel이 EventLoop에 등록됨</td>
</tr>
<tr>
<td>ChannelActive</td>
<td>Channel이 활성화됨(원격 피어로 연결됨). 이제 데이터 주고받기 가능</td>
</tr>
<tr>
<td>ChannelInactive</td>
<td>Channel이 원격 피어로 연결되지 않음</td>
</tr>
</tbody></table>
<p>일반적인 수명주기는 <code>ChannelRegistered</code> -&gt; <code>ChannelActive</code> -&gt; <code>ChannelInactive</code> -&gt; <code>ChannelUnregistered</code> 순으로 이뤄진다.<br>수명주기 상태 변경이 수행될 때 해당하는 이벤트가 생성된다. 이런 이벤트는 <code>ChannelPipeline</code>에 있는 <code>ChannelHandler</code>로 전달된다.</p>
<h2 id="ChannelHandler-수명주기"><a href="#ChannelHandler-수명주기" class="headerlink" title="ChannelHandler 수명주기"></a>ChannelHandler 수명주기</h2><table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>handlerAdded</td>
<td>ChannelHandler가 ChannelPipeline에 추가될 때 호출</td>
</tr>
<tr>
<td>handlerRemoved</td>
<td>ChannelHandler가 ChannelPipeline에서 제거될 때 호출</td>
</tr>
<tr>
<td>exceptionCaught</td>
<td>ChannelPipeline에서 처리 중에 오류가 발생하면 호출</td>
</tr>
</tbody></table>
<p>위 메소드는 <code>ChannelHandler</code>가 <code>ChannelPipeline</code>에 추가 또는 제거된 후 호출된다. 각 메소드는 <code>ChannelHandlerContext</code> 인수를 받는다.  </p>
<p><code>ChannelHandler</code>는 하위 인터페이스 <code>ChannelInboundHandler</code>와 <code>ChannelOutboundHandler</code>로 나뉜다.</p>
<ul>
<li>ChannelInboundHandler : 모든 유형의 인바운드 데이터와 상태 변경을 처리</li>
<li>ChannelOutboundHandler : 아웃 바운드 데이터를 처리하고 모든 작업의 가로채기를 허용함</li>
</ul>
<br>

<h2 id="ChannelInboundHandler-인터페이스"><a href="#ChannelInboundHandler-인터페이스" class="headerlink" title="ChannelInboundHandler 인터페이스"></a>ChannelInboundHandler 인터페이스</h2><p>클라이언트가 서버에 접속한 상태에서 서버로 데이터를 보내는 경우, 서버 측에서는 네티가 소켓에 읽을 데이터가 있다는 이벤트를 채널 파이프라인으로 보내게된다. 그러면 채널 파이프라인에 등록된 이벤트 핸들러 중에서 인바운드 이벤트 핸들러가 해당 이벤트에 해당하는 메소드를 수행한다.</p>
<ul>
<li>인바운드 이벤트 발생 순서</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 이벤트 루프에 채널 등록(channelRegistered)</span><br><span class="line">2. 채널 활성화(channelActive)</span><br><span class="line">3. 데이터 수신(channelRead)</span><br><span class="line">4. 데이터 수신 완료(channelReadComplete)</span><br><span class="line">5. 채널 비활성화(channelInactive)</span><br><span class="line">6. 이벤트 루프에서 채널 제거(channelUnregistered)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>channelRegistered</td>
<td>channel이 EventLoop에 등록되고 입출력을 처리할 수 있으면 호출됨</td>
</tr>
<tr>
<td>channelUnregistered</td>
<td>channel이 EventLoop에서 등록 해제되고 입출력을 처리할 수 없으면 호출됨</td>
</tr>
<tr>
<td>channelActive</td>
<td>channel의 연결과 바인딩이 완료되어 활성화되면 호출됨</td>
</tr>
<tr>
<td>channelInactive</td>
<td>channel이 활성 상태에서 벗어나 로컬 피어에 대한 연결이 해제되면 호출됨</td>
</tr>
<tr>
<td>channelReadComplete</td>
<td>channel에서 읽기 작업이 완료되면 호출됨</td>
</tr>
<tr>
<td>channelRead</td>
<td>channel에서 데이터를 읽을 때 호출 됨</td>
</tr>
<tr>
<td>channelWritabilityChanged</td>
<td>channel의 기록 가능 상태가 변경되면 호출된다. OutOfMemoryError를 방지하기 위해서 너무 빠르게 기록되지 않게 하거나 channel이 기록 가능한 상태가 되면 기록을 재개할 수 없다. Channel의 isWritable() 메소드를 호출해 해당 채널의 기록 가능 여부를 감지할 수 있다. 기록 가능 여부를 결정하는 임계값은 Channel.config().setWriteHighWaterMark()와 Channel.config().setWriteLowWaterMark() 메소드로 설정한다.</td>
</tr>
<tr>
<td>userEventTriggered</td>
<td>POJO가 ChannelPipeline을 통해 전달돼서 ChannelInboundHandler.fireUserEventTriggered()가 트리거되면 호출된다.</td>
</tr>
</tbody></table>
<p>위의 메소드들은 데이터가 수신되거나 연결된 Channel의 상태가 변경될 때 호출된다. 이런 메소드들은 <code>Channel의 수명 주기</code>와 관련이 깊다. 이 중 <code>channelRead</code> 메소드를 Override하는 경우 풀링된 ByteBuf 인스턴스의 메모리를 <code>release()</code> 메소드를 사용해 해제 해야한다.</p>
<p>매번 리소스 관리하기가 번거로운 경우 <code>SimpleChannelInboundHandler</code>를 상속받아 <code>channelRead0</code> 메소드를 사용하면 리소스를 해제 할 필요가 없다. 대신 메세지를 참조해 활용하는 경우 이 클래스를 사용하면 안된다.</p>
<ul>
<li>ChannelInboundHandlerAdapter 상속</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">    ReferenceCountUtil.release(msg);</span><br><span class="line">    <span class="comment">// 리소스 해제를 필수적으로 해줘야함</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>SimpleChannelInboundHandler 상속</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDiscardHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 리소스를 해제할 필요 없음</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li><strong>서버와 클라이언트의 channelRegistered 발생 위치</strong></li>
</ul>
<table>
<thead>
<tr>
<th align="right">네티 서버</th>
<th align="left">네티 클라이언트</th>
</tr>
</thead>
<tbody><tr>
<td align="right"></td>
<td align="left"><strong>connect() 호출</strong></td>
</tr>
<tr>
<td align="right">생성 및 이벤트 루프 호출</td>
<td align="left">생성 및 이벤트 루프 등록</td>
</tr>
<tr>
<td align="right">[서버 소켓 채널]</td>
<td align="left">[클라이언트 소켓 채널]</td>
</tr>
<tr>
<td align="right"><strong>↓</strong></td>
<td align="left"><strong>↓</strong></td>
</tr>
<tr>
<td align="right"><em>(1)channelRegistered 이벤트</em></td>
<td align="left"><em>(2)channelRegistered 이벤트</em></td>
</tr>
<tr>
<td align="right"><strong>↓</strong></td>
<td align="left"><strong>↓</strong></td>
</tr>
<tr>
<td align="right">연결</td>
<td align="left">요청</td>
</tr>
<tr>
<td align="right">[서버 소켓 채널]<strong>&lt;—–</strong></td>
<td align="left"><strong>—–</strong>[클라이언트 소켓 채널]</td>
</tr>
<tr>
<td align="right"><strong>↓</strong> accept()</td>
<td align="left"></td>
</tr>
<tr>
<td align="right">생성 및 이벤트 루프 등록</td>
<td align="left"></td>
</tr>
<tr>
<td align="right">[클라이언트 소켓 채널]</td>
<td align="left"></td>
</tr>
<tr>
<td align="right"><em>(3)channelRegistered 이벤트</em></td>
<td align="left"></td>
</tr>
</tbody></table>
<p><code>channelRegistered</code> 이벤트는 <strong>(1)과 같은 처음 서버 소켓 채널을 생성할 때</strong>, <strong>(3)과 같이 새로운 클라이언트가 서버에 접속해 클라이언트 소켓 채널이 생성될 때</strong> 발생한다. 즉, 서버 소켓 채널에서 발생한 channelRegistered 이벤트와 서버에 연결된 클라이언트 소켓 채널에서 발생한 channelRegistered 이벤트 2가지다. 클라이언트에서는 <strong>(2)와 같이 서버 접속을 위한 connect 메소드를 수행할 때</strong> channelRegistered 이벤트가 발생한다. 즉 channelRegistered 이벤트는 서버 클라이언트 상관 없이 새로운 채널이 생성되는 시점에 발생한다.</p>
<br>

<ul>
<li><strong>channelActive 이벤트</strong><br><code>channelActive</code> 이벤트는 channelRegistered 이벤트 이후에 발생한다. 채널이 생성되고 이벤트 루프에 등록된 후 네티 API를 통해 채널 입출력 상태가 가능하다는 것을 알려준다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 서버 어플리케이션에 연결된 클라이언트 갯수 세기</span><br><span class="line">- 서버 애플리케이션에 연결된 클라이언트에게 최초 연결에 대한 메세지 전송</span><br><span class="line">- 클라이언트 어플리케이션이 연결된 서버에 최초 메세지를 전달할 때</span><br><span class="line">- 클라이언트 어플리케이션이 서버에 연결된 상태에 대한 작업이 필요할 때</span><br></pre></td></tr></table></figure>

<p>위의 상황 같이 channelActive 이벤트를 서버 또는 클라이언트가 상대방에 연결한 직후 한번 수행하는 작업을 처리하기에 적합하다.</p>
<br>

<h2 id="ChannelOutboundHandler-인터페이스"><a href="#ChannelOutboundHandler-인터페이스" class="headerlink" title="ChannelOutboundHandler 인터페이스"></a>ChannelOutboundHandler 인터페이스</h2><p>아웃바운드 이벤트는 소켓 채널에서 발생한 이벤트 중에서 네티 사용자가 요청한 동작에 해당하는 이벤트를 말한다. 연결 요청, 데이터 전송, 소켓 닫기 등이 해당한다. 아웃바운드 이벤트는 <code>ChannelOutboundHandler</code> 인터페이스로 제공되고 모든 <code>ChannelOutboundHandler</code> 이벤트는 <code>ChannelOutboundHandlerContext</code> 객체를 인수로 받는다. ChannelOutboundHandler는 작업이나 이벤트를 지연하는 기능이 있어 정교하게 요청을 처리할 수 있다. 예를 들면 원격 피어에 대한 기록이 일시 중단된 경우 플러시 작업을 지연하고 나중에 재개할 수 있다.</p>
<table>
<thead>
<tr>
<th>메소드</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>bind(ChannelHandlerContext, SocketAddress, ChannelPromise)</td>
<td>Channel을 로컬 주소로 바인딩 요청, 서버 소켓 채널이 클라이언트의 연결을 대기하는 IP와 포트가 설정되었을 때 발생. 즉 bind 이벤트에서는 서버 소켓 채널이 사용중인 SocketAddress 객체가 인수로 입력된다.</td>
</tr>
<tr>
<td>connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)</td>
<td>Channel을 원격 피어로 연결 요청 시 호출 됨. 원격지의 SocketAddress 정보와 로컬 SocketAddress 정보가 인수로 입력된다.</td>
</tr>
<tr>
<td>disconnect(ChannelHandlerContext, ChannelPromise)</td>
<td>Channel을 원격 피어로부터 연결 해제 요청시 호출 됨.</td>
</tr>
<tr>
<td>close(ChannelHandlerContext, ChannelPromise)</td>
<td>Channel을 닫는 요청 시 호출 됨</td>
</tr>
<tr>
<td>deregister(ChannelHandlerContext, ChannelPromise)</td>
<td>Channel을 EventLoop에서 등록 해제 요청시 호출됨</td>
</tr>
<tr>
<td>read(ChannelHandlerContext)</td>
<td>Channel에서 데이터 읽기 요청시 호출됨</td>
</tr>
<tr>
<td>flush(ChannelHandlerContext)</td>
<td>Channel을 통해 원격 피어로 큐에 있는 데이터의 플러시 요청시 호출</td>
</tr>
<tr>
<td>write(ChannelHandlerContext, Object, ChannelPromise)</td>
<td>Channel을 통해 원격 피어로 데이터 기록 요청 시 호출됨. 소켓 채널에 기록된 데이터 버퍼가 인수로 입력된다.</td>
</tr>
</tbody></table>
<ul>
<li>ChannelPromise ? ChannelFuture ?  </li>
</ul>
<blockquote>
<p>ChannelOutboundHandler에 있는 대부분 메소드는 작업이 완료되면 알림을 전달받을 ChannelPromise 인수가 있다. ChannelPromise는 ChannelFuture의 하위 인터페이스로 setSuccess()나 setFailure()와 같은 기록 가능 메소드를 정의해서 ChannelFuture을 읽기전용으로 만든다.</p>
</blockquote>
<h3 id="리소스-관리"><a href="#리소스-관리" class="headerlink" title="리소스 관리"></a>리소스 관리</h3><p><code>ChannelInboundHandler.channelRead()</code> 또는 <code>ChannelOutboundHandler.write()</code>를 호출해 데이터를 작업한 경우 리소스 누출이 발생하지 않게 관리해아한다. 네티는 참조 카운팅을 이용해 풀링된 ByteBuf를 관리한다. 따라서 ByteBuf 사용 후 참조 카운트를 조정하는 것이 필요하다.<br>네티가 제공하는 <code>ResourceLeakDetector</code> 클래스를 이용한다.</p>
<ul>
<li>리소스 누출 감지 수준</li>
</ul>
<table>
<thead>
<tr>
<th>수준</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>DISABLED</td>
<td>누출 감지를 비활성화한다. 이 설정은 포괄적인 테스트를 거친 후에만 이용한다.</td>
</tr>
<tr>
<td>SIMPLE</td>
<td>기본 샘플링 비율 1%를 이용해 발견된 누출을 보고한다. 기본 샘플링 비율은 대부분의 경우에 적합하다</td>
</tr>
<tr>
<td>ADVANCED</td>
<td>발견된 누출과 메세지에 접근한 위치를 보고한다. 기본 샘플링 비율을 이용한다</td>
</tr>
<tr>
<td>PARANOID</td>
<td>ADVANCED와 비슷하지만 모든 접근을 샘플링한다. 성능에 큰 영향을 미쳐서 디버깅 단계에서만 사용해야한다.</td>
</tr>
</tbody></table>
<p>자바 시스템 속성을 표에 있는 값 중에 하나로 변경하면 설정할 수 있다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dio.netty.leakDetectionLevel=ADVANCED</span><br></pre></td></tr></table></figure>

<br>

<h2 id="ChannelHandlerContext-인터페이스"><a href="#ChannelHandlerContext-인터페이스" class="headerlink" title="ChannelHandlerContext 인터페이스"></a>ChannelHandlerContext 인터페이스</h2><p><code>ChannelHandlerContext</code>는 <code>ChannelHandler</code>와 <code>ChannelPipeline</code>간의 연결을 나타내며 <code>ChannelHandler</code>는 <code>ChannelPipeline</code>에 추가할 때마다 생성된다. <code>ChannelHandlerContext</code>에는 다양한 메소드가 있다.</p>
<p><code>ChannelHandlerContext</code>는 두 가지 네티 객체의 상호작용을 도와주는 인터페이스다. 첫번째는 채널에 대한 입출력 처리이며 두번째는 채널 파이프라인에 대한 상호작용이다.  </p>
<p>첫째 채널에 대한 입출력의 경우 <code>ChannelHandlerContext</code>의 <code>writeAndFlush</code>메소드로 채널에 데이터를 기록하고 <code>close</code> 메소드로 채널의 연결을 종료할 수 있다.    </p>
<p>두번째 파이프라인에 대한 상호작용은 사용자에 의한 이벤트 발생과 채널 파이프라인에 등록된 이벤트 핸들러의 상태가 변경되는 것 두가지가 있다. 파이프라인에는 여러 이벤트 핸들러는 등록할 수 있고 채널이 초기화될 때 채널 파이프라인의 이벤트 핸들러가 설정된다. <code>ChannelHandlerContext</code>는 채널이 초기화될 때 설정된 채널 파이프라인을 가져오는 메소드를 제공한다. 그래서 <code>ChannelHandlerContext</code>를 통해 설정된 채널 파이프라인을 수정할 수 있다.</p>
<br>

<h2 id="예외-처리"><a href="#예외-처리" class="headerlink" title="예외 처리"></a>예외 처리</h2><h3 id="인바운드-예외-처리"><a href="#인바운드-예외-처리" class="headerlink" title="인바운드 예외 처리"></a>인바운드 예외 처리</h3><p>인바운드 이벤트가 처리되는 동안 예외가 발생하면 실행된 <code>ChannelInboundHandler</code>부터 시작해 예외가 <code>ChannelPipeline</code>을 통과하기 시작한다. 이런 인바운드 예외를 처리하기 위해 <code>exceptionCaught</code> 메소드를 재정의한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure>

<ul>
<li>기본 인바운드 예외 처리<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>모든 인바운드 이벤트는 인바운드 방향으로 진행된다. 예외 또한 마찬가지이다. 따라서 예외 처리 루틴을 채널 파이프라인의 끝부분에 배치하면 채널 파이프라인에 어느 위치에서 예외가 발생하더라도 모두 처리할 수 있다.</p>
<p>예외 대응 방식은 애플리케이션에 따라 다르지만 Channel을 닫거나 복구를 시도하며, 예외처리를 구현하지 않는 경우 관련 내용을 알리는 로깅을 할 수 있다.</p>
<ul>
<li><code>ChannelHandler.exceptionCaught()</code>의 기본 구현은 현재 예외를 다음 파이프라인의 예외로 전달한다.</li>
<li>예외가 파이프라인 끝에 도달하면 예외가 처리되지 않았음을 알리는 항목이 로깅된다.</li>
<li>예외를 처리하는 방식을 원하는대로 하고 싶다면 <code>exceptionCaught()</code>를 재정의한다. 예외를 외부로 전파할지 말지 여부는 개발자가 결정할 수 있다.</li>
</ul>
<h3 id="아웃바운드-예외-처리"><a href="#아웃바운드-예외-처리" class="headerlink" title="아웃바운드 예외 처리"></a>아웃바운드 예외 처리</h3><p>아웃바운드 작업에서 정상적인 완료와 예외 처리하는 옵션은 <code>ChannelFuture</code>를 이용한다.</p>
<ul>
<li>모든 아웃바운드 작업은 <code>ChannelFuture</code>를 반환한다. 작업이 완료되면 <code>ChannelFuture</code>에 등록된 <code>ChannelFutureListener</code>에 성공이나 오류에 대한 알림이 제공된다.</li>
<li><code>ChannelOutboundHandler</code>의 거의 모든 메소드에는 <code>ChannelPromise</code>가 전달된다. <code>ChannelFuture</code>의 하위 클래스인 <code>ChannelPromise</code>에도 비동기 알림을 위한 수신기를 할당할 수 있다. 그리고 <code>ChannelPromise</code>에도 즉시 알림을 지원하는 쓰기 가능 메소드가 있다.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ChannelPromise <span class="title">setSuccess</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelPromise <span class="title">setFailure</span><span class="params">(Throwable cause)</span></span>;</span><br></pre></td></tr></table></figure>

<p>여기서 <code>ChannelFutureListener</code>를 추가하려면 <code>ChannelFuture</code> 인스턴스의 <code>addListener(Channel)</code>을 호출해야하는데 두가지 호출 방법이 있다.</p>
<p>(1) 아웃바운드 작업(write() 등)이 반환하는 <code>ChannelFuture</code>의 <code>addListener()</code>를 호출</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = channel.write(someMessage);</span><br><span class="line">future.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!f.isSuccess())&#123;</span><br><span class="line">      f.cause().printStackTrace();</span><br><span class="line">      f.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>(2) ChannelOutboundHandler 메소드에 인수로 전달되는 <code>ChannelPromise</code>에 <code>ChannelListener</code>를 추가</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutboundExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span></span>&#123;</span><br><span class="line">    promise.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f.isSuccess())&#123;</span><br><span class="line">          f.cause().printStackTrace();</span><br><span class="line">          f.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>예외를 세부적으로 처리하고 싶은 경우 (1)을, 간단하게 예외를 처리하고 싶다면 (2) 구현을 사용하는 것이 좋다.</p>
<br>

<h2 id="이벤트-실행-흐름"><a href="#이벤트-실행-흐름" class="headerlink" title="이벤트 실행 흐름"></a>이벤트 실행 흐름</h2><p>위의 내용들을 종합해 <code>ChannelPipeline</code>과 <code>ChannelHandler</code>를 통해 이벤트가 실행되는 과정을 알아보자.</p>
<ul>
<li>ChannelPipeline에 여러개의 핸들러 등록</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span>&#123;</span><br><span class="line">        ChannelPipeline p = ch.pipeline();</span><br><span class="line">        p.addLast(<span class="keyword">new</span> EchoServerFirstHandler());</span><br><span class="line">        p.addLast(<span class="keyword">new</span> EchoServerSecondHandler());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ChannelPipeline</code>에 두개의 이벤트 핸들러를 등록했다.</p>
<ul>
<li>FirstHandler 이벤트 핸들러</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerFirstHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">    ByteBuf readMessage = (ByteBuf)msg;</span><br><span class="line">    System.out.println(<span class="string">"channelRead:"</span>+readMessage.toString(Charset.defaultCharset()));</span><br><span class="line">    ctx.write(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>채널 파이프라인에 첫번째로 등록된 이벤트 핸들러. <code>channelRead</code> 이벤트 메소드만 구현했다.</p>
<ul>
<li>SecondHandler 이벤트 핸들러</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerSecondHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"channelReadComplete 발생"</span>);</span><br><span class="line">    ctx.flush();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>채널 파이프라인에 두번째로 등록한 이벤트 핸들러. <code>channelReadComplete</code> 이벤트 메소드와 <code>exceptionCaught</code> 이벤트 메소드를 구현했다.</p>
<ol>
<li>EchoServer에서 클라이언트 채널이 생성되고 해당 채널의 파이프라인에 <code>ChannelActive</code> 이벤트 발생</li>
<li>등록된 2개의 이벤트 핸들러에 ChannelActive 이벤트 메소드가 없어서 ChannelActive 이벤트는 무시됨.</li>
<li>다음으로 <code>channelRead</code> 이벤트가 발생</li>
<li>채널 파이프라인에 등록된 <code>EchoServerFirstHandler</code>의 <code>channelRead</code> 이벤트 메소드가 수행된다.</li>
<li>마지막으로 <code>channelReadComplete</code> 이벤트가 발생하고 <code>EchoServerSecondHandler</code>에 구현된 <code>channelReadComplete</code> 이벤트 메소드가 수행된다.</li>
</ol>
<ul>
<li>즉 여러개의 이벤트 핸들러가 등록되어 있을 때 이벤트에 해당하는 이벤트 메소드만 수행된다.  </li>
</ul>
<h3 id="만약에-여러개의-핸들러가-같은-이벤트를-처리한다면"><a href="#만약에-여러개의-핸들러가-같은-이벤트를-처리한다면" class="headerlink" title="만약에 여러개의 핸들러가 같은 이벤트를 처리한다면 ?"></a>만약에 여러개의 핸들러가 같은 이벤트를 처리한다면 ?</h3><ul>
<li>EchoServerSecondHandler 수정</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> channelRead(ChannelHandlerContext ctx, Object msg)&#123;</span><br><span class="line">  ByteBuf readMessage = (ByteBuf) msg;</span><br><span class="line">  System.out.println(<span class="string">"SecondHandler channelRead:"</span></span><br><span class="line">    +readMessage.toString(Charset.defaultCharset()));</span><br><span class="line">    <span class="comment">// channelRead 이벤트 메소드를 추가</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EchoServerSecondHandler에 EchoServerFirstHandler와 같은 이벤트 메소드인 <code>channelRead</code>를 구현해본 뒤 실행하면 두번째 이벤트 핸들러는 실행되지 않는다. 왜냐하면 이벤트에 해당하는 이벤트 메소드가 첫번째 핸들러에서 수행되면서 이벤트가 사라졌기 때문. 즉 하나의 이벤트는 하나의 이벤트 메소드만 수행한다.</p>
<h3 id="만약에-두번째-이벤트-핸들러의-channelRead-메소드도-수행하고-싶다면"><a href="#만약에-두번째-이벤트-핸들러의-channelRead-메소드도-수행하고-싶다면" class="headerlink" title="만약에 두번째 이벤트 핸들러의 channelRead 메소드도 수행하고 싶다면 ?"></a>만약에 두번째 이벤트 핸들러의 channelRead 메소드도 수행하고 싶다면 ?</h3><ul>
<li>EchoServerFirstHandler 수정</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> channelRead(ChannelHandlerContext ctx, Object msg)&#123;</span><br><span class="line">  ByteBuf readMessage = (ByteBuf) msg;</span><br><span class="line">  System.out.println(<span class="string">"channelRead:"</span>+readMessage.toString(Charset.defaultCharset()));</span><br><span class="line">  ctx.write(msg);</span><br><span class="line">  ctx.fireChannelRead(msg); <span class="comment">// 이 부분을 추가한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음 이벤트 핸들러로 이벤트를 넘겨주기 위해서 <code>ChannelHandlerContext</code>인터페이스를 사용해서 <code>fireChannelRead</code> 메소드를 이용하였다. 이는 채널 파이프라인에 이벤트를 발생시킨다.</p>
<hr>
<ul>
<li>참고 서적<ul>
<li>네티 인 액션</li>
<li>자바 네트워크 소녀 네티  </li>
</ul>
</li>
</ul>
<hr>

        </div>
        <footer class="article-footer">
            



    <a data-url="https://kodakyung.github.io/2018/05/25/server-netty-2018-05-25-netty-channel-event-and-eventhandler-and-pipeline/" data-id="ck7y3i6pm0079aw89bmrqj27r" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "Dakyung Ko"
        },
        "headline": "Netty 채널 이벤트와 이벤트핸들러, 그리고 파이프라인",
        "image": "https://kodakyung.github.io/images/2018-05-25/01.jpeg",
        "keywords": "Network Netty",
        "genre": "Server Netty",
        "datePublished": "2018-05-25",
        "dateCreated": "2018-05-25",
        "dateModified": "2020-03-19",
        "url": "https://kodakyung.github.io/2018/05/25/server-netty-2018-05-25-netty-channel-event-and-eventhandler-and-pipeline/",
        "description": "Netty의 ChannelPipeline은 Channel에서 발생한 이벤트가 이동하는 통로이다. 이 통로를 통해 이동하는 이벤트를 처리하는 클래스가 이벤트 핸들러이다. 네티의 이벤트 메소드는 데이터가 수신되면 네티가 자동으로 호출한다.

Netty의 전체적인 구조는 이 게시글을 참고

자바를 이용한 기존의 서버 프로그래밍은 소켓을 이용하고 데이터가 수신하기"
        "wordCount": 2908
    }
</script>

</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>




                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>follow:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/kodakyung" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="rss" href="https://kodakyung.github.io/feed.xml" target="_blank" rel="noopener">
                        <i class="icon fa fa-rss"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2018/06/01/server-netty-2018-06-02-netty-codec-framework/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">newer</strong>
        <p class="article-nav-title">
        
            Netty Codec Framework
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2018/05/23/server-netty-2018-05-23-netty-datacontainer-bytebuf/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">older</strong>
        <p class="article-nav-title">Netty의 데이터 컨테이너(ByteBuf)</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">recents</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/troubleshooting/">Troubleshooting</a></p>
                            <p class="item-title"><a href="/2020/02/01/troubleshooting-20200201-reverting-invalid-git-merge/" class="title">git 커밋 중간에 잘못된 merge 되돌리기</a></p>
                            <p class="item-date"><time datetime="2020-02-01T14:41:26.000Z" itemprop="datePublished">2020-02-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/think/">Think</a></p>
                            <p class="item-title"><a href="/2020/01/20/think-20200120-women-who-code-talk-with-sonia-from-ms/" class="title">Talk with Sonia from Microsoft - Inspiring Tech Women</a></p>
                            <p class="item-date"><time datetime="2020-01-20T13:54:30.000Z" itemprop="datePublished">2020-01-20</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/programming/">Programming</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/programming/common/">Common</a></p>
                            <p class="item-title"><a href="/2020/01/19/programming-common-20200119-encryption-vs-hash/" class="title">암호화 vs 해시</a></p>
                            <p class="item-date"><time datetime="2020-01-19T12:03:04.000Z" itemprop="datePublished">2020-01-19</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/programming/">Programming</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/programming/java/">Java</a></p>
                            <p class="item-title"><a href="/2019/10/20/programming-java-20191020-java-stream/" class="title">Java - Stream 기초</a></p>
                            <p class="item-date"><time datetime="2019-10-19T21:54:07.000Z" itemprop="datePublished">2019-10-20</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/programming/">Programming</a><i class="icon fa fa-angle-right"></i><a class="article-category-link" href="/categories/programming/common/">Common</a></p>
                            <p class="item-title"><a href="/2019/10/20/programming-common-20191020-functional-thinking-ch7/" class="title">함수형 사고 - ch7 실용적 사고</a></p>
                            <p class="item-date"><time datetime="2019-10-19T21:47:20.000Z" itemprop="datePublished">2019-10-20</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/cs/">CS</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/cs/database/">DataBase</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cs/os/">OS</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/programming/">Programming</a><span class="category-list-count">37</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/programming/common/">Common</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/programming/java/">Java</a><span class="category-list-count">24</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/programming/javascript/">Javascript</a><span class="category-list-count">9</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/server/">Server</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/server/netty/">Netty</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/server/orm/">ORM</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/server/spring/">Spring</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/server/test/">Test</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/system/">System</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/system/docker/">Docker</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/system/shell/">Shell</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/think/">Think</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/troubleshooting/">Troubleshooting</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">Web</a><span class="category-list-count">3</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a><span class="archive-list-count">9</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">tag cloud</h3>
        <div class="widget tagcloud">
            <a href="/tags/authrization/" style="font-size: 11.11px;">Authrization</a> <a href="/tags/design-pattern/" style="font-size: 10px;">Design Pattern</a> <a href="/tags/docker/" style="font-size: 12.22px;">Docker</a> <a href="/tags/effective-java/" style="font-size: 18.89px;">Effective Java</a> <a href="/tags/encryption/" style="font-size: 10px;">Encryption</a> <a href="/tags/fish-shell/" style="font-size: 10px;">Fish Shell</a> <a href="/tags/functional-programming/" style="font-size: 10px;">Functional Programming</a> <a href="/tags/functional-thinking/" style="font-size: 12.22px;">Functional Thinking</a> <a href="/tags/git/" style="font-size: 11.11px;">Git</a> <a href="/tags/gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/http/" style="font-size: 10px;">HTTP</a> <a href="/tags/hash/" style="font-size: 10px;">Hash</a> <a href="/tags/hibernate/" style="font-size: 12.22px;">Hibernate</a> <a href="/tags/intellij/" style="font-size: 10px;">IntelliJ</a> <a href="/tags/jpa/" style="font-size: 10px;">JPA</a> <a href="/tags/java/" style="font-size: 20px;">Java</a> <a href="/tags/javascript/" style="font-size: 16.67px;">Javascript</a> <a href="/tags/junit/" style="font-size: 10px;">Junit</a> <a href="/tags/maven/" style="font-size: 10px;">Maven</a> <a href="/tags/meetup/" style="font-size: 10px;">Meetup</a> <a href="/tags/mysql/" style="font-size: 12.22px;">MySQL</a> <a href="/tags/netty/" style="font-size: 15.56px;">Netty</a> <a href="/tags/network/" style="font-size: 15.56px;">Network</a> <a href="/tags/oauth2/" style="font-size: 12.22px;">OAuth2</a> <a href="/tags/os/" style="font-size: 10px;">OS</a> <a href="/tags/reactjs/" style="font-size: 10px;">ReactJS</a> <a href="/tags/refactoring/" style="font-size: 10px;">Refactoring</a> <a href="/tags/sts/" style="font-size: 11.11px;">STS</a> <a href="/tags/shell/" style="font-size: 10px;">Shell</a> <a href="/tags/spring/" style="font-size: 13.33px;">Spring</a> <a href="/tags/springboot/" style="font-size: 12.22px;">SpringBoot</a> <a href="/tags/stub/" style="font-size: 10px;">Stub</a> <a href="/tags/study/" style="font-size: 12.22px;">Study</a> <a href="/tags/tdd/" style="font-size: 10px;">TDD</a> <a href="/tags/tacademy/" style="font-size: 10px;">Tacademy</a> <a href="/tags/test/" style="font-size: 12.22px;">Test</a> <a href="/tags/think/" style="font-size: 10px;">Think</a> <a href="/tags/troubleshooting/" style="font-size: 14.44px;">Troubleshooting</a> <a href="/tags/web/" style="font-size: 12.22px;">Web</a> <a href="/tags/women-who-code/" style="font-size: 10px;">Women Who Code</a> <a href="/tags/생활코딩/" style="font-size: 17.78px;">생활코딩</a>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2020 Dakyung Ko</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

        
    
    <script>
    var disqus_shortname = 'kodakyung';
    
    
    var disqus_url = 'https://kodakyung.github.io/2018/05/25/server-netty-2018-05-25-netty-channel-event-and-eventhandler-and-pipeline/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
