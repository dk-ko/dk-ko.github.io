<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jade&#39;s Blog</title>
  
  <subtitle>An archive for daily discovery</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://kodakyung.github.io/"/>
  <updated>2020-03-19T00:43:22.718Z</updated>
  <id>https://kodakyung.github.io/</id>
  
  <author>
    <name>Dakyung Ko</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git 커밋 중간에 잘못된 merge 되돌리기</title>
    <link href="https://kodakyung.github.io/2020/02/01/troubleshooting-20200201-reverting-invalid-git-merge/"/>
    <id>https://kodakyung.github.io/2020/02/01/troubleshooting-20200201-reverting-invalid-git-merge/</id>
    <published>2020-02-01T14:41:26.000Z</published>
    <updated>2020-03-19T00:43:22.718Z</updated>
    
    <content type="html"><![CDATA[<p>어느날 오랜만에 커밋을 보니까,<br><code>master</code> 브랜치가 뭔가 잘못되어 있었다.</p><p><img src="01.png" alt="어.. 얘네가 여기 있으면 안되는데..?"></p><blockquote><p>deploy 브랜치에 있는 배포용 커밋이 master 브랜치에 있는 상황</p></blockquote><p>커밋 로그를 추적해보다가 <code>rebase conflict</code>를 해결하다 병합에 문제가 생긴걸 알았다.<br>(merge를 잘못해서 생긴것 일것으로 추측, 실수로 deploy 브랜치에서 작업 후 merge를 시도했다던지..)</p><blockquote><p>rebase는 커밋 이력이 남지 않아서, merge 실수를 일일히 찾아야한다.</p></blockquote><p><img src="02.png" alt="commit log"></p><p>과거의 내가 <code>fix: rebase conflict</code>라고 남겨놓아서 그나마 쉽게 찾을 수 있었다.</p><blockquote><p>오늘의 교훈 : 커밋 메세지를 잘남기자..</p></blockquote><p>아무튼 이걸 해결하려면 중간에 <code>잘못 머지한 이력</code>을 지우고 원래대로 <code>개발 완료한 커밋 내역</code>으로 돌려야한다.</p><p>검색해보니 <code>merge</code>를 되돌리기 위해서는 <code>reset</code>과 <code>revert</code>를 사용한다.<br><code>revert --mainline</code> 옵션으로 시도했지만 <code>revert</code>는 기존 커밋 내역을 보존하고 추가 커밋을 덧붙이는거라 지금 내 상황에 맞지 않았다.</p><p>만약 팀 프로젝트와 같이 <code>commit id</code>가 중요하면 <code>reset</code>과 같이 <strong>commit id가 변경</strong>되는 명령어를 쉽게 쓸 수 없었겠지만 상황상 <code>reset</code>으로 되돌리기를 시도했다.</p><p><img src="03.png" alt="git reset --merge [COMMIT_ID]"></p><p><code>git reset --merge [COMMIT_ID]</code> 적용 후 deploy 관련 커밋이 깔끔하게 삭제 되어 git graph가 깨끗해졌다. (기본 mixed 옵션으로 적용)</p><p><img src="04.png" alt="-111 커밋이 삭제된 master 브랜치"></p><p>이제 문제는 원래 개발했던 내용을 되돌려놓는 것</p><p>문제가 생겼던 프로젝트는 기존에 <code>git flow</code> 방식을 차용해서 커밋했기에 <code>develop branch</code>에<br>동작이 보증된 개발 완료된 코드들이 남아있었다.<br><code>master branch</code>는 <code>mixed option</code>으로 <code>reset</code> 했기에 stage가 깨끗해서 <code>develop</code>을 바로 master로 <code>merge</code>할 수 있다.</p><blockquote><p>만약 soft 옵션으로 reset 했다면 남아있는 파일을 모두 지우고 시도한다.</p></blockquote><blockquote><p>만약 branch 관리를 하지 않아 branch가 꼬여있었다면 이 방법으로 해결하지 못했을지도..</p></blockquote><p><img src="05.png" alt="develop 브랜치에 잘못 merge한 이후의 개발 이력이 남아있다."></p><p><img src="06.png" alt="master 브랜치에 develop을 merge한 뒤 3개 커밋이 추가되어 -108로 변경되었다."></p><p><img src="07.png" alt="최종적으로 정리된, develop merge 후 master 브랜치 log"></p><p><img src="08.png" alt="이전의, 중간 잘못된 merge commit 삭제 전 꼬여있는 master 브랜치 log"></p><p>이후 확인해보면 이력이 깨끗하게 정리된 것을 확인할 수 있다.</p><p>최종적으로 <code>master</code>에 푸시한다.<br><code>reset</code>으로 커밋 내역을 변경했기 때문에 당연히 <code>-f</code> 로 강제 push를 한다<br>강제 <code>push</code>는 브랜치에 protected가 걸려있으면 할 수 없다.<br>따라서 해당 방법은 아무래도 실무에서 여러가지 제약이 있으면 적용하기는 어려울 것 같고<br>실무에서는 잘못 merge시 revert를 통해 우회하는 방식을 사용해야할 것 같다.</p><p>git reset 후 변경 내역에 대해 새로 커밋을 하는 경우는 commit id가 변경되지만<br>기존에 있는 브랜치에서 병합했기 때문에 커밋 아이디는 변경되지 않았다.</p><h3 id="오늘-알게된-것"><a href="#오늘-알게된-것" class="headerlink" title="오늘 알게된 것."></a>오늘 알게된 것.</h3><ul><li>커밋을 잘 남기자.<ul><li>섣불리 rebase하지 말고 merge로 merge 이력을 남기자.</li></ul></li><li>브랜치를 잘 나눠서 사용하자</li></ul><h3 id="참고한-링크"><a href="#참고한-링크" class="headerlink" title="참고한 링크"></a>참고한 링크</h3><ul><li><a href="https://www.tuwlab.com/ece/22223" target="_blank" rel="noopener">https://www.tuwlab.com/ece/22223</a></li><li><a href="https://victorydntmd.tistory.com/79" target="_blank" rel="noopener">https://victorydntmd.tistory.com/79</a></li><li><a href="https://nesoy.github.io/articles/2018-07/Git-Revert" target="_blank" rel="noopener">https://nesoy.github.io/articles/2018-07/Git-Revert</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;어느날 오랜만에 커밋을 보니까,&lt;br&gt;&lt;code&gt;master&lt;/code&gt; 브랜치가 뭔가 잘못되어 있었다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;01.png&quot; alt=&quot;어.. 얘네가 여기 있으면 안되는데..?&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dep
      
    
    </summary>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/categories/troubleshooting/"/>
    
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/tags/troubleshooting/"/>
    
      <category term="Git" scheme="https://kodakyung.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Talk with Sonia from Microsoft - Inspiring Tech Women</title>
    <link href="https://kodakyung.github.io/2020/01/20/think-20200120-women-who-code-talk-with-sonia-from-ms/"/>
    <id>https://kodakyung.github.io/2020/01/20/think-20200120-women-who-code-talk-with-sonia-from-ms/</id>
    <published>2020-01-20T13:54:30.000Z</published>
    <updated>2020-03-19T00:43:22.705Z</updated>
    
    <content type="html"><![CDATA[<p>Date 2020.1.20 Mon / Time PM 6:30~8:30 / Place 한국 마이크로소프트</p><p>오랜만에 <code>Women Who Code</code>의 Meetup에 참여하기 위해 한국 마이크로소프트 건물을 찾았다.<br>마이크로소프트 소속의 Sonia와 Tech에 대해 대화를 나누는 밋업이었다.</p><h2 id="Women-Who-Code란"><a href="#Women-Who-Code란" class="headerlink" title="Women Who Code란"></a>Women Who Code란</h2><ul><li><p>미국에서 시작해 전세계 60개국에서 활동중인 여성 단체로 더 많은 여성들이 기술 경력을 갖도록 장려하는 비영리 단체이다.</p></li><li><p>최근에 <code>Meetup App</code>으로 알게된 단체인데 알고보니 최근 한국으로 진출했다고 한다.</p></li><li><p>전세계적으로 네트워크가 있는 단체라 취업이나 여행시에 해당 국가에서 테크 관련된 행사를 참여하고 싶은 경우 네트워크 문의 가능하다고.</p></li><li><p>한국에서는 페이스북 그룹을 기반으로 활동하는 듯 하다.</p></li><li><p>연사 초청 강의, 해커톤 등의 행사, 구직 기회도 있다고 한다.</p></li></ul><h2 id="Talk-with-Sonia-from-Microsoft"><a href="#Talk-with-Sonia-from-Microsoft" class="headerlink" title="Talk with Sonia from Microsoft"></a>Talk with Sonia from Microsoft</h2><blockquote><p>Sonia가 우리에게 해준 말들</p></blockquote><p><img src="01.JPG" alt="Talk with Sonia"></p><h3 id="Change-your-plan"><a href="#Change-your-plan" class="headerlink" title="Change your plan."></a>Change your plan.</h3><blockquote><p>계획이 바뀌는 것에 관대해져라</p></blockquote><h3 id="If-you-are-not-sure-Answer-yes"><a href="#If-you-are-not-sure-Answer-yes" class="headerlink" title="If you are not sure, Answer yes"></a>If you are not sure, Answer yes</h3><blockquote><p>확실하지 않다면 두려워하지 말고 예스라고 해볼 것.</p></blockquote><ul><li>새로운 것에 도전하라는 의미.</li></ul><h3 id="If-you-hate-it-Then-leave"><a href="#If-you-hate-it-Then-leave" class="headerlink" title="If you hate it, Then leave."></a>If you hate it, Then leave.</h3><blockquote><p>싫어하면 떠나라</p></blockquote><ul><li>테크 환경에는 다양한 룰이 있다.</li><li>나에게 맞는 룰을 찾는데 시간이 걸릴 수 있다</li></ul><h3 id="Find-career-support-Take-their-advice"><a href="#Find-career-support-Take-their-advice" class="headerlink" title="Find career support. Take their advice."></a>Find career support. Take their advice.</h3><blockquote><p>내가 하고싶은 일을 도와주는 사람을 찾고 조언을 적극적으로 받아들이자.</p></blockquote><h3 id="Learn-and-understand-the-basics"><a href="#Learn-and-understand-the-basics" class="headerlink" title="Learn and understand the basics."></a>Learn and understand the basics.</h3><blockquote><p>끊임 없이 배우고, 기본을 이해하자.</p></blockquote><h3 id="Take-a-chance"><a href="#Take-a-chance" class="headerlink" title="Take a chance."></a>Take a chance.</h3><blockquote><p>뻔한 말이지만, 기회를 잡아라</p></blockquote><h3 id="Take-more-chances"><a href="#Take-more-chances" class="headerlink" title="Take more chances."></a>Take more chances.</h3><blockquote><p>또 뻔한 말이지만, 더 많은 기회를 잡아라.</p></blockquote><ul><li>누군가 기회를 준다면 바로 잡아라.</li></ul><h3 id="Know-your-worth"><a href="#Know-your-worth" class="headerlink" title="Know your worth."></a>Know your worth.</h3><blockquote><p>너의 가치를 알아라</p></blockquote><h3 id="Reliable-Dedicated-Persevering-Learning-Helpful-Sharing-Encouraging"><a href="#Reliable-Dedicated-Persevering-Learning-Helpful-Sharing-Encouraging" class="headerlink" title="Reliable, Dedicated, Persevering, Learning, Helpful, Sharing, Encouraging"></a>Reliable, Dedicated, Persevering, Learning, Helpful, Sharing, Encouraging</h3><h3 id="Look-after-yourselft"><a href="#Look-after-yourselft" class="headerlink" title="Look after yourselft"></a>Look after yourselft</h3><blockquote><p>그리고 나를 돌보면서 일해라.</p></blockquote><ul><li>나를 돌보는 방법 중 하나. 나와 잘 맞는 친구들을 찾는 것<br>나에게 괜찮다고 말해줄 수 있는.</li><li>그리고 쉬는 시간 여가시간, 취미를 즐기는 시간을 계획하자.<br>언젠가하려고 하면 할 수 없다.</li></ul><h3 id="Take-even-more-chances"><a href="#Take-even-more-chances" class="headerlink" title="Take even more chances."></a>Take even more chances.</h3><h3 id="Share-your-stories"><a href="#Share-your-stories" class="headerlink" title="Share your stories."></a>Share your stories.</h3><blockquote><p>사소한 이야기라도 나누자.</p></blockquote><ul><li>이런 이야기를 알거라고 생각하지만 모르는 경우가 많다</li><li>내가 했던 일을 다른 사람이 안했을 수도 있기 때문에, 사소한 이야기라도 나누자.</li><li>서로 공유를 통해 배울 수 있다.</li><li>내가 이 포스팅을 굳이 쓰고 있는 이유이기도 하다.</li></ul><h3 id="Always-be-learning"><a href="#Always-be-learning" class="headerlink" title="Always be learning"></a>Always be learning</h3><blockquote><p>항상 새로운 걸 배워라.</p></blockquote><ul><li>기술은 매일 변하니까 20년이 넘어도 항상 새로운 걸 배운다.</li><li>기본은 여전히 똑같다</li></ul><h3 id="Expand-your-scope"><a href="#Expand-your-scope" class="headerlink" title="Expand your scope."></a>Expand your scope.</h3><blockquote><p>나의 영역을 조금씩 확장해나가자.</p></blockquote><ul><li>내가 포커스하고 있는 영역 외에도 다른 영역에 관심을 가지는 것이 중요하다.</li><li>내가 어떤 일을 하게 될지 모르므로.</li></ul><hr><p>이 모든 것이 뻔하다면 뻔한말이지만, 중요한 것은 그 것을 직접 경험하고 이뤄온 인물을 눈앞에서 보고 “정말 그렇게 될 수 있구나”라고 느낄 수 있었다는 것이라 생각한다. <code>Inspiring</code>이라는 단어에 걸맞는 밋업이었다.</p><p>처음에는 영어로 진행되고 통역이 없는 것 같아서 참석에 망설였는데 현장에서 통역을 해주시는 분이 있어서 다행히 잘 들을 수 있었다. 정말 영어를 공부해야 나를 둘러싼 세계가 더 넓어지는구나 깨닫게 된 순간이기도 했다.</p><hr><h2 id="QnA"><a href="#QnA" class="headerlink" title="QnA"></a>QnA</h2><blockquote><p>아무래도 통역에 의존해서 내용이 정확하지 않을 수 있지만 인상적인 질문을 몇개 추려보았다.</p></blockquote><p>Q. 주변의 뛰어난 사람과 비교하며, 운이 좋아서 성공했다는 생각이 들 때 어떻게 극복했는지 ?<br>A. 그 사람과 같은 주제를 정하고 공부, 공유한다 &gt; 나와 크게 다르지 않다는걸 알게됨.<br>A. 긍정적인 피드백을 받으려고 함<br>A. 지금까지 해왔던 성취를 적어보면서 극복함</p><p>Q. 테크 업계에서 여성으로서의 어려움을 어떻게 극복해왔는지 ?<br>A. 여성으로서 어려움이 많지만 내가 바꿀 수 있는 것은 바꾸려고 하고 바꿀 수 없는 것은 내버려둔다.</p><p>Q. 비전공자가 테크 영역으로 가려는데 뭘 해야할까?<br>A. Technical Account Manager<br>A. 기술 영업 매니저<br>A. 오픈소스, 데브옵스 커뮤니티가서 현장에 일하는 사람의 얘기를 들어보는 것이 좋다.</p><p>Q. 기술 중심의 사람을 만날 때 압도당하는 기분을 느끼는데 어떻게 하는지?<br>A. 여자들이 질문을 하지 않고 트레이닝하려는 경향이 있다<br>A. 질문에 대한 대답하는 법을 모르기 때문<br>A. 그런 질문들에 답해줄 수 있는 사람을 찾는 것이 중요하다.<br>A. 여성이 여성에게 트레이닝하는 곳이 더 효과적이다.</p><p>Q. 스타트업을 하는 분이 조언을 구하는 질문 내용.<br>A. 네트워킹할때 내가 뭘 줄 수 있는지, 어떤걸 도움 받고 싶은지 명확하게 하라.<br>A. 주변에 많이 알려라. 그렇다면 지금 당장은 얻지 못해도 나중에 돌아올 수 있다.</p><p>Q. 한국에는 개발자의 주류가 남성이라 일터에서 성차별 문제가 있을때가 있는데 어떤식으로 극복했는지 ?<br>A. 이뤄왔던 성취를 봐라.<br>A. 성취가 없는 경우 그런 것을 해낼 수 있는 사람이라는 것을 보여줘라.<br>A. 성취를 크게 말하고 알려라. 내가 무엇을 했는지.</p><hr><p>마지막으로 좋았던 것은, Women Who Code의 공식 의식(?)인 <code>#ApplaudHer</code>였다.<br>지금의 우리를 모두 칭찬해주자는 의미로 하는 것으로, 현장에 있는 사람들이 스스로 또는 지금 함께 있는 사람들에게 칭찬하고 싶은 내용을 말하고 서로 박수치며 칭찬하는 것이다.</p><p>우리는 좋은 질문을 해준 서로를 칭찬하고, 이런 행사를 기획하고 추운 날씨에 퇴근 후 참여한 서로를 칭찬했다. 모두가 자연스럽게 칭찬하는 분위기가 되어 나도 용기를 내서 칭찬의 한마디를 건넸다.</p><p>여성 개발자로서 IT 모임에 갔을 때 대다수가 남자인 경험이 대부분이었던 나에게 같은 길을 걸어가는 여성 개발자들의 모임은 아무래도 힘이 된다. 항상 ‘보통’이 아니고 ‘특별’했는데, 여성이 개발자인 것이 이상하지 않다는 것만으로.</p><p>이제서야 커리어를 시작하는 병아리 개발자지만, 백엔드 업무에 여자 개발자가 더 많다는 것이 이상하게 느껴지지 않는 세상이 될 때까지 나도 이 자리를 지키고 있어야겠다는 생각이 든다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Date 2020.1.20 Mon / Time PM 6:30~8:30 / Place 한국 마이크로소프트&lt;/p&gt;
&lt;p&gt;오랜만에 &lt;code&gt;Women Who Code&lt;/code&gt;의 Meetup에 참여하기 위해 한국 마이크로소프트 건물을 찾았다.&lt;br
      
    
    </summary>
    
      <category term="Think" scheme="https://kodakyung.github.io/categories/think/"/>
    
    
      <category term="Meetup" scheme="https://kodakyung.github.io/tags/meetup/"/>
    
      <category term="Women Who Code" scheme="https://kodakyung.github.io/tags/women-who-code/"/>
    
  </entry>
  
  <entry>
    <title>암호화 vs 해시</title>
    <link href="https://kodakyung.github.io/2020/01/19/programming-common-20200119-encryption-vs-hash/"/>
    <id>https://kodakyung.github.io/2020/01/19/programming-common-20200119-encryption-vs-hash/</id>
    <published>2020-01-19T12:03:04.000Z</published>
    <updated>2020-03-19T00:43:22.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="암호화"><a href="#암호화" class="headerlink" title="암호화"></a>암호화</h2><p>: 복호화할 수 있다 = 원래대로 되돌릴 수 있다</p><ul><li>원래대로 되돌리는 것 = 가역</li><li>공통키 암호 방식 vs 공개키 암호방식<ul><li>공통키 : 패스워드를 거는 것</li><li>공개키 : 암호화, 복호화에 각각 다른 암호화 키를 준비해 암호화하는 쪽의 키를 공개하는 방법</li><li>ex) DES, 3DES, AES 등</li></ul></li></ul><h2 id="해시"><a href="#해시" class="headerlink" title="해시"></a>해시</h2><p>: 복호화할 수 없다 = 원래대로 되돌릴 수 없다.</p><ul><li>원래대로 되돌릴 수 없는 것 = 불가역</li><li>해시화하기 전의 상태를 유추할 수 없다.</li><li>but 원래 데이터가 같으면 해시값도 동일한 값이 된다.</li><li>해시 방식에 따라 충돌이 일어나면 값이 다르지만 동일한 해시값이 될 수 있다.<ul><li>ex) MD5, SHA1, SHA256, SH512</li></ul></li></ul><h3 id="암호화를-푸는-방식"><a href="#암호화를-푸는-방식" class="headerlink" title="암호화를 푸는 방식"></a>암호화를 푸는 방식</h3><ol><li>알고리즘이 해독되어 있는 경우</li><li>추측되는 암호를 대입해 푸는 경우</li></ol><blockquote><p>따라서 알고리즘이 해독되어 있지 않고, RandomSeed가 불규칙해서 대입하는 방식으로 현실적으로 해독할 수 없는 경우를 채택해야함.</p></blockquote><h3 id="해시를-푸는-방식"><a href="#해시를-푸는-방식" class="headerlink" title="해시를 푸는 방식"></a>해시를 푸는 방식</h3><ul><li>암호화에 비해 복호화될 걱정은 거의 없는 편</li><li>하지만 문자열의 변환이기 때문에 패스워드같이 짧은 문자열은 해시화 방식이 알려지면 해시화된 목록을 갖고 있는 경우 해독될 가능성 있음</li><li>ex) A~Z, 0~9에 대해 md5한 목록을 이미 작성해 갖고 있으면 대입으로 유추 가능</li></ul><blockquote><p>이를 피하기 위해 특정 변환(길게 하기 = Salt 넣기)을 진행한 뒤 해시화하는 방법이 있다.</p></blockquote><ul><li>Salt란 ? 변환시 추가하는 임의의 데이터</li></ul><h2 id="외부로-유출되면-안되는-정보는"><a href="#외부로-유출되면-안되는-정보는" class="headerlink" title="외부로 유출되면 안되는 정보는.."></a>외부로 유출되면 안되는 정보는..</h2><ul><li>패스워드는 암호화가 아니라 <code>해시</code>로 보호</li><li>해시화의 방식과 관계없이, 해시화를 하는 경우 <code>길이가 긴 Salt</code>를 사용</li><li>해시화의 방식과 관계없이, 해시화의 원래 문자열(패스워드)에서 사용하는 <code>문자의 종류</code>를 늘린다.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;암호화&quot;&gt;&lt;a href=&quot;#암호화&quot; class=&quot;headerlink&quot; title=&quot;암호화&quot;&gt;&lt;/a&gt;암호화&lt;/h2&gt;&lt;p&gt;: 복호화할 수 있다 = 원래대로 되돌릴 수 있다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;원래대로 되돌리는 것 = 가역&lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Common" scheme="https://kodakyung.github.io/categories/programming/common/"/>
    
    
      <category term="Encryption" scheme="https://kodakyung.github.io/tags/encryption/"/>
    
      <category term="Hash" scheme="https://kodakyung.github.io/tags/hash/"/>
    
  </entry>
  
  <entry>
    <title>Java - Stream 기초</title>
    <link href="https://kodakyung.github.io/2019/10/20/programming-java-20191020-java-stream/"/>
    <id>https://kodakyung.github.io/2019/10/20/programming-java-20191020-java-stream/</id>
    <published>2019-10-19T21:54:07.000Z</published>
    <updated>2020-03-19T00:43:22.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><ul><li>데이터의 흐름</li><li>배열 또는 컬렉션 인스턴스에 <code>함수</code> 여러개를 <code>조합</code>해 원하는 결과를 <code>필터링</code>하고 <code>가공된 결과</code>를 얻을 수 있다.</li><li>자바 8에서 추가된 것으로 람다를 활용할 수 있는 기술 중 하나.</li></ul><h3 id="Stream-VS-Collection"><a href="#Stream-VS-Collection" class="headerlink" title="Stream VS Collection"></a>Stream VS Collection</h3><p><strong>1. 스트림은 요소를 보관하지 않는다.</strong>  </p><ul><li>요소들은 하부 컬렉션에 보관되거나 필요할 때 생성된다.</li><li>ex) List기반으로 스트림을 생성한다면, 요소는 List에 저장되어 있는 것. 단지 그 위에 Stream이 생성된다.</li></ul><p><strong>2. 스트림 연산은 원본을 변경하지 않으며 결과를 담은 새로운 스트림을 반환한다.</strong><br><strong>3. 스트림은 가능한 지연(lazy) 처리된다.</strong>  </p><ul><li>즉 결과가 필요하기 전까지 실행되지 않는다.</li></ul><h2 id="생성하기"><a href="#생성하기" class="headerlink" title="생성하기"></a>생성하기</h2><ul><li>일반적으로 배열 또는 컬렉션으로 생성한다.</li></ul><h3 id="배열-스트림"><a href="#배열-스트림" class="headerlink" title="배열 스트림"></a>배열 스트림</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (1) Arrays.stream </span></span><br><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;; <span class="comment">// 배열 생성</span></span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(arr); </span><br><span class="line">Stream&lt;String&gt; streamOfArrayPart = Arrays.stream(arr, <span class="number">1</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">// (2) Stream.of </span></span><br><span class="line">Stream&lt;String&gt; stream2 = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br></pre></td></tr></table></figure><h3 id="컬렉션-스트림"><a href="#컬렉션-스트림" class="headerlink" title="컬렉션 스트림"></a>컬렉션 스트림</h3><ul><li><p>Java의 <code>컬렉션 타입</code>(Collection, List, Set)의 인터페이스에 <code>default method</code>로 <code>stream</code>이 추가되어 이를 통해 생성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = numbers.stream();</span><br></pre></td></tr></table></figure></li><li><p>그밖에도 빈 스트림, Stream.builder(), 무한 스트림(Stream.generate()), Stream.iterate(), 기본 타입 스트림, 문자열 스트림, 파일 스트림, 병렬 스트림(Paralle Stream)을 생성할 수 있다.</p></li><li><p>스트림 연결하기(Stream.concat)도 가능하다.</p></li></ul><h2 id="중간-연산-Intermediate-Operation"><a href="#중간-연산-Intermediate-Operation" class="headerlink" title="중간 연산(Intermediate Operation)"></a>중간 연산(Intermediate Operation)</h2><ul><li>Stream에서 원하는 내용만 <code>가공</code>하는 작업</li><li><code>Stream을 반환</code>하기 때문에 <code>method chainig</code>으로 호출할 수 있다.</li></ul><h3 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h3><ul><li><p><code>filter</code>로 스트림 내 원하는 요소를 걸러낸다.</p></li><li><p>인자로 <code>Predicate</code>를 받아 <code>boolean</code>을 리턴하는 함수형 인터페이스가 사용된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter 함수</span></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"><span class="comment">// 사용 예 </span></span><br><span class="line">System.out.println(</span><br><span class="line">  Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .filter(i -&gt; i &gt; <span class="number">3</span>) <span class="comment">// Lambda Expression</span></span><br><span class="line">        .count() <span class="comment">// Terminal Operation</span></span><br><span class="line">); <span class="comment">// "2" 출력</span></span><br></pre></td></tr></table></figure></li><li><p><code>filter()</code>함수가 인자로 <code>Predicate</code>를 받으므로 <code>i -&gt; i &gt; 3</code>가 <code>true</code>인 경우만 필터링 되어 <code>count()</code>함수에 의해 집계된다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(</span><br><span class="line">  Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment">// Anonymous Class</span></span><br><span class="line">        .filter(<span class="keyword">new</span> Predicate&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (integer &gt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).count()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>Lambda 식을 사용하지 않으면 이렇게 불필요한 코드가 많아진다.</li></ul><h3 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h3><ul><li><p><code>map</code>으로 스트림 내 요소들을 하나씩 특정 값으로 <code>변환</code>한다. (T &gt; R)</p></li><li><p>인자로 <code>Function&lt;T, R&gt;</code>을 사용한다.</p></li><li><p>함수형 인터페이스인 <code>Function</code>은 <code>T</code>를 받아 <code>R</code>을 리턴한다.</p></li><li><p>즉 <code>인자로 받은 데이터</code>와 <code>다른 데이터</code>를 반환할 때 쓰인다.</p></li><li><p>스트림에 들어있는 값이 input되어 사용자가 지정한 로직을 수행한 후 output 되어 리턴되는 새로운 스트림에 담긴다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map 함수</span></span><br><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br><span class="line"><span class="comment">// 사용 예</span></span><br><span class="line">Stream&lt;String&gt; stringStream = </span><br><span class="line">  Stream.of(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">        .filter(i -&gt; i &gt; <span class="number">2</span>) <span class="comment">// filtering된 데이터를</span></span><br><span class="line">        .map(i -&gt; i * <span class="number">2</span>) <span class="comment">// (1) *2 한뒤</span></span><br><span class="line">        .map(i -&gt; <span class="string">"#"</span> + i); <span class="comment">// (2) #을 붙인 스트링값이 있는 Stream으로 반환한다.</span></span><br></pre></td></tr></table></figure></li><li><p>(1)에서 <code>3, 3, 5, 5</code>가 <code>6, 6, 10, 10</code>으로 변환된다.</p></li><li><p>(2)에서 <code>6, 6, 10, 10</code>이 <code>#6, #6, #10, #10</code>으로 변환된다. </p></li><li><p>Stream은 <code>Lazy</code>하게 동작하므로 위 코드는 <code>Terminal Operation</code>이 없어서 아직 수행되지 않는다.</p></li><li><p>그밖에도 flatMap, sorted, compare, peek 등이 있다.</p></li></ul><h2 id="최종-연산-Terminal-Operation"><a href="#최종-연산-Terminal-Operation" class="headerlink" title="최종 연산(Terminal Operation)"></a>최종 연산(Terminal Operation)</h2><ul><li>스트림 데이터로 부터 <code>결과</code>를 얻는 작업.</li><li>이 과정에서 사용하는 메소드를 <code>reduction method</code>라 한다. </li></ul><h3 id="단순-리덕션"><a href="#단순-리덕션" class="headerlink" title="단순 리덕션"></a>단순 리덕션</h3><ul><li><code>count()</code>, <code>sum()</code>, <code>min()</code>, <code>max()</code> 등 단순 계산을 수행한다.</li><li><code>Optional</code>로 반환한다.</li></ul><h3 id="리덕션-연산"><a href="#리덕션-연산" class="headerlink" title="리덕션 연산"></a>리덕션 연산</h3><ul><li><p><code>여러 Element</code>를 받아 하나하나 줄여나가 최종적으로 <code>하나</code>를 남긴다.</p></li><li><p>가장 단순한 형태는 이항 함수(Binary Function)을 받는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; values = ...;</span><br><span class="line">Optional&lt;Integer&gt; sum = values.reduce((x, y) -&gt; x + y);</span><br></pre></td></tr></table></figure></li><li><p>위의 경우 reduce는 <code>v0 + v1 + v2 + ...</code>을 계산한뒤 최종적으로 하나의 값(총합)을 반환한다.</p></li><li><p>리덕션에서 사용되는 연산은 (위의 +) <code>결합 법칙</code>을 지원해야한다.</p><ul><li>즉 요소들을 결합할 때 <code>순서</code>가 문제가 되어선 안된다.</li></ul></li></ul><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OptionalInt reduced = </span><br><span class="line">  IntStream.range(<span class="number">1</span>, <span class="number">4</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">            .reduce((a, b) -&gt; Integer.sum(a, b)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>처음에 <code>a = 1, b = 2</code>로 <code>sum</code>을 수행해 <code>3</code>이 된다.</li><li><code>a = 3(이전 상태), b = 3</code>으로 <code>3 + 3</code>으로 최종적으로 <code>6</code>이 된다.</li><li><code>Primitive Type Stream</code> 들은 기본적으로 <code>sum()</code>이 구현되어 있으므로 그걸 사용하는게 편하다.</li><li><code>Object Stream</code>의 경우 <code>sum()</code>을 구현한다면 <code>reduce()</code>를 사용해야한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> List&lt;Product&gt; products = Arrays.asList(</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">1L</span>, <span class="string">"A"</span>, <span class="keyword">new</span> BigDecimal(<span class="string">"100.50"</span>)),</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">2L</span>, <span class="string">"B"</span>, <span class="keyword">new</span> BigDecimal(<span class="string">"23.00"</span>)),</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">3L</span>, <span class="string">"C"</span>, <span class="keyword">new</span> BigDecimal(<span class="string">"31.45"</span>)),</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">4L</span>, <span class="string">"D"</span>, <span class="keyword">new</span> BigDecimal(<span class="string">"80.20"</span>)),</span><br><span class="line">  <span class="keyword">new</span> Product(<span class="number">5L</span>, <span class="string">"E"</span>, <span class="keyword">new</span> BigDecimal(<span class="string">"7.50"</span>))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Product 객체 리스트에서 price의 합을 구하고 싶을 때 </span></span><br><span class="line">System.out.println(<span class="string">"Total Price: "</span> +</span><br><span class="line">  products.stream() <span class="comment">// List에서 Stream 생성</span></span><br><span class="line">          .map(product -&gt; product.getPrice()) <span class="comment">// (1)</span></span><br><span class="line">          .reduce( <span class="comment">// (2)</span></span><br><span class="line">            BigDecimal.ZERO, </span><br><span class="line">            (price1, price2) -&gt; price1.add(price2))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>(1) <code>Product</code> 객체에서 <code>price value(BigDecimal 객체)</code>를 사용해야하므로 <code>map()</code>으로 데이터를 변환해준다. (Product &gt; BigDecimal)</li><li>(2) 초기값과 연산을 인자로 넣어준다.<ul><li>덧셈에 영향을 주지 않는 데이터가 0이므로 0을 넣는다.</li><li><code>100.50 + 23.00 + 31.45 ...</code> 를 수행한 뒤 결과(총 합)를 반환한다.</li></ul></li></ul><h3 id="collect"><a href="#collect" class="headerlink" title="collect()"></a>collect()</h3><ul><li><code>Collector</code> 타입의 인자를 받아 종료 작업을 한다.</li><li>주로 스트림을 <code>Collection 객체</code>로 변환하는 작업을 한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collectorCollection =</span><br><span class="line">  productList.stream()</span><br><span class="line">              .map(Product::getName) <span class="comment">// Product &gt; String</span></span><br><span class="line">              .collect(Collectors.toList() <span class="comment">// List&lt;String&gt; 반환</span></span><br><span class="line">  <span class="comment">// [A, B, C, D, E]</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>Product 객체의 이름을 추출해 List로 반환한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String listToString = </span><br><span class="line"> productList.stream()</span><br><span class="line">  .map(Product::getName)</span><br><span class="line">  .collect(Collectors.joining()); </span><br><span class="line">  <span class="comment">// ABCDE</span></span><br></pre></td></tr></table></figure><ul><li>연산 결과를 String으로 반환하고 싶은 경우 <code>joining</code>을 사용한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String listToString = </span><br><span class="line"> productList.stream()</span><br><span class="line">  .map(Product::getName)</span><br><span class="line">  .collect(Collectors.joining(<span class="string">", "</span>, <span class="string">"&lt;"</span>, <span class="string">"&gt;"</span>)); </span><br><span class="line">  <span class="comment">// &lt;A, B, C, D, E&gt;</span></span><br></pre></td></tr></table></figure><ul><li>구분자와 prefix, suffix를 지정할 수 있다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://futurecreator.github.io/2018/08/26/java-8-streams/" target="_blank" rel="noopener">java 8 stream</a></li><li>가장 빨리 만나는 자바 8</li><li><a href="https://www.youtube.com/watch?v=mu9XfJofm8U&list=PLRIMoAKN8c6O8_VHOyBOhzBCeN7ShyJ27&index=1" target="_blank" rel="noopener">케빈 TV - 모던 자바</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Stream&quot;&gt;&lt;a href=&quot;#Stream&quot; class=&quot;headerlink&quot; title=&quot;Stream&quot;&gt;&lt;/a&gt;Stream&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;데이터의 흐름&lt;/li&gt;
&lt;li&gt;배열 또는 컬렉션 인스턴스에 &lt;code&gt;함수&lt;/code&gt;
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
      <category term="Functional Programming" scheme="https://kodakyung.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>함수형 사고 - ch7 실용적 사고</title>
    <link href="https://kodakyung.github.io/2019/10/20/programming-common-20191020-functional-thinking-ch7/"/>
    <id>https://kodakyung.github.io/2019/10/20/programming-common-20191020-functional-thinking-ch7/</id>
    <published>2019-10-19T21:47:20.000Z</published>
    <updated>2020-03-19T00:43:22.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h2><ul><li>Java가 기존에 가지고 있는 Class와 Collection에 <code>map()</code>과 <code>reduce()</code>와 같은 함수형 구조를 더했다.</li><li><code>함수형 구조</code>를 통해 Java의 컬렉션들을 효과적으로 처리할 수 있다.</li><li><code>reduce</code>의 경우 불변객체를 이용한 조작 연산이지만, Java 컬렉션의 대부분은 가변형이므로 가변 리듀스 작업을 하는 <code>collect</code>가 추가되었다.<ul><li>Java8에서 reduce는 불변 객체를, collect는 가변 객체를 조작할 때 사용한다.</li></ul></li></ul><h3 id="함수형-인터페이스-Functional-Interface"><a href="#함수형-인터페이스-Functional-Interface" class="headerlink" title="함수형 인터페이스(Functional Interface)"></a>함수형 인터페이스(Functional Interface)</h3><ul><li>Java의 <code>일급 객체</code>는 <code>Function</code>이 아니다.<ul><li>일급 객체(first-class object)란 ? <ul><li>다른 객체들에 일반적으로 <code>적용 가능한 연산</code>을 <code>모두 지원</code>하는 객체</li><li>보통 함수에 매개변수로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라 함.</li></ul></li></ul></li><li>따라서 함수 자체를 주고 받을 수 없으므로 인터페이스를 이용하며, 이를 <code>함수형 인터페이스</code>라한다.</li><li>Java의 함수형 인터페이스는 <code>단일 추상 메소드(Single Abstract Method, SAM) 인터페이스</code>이다.<ul><li>인터페이스에 추상 메소드가 1개인 것을 의미</li><li>default, static method는 상관 없다. </li><li>즉, 함수가 아닌 <code>인터페이스</code>를 주고 받는다. 그리고 구체적인 함수는 인터페이스 내부의 유일한 추상메소드를 <code>@Override</code>해 사용한다.</li><li>기존의 자바라면 익명 클래스를 사용하지만 <code>Lambda</code> 표현을 통해 간략하게 사용할 수 있다.</li></ul></li><li><code>@FunctionalInterface</code>로 함수형 인터페이스를 컴파일 레벨에서 check 할 수 있다.</li><li>Java8부터는 interface에 default method가 추가되었다.<ul><li>이 같은 개념을 mixin(믹신)이라 한다.</li><li>다른 클래스에서 사용될 메서드를 정의하지만 그 클래스의 상속 체계에 포함되지 않은 클래스</li><li>언어마다 다르지만 공통적으로 코드의 재사용이 좋아지고 다중상속의 모호함을 해결해준다.</li></ul></li></ul><h4 id="Java의-함수형-인터페이스"><a href="#Java의-함수형-인터페이스" class="headerlink" title="Java의 함수형 인터페이스"></a>Java의 함수형 인터페이스</h4><table><thead><tr><th>인터페이스</th><th>추상 메소드</th><th>설명</th></tr></thead><tbody><tr><td>Consumer<t></t></td><td>void accept(T t)</td><td>객체 T를 받아 소비함</td></tr><tr><td>Supplier<t></t></td><td>T get()</td><td>T 객체를 리턴함</td></tr><tr><td>Functioin&lt;T, R&gt;</td><td>R apply(T t)</td><td>객체 T를 객체 R로 매핑</td></tr><tr><td>Predicate<t></t></td><td>Boolean test(T t)</td><td>객체 T를 조사한 뒤 결과 반환</td></tr></tbody></table><ul><li>함수형 인터페이스 내의 메소드 명은 중요하지 않다.</li></ul><h3 id="Optional-옵셔널"><a href="#Optional-옵셔널" class="headerlink" title="Optional(옵셔널)"></a>Optional(옵셔널)</h3><ul><li>Stream이 종료된 후 Java의 내장 메소드는 <code>Optional</code>을 리턴한다.</li><li>Optional로 한번 감싸므로 <code>NPE</code>을 방지한다.</li></ul><h3 id="Java8-Stream"><a href="#Java8-Stream" class="headerlink" title="Java8 Stream"></a>Java8 Stream</h3><ul><li>대부분 함수형 언어들은 <code>Stream(스트림)</code>이라는 추상화가 포함되어 있다.<h4 id="스트림의-특징"><a href="#스트림의-특징" class="headerlink" title="스트림의 특징"></a>스트림의 특징</h4><ul><li>스트림은 <strong>값을 저장하지 않고</strong>, 종결 작업을 통해 <strong>입력에서 종착점까지 흐르는 파이프라인</strong>처럼 사용한다.</li><li><strong>상태를 유지하지 않는다.</strong><ul><li>ex) filter() 작업은 밑에 깔린 컬렉션을 바꾸지 않고 필터된 스트림을 받는 것</li></ul></li><li><strong>스트림은 Lazy Evaluation이다.</strong></li><li><strong>무한 스트림이 가능하다.</strong><ul><li><code>limit()</code>, <code>findFirst()</code> 같은 제한 메소드로 부분집합을 구할 수 있다.</li></ul></li></ul></li><li>스트림은 <code>중간 작업(Intermediate Operation)</code> 또는 <code>종결 작업(Terminal Operation)</code>이다.<ul><li>중간 작업은 항상 새 스트림을 리턴한다.</li><li>스트림은 게으르기(Lazy) 때문에 종결 작업까지 선언되어야 스트림에 해당하는 값을 구할 수 있다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"java"</span>);</span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line">Stream&lt;String&gt; stream = list.stream()</span><br><span class="line">  .filter(el -&gt; &#123;</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="keyword">return</span> el.contains(<span class="string">"a"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">System.out.println(counter); <span class="comment">// "0"</span></span><br><span class="line"><span class="comment">// 종결 작업이 선언되지 않았기 때문에 </span></span><br><span class="line"><span class="comment">// 스트림 연산이 이루어지지 않아 값이 나오지 않는다.</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Immutable-Objects"><a href="#Immutable-Objects" class="headerlink" title="Immutable Objects"></a>Immutable Objects</h3><ul><li>함수형 프로그래밍은 <code>불변성</code>이 기본이다.</li><li>불변형 객체는 <code>변이</code>가 없으므로 테스트가 간편해지고, 기본적으로 thread-safe해 동기화 문제가 없으며, 상태를 알 수 없거나 잘못된 상태를 가질일이 없다.</li><li>불변 객체는 <code>생성될 때 초기화</code>가 일어나므로 생성 시 모든 문제를 알 수 있다.(컴파일 레벨에서 확인)<ul><li>이를 <code>실패의 원자성(Failure Atomicity)</code>이라 한다.</li></ul></li></ul><h4 id="Immutable-Objects-of-Java"><a href="#Immutable-Objects-of-Java" class="headerlink" title="Immutable Objects of Java"></a>Immutable Objects of Java</h4><ol><li>모든 필드를 final 선언</li><li>클래스를 final 선언해 Override 방지</li><li>인수가 없는 생성자를 제공하지 않는다.<ul><li>불변형은 생성시 초기화 되므로 인수 없는 생성자가 필요하지 않다.</li></ul></li><li>적어도 하나의 생성자를 제공한다.</li><li>생성자 외에 변이 메소드(setter)를 제공하지 않는다.<ul><li>setter 외에도 가변 객체 참조를 전달하지 않게 주의해야한다.</li></ul></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>함수형 사고</li><li><a href="https://stackoverflow.com/questions/22577197/java-8-streams-collect-vs-reduce" target="_blank" rel="noopener">java 8 streams collect vs reduce</a></li><li><a href="https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B8%89_%EA%B0%9D%EC%B2%B4" target="_blank" rel="noopener">일급 객체</a></li><li><a href="https://futurecreator.github.io/2018/08/26/java-8-streams-advanced/" target="_blank" rel="noopener">java 8 stream advanced</a></li><li><a href="https://palpit.tistory.com/673" target="_blank" rel="noopener">람다식 - 표준 API의 함수적 인터페이스1</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-8&quot;&gt;&lt;a href=&quot;#Java-8&quot; class=&quot;headerlink&quot; title=&quot;Java 8&quot;&gt;&lt;/a&gt;Java 8&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Java가 기존에 가지고 있는 Class와 Collection에 &lt;code&gt;map()&lt;
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Common" scheme="https://kodakyung.github.io/categories/programming/common/"/>
    
    
      <category term="Functional Thinking" scheme="https://kodakyung.github.io/tags/functional-thinking/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>데이터베이스의 성능 향상(feat. 인덱스)</title>
    <link href="https://kodakyung.github.io/2019/10/17/cs-database-20191017-database-index/"/>
    <id>https://kodakyung.github.io/2019/10/17/cs-database-20191017-database-index/</id>
    <published>2019-10-16T17:56:01.000Z</published>
    <updated>2020-03-19T00:43:22.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="성능이란"><a href="#성능이란" class="headerlink" title="성능이란 ?"></a>성능이란 ?</h2><blockquote><p>기본적으로 “빠르기”를 기준으로 한 개념</p></blockquote><h3 id="성능을-측정하는-2가지-지표"><a href="#성능을-측정하는-2가지-지표" class="headerlink" title="성능을 측정하는 2가지 지표"></a>성능을 측정하는 2가지 지표</h3><ol><li><code>처리시간(Processing Time)</code> or <code>응답시간(Response Time)</code><ul><li>어떤 특정 처리의 시작부터 종료까지 걸린 시간</li></ul></li><li><code>처리율(Throughput)</code><ul><li>특정 처리(트랜잭션)를 단위 시간에 몇 건 처리 가능한가<ul><li>ex) 트랜잭션을 초당 50건 처리하는 것이 가능하면, 50 TPS(Transaction Per Second)</li></ul></li></ul></li></ol><h3 id="정점과-한계"><a href="#정점과-한계" class="headerlink" title="정점과 한계"></a>정점과 한계</h3><ul><li><p><code>처리율이 높은</code> 시스템일수록 (CPU나 하드웨어같은) <code>자원이 많이</code> 필요하다</p><ul><li>즉 동시에 실행되는 처리가 증가할 수록 필요한 물리 자원도 증가한다.</li></ul></li><li><p>이때 동시 실행 처리 수가 자원의 한계를 넘어서는 경우 응답시간이 상승하고 처리율이 떨어지며 성능이 나빠진다.</p></li><li><p>한 가지 자원이라도 한계에 이르면 성능이 나빠지기 시작하는데 이를 <code>버틀넥 포인트(Bottleneck Point)</code>, <code>병목</code>이라 한다.</p></li><li><p>시스템은 동시에 실행되는 처리가 가장 많아질 때를 기준으로 자원을 준비하지 않으면 <code>정점(Peek)</code>일 때 극단적인 지연을 일으킨다.</p></li><li><p>정점을 상정한 자원을 확보해두는 것을 <code>사이징(Sizing)</code>이나 <code>캐퍼시티 플랜(Capacity Planinig)</code>이라 한다.</p></li><li><p>정점일때와 아닐 때의 차이가 큰 경우 정점에 맞추는 경우 평상시에 낭비되는 자원이 크다.</p></li><li><p>그렇기에 클라우드를 통해 스케일업과 스케일아웃을 하며 동적인 자원관리를 하는 추세이다.</p><ul><li><code>스케일업(Scale-Up)</code> : 고성능 장비 도입</li><li><code>스케일아웃(Scale-Out)</code> : 장비 추가 도입</li></ul></li></ul><h2 id="데이터베이스의-성능"><a href="#데이터베이스의-성능" class="headerlink" title="데이터베이스의 성능"></a>데이터베이스의 성능</h2><h3 id="데이터베이스-병목"><a href="#데이터베이스-병목" class="headerlink" title="데이터베이스 병목"></a>데이터베이스 병목</h3><blockquote><p>데이터 베이스가 시스템에서 병목이 되기 쉬운 이유</p></blockquote><p><strong>1. 취급하는 데이터 양이 많다.</strong></p><ul><li>최근들어 저장되는 데이터가 폭발적으로 증가하는 추세라 데이터를 보존하는 저장소에서 병목이 일어나는 경우가 많다.</li></ul><p><strong>2. 자원 증가(스케일 아웃)를 통한 성능 향상이 어렵다.</strong></p><ul><li>데이터베이스의 병목 지점은 CPU나 메모리가 아니라 <code>주로 보조기억 장치</code>이므로 스케일 아웃이 어렵다.<ul><li>데이터베이스는 기본적으로 <code>Active-StandBy</code>나 <code>Active-Active</code> 구성을 취하기 때문</li><li>이런 이유로 주로 한정된 자원을 효율적으로 쓰기 위한 ‘<code>튜닝</code>‘이 발전함</li></ul></li><li>최근에는 저장소를 더 고속 매체인 <code>메모리</code>에 적재하는 등으로 <code>스케일업</code>에 의한 성능 개선도 이루어지고 있다. <ul><li>이런 발상으로 만들어진 데이터베이스가 인메모리 데이터베이스(In-memory)</li></ul></li></ul><h2 id="데이터베이스-성능을-결정하는-요인"><a href="#데이터베이스-성능을-결정하는-요인" class="headerlink" title="데이터베이스 성능을 결정하는 요인"></a>데이터베이스 성능을 결정하는 요인</h2><h3 id="데이터베이스의-실행-과정"><a href="#데이터베이스의-실행-과정" class="headerlink" title="데이터베이스의 실행 과정"></a>데이터베이스의 실행 과정</h3><p><strong>1. 파스 (Parse)</strong></p><ul><li>내부 프로그램인 Parsor가 구문 오류를 체크한다.</li></ul><p><strong>2. 실행계획 (Execution Plan OR Access Plan)</strong><br><strong>- 실행계획 작성 &gt; 실행계획 평가</strong></p><ul><li><p>내부 프로그램인 <code>Optimizer</code>가 SQL문에 어떤 경로로 접근할지 <code>계획</code>한다.</p><ul><li>프로그래머는 SQL을 선언만하고 과정은 옵티마이저가 하므로 일반적인 절차형 언어와 다르게 <code>선언형 언어</code>라 하기도 함.</li><li>옵티마이저가 보통 프로그래머보다 효율적인 실행계획을 세우므로 직접 실행계획을 세우는 것은 지양하는 것이 좋다.</li><li>옵티마이저가 최적의 속도로 동작할 수 있는 환경을 구성해주는 것이 중요</li></ul></li><li><p><code>통계 정보</code>를 참고해 <code>실행 계획</code>을 세운다.</p><ul><li><p>통계 정보란 ? 옵티마이저가 실행계획을 세울 때 참고하는 정보</p><ol><li>테이블의 행수,열수</li><li>각 열의 길이와 데이터형</li><li>테이블의 크기</li><li>열에 대한 기본키나 NOT NULL 제약의 정보</li><li>열값의 분산과 편향 등.</li></ol></li><li><p>통계 정보는 테이블에 보존되어 있다.</p><ul><li><p><code>show table status;</code><br><img src="01.png" alt="show table status"></p><ul><li>Rows : 행 수</li><li>Avg_row_length : 평균 레코드 크기</li></ul></li><li><p><code>show index from [TABLE_NAME];</code><br><img src="02.png" alt="show index from TABLE_NAME"></p><ul><li>Cardinality : 인덱스 대상의 분산도</li></ul></li></ul></li><li><p>통계 데이터는 대부분 <code>자동으로 수집</code>되어 구현된다.</p><ul><li>대체로 대량의 데이터가 변경되거나 특정 시간을 정할 수 있다.</li></ul></li></ul></li></ul><ol start="3"><li>데이터 액세스</li></ol><h3 id="데이터베이스가-실행계획을-세우는-기준"><a href="#데이터베이스가-실행계획을-세우는-기준" class="headerlink" title="데이터베이스가 실행계획을 세우는 기준"></a>데이터베이스가 실행계획을 세우는 기준</h3><blockquote><p>인덱스 </p></blockquote><ul><li><p>인덱스의 유무로 <code>풀 스캔(full scan)</code>과 <code>레인지 스캔(range scan)</code>이 나뉜다.</p><ul><li>풀 스캔: 테이블의 레코드를 전부 읽는 것</li><li>레인지 스캔: 테이블 일부 레코드만 읽는 것</li></ul></li><li><p>인덱스가 있는 경우<br><img src="03.png" alt="인덱스가 있는 경우 1"><br><img src="04.png" alt="인덱스가 있는 경우 2"></p><ul><li><code>TYPE</code>이 All이 아닌 <code>CONST</code>, <code>RANGE</code></li><li>스캔 종류의 이름은 조건에 따라 조금씩 달라진다.</li></ul></li><li><p>인덱스가 없는 경우<br><img src="05.png" alt="인덱스가 없는 경우"></p><ul><li>현재 예시 테이블은 <code>id</code>와 <code>fk</code>에만 인덱스가 존재한다.</li><li>인덱스가 없는 컬럼을 조회하므로 <code>ALL 풀 스캔</code>을 한다. </li><li><code>기본키</code>는 따로 설정하지 않아도 인덱스가 존재한다.</li></ul></li><li><p>인덱스 생성</p><ul><li><code>create index [INDEX_NAME] on [TABLE_NAME]([COLOMN_NAME])</code></li></ul></li></ul><h2 id="인덱스의-구조"><a href="#인덱스의-구조" class="headerlink" title="인덱스의 구조"></a>인덱스의 구조</h2><p><img src="btree.png" alt="B-Tree 구조"></p><ul><li>B-Tree 로 되어있다.</li><li>따라서 데이터들은 반드시 <code>정렬</code>된 데이터로 유지된다.</li><li>B-Tree는 균형 트리이기에 어떤 값에 대해서도 <code>속도가 일정</code>하다(최선, 최악의 경우가 비슷)<ul><li>일반적으로 B-Tree는 3~4층 정도로 조절된다.</li></ul></li><li>처음 생성시 <code>균형 트리</code>이지만 <code>INSERT/DELETE/UPDATE</code> 등이 일어나면 트리가 깨지며 성능이 나빠질 수 있다.</li><li>따라서 <code>갱신</code> 빈도가 높은 테이블은 정기적으로 인덱스 재구성이 필요하다.</li></ul><h2 id="인덱스의-성능"><a href="#인덱스의-성능" class="headerlink" title="인덱스의 성능"></a>인덱스의 성능</h2><p><strong>- 데이터에 비례해 효과가 좋아진다.</strong></p><ul><li>어느정도 큰 데이터에서 생성하는 것이 좋다.  </li></ul><p><strong>- 정렬을 건너뛰는 것이 가능하다.</strong></p><ul><li>예를 들면 groupby로 count하는 경우<ul><li>인덱스가 없다면 <code>풀 스캔</code> + <code>정렬을 위한 임시영역에 파일을 저장</code>한다.<ul><li>이런식으로 임시영역을 사용해 처리하면 매우 느려 성능 이슈를 일으킬 수 있다.</li></ul></li><li>인덱스가 있다면 이미 정렬되어 있으므로 고속 처리가 가능하다.</li></ul></li><li>SQL 내부에서 정렬하는 경우<ul><li>GROUP BY</li><li>COUNT/SUM/AVG 등의 집약 함수</li><li>UNION/INTERSECT/EXCEPT 등의 집합연산</li></ul></li></ul><h2 id="인덱스-주의사항"><a href="#인덱스-주의사항" class="headerlink" title="인덱스 주의사항"></a>인덱스 주의사항</h2><ul><li>인덱스는 <code>SELECT</code> 성능을 향상시키고 <code>INSERT/UPDATE/DELECT</code> 성능을 약화시킨다.<ul><li>인덱스 갱신의 오버헤드로 성능이 떨어진다.</li></ul></li><li>너무 많은 인덱스를 만드는 경우 의도한 것과 다르게 실행될 수 있다.<ul><li>인덱스를 생성만 할 뿐 실행은 옵티마이저가 자동으로 하기 때문에 의도와 다르게 동작해 더 느릴 수 있다.</li></ul></li><li>따라서 크기가 큰 테이블에만 만들고</li><li>기본키 제약이나 유일성 제약이 붙은 경우 자동으로 인덱스가 생성되므로 추가 생성하지 않는다.</li><li><code>Cardinality</code>가 높은 열에 만든다.</li></ul><h2 id="성능-안티-패턴"><a href="#성능-안티-패턴" class="headerlink" title="성능 안티 패턴"></a>성능 안티 패턴</h2><ul><li>통계 정보 갱신 설정이 off인 경우</li><li>정기 갱신을 설정하고 데이터양이 급격하게 바뀌는 경우<ul><li>정기 갱신 전 바뀐 데이터에 대해 인덱스가 적용되지 않은 상태라 성능 향상을 기대하기 어렵다.</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>데이터베이스 첫걸음 </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;성능이란&quot;&gt;&lt;a href=&quot;#성능이란&quot; class=&quot;headerlink&quot; title=&quot;성능이란 ?&quot;&gt;&lt;/a&gt;성능이란 ?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;기본적으로 “빠르기”를 기준으로 한 개념&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 
      
    
    </summary>
    
      <category term="CS" scheme="https://kodakyung.github.io/categories/cs/"/>
    
      <category term="DataBase" scheme="https://kodakyung.github.io/categories/cs/database/"/>
    
    
      <category term="MySQL" scheme="https://kodakyung.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>함수형 사고 - ch2 전환</title>
    <link href="https://kodakyung.github.io/2019/10/16/programming-common-20191016-functional-thinking-ch2/"/>
    <id>https://kodakyung.github.io/2019/10/16/programming-common-20191016-functional-thinking-ch2/</id>
    <published>2019-10-16T11:54:04.000Z</published>
    <updated>2020-03-19T00:43:22.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="생각의-전환"><a href="#생각의-전환" class="headerlink" title="생각의 전환"></a>생각의 전환</h2><ul><li>새로운 언어를 배우는 것은 쉽지만, <code>새로운 패러타임</code>을 익히는 것은 어렵다.</li><li>함수형 코드를 제대로 작성하기 위해서는 <code>문제를 접근하는 방식의 전환</code>이 필요하다.</li></ul><h2 id="명령형에서-함수형으로의-전환"><a href="#명령형에서-함수형으로의-전환" class="headerlink" title="명령형에서 함수형으로의 전환"></a>명령형에서 함수형으로의 전환</h2><h3 id="명령형-처리"><a href="#명령형-처리" class="headerlink" title="명령형 처리"></a>명령형 처리</h3><ul><li>명령형 프로그래밍이란 <code>상태</code>를 <code>변경하는 명령</code>으로 이루어진 프로그래밍 (일반적으로 for 루프)</li></ul><script src="https://gist.github.com/kodakyung/02948b60d265572d4fd90464fe8e04e5.js"></script><ul><li>이러한 프로그래밍은 개발자가 <code>루프 내에서 연산</code>하기를 권장한다.</li><li>한 글자 이름 필터, 목록에 남아 있는 이름 대문자 변형, 목록을 하나의 문자열로 변환하는 일련의 과정을 모두 <code>저 수준의 매커니즘</code>에서 사용한다. </li></ul><h3 id="함수형-처리"><a href="#함수형-처리" class="headerlink" title="함수형 처리"></a>함수형 처리</h3><ul><li><code>필터, 변형, 변환</code> 등 논리적 분류로 구현한다.</li><li><code>고계함수</code>에 <code>매개변수로 주어지는 함수</code>를 이용해 저수준의 작업을 커스텀한다.<ul><li>고계함수란 ? 함수를 다루는 함수, 함수를 인자로 받을 수 있고 함수를 반환하기도 함. 함수가 정수와 동등하게 다루어짐</li></ul></li></ul><script src="https://gist.github.com/kodakyung/f891d3978441e6991f3c3e7deb2fb5a3.js"></script><ul><li>한 글자 이름을 필터하고, 이 연산의 결과를 map 함수에 넘긴뒤 reduce를 통해 결합한다.</li><li>모든 함수형 언어에서 비슷한 기능을 제공해준다.</li></ul><blockquote><p>이와 같이 함수형 사고로의 전환은 “세부적인 구현을 하지 않고 고수준 추상 개념을 적용하는 법”을 배우는 것이다. </p></blockquote><h3 id="고수준의-추상적-사고로-얻는-이점들"><a href="#고수준의-추상적-사고로-얻는-이점들" class="headerlink" title="고수준의 추상적 사고로 얻는 이점들"></a>고수준의 추상적 사고로 얻는 이점들</h3><ol><li><p>문제의 공통점을 고려해 <code>다른 방식으로 분류</code>하는 것을 권장함</p></li><li><p><code>런타임</code>이 <code>최적화</code>를 잘할 수 있도록 한다.</p><ul><li>더 적은 아이템을 처리하는 경우</li><li>ex) Java8 Supplier를 이용한 Lazy Evaluation 등</li></ul></li><li><p>개발자가 <code>엔진의 세부사항</code>을 깊게 고려하지 않고 프로그래밍 할 수 있다. </p><ul><li><p>책에서는 <del>“개발자가 엔진 세부사항에 깊이 파묻힐 경우 불가능한 해답을 가능하게 한다.”</del> 고 나와 있지만 위의 뜻인 것 같다. </p></li><li><p>예를 들면 위의 명령형 처리 로직에 스레드 처리가 추가된다면 스레드 관련 코드가 로직 코드에 섞여 들어간다. 하지만 함수형으로 프로그래밍한다면 병렬 처리를 의미하는 코드 한줄만 추가하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cleanNamesP</span><span class="params">(List&lt;String&gt; names)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (names == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">return</span> names</span><br><span class="line">          .parallelStream() <span class="comment">// 이 한줄이 추가되었다. </span></span><br><span class="line">          .filter(n -&gt; n.length() &gt; <span class="number">1</span>) </span><br><span class="line">          .map(e -&gt; capitalize(e))</span><br><span class="line">          .collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>이후 저수준의 세부적인 최적화는 런타임이 담당한다. </p></li></ul></li></ol><h3 id="명령형에서-함수형으로의-전환-과정"><a href="#명령형에서-함수형으로의-전환-과정" class="headerlink" title="명령형에서 함수형으로의 전환 과정"></a>명령형에서 함수형으로의 전환 과정</h3><ul><li><code>OOP</code> 언어는 캡슐화가 이점이므로 <code>내부 상태</code> 사용이 보편적이고 권장된다.</li><li><code>FP</code>은 내부 변수를 사용하지 않고 필요한 값을 <code>매개변수</code>로 넘긴다.<ul><li>부수 효과가 없는 <code>순수 함수</code>를 사용한다.<ul><li>입력만 결과에 영향을 주는 함수</li></ul></li><li>따라서 캐싱하지 않고 항상 계산 하기때문에 성능이 떨어지며, 이를 막기 위해 <code>메모이제이션</code>을 사용한다.</li></ul></li><li>완전한 <code>FP</code>은 <code>Stream</code>을 이용한다.<ul><li>연산의 중간과정을 스트림에 저장한 뒤 완전히 연산히 끝났을 때 스트림을 종료하고 값을 생성한다.</li><li>이를 <code>게으른 평가(Lazy Evaluation)</code>이라 한다.</li></ul></li></ul><h2 id="함수형-언어들의-공통된-빌딩-블록"><a href="#함수형-언어들의-공통된-빌딩-블록" class="headerlink" title="함수형 언어들의 공통된 빌딩 블록"></a>함수형 언어들의 공통된 빌딩 블록</h2><ul><li><code>필터 / 변형 / 변환</code>에 관한 내용은 함수형 언어 및 프레임 워크에 <code>공통적</code>으로 존재한다.</li></ul><h3 id="1-필터"><a href="#1-필터" class="headerlink" title="1. 필터"></a>1. 필터</h3><ul><li><code>사용자가 정한 조건</code>으로 목록에 있는 요소를 <code>필터</code>해서 더 작은 목록으로 만든다.</li><li>ex) java8 - filter()</li></ul><h3 id="2-맵"><a href="#2-맵" class="headerlink" title="2. 맵"></a>2. 맵</h3><ul><li>각 요소에 <code>같은 함수</code>를 적용해 <code>새로운 컬렉션</code>을 만든다.</li><li>ex) java8 - map()</li></ul><h3 id="3-폴드-리듀스"><a href="#3-폴드-리듀스" class="headerlink" title="3. 폴드 / 리듀스"></a>3. 폴드 / 리듀스</h3><ul><li>언어마다 이름도 다양하고 약간의 의미도 다르지만, 기본적으로 캐터모피즘(catamorphism)이라는 <code>목록 조작 개념의 변형</code>을 의미한다. <ul><li>목록을 접어서 다른 형태로 만드는 연산</li></ul></li><li>ex) java8의 filter로 값을 추출 후 reduce를 통해 추가 연산 후 결과를 반환</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>함수형 사고(Functional Thinking), 한빛미디어</li><li><a href="https://github.com/oreillymedia/functional_thinking" target="_blank" rel="noopener">Functional Thinking Code</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;생각의-전환&quot;&gt;&lt;a href=&quot;#생각의-전환&quot; class=&quot;headerlink&quot; title=&quot;생각의 전환&quot;&gt;&lt;/a&gt;생각의 전환&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;새로운 언어를 배우는 것은 쉽지만, &lt;code&gt;새로운 패러타임&lt;/code&gt;을 익히는 것
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Common" scheme="https://kodakyung.github.io/categories/programming/common/"/>
    
    
      <category term="Functional Thinking" scheme="https://kodakyung.github.io/tags/functional-thinking/"/>
    
  </entry>
  
  <entry>
    <title>함수형 사고 - ch1 왜?</title>
    <link href="https://kodakyung.github.io/2019/10/16/programming-common-20191016-functional-thinking-ch1/"/>
    <id>https://kodakyung.github.io/2019/10/16/programming-common-20191016-functional-thinking-ch1/</id>
    <published>2019-10-16T11:26:14.000Z</published>
    <updated>2020-03-19T00:43:22.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="함수형-프로그래밍을-하는-이유"><a href="#함수형-프로그래밍을-하는-이유" class="headerlink" title="함수형 프로그래밍을 하는 이유"></a>함수형 프로그래밍을 하는 이유</h2><h3 id="1-패러다임의-전환"><a href="#1-패러다임의-전환" class="headerlink" title="1. 패러다임의 전환"></a>1. 패러다임의 전환</h3><ul><li><p>문제에 대해 사람이 생각하는 것과 같은 방식으로 프로그래밍 할 수 있다.</p><ul><li><p>예를 들면, Java에서 <code>1)텍스트 파일을 읽고 2)가장 많이 사용된 단어를 찾고 3)그 단어들과 빈도를 정렬된 목록으로 출력해야 한다</code>면 일반적으로 성능을 위해 한 loop 안에서 3가지 연산을 섞어서 사용 할 것</p><blockquote><p>책에서는 이것을 “성능을 명료함과 맞바꾸었다”고 표현함.</p></blockquote></li><li><p>반면에 함수형 프로그래밍을 한다면 <code>map</code>과 <code>filter</code>와 같은 고계함수를 이용해 사람이 생각하는 것과 같은 흐름(위의 <code>1)</code>~<code>3)</code>)으로 프로그래밍 할 수 있게 한다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map <span class="title">wordFreq</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">  TreeMap&lt;String, Integer&gt; wordMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">  regexToList(words, <span class="string">"\\w+"</span>).stream() <span class="comment">// 정규표현식을 검색한 뒤 스트림으로 변경</span></span><br><span class="line">    .map(w -&gt; w.toLowerCase()) <span class="comment">// 소문자로 바꾼다.</span></span><br><span class="line">    .filter(w -&gt; !NON_WORDS.contains(w))<span class="comment">// 비단어를 골라내고</span></span><br><span class="line">    .forEach(w -&gt; wordMap.put(w, wordMap.getOrDefault(w, <span class="number">0</span>) + <span class="number">1</span>)); <span class="comment">// 단어 빈도수를 센다.</span></span><br><span class="line">  <span class="keyword">return</span> wordMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-최근-언어-트렌드"><a href="#2-최근-언어-트렌드" class="headerlink" title="2. 최근 언어 트렌드"></a>2. 최근 언어 트렌드</h3><ul><li>주요 언어들이 함수형 기능을 더하고 있다. </li><li>즉 함수형 패러다임을 이해한다면 다른 최신 함수형 언어들을 쉽게 익히고 사용할 수 있게된다.</li></ul><h3 id="3-언어-런타임에-제어를-양도함"><a href="#3-언어-런타임에-제어를-양도함" class="headerlink" title="3. 언어/런타임에 제어를 양도함"></a>3. 언어/런타임에 제어를 양도함</h3><ul><li>c++에서 Java로 GC를 사용하는 것처럼, 까다로운 <code>저수준의 문제</code>를 언어나 런타임에 최대한 맡길수록 <code>더 중요한 문제</code>에 집중 할 수 있게 된다.</li></ul><h3 id="4-간결함"><a href="#4-간결함" class="headerlink" title="4. 간결함"></a>4. 간결함</h3><blockquote><p>객체지향 프로그래밍은 움직이는 부분을 캡슐화하여 코드 이해를 돕고, 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드 이해를 돕는다. </p></blockquote><ul><li>캡슐화, 스코핑, 가시성 등의 <code>상태 변화</code>에 대해 필요한 세밀한 제어들을 직접 제어 하기 보다는 이 부분을 <code>제거</code>하는데 주력한다.</li><li>객체지향 개발자는 항상 새로운 자료구조(Object)와 거기에 메소드를 만드므로 메서드 수준의 재사용보다<code>큰 프레임워크 스타일의 재사용</code>을 하게된다.</li><li>함수 수준의 캡슐화는 모든 문제에 새로운 클래스를 생성하기보다는 <code>더 세부적인 수준에서 재사용</code>을 가능하게 한다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>함수형 사고(Functional Thinking), 한빛미디어</li><li><a href="https://github.com/oreillymedia/functional_thinking" target="_blank" rel="noopener">Functional Thinking Code</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;함수형-프로그래밍을-하는-이유&quot;&gt;&lt;a href=&quot;#함수형-프로그래밍을-하는-이유&quot; class=&quot;headerlink&quot; title=&quot;함수형 프로그래밍을 하는 이유&quot;&gt;&lt;/a&gt;함수형 프로그래밍을 하는 이유&lt;/h2&gt;&lt;h3 id=&quot;1-패러다임의-전
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Common" scheme="https://kodakyung.github.io/categories/programming/common/"/>
    
    
      <category term="Functional Thinking" scheme="https://kodakyung.github.io/tags/functional-thinking/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 트랜잭션과 동시성 제어</title>
    <link href="https://kodakyung.github.io/2019/10/15/cs-database-20191015-mysql-transaction-and-concurrency-control/"/>
    <id>https://kodakyung.github.io/2019/10/15/cs-database-20191015-mysql-transaction-and-concurrency-control/</id>
    <published>2019-10-15T14:20:32.000Z</published>
    <updated>2020-03-19T00:43:22.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="트랜잭션과-동시성제어"><a href="#트랜잭션과-동시성제어" class="headerlink" title="트랜잭션과 동시성제어"></a>트랜잭션과 동시성제어</h1><h2 id="트랜잭션이란"><a href="#트랜잭션이란" class="headerlink" title="트랜잭션이란?"></a>트랜잭션이란?</h2><p><strong>복수의 쿼리의 처리 단위</strong></p><ul><li>데이터 갱신은 단일 쿼리보다 <code>복수 쿼리를 연속적</code>으로 수행하는 경우가 많다.</li><li><code>동시성 제어</code>를 위해 필요</li></ul><h3 id="MyISAM-vs-InnoDB"><a href="#MyISAM-vs-InnoDB" class="headerlink" title="MyISAM vs InnoDB"></a>MyISAM vs InnoDB</h3><ul><li>전자는 테이블 단위 잠금, <code>트랜잭션 사용 불가</code></li><li>후자는 행 단위 잠금, <code>트랜잭션 사용 가능</code></li></ul><h2 id="트랜잭션-특성-ACID-특성"><a href="#트랜잭션-특성-ACID-특성" class="headerlink" title="트랜잭션 특성 (ACID 특성)"></a>트랜잭션 특성 (ACID 특성)</h2><ol><li><p>Atomicity(원자성)</p><ul><li>데이터 변경(<code>update, delete, insert</code>)시 데이터 조작이 전부 성공 or 전부 실패하도록 보증</li></ul></li><li><p>Consistency(일관성)</p><ul><li>데이터 조작 전후로 상태를 유지하는 것을 보증함…?</li><li>ex) 일관성을 유지하기 위해 사용자 등록 시 사용자 구분하기 위한 일련 번호에 unique 제약 조건을 검</li></ul></li><li><p>Isolation(고립성, 격리성)</p><ul><li><p><code>복수의 사용자</code>가 <code>데이터 조작</code>을 해도 각각 처리가 <code>모순 없이</code> 동작함</p></li><li><p>모순 없이 동작한다는 것은 동시에 말고 순서대로 실행 시켰을 때와 같은 동작을 한다는 것을 의미</p><ul><li><p>병렬로 실행되지 않은 상태를 의미(<code>직렬</code>)</p></li><li><p>ex) 호텔방 예약 시 1. 빈 방 확인 2. 빈방에서 -1 후 결과를 빈방 수로 되돌려준다는 로직을 수행하는 경우 사용자 a와 사용자 b가 동시에 수행하면 8개가 아닌 9개가 남았다고 될 수 있음</p></li></ul></li><li><p>Isolation을 유지하기 위해 <code>lock</code> 을 사용</p><ul><li>잠금 단위는 테이블 전체, 블록, 행 등</li></ul></li><li><p>MySQL은 주로 트랜잭션 처리 시 <code>행 단위</code> 잠금 이용 (<code>select ~ for update</code>)</p><ul><li>후속 처리는 해당 잠금이 해제될 때 (<code>commit</code> or <code>rollback</code> )까지 대기한 후 처리한다.</li></ul></li><li><p>InnoDB형 테이블은 <code>MVCC</code> 구조로 동작하기 때문에 단순 값 참조 시 <code>select ~ for update</code> 구준은 불필요. 읽기가 블록되지 않음.</p><ul><li>이 때 테이블 갱신하는 사용자가 소수고 참조하는 사용자가 많은 경우 사용자의 동시성, 병렬성이 높아짐.</li></ul></li><li><p>모순 없는 동작(직렬)을 위해 DBMS에서  <code>Serializable</code> (직렬화 가능) 이라는 <code>격리 수준</code>을 제공함</p></li><li><p>이때 항상 <code>동시에 동작하는 트랜잭션</code>이 <code>1개</code>여야 하므로 성능에서 실용적이지 않음</p></li><li><p>따라서 격리 수준을 완화해 <code>단계별</code>로 제공한다.</p></li></ul><br><h3 id="Trasaction-Isolation-Level-트랜잭션-격리-수준"><a href="#Trasaction-Isolation-Level-트랜잭션-격리-수준" class="headerlink" title="Trasaction Isolation Level(트랜잭션 격리 수준)"></a>Trasaction Isolation Level(트랜잭션 격리 수준)</h3><ol><li>커밋되지 않은 읽기(<code>Read Uncommied</code>) - 가장 완화</li><li>커밋된 읽기(<code>Read Committed</code>)</li><li>반복 읽기(<code>Repeatable Read</code>) - MySQL의 기본 설정</li><li>직렬화 가능(<code>Serializable</code>) - 가장 엄격</li></ol><br><h3 id="격리-수준-완화에-따라-일어나는-현상"><a href="#격리-수준-완화에-따라-일어나는-현상" class="headerlink" title="격리 수준 완화에 따라 일어나는 현상"></a>격리 수준 완화에 따라 일어나는 현상</h3><ol><li>더티 읽기(<code>Dirty Read</code>) (1 이하)<ul><li>어떤 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽는 현상</li></ul></li><li>애매한 읽기(<code>Fuzzy/Non-Repetable Read</code>) (2 이하)<ul><li>어떤 트랜잭션이 이전에 읽어들인 데이터에를 다시 읽을 때 2회 이후의 결과가 1회 때와 다른 것</li></ul></li><li>팬텀 읽기(<code>Phantom Read</code>) (3 이하)<ul><li>어떤 트랜잭션을 읽을 때 데이터가 나타나거나 사라지는 현상.</li></ul></li></ol><table><thead><tr><th>격리수준</th><th>더티 읽기</th><th>애매한 읽기</th><th>팬텀 읽기</th></tr></thead><tbody><tr><td>커밋되지 않은 읽기</td><td>O</td><td>O</td><td>O</td></tr><tr><td>커밋된 읽기</td><td>X</td><td>O</td><td>O</td></tr><tr><td>반복 읽기</td><td>X</td><td>X</td><td>O</td></tr><tr><td>직렬화 가능</td><td>X</td><td>X</td><td>X</td></tr></tbody></table></li><li><p>Durability(지속성)</p><ul><li>commit 후 (데이터 조작 완료 후) 완료 통지를 사용자가 받는 시점에서 그 조작이 <code>영구적</code>이고 결과를 잃지 않는 경우를 의미</li><li>시스템이 비정상일 때도 성립해야함(os 이상종료 등의 시스템 장애에도 해당)</li><li>MySQL과 같은 데이터베이스는 트랜잭션 조작을 하드 디스크에 <code>로그</code> 로 기록, 시스템 이상 발생 시 그 로그를 사용해 발생 전 상태로 복원함.</li></ul></li></ol><h2 id="다른-커넥션에서-테이블을-보는-경우"><a href="#다른-커넥션에서-테이블을-보는-경우" class="headerlink" title="다른 커넥션에서 테이블을 보는 경우"></a>다른 커넥션에서 테이블을 보는 경우</h2><ul><li>DDL에 의한 테이블 작성과 , DML에 의한 데이터 저장은 <code>트랜잭션 커밋 전까지 다른 커넥션에서 보이지 않지만</code> 이와 별개로 보이는 경우가 있다.</li></ul><ol><li><p>DDL에 의한 암묵적인 커밋</p><ul><li>MySQL이나 Oracle에서 create  table같은 <code>DDL 실행시 암묵적인 커밋</code> 발생.</li><li>따라서 한개의 커넥션에서 실행된 create table 성공시 다른 커넥션에서도 참조 가능</li></ul></li><li><p>오토커밋 설정</p><ul><li>트랜잭션의 개시(begin transaction, start transaction 등)가 명시적으로 지정되지 않았을 때 2가지 모드로 구분함</li></ul><ol><li><code>하나의 SQL</code>문을 하나의 트랜잭션으로</li><li>사용자가 <code>commit 또는 rollback을 실행할 때 까지</code>가 하나의 트랜잭션</li></ol><ul><li>일반적인 dbms에서는 선택 가능.</li><li>mysql, postgreSQL, SQL Server는 기본 설정이 2.오토커밋</li></ul></li></ol><ul><li>이와 별개로 갱신을 수행하는 트랜잭션 자신은 트랜잭션 격리 수준, commit, rollback과 상관없이 자신이 수행한 갱신을 즉시 볼 수 있다.</li></ul><h2 id="MVCC에-따른-MySQL-InnoDB-의-특성"><a href="#MVCC에-따른-MySQL-InnoDB-의-특성" class="headerlink" title="MVCC에 따른 MySQL(InnoDB)의 특성"></a>MVCC에 따른 MySQL(InnoDB)의 특성</h2><h3 id="MVCC-Multi-Versioning-Concurrency-Control"><a href="#MVCC-Multi-Versioning-Concurrency-Control" class="headerlink" title="MVCC(Multi Versioning Concurrency Control)"></a>MVCC(Multi Versioning Concurrency Control)</h3><p>: 다중 버전 동시성 제어</p><ul><li><p>RDBMS는 <code>공유 데이터</code>를 사용하기 때문에 <code>동시성 제어가 필요</code>함</p></li><li><p>이를 <code>Rock</code>을 통해 <code>상호배제</code>를 해 컨트롤 했지만 이는 <code>대기 현상</code>이 발생하기 때문에 <code>성능</code>이 떨어짐</p></li><li><p>어떤 데이터에 여러 차례 수정이 가해진 경우 <code>수정이 가해진 시점</code>에 대해 <code>버전 별</code>로 <code>데이터</code>를 저장하고 읽기와 쓰기간 경합을 최소화해 <code>동시성 제어</code> 성능을 높임.</p></li></ul><ol><li><strong><code>읽기</code>를 수행할 경우 갱신 중이라도 <code>블록되지 않는다</code>(읽기←&gt;읽기는 서로 블록되지 않음)</strong></li><li>읽기 내용은 <code>격리 수준에 따라</code> 내용이 바뀌는 경우가 있다.<ul><li>반복 읽기의 경우 최초 쿼리 실행한 시점에 커밋된 데이터를 읽음. 따라서 같은 쿼리 복수 회 실행 시 사이에 다른 트랜잭션이 커밋해도 그 내용은 반영되지 않음</li><li>커밋된 읽기는 쿼리를 실행한 시점에서 커밋된 데이터를 읽는다. 같은 쿼리 복수 회 실행시 그 사이에 다른 트랜잭션에서 커밋시 최신 쿼리 실행 개시 시점의 커밋된 데이터를 읽음</li></ul></li><li><code>갱신(데이터 쓰기)</code> 시 <code>배타적 잠금</code>을 얻는다. 잠금은 기본적으로 행 단위이며 트랜잭션이 종료될 때까지 유지한다. 격리 수준이나 InnoDB 설정에 따라 실제로 잠금하는 행의 범위가 다를 수 있음.</li><li><strong>갱신과 갱신은 나중에 온 트랜잭션이 잠금을 획득하려할 때 <code>블록</code>된다. 일정 시간을 기다리고, 그 안에 잠금을 얻을 수 없을 시 <code>잠금 타임아웃(lock timeout)</code>된다.</strong></li><li>갱신하는 경우 갱신 전 데이터를 <code>undo 로그</code>로 ‘롤백 세그먼트’영역에 유지한다. <ul><li>undo 로그 용도 2가지</li></ul><ol><li>갱신하는 트랜잭션 <code>롤백</code> 시 <code>갱신 전</code>으로 되돌리는 것</li><li>복수의 트랜잭션에서 격리 수준에 따라 대응하는 <code>갱신 데이터를 참조</code>하는데 이용함.<ul><li>같은 행 갱신할 때마다 undo로그가 작성되고 같은 행에 대한 복수 버전이 존재한다.</li><li>이에 의해 1,2가 실현된다.</li></ul></li></ol></li></ol><h3 id="MVCC에서의-잠금-같은-행인-경우"><a href="#MVCC에서의-잠금-같은-행인-경우" class="headerlink" title="MVCC에서의 잠금(같은 행인 경우)"></a>MVCC에서의 잠금(같은 행인 경우)</h3><ul><li>트랜잭션 A, B 둘다 읽기 &gt; O</li><li>A 읽기, B 쓰기 &gt; O</li><li>A 쓰기, B 쓰기 &gt; X<ul><li>A가 lock을 얻고 수행하는 동안 B는 block된다</li><li>지정된 시간안에 lock을 얻을 수 없는 경우 lock timeout 된다.</li></ul></li></ul><h3 id="MVCC에서의-커밋되지-않은-읽기"><a href="#MVCC에서의-커밋되지-않은-읽기" class="headerlink" title="MVCC에서의 커밋되지 않은 읽기"></a>MVCC에서의 커밋되지 않은 읽기</h3><ul><li>커밋되지 않은 읽기 격리 수준은 커밋되지 않은 경우, 읽기도 블록되는 경우 이를 허용하는 것.</li><li>MVCC는 <code>읽기가 블록되는 경우가 없어서</code> 이 레벨이 필요하지 않다.</li></ul><h2 id="잠금-타임아웃과-교착-상태"><a href="#잠금-타임아웃과-교착-상태" class="headerlink" title="잠금 타임아웃과 교착 상태"></a>잠금 타임아웃과 교착 상태</h2><h3 id="잠금-타임아웃"><a href="#잠금-타임아웃" class="headerlink" title="잠금 타임아웃"></a>잠금 타임아웃</h3><ul><li>갱신과 갱신이 부딪칠 때 <code>나중에 온 갱신</code>이 <code>잠금 대기 상태</code>가 됨.</li><li>잠금을 건 쪽이 언제 잠금을 풀지 알 수 없어서 잠금 해제를 기다리는 쪽에서<ol><li>기다리거나</li><li>기다리지 않거나</li><li>어느정도 기다릴지 를 설정할 수 있다.<ul><li><code>innodb_lock_wait_timeout</code> 시스템 변수에 설정</li><li>MySQL에서는 잠금 대기로 타임아웃 발생 시 롤백되는 단위는 기본으로 오류가 발생한 쿼리임.</li></ul></li></ol></li></ul><h3 id="교착-상태"><a href="#교착-상태" class="headerlink" title="교착 상태"></a>교착 상태</h3><ul><li>트랜잭션 A가 테이블 A의 lock을, 트랜잭션 B가 테이블 B의 lock을 가진 상태에서 서로 잠금한 테이블의 자원이 필요한 경우 <strong>아무리 기다려도 상황이 바뀌지 않음</strong>. 이를 교착상태(데드락)이라 함.</li></ul><h3 id="교착상태의-빈도를-낮추는-대책"><a href="#교착상태의-빈도를-낮추는-대책" class="headerlink" title="교착상태의 빈도를 낮추는 대책"></a>교착상태의 빈도를 낮추는 대책</h3><ul><li><p>잠금 타임 아웃과 달리 교착 상태를 기다려도 상황이 개선되지 않는다.</p></li><li><p>따라서 일반적으로 DBMS에서는 <code>교착상태</code>를 검출해 <code>보고</code>한다.</p><ul><li>MySQL의 경우 교착 상태가 일어나면 시스템 영향이 작은 쪽 트랜잭션을 트랜잭션 개시 시점까지 롤백한다.</li></ul></li><li><p>교착 상태를 모두 없애는 것은 불가.</p></li><li><p>따라서 항상 트랜잭션이 교착 상태를 일으켜 롤백되는 경우 트랜잭션을 재실행할 수 있는 구조로 만들어야함.</p></li><li><p>DBMS의 전반적인 대책</p></li></ul><ol><li>트랜잭션을 자주 커밋, 트랜잭션이 <code>더 작은 단위</code>가 되어 교착상태 가능성을 낮춤</li><li><code>정해진 순서</code>로 테이블(과 행)에 액세스 하게 한다.<ul><li>ex) 트랜잭션 A가 테이블 a&gt;테이블b로 엑세스 하고 트랜잭션 B가 테이블 b&gt; 테이블 a로 액세스해 교착상태가 발생한 것이므로 어떤 트랜잭션도 테이블 a&gt;b순으로 엑세스 하도록함.</li></ul></li><li>필요 없는 경우 <code>읽기 잠금 획득(select ~ for update)</code> 사용을 피한다</li><li>쿼리에 의한 <code>잠금 범위</code>를 좁히거나(테이블 &gt; 행 등), <code>잠금 정도</code>를 더 작은 것으로 (격리 레벨 완화) 한다.<ul><li>테이블 잠금보다 행 잠금을 사용</li><li>MySQL은 기본 설정인 반복 읽기가 아닌 커밋된 읽기로 설정</li></ul></li><li>동시에 많은 연결에서 갱신 때문에 교착 상태가 자주 발생하는 경우 테이블 단위 잠금을 획득해 갱신을 <code>직렬화</code> 하면 동시성은 떨어져도 교착상태는 회피할 수 있어 전체 처리로 보면 좋을 수도 있다.</li><li>(MySQL(InnoDB)의 대책) 테이블에 적절한 인덱스를 추가해 인덱스가 이를 이용하게 한다. 인덱스가 사용되지 않는 경우에는 필요한 행의 잠금이 아닌 스캔한 행 전체에 대해 잠금이 걸리게된다. …? 이해안됨</li></ol><h2 id="해서는-안-되는-트랜잭션-처리"><a href="#해서는-안-되는-트랜잭션-처리" class="headerlink" title="해서는 안 되는 트랜잭션 처리"></a>해서는 안 되는 트랜잭션 처리</h2><ol><li>오토커밋<ul><li>MySQL의 새로운 연결은 모두 기본값으로 오토 커밋</li><li>오토 커밋은 <code>쿼리 단위</code>로 <code>커밋</code>하는 것.</li><li>테스트용으로는 좋지만 애플리케이션에 사용하기엔 <code>부하</code>가 너무 높음</li></ul></li><li>긴 트랜잭션<ul><li>긴 트랜잭션은 데이터베이스 트랜잭션의 <code>동시성</code>이나 <code>자원의 효율성</code>을 저하함.</li><li>갱신을 포함한 트랜잭션은 같은 데이터를 갱신하려는 다른 테이블을 <code>블록</code>하고 이에 <code>타임아웃</code>될 수 있음.</li><li>이 잠금과 블록 사이에 교차가 발생하면 <code>교착상태</code>도 발생, 이에 긴 트랜잭션 중 하나가 롤백됨</li><li>이를 위해 <code>교착상태의 빈도를 낮추는 대책</code> 에 나온 방법을 시행하는 것이 좋음.</li></ul></li></ol><ul><li>그밖의 피해야할 것.<ol><li><code>대량 처리</code>를 한 개의 트랜잭션이 실행<ul><li>대량의 갱신 처리를 한개의 트랜잭션으로 실행하면 트랜잭션으로 이 처리를 롤백하기 위해 <code>대량의 undo 로그</code>를 트랜잭션 종료 시까지 유지해야 한다.</li><li>Undo 로그가 불필요해진 시점에 해당 영역은 해제되어 재사용되지만 os파일 시스템에서의 크기는 줄어들지 않는다 .</li><li>이 때문에 겉보기에 불필요하게 undo 로그가 큰 경우가 있음.</li><li>이를 막기 위해 대량 처리를 <code>적당한 크기</code>의 트랜잭션으로 나누어 처리하는 것이 좋다.</li><li>예를 들면 신규테이블에 데이터를 로드할 때 1만건당 커밋</li></ul></li><li>아무것도 하지 않는 트랜잭션 유의<ul><li>테이블을 <code>select</code>한 후 아무것도 하지 않고 트랜잭션을 <code>열린 채로 두면</code> 같은 테이블에 갱신을 실행할 때 이 테이블의 반복 읽기를 유지하기 위해 <code>undo 로그</code>가 계속 유지된다 .따라서 피하는 것이 좋다.</li></ul></li><li>트랜잭션 중 <code>대화 처리</code>를 넣는 경우<ul><li>dbms의 트랜잭션은 빡빡한 처리를 동시에 실행하는 구조</li><li>따라서 언제 끝날지 알 수 없는 <code>불명확한 처리</code>를 포함해선 안된다.</li></ul></li><li>처리 능력 이상의 트랜잭션 수<ul><li>트랜잭션에서 어떤 잠금이 있는 처리를 수행할 때 이 잠금이 다른 트랜잭션의 처리를 막지 않는 것이 좋지만, 트랜잭션 실행이 다른 트랜잭션 잠금 때문에 막힌다면 잠금 타임아웃이나 교착 상태 확률이 증가하고 성능 저하로 이어짐.</li><li>커넥션이 잘 작동하는 수나 동시 실행할 수 있는 수의 상한을 어느정도로 설정할 지는 시스템 요건(갱신이 많은지 검색이 많은지)나 하드웨어 성능에도 좌우되므로 <code>최적의 트랜잭션 수</code>는 <code>부하 실행</code>을 수행해 측정할 수 밖에 없다.</li><li>MySQL은 데이터베이스 서버의 커넥션 수 상한을 설정하는 <code>max_connections</code> 라는 시스템 변수가 있어 이것으로 조절할 수 있다.</li></ul></li></ol></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>데이터베이스 첫걸음</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;트랜잭션과-동시성제어&quot;&gt;&lt;a href=&quot;#트랜잭션과-동시성제어&quot; class=&quot;headerlink&quot; title=&quot;트랜잭션과 동시성제어&quot;&gt;&lt;/a&gt;트랜잭션과 동시성제어&lt;/h1&gt;&lt;h2 id=&quot;트랜잭션이란&quot;&gt;&lt;a href=&quot;#트랜잭션이란&quot; cla
      
    
    </summary>
    
      <category term="CS" scheme="https://kodakyung.github.io/categories/cs/"/>
    
      <category term="DataBase" scheme="https://kodakyung.github.io/categories/cs/database/"/>
    
    
      <category term="MySQL" scheme="https://kodakyung.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>🐥병아리 개발자가 IT 정보를 얻는 방법들</title>
    <link href="https://kodakyung.github.io/2019/09/26/think-20190926-how-junior-developers-get-it-information/"/>
    <id>https://kodakyung.github.io/2019/09/26/think-20190926-how-junior-developers-get-it-information/</id>
    <published>2019-09-26T13:30:38.000Z</published>
    <updated>2020-03-19T00:43:22.696Z</updated>
    
    <content type="html"><![CDATA[<p>개발을 처음 시작하거나, 잘 모르는 경우 <code>IT/개발 정보</code>를 어디에서 얻어야하는지부터 잘 모르는 경우가 있다.<br>본인 또한 IT 정보를 얻고 커뮤니케이션을 하는 방법을 잘 몰랐기 때문에,<br>과거의 나처럼 잘 모르는 병아리 개발자들에게 정보를 공유하고 싶어서 글을 적게되었다.</p><h2 id="1-페이스북"><a href="#1-페이스북" class="headerlink" title="1. 페이스북"></a>1. 페이스북</h2><p>개발자들이 <code>가장 빠른 정보</code>를 주고 받는 플랫폼은 페이스북인 것 같다.<br>특히 <code>세미나/컨퍼런스</code>에 대한 정보를 실시간으로 얻기 좋다.<br>그리고 IT 계에서 유명한 분들의 글 중 특히 양질의 글이 추천으로 올라오기도 한다.<br>SNS를 하기 싫더라도 페이스북은 구독용 계정이라도 만드는 것을 추천한다.(<del>본인 얘기</del>)<br>자신이 관심 있는 분야의 페이지를 구독하는 것이 좋지만, 정말 아무 것도 모른다면 <code>생활코딩</code> 페이지를 구독하자. <code>생활코딩</code> 페이지에서 글을 보다보면 다른 페이지의 글을 공유해오기도 하고 다른 여러 IT 관련 페이지들이 추천으로 뜨는 편이다.  </p><h3 id="기본적으로-추천하는-페이지들"><a href="#기본적으로-추천하는-페이지들" class="headerlink" title="기본적으로 추천하는 페이지들"></a>기본적으로 추천하는 페이지들</h3><ul><li>생활코딩 : 온갖 IT 글이 종류를 가리지 않고 올라온다.</li><li>출퇴근길 개발 읽기 : 개발에 관련된 양질의 포스팅이 올라온다.</li><li>좋은 지식 공유 Popit : Popit 사이트의 글이 올라온다.</li><li>초보 개발자 모임</li></ul><blockquote><p>우선 이 4개 페이지는 구독하고 시작하자</p></blockquote><h2 id="2-RSS"><a href="#2-RSS" class="headerlink" title="2. RSS"></a>2. RSS</h2><p>좋은 개발자 블로그는 많은데, 블로그를 매번 찾아가서 신규 게시글을 읽는건 생각보다 엄청나게 힘든일이다. 그때 RSS 구독을 이용하는 것을 추천한다. 개발자들이라면 보통 블로그에 RSS 설정을 해둔 곳이 많다. (<del>이 블로그도 되어있다..</del>)<br><code>Chrome Extension</code>이나 <code>Feedly</code> 등의 App을 이용하면 이런 개발자들의 블로그들을 구독할 수 있다. 관심 있는 분야의 블로그를 구독해두고 짬짬히 글을 읽는 것을 추천한다.<br>하지만 RSS 구독은 <code>push</code>가 오지 않기 때문에 버릇을 들이지 않으면 자주 안읽게 된다는 단점이 있다. 그래서 가급적이면 하루 1번은 들어가려고 노력 중이다..  </p><p><img src="01.png" alt="Feedly"></p><blockquote><p>이런식으로 블로그글을 한번에 모아서 볼 수 있다.<br>또한 인기 있는 글도 모아서 보여준다. </p></blockquote><p>그 밖에도 좋은 개발 블로그들을 모아둔 <a href="https://github.com/isme2n/awesome-blogs" target="_blank" rel="noopener">awesome-blogs</a>도 RSS 서비스를 제공하니 구독하는 것을 추천한다. </p><h2 id="3-Slack"><a href="#3-Slack" class="headerlink" title="3. Slack"></a>3. Slack</h2><p>관심 있는 IT 커뮤니티의 Slack에 참여하는 것도 정보를 얻는 좋은 방법이다.<br><code>DjangoGirls</code>나 <code>9XD</code>, <code>백준 알고리즘</code>과 같이 관심 있는 IT 커뮤니티의 Slack에 가입해보자.</p><h2 id="4-메일링-서비스"><a href="#4-메일링-서비스" class="headerlink" title="4. 메일링 서비스"></a>4. 메일링 서비스</h2><p>개인적으로 IT 정보를 얻을 때 메일링 서비스를 애용하는 편이 아니라 구독하는 경로는 잘모르지만 RSS보다 메일링 서비스를 선호하는 경우도 많다.<br><a href="http://daily-devblog.com" target="_blank" rel="noopener">Daily DevBlog</a>에서 개발자 블로그를 메일링 해주며, <code>매일 프로그래밍</code>은 매일 아침 알고리즘 문제를 보내준다. 그밖에 <a href="https://newneek.co" target="_blank" rel="noopener">NewNeek</a>은 간단한 시사이슈를 정리해 메일링해준다.</p><h2 id="5-기타-IT-커뮤니티"><a href="#5-기타-IT-커뮤니티" class="headerlink" title="5. 기타 IT 커뮤니티"></a>5. 기타 IT 커뮤니티</h2><p>가장 대중적으로 유명한 커뮤니티는 <a href="https://okky.kr/" target="_blank" rel="noopener">okky</a>이다. 위의 모든 것들을 읽고 나면 커뮤니티까지 가기는 어려워서 자주 가진 않지만 좋은 글들이 많다.</p><h2 id="6-동료-개발자들"><a href="#6-동료-개발자들" class="headerlink" title="6. 동료 개발자들"></a>6. 동료 개발자들</h2><p>가장 중요한 것은 열정적인 <code>동료 개발자들</code>(🐏🐑)이 주변에 있는 것이라 생각한다.<br>1번부터 5번까지 현실적으로 모든 정보를 혼자서 다 얻기는 어려운 일이다.<br>주변에 함께 개발을 하는 친구들과 개발에 대한 얘기를 나누다보면 서로의 관심사에 대해 알게되고,<br>서로의 관심사에 대해 알게되면 관련된 IT 정보를 얻게 되었을 때 서로가 서로에게 알려주며 도움도 되고 자극 받으며 성장할 수 있는 것 같다.</p><p>개발을 할수록, 개발자의 문화에 익숙해질수록 개발자끼리의 커뮤니케이션이 굉장히 중요하다는 생각이 든다.<br>다른 직업들도 그렇겠지만 개발자야말로 외골수가 아닌 커뮤니케이터가 필요하다는 것을 깨닫게 된다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;개발을 처음 시작하거나, 잘 모르는 경우 &lt;code&gt;IT/개발 정보&lt;/code&gt;를 어디에서 얻어야하는지부터 잘 모르는 경우가 있다.&lt;br&gt;본인 또한 IT 정보를 얻고 커뮤니케이션을 하는 방법을 잘 몰랐기 때문에,&lt;br&gt;과거의 나처럼 잘 모르는 병
      
    
    </summary>
    
      <category term="Think" scheme="https://kodakyung.github.io/categories/think/"/>
    
    
      <category term="Think" scheme="https://kodakyung.github.io/tags/think/"/>
    
  </entry>
  
  <entry>
    <title>Gradle로 빌드 시 현재 git branch 사용하기</title>
    <link href="https://kodakyung.github.io/2019/08/31/troubleshooting-20190831-using-gradle-build-current-git-branch/"/>
    <id>https://kodakyung.github.io/2019/08/31/troubleshooting-20190831-using-gradle-build-current-git-branch/</id>
    <published>2019-08-31T09:38:55.000Z</published>
    <updated>2020-03-19T01:37:26.436Z</updated>
    
    <content type="html"><![CDATA[<p>현재 대외 IT 동아리인 YAPP에서 동아리 프로젝트 아카이빙 프로젝트를 진행하고 있다.<br>기존에는 AWS를 이용해 프로젝트를 진행하고 배포까지 했으나 동아리에서 <code>네이버 클라우드 플랫폼(Naver Cloud Platform, 이하 NCP)</code>을 지원 받게 되어 서버 이전 작업을 진행중이다.<br>AWS로 프로젝트를 진행할 때에는 <code>Travis CI</code>를 이용해 테스트와 CI를 하고 <code>AWS S3</code>,<code>AWS CodeDeploy</code>를 이용해 <code>AWS EC2</code> 프리티어 인스턴스에 자동으로 배포 되도록 설정을 해두었다.<br>NCP에서 비슷한 기능을 찾아보니 유료로 제공되고 동아리 지원금을 마음대로 쓸 수 없어서 어쩔수 없이 자동으로 배포되는 것을 포기하고 수동으로 <code>Shell Script</code>를 짜서 배포를 하기로 결정했다.</p><p>배포를 진행하다 문제가 된 것은 현재 프로젝트에서 배포용 코드는 <code>deploy branch</code>에 분리해두었는데 스크립트로 빌드(<code>gradle build</code>)를 실행해 배포하는 경우 <code>master branch</code> 기준으로 빌드가 되는 것이었다. </p><p><code>profile</code>을 변경해 실행 하는 경우 아래의 <code>java -jar</code> 명령어를 사용하거나</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Dspring.profiles.active=<span class="variable">$&#123;profile&#125;</span> <span class="variable">$&#123;jarfile&#125;</span></span><br></pre></td></tr></table></figure><p>Gradle의 <code>BootRun</code>을 이용하는 경우 아래의 설정을 이용하면 된다. </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bootRun &#123;</span><br><span class="line">    String activeProfile = System.properties[<span class="string">'spring.profiles.active'</span>]</span><br><span class="line">    systemProperty <span class="string">"spring.profiles.active"</span>, activeProfile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금은 <code>profile</code>이 아닌 <code>git branch</code>으로 빌드가 되어야했기 때문에 구글에 검색해보니 비슷한 사례가 나왔다.<br><code>gradle-git plugin</code>을 사용하는 경우가 있고 플러그인 없이 사용하는 방법이 있다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gradle-git plugin 사용하는 경우 </span></span><br><span class="line"><span class="keyword">task</span> getBranchName(type: GitBranchList) &lt;&lt; &#123;</span><br><span class="line">    <span class="keyword">print</span> getWorkingBranch().name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugin 없이 사용하는 경우 </span></span><br><span class="line"><span class="keyword">def</span> gitBranch() &#123;</span><br><span class="line">    <span class="keyword">def</span> branch = <span class="string">""</span></span><br><span class="line">    <span class="keyword">def</span> proc = <span class="string">"git rev-parse --abbrev-ref HEAD"</span>.execute()</span><br><span class="line">    proc.in.<span class="keyword">eachLine</span> &#123; line -&gt; branch = line &#125;</span><br><span class="line">    proc.err.<span class="keyword">eachLine</span> &#123; line -&gt; <span class="keyword">println</span> line &#125;</span><br><span class="line">    proc.waitFor()</span><br><span class="line">    branch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://stackoverflow.com/questions/15061277/how-can-i-get-the-current-git-branch-in-gradle" target="_blank" rel="noopener">https://stackoverflow.com/questions/15061277/how-can-i-get-the-current-git-branch-in-gradle</a></li><li><a href="http://coders-kitchen.com/2013/11/01/gradle-git-how-to-map-your-branch-to-a-deployment-profile/" target="_blank" rel="noopener">http://coders-kitchen.com/2013/11/01/gradle-git-how-to-map-your-branch-to-a-deployment-profile/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;현재 대외 IT 동아리인 YAPP에서 동아리 프로젝트 아카이빙 프로젝트를 진행하고 있다.&lt;br&gt;기존에는 AWS를 이용해 프로젝트를 진행하고 배포까지 했으나 동아리에서 &lt;code&gt;네이버 클라우드 플랫폼(Naver Cloud Platform, 이하 
      
    
    </summary>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/categories/troubleshooting/"/>
    
    
      <category term="SpringBoot" scheme="https://kodakyung.github.io/tags/springboot/"/>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/tags/troubleshooting/"/>
    
      <category term="Gradle" scheme="https://kodakyung.github.io/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>OS - 동기화(Synchronization)와 임계 영역(Critical Section)</title>
    <link href="https://kodakyung.github.io/2019/07/17/cs-os-20190717-os-synchronization-and-critical-section/"/>
    <id>https://kodakyung.github.io/2019/07/17/cs-os-20190717-os-synchronization-and-critical-section/</id>
    <published>2019-07-17T14:46:37.000Z</published>
    <updated>2020-03-19T00:43:22.664Z</updated>
    
    <content type="html"><![CDATA[<p>병렬 프로그래밍에서 임계영역 까지의 흐름을 정리해보았다. </p><h2 id="병렬-프로그래밍-Parallel-Programming"><a href="#병렬-프로그래밍-Parallel-Programming" class="headerlink" title="병렬 프로그래밍(Parallel Programming)"></a>병렬 프로그래밍(Parallel Programming)</h2><ul><li>멀티코어(<code>Multi-Core</code>)가 등장한 이후 여러 개의 코어를 효과적으로 사용하기 위해 등장.</li><li>하나의 프로그램이 <code>동시에 여러 일</code>을 수행하게 만드는 방법을 통칭하는 용어이다.</li><li>여기서는 동시 프로그래밍(<code>Concurrent Programming</code>) 의미의 병렬프로그램이다.<ul><li>다른 의미로 고성능 컴퓨팅(High Performance Computing)의 한 분야를 지칭하기도 한다. </li></ul></li><li>규모가변성(<code>Scalability</code>)이 뛰어난 프로그램이라면 코어의 수를 늘렸을 때 프로그램의 성능이 향상된다.</li><li>규모가변성이 보장되면서 스레드 세이프(<code>Thread-Safe</code>)한 코드를 작성하는 것은 매우 어려운 편이다.</li></ul><h3 id="고전적인-병렬-프로그램-예시들"><a href="#고전적인-병렬-프로그램-예시들" class="headerlink" title="고전적인 병렬 프로그램 예시들"></a>고전적인 병렬 프로그램 예시들</h3><ul><li>공통된 자원을 공유하고 락(Lock)과 컨디션 변수(Condition Variable)를 통해 공유 자원의 접근을 통제하는 멀티 스레드 프로그래밍(Multi-Thread Programming).</li><li>OS 프로세스 여러개에 프로세스 간 통신(Inter-Process Communication)을 통해 데이터를 처리하는 경우. </li><li>등등…</li></ul><h2 id="멀티-스레드-프로그래밍"><a href="#멀티-스레드-프로그래밍" class="headerlink" title="멀티 스레드 프로그래밍"></a>멀티 스레드 프로그래밍</h2><ul><li>공유 자원(or 메모리)를 여러 개의 스레드가 동시에 프로그래밍을 수행하며 같은 자원에 데이터를 읽고 쓰며 통신하는 것.</li><li>일반적으로 운영체제나 시스템 SW에 사용됐지만 <code>Java</code>의 <code>Monitor</code> 개념에 도입되면서 일반 개발자들도 많이 사용한다.</li><li>멀티스레드 프로그래밍은 오류 없이 설계하기 어렵고 비결정적이며 테스트가 어렵고 버그도 재현이 어려워 디버깅이 거의 불가능하다.</li><li>즉 <code>안정성</code>과 <code>규모가변성</code>이 상충되기 때문에 적절한 프로그래밍을 하는 것이 어렵다.</li></ul><blockquote><p>참고  </p><ul><li>아래부터 언급하는 Process는 해당 개념이 사용되는 영역이 어떤 것이냐에 따라 Thread로 해석할 수 있다.</li><li>ex) OS(ex Linux)에서는 Process 기준, Java에서는 Thread 기준이다.</li></ul></blockquote><h2 id="동기화-Synchronization"><a href="#동기화-Synchronization" class="headerlink" title="동기화(Synchronization)"></a>동기화(Synchronization)</h2><ul><li><code>레이스 컨디션</code> 상황을 막기 위해 프로세스/스레드들에 하나의 자원에 대한 처리 <code>권한</code>을 주거나 <code>순서</code>를 조정해주는 기법이다. </li><li><code>다중 스레드</code> 환경에 공유되는 자원이 있다면 필수적으로 고려해야한다. </li><li>프로세스의 경우 OS 레벨에서 공유 자원 문제를 처리해주지만 한 프로세스 내에서 실행되는 여러 개의 스레드들은 공유 자원에 대해 동기화 문제를 고려해야한다. </li></ul><h3 id="경쟁-상황-레이스-컨디션-Race-Condition"><a href="#경쟁-상황-레이스-컨디션-Race-Condition" class="headerlink" title="경쟁 상황(레이스 컨디션, Race Condition)"></a>경쟁 상황(레이스 컨디션, Race Condition)</h3><ul><li><code>공유 자원</code>에 여러 프로세스/스레드가 동시에 접근하기 위해 <code>경쟁</code>하는 상태를 뜻한다.<ul><li>ex) OS에서 CPU 점유율 등 </li></ul></li><li><code>동기화 처리</code>를 제대로 하지 않으면 의도하지 않은 잘못된 결과가 나올 수 있다. </li></ul><h2 id="임계-영역-Critical-Section"><a href="#임계-영역-Critical-Section" class="headerlink" title="임계 영역(Critical Section)"></a>임계 영역(Critical Section)</h2><ul><li><code>공유 자원</code>에 <code>접근</code>하는 프로세스 내부의 코드 영역.</li><li>한 프로세스의 임계 영역이 수행 중일 때 다른 프로세스가 같은 공유 자원을 사용하는 임계 영역을 수행한다면 문제가 발생할 수 있다.</li><li>따라서 한 번에 한 프로세스만 접근해 사용한다.</li><li>임계 영역을 들어오는 진입 영역(entry section), 나가는 부분인 퇴출 영역(exit section), 나머지 영역(remainder section)으로 구분된다. </li></ul><h2 id="임계-영역의-조건"><a href="#임계-영역의-조건" class="headerlink" title="임계 영역의 조건"></a>임계 영역의 조건</h2><h3 id="상호-배제-Mutual-Exclusion-Mutex"><a href="#상호-배제-Mutual-Exclusion-Mutex" class="headerlink" title="상호 배제(Mutual Exclusion( == Mutex))"></a>상호 배제(Mutual Exclusion( == Mutex))</h3><ul><li>한 프로세스가 자신의 임계 영역 내에서 실행되는 동안, 다른 프로세스가 같은 공유 자원을 사용하는 자신의 임계 영역에서 실행될 수 없는 것.</li></ul><h3 id="진행-Progress"><a href="#진행-Progress" class="headerlink" title="진행 (Progress)"></a>진행 (Progress)</h3><ul><li>임계 영역을 실행 중인 프로세스가 없고 자신의 임계 영역으로 진입하려는 프로세스가 있다면, 나머지 영역에서 실행 중이지 않은 프로세스들만 임계 영역으로 진입하기 위해 요청할 수 있다.</li><li>이는 무기한 연기될 수 없다.</li></ul><h3 id="한정된-대기-Bounded-waiting"><a href="#한정된-대기-Bounded-waiting" class="headerlink" title="한정된 대기 (Bounded waiting)"></a>한정된 대기 (Bounded waiting)</h3><ul><li>프로세스가 자신의 임계 영역에 진입하기 위해 요청을 한 뒤, 그 요청이 허가될 때까지 다른 프로세스들이 자신의 임계 영역에 진입하도록 허용하는 횟수의 제한이 있어야한다. </li></ul><h2 id="임계-영역-해결-방안-동기화"><a href="#임계-영역-해결-방안-동기화" class="headerlink" title="임계 영역 해결 방안(동기화)"></a>임계 영역 해결 방안(동기화)</h2><ul><li>하드웨어 기반 동기화와 소프트웨어 기반 동기화로 나뉜다.</li><li>대표적인 소프트웨어 기반 동기화 기법으로 상호 배제(<code>Mutex</code>), 세마포어(<code>Semaphore</code>), 모니터(<code>Monitor</code>) 등이 있다.</li></ul><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://skyul.tistory.com/327" target="_blank" rel="noopener">소프트웨어 트랜잭션 메모리와 하스켈</a></li><li><a href="https://tiredsleeper.tistory.com/32?category=779575" target="_blank" rel="noopener">프로세스 동기화의 필요성, 임계 영역</a></li><li><a href="https://12bme.tistory.com/68" target="_blank" rel="noopener">멀티 스레드와 동기화</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;병렬 프로그래밍에서 임계영역 까지의 흐름을 정리해보았다. &lt;/p&gt;
&lt;h2 id=&quot;병렬-프로그래밍-Parallel-Programming&quot;&gt;&lt;a href=&quot;#병렬-프로그래밍-Parallel-Programming&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="CS" scheme="https://kodakyung.github.io/categories/cs/"/>
    
      <category term="OS" scheme="https://kodakyung.github.io/categories/cs/os/"/>
    
    
      <category term="OS" scheme="https://kodakyung.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-ReactJS 프로젝트에서 OAuth 소셜 로그인 구현 중 마주친 CORS 문제</title>
    <link href="https://kodakyung.github.io/2019/06/16/troubleshooting-2019-06-16-springboot-react-cors/"/>
    <id>https://kodakyung.github.io/2019/06/16/troubleshooting-2019-06-16-springboot-react-cors/</id>
    <published>2019-06-15T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.717Z</updated>
    
    <content type="html"><![CDATA[<p><code>SpringBoot</code> 프로젝트에 <code>OAuth2</code> 소셜 로그인을 구현하는 프로젝트에서 발생한 문제이다. 작은 규모의 프로젝트였기 때문에 SpringBoot와 View단의 <code>ReactJS</code>를 따로 호스팅하지 않고 SpringBoot의 정적 리소스에 React Build 파일을 포함해 배포를 하였다. 여기서 React에서 Login API를 호출하는데 CORS 에러가 발생하였다.</p><h3 id="CORS란"><a href="#CORS란" class="headerlink" title="CORS란?"></a>CORS란?</h3><blockquote><p>Cross Origin Resource Sharing의 약자로 현재 웹페이지가 이 페이지를 받은 서버가 아닌 다른 서버의 리소스를 호출하는 것을 의미한다.</p></blockquote><p>우선 OAuth 로그인 프로세스를 살펴보면 여러가지 승인 타입이 있는데 이 중 <code>권한 부여 코드 승인 타입(Authorization Code Grant Type)</code>을 이용해 로그인을 구현하였다. 페이스북이나 구글, 카카오 등에서 위 타입의 방식으로 웹 서버 클라이언트를 지원한다.</p><h3 id="권한-부여-코드-승인-타입-Authorization-Code-Grant-Type"><a href="#권한-부여-코드-승인-타입-Authorization-Code-Grant-Type" class="headerlink" title="권한 부여 코드 승인 타입(Authorization Code Grant Type)"></a>권한 부여 코드 승인 타입(Authorization Code Grant Type)</h3><p><img src="/images/2019-06-16/auth_code_flow.png" alt="authorization-code-grant-type"></p><blockquote><p><a href="http://www.bubblecode.net/en/2016/01/22/understanding-oauth2/" target="_blank" rel="noopener">이미지 출처</a></p></blockquote><p>인증 과정을 살펴보면 처음에 <code>client</code>가 <code>Authorization Code Request</code>를 한뒤 <code>Authorization Server</code>에서 <code>client_id</code>와 <code>redirect_uri</code>, <code>response_type</code>을 확인한 뒤 <code>Resource Owner</code>가 로그인할 수 있도록 한다. 이후 <code>Resource Owner</code>가 로그인을 하면 뒤의 인증과정이 더 이루어지는 것이다.</p><p>여기서 <code>Authorization Server</code> 즉 소셜로그인을 하려는 대상인 서버(현 프로젝트에서는 Google)에서 필요한 조건들을 확인한 뒤 <code>Login</code>창으로 <code>Redirect</code>를 해주는데 현 프로젝트에서 <code>CORS</code> 에러가 발생한 부분이 이 부분이었다.<br>즉 처음 <code>Request</code>를 보내고 정상적으로 동작한다면 <code>302</code> code를 받고 로그인 창으로 이동하고, 유저가 로그인을 하면 내부적으로 인증 과정이 동작해야하는데 <code>302</code> 코드가 아닌 <code>405</code> 코드를 반환하면서 에러가 발생했다.</p><ul><li>302, 405 Status Code</li></ul><blockquote><p>3으로 시작하는 코드는 Redirection을 의미한다. 그 중 302는 Found로 리퀘스트된 리소스에 새로운 URI가 할당되어 있고 그 URI를 참조하라는 의미이다. 301,302,303 코드가 되돌아오면 대부분 브라우저에서는 POST를 GET으로 바꾸어 리퀘스트의 엔티티 바디를 삭제하고 리퀘스트를 자동적으로 재송신하도록 되어있다.</p></blockquote><blockquote><p>405 코드는 Method Not Allowed. 허용되지 않은 메소드를 호출한 것을 의미한다.</p></blockquote><h2 id="Error-Message"><a href="#Error-Message" class="headerlink" title="Error Message"></a>Error Message</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.</span><br><span class="line">&gt; OPTIONS https://LOGIN-ENDPOINT/login&amp;response_type=code&amp;scope=email%20profile&amp;state=6Zy6nR 405</span><br><span class="line"></span><br><span class="line">Access to XMLHttpRequest at &apos;https://accounts.google.com/o/oauth2/v2/auth?client_id=CLIENT_ID_VALUE&amp;redirect_uri=http://LOGIN-ENDPOINT/login&amp;response_type=code&amp;scope=email%20profile&amp;state=6Zy6nR&apos; from origin &apos;https://REQUESTER&apos; has been blocked by CORS policy: Response to preflight request doesn&apos;t pass access control check: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource.</span><br></pre></td></tr></table></figure><p>처음에 뜬 에러는 이 메세지가 아닐수도 있다. 어느 쪽 코드가 잘못된 것인지 많은 경우의 수가 있어서 Front 코드 하나 Server 코드 하나하나 수정해가면서 서버에 배포해서 확인하느라 하나하나 기록하지는 못했다. 우선 트러블슈팅 후반부(?)에 계속 참고한 에러 메세지는 이것이었다.<br>(이외에도 request시 origin이 null이 된다는 등 다양한 에러가 계속 발생했었다.)</p><h2 id="Troubleshooting"><a href="#Troubleshooting" class="headerlink" title="Troubleshooting"></a>Troubleshooting</h2><p>우선 서버에 문제가 있나 확인하기 위해서 <code>curl</code> 명령어로 확인을 해보았다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl \                                     </span><br><span class="line">  --verbose \</span><br><span class="line">  --request GET \</span><br><span class="line">  &apos;https://LOGIN-ENDPOINT/login&apos; \</span><br><span class="line">  --header &apos;Origin: http://REQUESTER&apos; \</span><br><span class="line">  --header &apos;Access-Control-Request-Headers: Origin, Accept, Content-Type&apos; \</span><br><span class="line">  --header &apos;Access-Control-Request-Method: GET&apos;</span><br></pre></td></tr></table></figure><p>curl에서는 정상적으로 <code>302</code> 코드를 반환하였다. 즉 서버의 문제가 아닌 <code>React</code>와 합쳐서 배포하는 과정에서 생긴 이슈인 것을 알았다.</p><hr><ul><li><p>CORS 동작과정 (<a href="https://www.popit.kr/corss-domain-api-서버-구성/" target="_blank" rel="noopener">참고링크</a>)</p><ul><li>브라우저는 다른 도메인으로 Ajax 등의 호출을 보내기 전에 다음과 같은 순서로 동작합니다.  </li></ul><ol><li>“preflight” 확인 요청을 OPTIONS method로 전송(요청 시 Http Header의 속성으로 “Origin”에 자신의 도메인을 전송) </li><li>이 요청을 받은 서버는 정상적인 요청인지 확인하여, 정상적인 요청이면 Response에 허용 가능한 도메인(Access-Control-Allow-Origin), Method(Access-Control-Allow-Methods), Header 속성(Access-Control-Allow-Headers) 등을 설정하여 응답  </li><li>OPTIONS 요청에 대해 수신을 받은 브라우저는 Header의 “Access-Control-Allow-*” 정보를 이용하여 요청을 보낼 수 있는지 판단하여 권한이 없는 경우 위와 같은 에러 처리를 하고 요청을 보낼 수 있으면 요청 전송</li></ol></li></ul><hr><p>위 에러 메세지를 기반으로 여러가지를 찾아봤는데 초기에는 Front 쪽에서 API를 호출할 때 Header에 CORS 허용을 하지 않아서(<code>Access-Control-Allow-Origin</code> 설정) 많은 시간을 허비했다. 하지만 이 이후에도 CORS 에러가 해결되지 않았다. 그리고 위 링크에서 Spring을 사용하는 경우 <code>@CrossOrigin</code> 어노테이션으로 쉽게 해결할 수 있다 했지만 OAuth Social Login Endpoint의 경우 <strong>컨트롤러를 직접 만드는 것이 아니기 때문에 위 문제로 해결할 수 없었다.</strong><br>(login / logout endpoint외에는 전부 Controller로 작성했기 때문에 CORS 관련 Config 설정을 하기 전에 임시로 @CrossOrigin 어노테이션을 붙여뒀다. 이 어노테이션을 붙이는 경우 Front에서 <code>Access-Control-Allow-Origin</code> 설정을 하지 않아도 API 호출에 CORS 에러가 발생하지 않는다. 이 부분 때문에 좀 더 헷갈렸던 것도 있다.)</p><p><code>405</code>를 반환한다는 것은 허용되지 않은 메소드를 호출했다는 것인데 그래서 이후에는 <code>preflight</code> 확인 요청을 <code>OPTIONS method</code>로 보내는 과정에 문제가 있는지 찾아보았다.</p><p>이 <a href="https://oddpoet.net/blog/2017/04/27/cors-with-spring-security/" target="_blank" rel="noopener">링크</a>를 참고해서 <code>Spring Security Config</code>에 <code>PreFlightRequest</code>를 허용해주었지만 이 코드도 동작하지 않았다.</p><p>혹시나해서 Front쪽에서 <code>axios</code>가 아닌 <code>XMLHttpRequest</code>를 직접 사용해봤지만 새로운 에러만 발생했다. </p><blockquote><p>찾아본 바로는 오히려 OAuth 기반 서비스는 XHR이나 Fetch API를 사용하면 안된다고 한다.</p></blockquote><p><code>Spring Security Config</code>에 <code>OPTIONS</code>를 전부 허용하고(permitAll), <code>CORS Filter</code>를 인증 필터 제일 앞단에 위치하도록 코드도 작성했지만 이 문제도 실패했다.</p><p>이쯤 되니 혹시 배포 서버에 설정한 <code>Reverse Proxy Server</code>의 <code>Nginx</code> 설정이 문제일까 의심이 들어서 설정을 몇개 수정해보았지만 감이 잡히지 않았다. (<a href="http://oskarhane.com/avoid-cors-with-nginx-proxy_pass/" target="_blank" rel="noopener">Avoid cors with nginx proxy pass 참고</a>) (Nginx 설정은 지정한 도메인으로 http나 https 요청이 들어오면 https를 가리키도록 하는 것이 다였다.)</p><p>아무리 생각해도 코드 레벨에서 서버에서 할 수 있는 모든 설정을 다 한 것 같았다. 처음 <code>get</code>으로 login uri를 호출할 때는 Server 기준에서 호출하는데 이후 302 코드를 받고 자동으로 다시 리다이렉트 uri를 호출하는 과정에 Front 기준으로 호출해서 이런 에러가 발생한 것 같았다.</p><p>이후 찾아본 <a href="https://stackoverflow.com/questions/45602875/trying-to-redirect-client-to-google-oauth-getting-405-error" target="_blank" rel="noopener">StackOverFlow 링크</a>에서 힌트를 얻었다.</p><p>3xx의 상태코드를 받으면 브라우저가 자동으로 클라이언트를 대신해 반환된 위치로 <code>get</code> 요청을 보내는데 이를 Front에서 캐치해서 수동으로 redirection을 하라는 답변이었다.<br>여기에 힌트를 얻어서 Front에서 <code>window.locaion</code>으로 새창을 띄워 login api를 호출하니 자동으로 redirect되며 문제가 해결되었다. 새로 띄운 창에서는 Front 코드의 영향을 받지 않아서 Server의 설정대로 잘 동작을 한 것 같다. </p><h2 id="마치며"><a href="#마치며" class="headerlink" title="마치며"></a>마치며</h2><p>이번 프로젝트로 <code>CORS</code>의 동작방식과 <code>OPTIONS</code> 메소드와 <code>preflight</code>에 대해 많이 알게되었다. <del>지금 해결한 방식이 완벽한 해결방식은 아니고 우회한 방법에 가깝다고 생각하지만 현재로써는 이 이상 해결하긴 어려울 것 같다.</del> (2019.9 - CORS로 시작했지만 결과적으로 <strong>인증</strong>의 문제였던 것 같다.) 그리고 아예 MSA로 분리하면 분리했지 애매하게 붙여서 배포하는 것이 에러가 발생했을 때 더 확인하기 어렵다는 것을 알았다. Front와 Server를 분리해서 개발하면서 배포는 함께 하니까 이렇게 <em>배포했을 때 어느 부분에서 에러가 발생했는지 조차 모르는 경우 에러를 추적하기가 어려웠다.</em>   </p><p>팀원과 함께 오류를 찾으며 느낀 것은 <em>내가 개발한/맡은 부분이 잘못되었을 수 있다는 생각을 갖는게 중요하다는 점이었다.</em> 만약 나 또는 상대 개발자가 서로 자신의 코드가 잘못되었을 수 있다는 가정을 하지 않았다면 이 문제를 해결하는데 더 오래걸렸을 것 같다. 이전 프로젝트에서도 자신의 코드가 무조건 옳다고 주장해서 팀원의 코드를 전부 뜯어보느라 해결하는데 오래 걸린 경우가 있었다.<br>알고있는 분야가 서로 다르므로 서로 열린 마음으로 자신이 아는 부분, 고민하는 부분을 함께 교류하고 소통해야한다고 생각한다. 그리고 그렇게해서 이 문제를 해결할 수 있었던 것 같다. 개발자로써 좀 더 상대방과 소통할 수 있는 개발자가 되어야겠다는 생각이 든다. </p><h3 id="참고한-링크들"><a href="#참고한-링크들" class="headerlink" title="참고한 링크들"></a>참고한 링크들</h3><ul><li><a href="https://www.popit.kr/corss-domain-api-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%84%B1/" target="_blank" rel="noopener">https://www.popit.kr/corss-domain-api-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%84%B1/</a></li><li><a href="https://oddpoet.net/blog/2017/04/27/cors-with-spring-security/" target="_blank" rel="noopener">https://oddpoet.net/blog/2017/04/27/cors-with-spring-security/</a></li><li><a href="https://www.popit.kr/cors-preflight-인증-처리-관련-삽질/" target="_blank" rel="noopener">https://www.popit.kr/cors-preflight-인증-처리-관련-삽질/</a></li><li><a href="https://homoefficio.github.io/2015/07/21/Cross-Origin-Resource-Sharing/" target="_blank" rel="noopener">https://homoefficio.github.io/2015/07/21/Cross-Origin-Resource-Sharing/</a></li><li><a href="https://medium.com/@muiruri/spring-oauth2-and-cors-configuration-3529337525b4" target="_blank" rel="noopener">https://medium.com/@muiruri/spring-oauth2-and-cors-configuration-3529337525b4</a></li><li><a href="http://oskarhane.com/avoid-cors-with-nginx-proxy_pass/" target="_blank" rel="noopener">http://oskarhane.com/avoid-cors-with-nginx-proxy_pass/</a></li><li><a href="https://stackoverflow.com/questions/45602875/trying-to-redirect-client-to-google-oauth-getting-405-error" target="_blank" rel="noopener">https://stackoverflow.com/questions/45602875/trying-to-redirect-client-to-google-oauth-getting-405-error</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;SpringBoot&lt;/code&gt; 프로젝트에 &lt;code&gt;OAuth2&lt;/code&gt; 소셜 로그인을 구현하는 프로젝트에서 발생한 문제이다. 작은 규모의 프로젝트였기 때문에 SpringBoot와 View단의 &lt;code&gt;ReactJS&lt;/code&gt;
      
    
    </summary>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/categories/troubleshooting/"/>
    
    
      <category term="SpringBoot" scheme="https://kodakyung.github.io/tags/springboot/"/>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/tags/troubleshooting/"/>
    
      <category term="ReactJS" scheme="https://kodakyung.github.io/tags/reactjs/"/>
    
      <category term="OAuth2" scheme="https://kodakyung.github.io/tags/oauth2/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ에서 SpringBoot DevTools 사용하기</title>
    <link href="https://kodakyung.github.io/2019/06/11/server-spring-2019-06-11-intellij-devtools/"/>
    <id>https://kodakyung.github.io/2019/06/11/server-spring-2019-06-11-intellij-devtools/</id>
    <published>2019-06-10T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.692Z</updated>
    
    <content type="html"><![CDATA[<p>SpringBoot의 경우 정적 리소스(html,css,js 등)들을 <code>resource</code> 폴더 하위에서 관리하기 때문에 정적 리소스를 갱신하기 위해 <code>Tomcat</code>을 재시작해야한다.</p><p><code>DevTools</code> 를 사용하면 자동으로 정적 리소스를 <code>reload</code> 할 수 있게 된다.</p><p>하지만 IntelliJ에서 사용시 DevTools을 추가해도 적용이 안되는 경우가 있다.</p><blockquote><p>intellij devtools not working</p></blockquote><p>이 때 IntelliJ에서 추가적인 설정을 해주어야 한다.</p><ul><li>IntelliJ에서 DevTool 사용하기</li></ul><p><img src="/images/2019-06-11/intellij-devtools1.png" alt="devtools1"></p><ul><li><code>cmd + shift + a</code> : <code>registry</code> 검색</li></ul><p><img src="/images/2019-06-11/intellij-devtools2.png" alt="devtools2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SpringBoot의 경우 정적 리소스(html,css,js 등)들을 &lt;code&gt;resource&lt;/code&gt; 폴더 하위에서 관리하기 때문에 정적 리소스를 갱신하기 위해 &lt;code&gt;Tomcat&lt;/code&gt;을 재시작해야한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Spring" scheme="https://kodakyung.github.io/categories/server/spring/"/>
    
    
      <category term="SpringBoot" scheme="https://kodakyung.github.io/tags/springboot/"/>
    
      <category term="IntelliJ" scheme="https://kodakyung.github.io/tags/intellij/"/>
    
  </entry>
  
  <entry>
    <title>Java - Use overloading judiciously</title>
    <link href="https://kodakyung.github.io/2019/04/18/programming-java-effective-java-2019-04-18-java-use-overloading-judiciously/"/>
    <id>https://kodakyung.github.io/2019/04/18/programming-java-effective-java-2019-04-18-java-use-overloading-judiciously/</id>
    <published>2019-04-17T15:00:00.000Z</published>
    <updated>2020-03-19T01:05:56.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-52"><a href="#Effective-Java-Item-52" class="headerlink" title="Effective Java Item 52"></a>Effective Java Item 52</h2><blockquote><p>다중정의(Overloading)는 신중히 사용하라</p></blockquote><h3 id="Overriding-VS-Overloading"><a href="#Overriding-VS-Overloading" class="headerlink" title="Overriding VS Overloading"></a>Overriding VS Overloading</h3><ul><li><code>Overriding</code>한 메소드는 <code>동적</code>으로 선택되고, <code>Overloading</code>한 메소드는 <code>정적</code>으로 선택된다.</li><li>따라서 <code>Overloading</code>의 경우 <strong>해당 객체의  타입</strong>이 어떤 메소드를 호출할지 <strong>기준</strong>이 된다.</li></ul><h4 id="Overriding-예"><a href="#Overriding-예" class="headerlink" title="Overriding 예"></a>Overriding 예</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class Wine &#123;</span><br><span class="line">  <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"포도주"</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Class SparklingWine extends Wine &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"발포성 포도주"</span>&#125;; <span class="comment">// Overriding</span></span><br><span class="line">&#125;</span><br><span class="line">Class Champagne extends SparklingWine &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function">String <span class="title">name</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"샴페인"</span>&#125;; <span class="comment">// Overriding</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class Overriding &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Wine&gt; wineList = List.of(</span><br><span class="line">      <span class="keyword">new</span> Wine(), <span class="keyword">new</span> SparklingWine(), <span class="keyword">new</span> Champagne());</span><br><span class="line">    <span class="keyword">for</span>(Wine wine : wineList)</span><br><span class="line">      System.out.println(wine.name()); <span class="comment">// Overriding한 메소드 호출</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/WegraLee/effective-java-3e-source-code/tree/master/src/effectivejava/chapter8/item52" target="_blank" rel="noopener">출처</a></p></blockquote><ul><li>기대한 대로 “포도주, “발포성 포도주”, “샴페인”순으로 출력된다.</li><li>가장 하위에 정의한 재정의 메소드가 실행되기 때문</li></ul><h4 id="Overloading-예"><a href="#Overloading-예" class="headerlink" title="Overloading 예"></a>Overloading 예</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionClassifier</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Set&lt;?&gt; s)</span></span>&#123; <span class="comment">// Overloading</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"집합"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(List&lt;?&gt; list)</span></span>&#123; <span class="comment">// Overloading</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"리스트"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">classify</span><span class="params">(Collection&lt;?&gt; c)</span></span>&#123; <span class="comment">// Overloading</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"그 외"</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Collection&lt;?&gt;[] collections = &#123;</span><br><span class="line">      <span class="keyword">new</span> HashSet&lt;String&gt;(),</span><br><span class="line">      <span class="keyword">new</span> ArrayList&lt;BigInteger&gt;(),</span><br><span class="line">      <span class="keyword">new</span> HashMap&lt;String, String&gt;().values()</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Collection&lt;?&gt; c : collections)</span><br><span class="line">      System.out.println(classify(c)); <span class="comment">// Overloading한 메소드 호출</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/WegraLee/effective-java-3e-source-code/tree/master/src/effectivejava/chapter8/item52" target="_blank" rel="noopener">출처</a></p></blockquote><ul><li>예상과는 다르게 “그 외”를 3회 출력한다.</li><li><code>Overloading</code>은 <strong>컴파일 타임</strong>에 <strong>타입</strong>이 결정되기 때문이다.</li><li>해당 코드에서는 컴파일 타임에 항상 <code>Collection&lt;?&gt;</code> 타입으로 받아 <code>Overloading</code>에 영향을 주지 못했다.</li></ul><h3 id="다중정의-Overloading-시-주의할-점"><a href="#다중정의-Overloading-시-주의할-점" class="headerlink" title="다중정의(Overloading)시 주의할 점"></a>다중정의(Overloading)시 주의할 점</h3><ul><li><code>일반적으로 프로그래머가 기대하는 코드</code>와 <code>다른 결과</code>를 보여주는 헷갈릴 수 있는 코드는 작성하지 않는 것이 좋다.</li><li>특히 공개 API의 경우 사용자가 매개변수를 넘길때 어떤 <code>다중정의된 메소드</code>가 동작할지 <code>예측</code>되지 않는다면 더 좋지 않다.</li><li>서로 다른 <code>함수형 인터페이스라</code>도 <code>같은 위치의 인수</code>로 받아선 안된다. </li></ul><h3 id="그나마-안전하게-다중정의-Overloading-하려면"><a href="#그나마-안전하게-다중정의-Overloading-하려면" class="headerlink" title="그나마 안전하게 다중정의(Overloading) 하려면"></a>그나마 안전하게 다중정의(Overloading) 하려면</h3><ol><li><code>매개변수 수</code>가 같은 다중정의를 가급적 피한다.</li><li><code>가변인수</code>를 사용하는 메소드는 절대 다중정의하지 않는다.<ul><li>아이템 53</li></ul></li><li>다중정의 대신 <code>메소드 이름</code>을 다르게 지어준다.<ul><li>ex) <code>ObjectOutputStream</code> Class의 <code>write</code> 메소드 들 &gt; <code>writeBoolean(boolean)</code>, <code>writeInt(int)</code>, …</li></ul></li><li>1~3을 지키기 어려운 <code>생성자</code>의 경우 매개변수를 형변환해 정확한 메소드가 선택되도록 한다.</li><li><code>매개변수 수</code>가 같은 다중정의 메소드가 많은 경우 그 매개변수 중 하나 이상이 “근본적으로 다르다(radically different)”면 괜찮다.<ul><li>“근본적으로 다르다”는 “두 타입이 (null 제외) 서로 어느 쪽으로도 형변환할 수 없다는 뜻”</li></ul></li><li>5가 되지 않는다면 <code>같은 객체</code>를 <code>입력</code>받는 <code>다중 메소드</code>가 모두 <code>같은 동작</code>을 하도록한다.<ul><li>ex) 기존 클래스를 수정해 새로운 Interface를 implements 하는 경우<ul><li>기존에 있던 String 클래스에 <code>CharSequence</code> 인터페이스 등장 후 기존에 있던 <code>contentEquals(StringBuffer)</code> 메소드가 <code>contentEquals(CharSequence)</code>로 다중 정의 되었지만 같은 동작을 하기 때문에 사용자 입장에서 문제가 없다. </li></ul></li></ul></li><li>서로 다른 <code>함수형 인터페이스</code>라도 같은 위치의 인수로 받지 않는다.</li></ol><h3 id="생성자-다중정의-Overloading"><a href="#생성자-다중정의-Overloading" class="headerlink" title="생성자 다중정의(Overloading)"></a>생성자 다중정의(Overloading)</h3><ul><li>생성자는 이름을 다르게 지을 수 없기 때문에 위의 1~3 규칙을 적용하기 어렵다.</li><li>이때는 <code>정적 팩터리</code>를 사용한다.</li><li>그래도 생성자는 재정의가 안되기 때문에 다중정의와 혼용될 가능성은 적다.</li><li>5의 규칙을 따라서 다중정의 한다면 다중정의 메소드 중 어떤 메소드를 선택해 호출할 지 매개변수의 런타임 타입으로 결정된다. </li></ul><h3 id="함수형-인터페이스의-다중정의"><a href="#함수형-인터페이스의-다중정의" class="headerlink" title="함수형 인터페이스의 다중정의"></a>함수형 인터페이스의 다중정의</h3><ul><li>“<code>암시적 타입 람다식</code>이나 <code>부정확한 메소드 참조</code> 같은 표현식은 목표 타입이 선택되기 전까지 의미가 정해지지 않기 때문에 적용성 테스트 때 무시된다.” 고 책에서 말한다.<ul><li>부정확한 메소드 참조 타입이란 메소드와 인자 모두 다중 정의된 경우를 뜻한다. </li></ul></li><li>말이 어려운데, 간단히 말하자면 정확한 타입이 정해지기 전까지는 의도한대로 동작하지 않는다는 말이다.</li><li>따라서 <code>함수형 인터페이스</code>는 서로 다른 타입이어도 결과적으로 Overloading 때 같은 타입으로 인식한다. </li></ul><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><ul><li>다중정의된 메소드 중 하나를 선택하는 규칙은 복잡하기 때문에 프로그래머가 모두 알고 프로그래밍하기는 어렵다. </li><li>따라서 매개변수가 같을 때는 가급적 다중정의를 피하거나 그것이 안된다면 안전하게 다중정의하는 규칙을 따라 만드는 것이 좋다.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Effective Java (3rd Edition)</li><li><a href="https://jeong-pro.tistory.com/148" target="_blank" rel="noopener">JVM 구조와 자바 런타임 메모리 구조</a></li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-52&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-52&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 52&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Design method signatures carefully</title>
    <link href="https://kodakyung.github.io/2019/04/17/programming-java-effective-java-2019-04-17-java-design-method-signatures-carefully/"/>
    <id>https://kodakyung.github.io/2019/04/17/programming-java-effective-java-2019-04-17-java-design-method-signatures-carefully/</id>
    <published>2019-04-16T15:00:00.000Z</published>
    <updated>2020-03-19T01:05:50.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-51"><a href="#Effective-Java-Item-51" class="headerlink" title="Effective Java Item 51"></a>Effective Java Item 51</h2><blockquote><p>메서드 시그니처를 신중히 설계하라</p></blockquote><h2 id="API-설계-요령"><a href="#API-설계-요령" class="headerlink" title="API 설계 요령"></a>API 설계 요령</h2><h3 id="1-메서드-이름을-신중히"><a href="#1-메서드-이름을-신중히" class="headerlink" title="1. 메서드 이름을 신중히"></a>1. 메서드 이름을 신중히</h3><ul><li>표준 명명 규칙을 따른다<ul><li>E.J의 아이템 68 참고</li></ul></li></ul><h3 id="2-지나친-편의-메서드-남발-금물"><a href="#2-지나친-편의-메서드-남발-금물" class="headerlink" title="2. 지나친 편의 메서드 남발 금물"></a>2. 지나친 편의 메서드 남발 금물</h3><ul><li>아주 자주 쓰일 때만 별도의 편의 메서드로 작성한다.<ul><li>이 부분에 관점에 따라 상충되는 듯하다. </li><li>예를 들면 박재성(자바지기)님의 경우 Test를 위해 가급적 메소드를 잘게 쪼개는 것을 추천한다. 즉 한번에 한가지 기능만 갖고 있는 원자성을 띄는 메소드를 작성하는걸 추천한다. </li><li>이 책의 저자는 메소드가 너무 많은 경우 클래스를 익히고 사용하는게 어렵기 때문에 추천하지 않는다고 한다.</li><li><del>알아서 걸러듣자..</del></li></ul></li></ul><h3 id="3-매개변수-목록은-가능한-짧게"><a href="#3-매개변수-목록은-가능한-짧게" class="headerlink" title="3. 매개변수 목록은 가능한 짧게"></a>3. 매개변수 목록은 가능한 짧게</h3><ul><li>4개 이하가 좋다고 한다.</li><li>특히 같은 타입의 매개변수가 여러개 나오는 경우가 좋지 않은 경우다. 왜냐하면 실수로 순서를 바꿔 입력해도 컴파일러가 눈치채지 못하기 때문.</li></ul><h3 id="4-매개변수-타입은-클래스보단-인터페이스로"><a href="#4-매개변수-타입은-클래스보단-인터페이스로" class="headerlink" title="4. 매개변수 타입은 클래스보단 인터페이스로"></a>4. 매개변수 타입은 클래스보단 인터페이스로</h3><ul><li>아이템 64</li><li>클래스를 인자로 받는다면 매개변수를 특정 구현체로 한정하기 때문에 좋지 않다.</li></ul><h3 id="5-Boolean-보다-원소-2개인-Enum-타입으로"><a href="#5-Boolean-보다-원소-2개인-Enum-타입으로" class="headerlink" title="5. Boolean 보다 원소 2개인 Enum 타입으로"></a>5. Boolean 보다 원소 2개인 Enum 타입으로</h3><ul><li>의미상 Boolean이 더 나은경우가 아니라면 열거체를 사용하는게 좋다.</li><li>왜냐하면 코드상 의미가 더 명확하기 때문</li><li>또한 개별 열거타입별 의존성을 추가해주기도 좋다. (열거타입 내부 메소드로)</li></ul><br><h3 id="긴-매개변수를-짧게-줄이는-기술들"><a href="#긴-매개변수를-짧게-줄이는-기술들" class="headerlink" title="긴 매개변수를 짧게 줄이는 기술들"></a>긴 매개변수를 짧게 줄이는 기술들</h3><h4 id="1-여러-메서드로-쪼갠다"><a href="#1-여러-메서드로-쪼갠다" class="headerlink" title="1. 여러 메서드로 쪼갠다."></a>1. 여러 메서드로 쪼갠다.</h4><ul><li>API 설계 요령 2번과 상충되는 것 같지만, API를 공통점이 없는 기능으로 잘 분리한다면 결과적으로 매개변수의 길이가 줄어들 수 있다.</li><li>잘게 쪼개둘수록 여러가지로 조합할 수 있기 때문</li></ul><h4 id="2-도우미-클래스를-만든다"><a href="#2-도우미-클래스를-만든다" class="headerlink" title="2. 도우미 클래스를 만든다."></a>2. 도우미 클래스를 만든다.</h4><ul><li>매개변수 여러개를 묶는 도우미 클래스를 만든다.</li><li>매개변수 몇 개를 독립된 하나의 단위로 볼 수 있는 경우</li><li>ex) 카드게임에서 카드를 의미하는 부분</li></ul><h4 id="3-메서드에-빌더-Builder-패턴을-응용한다"><a href="#3-메서드에-빌더-Builder-패턴을-응용한다" class="headerlink" title="3. 메서드에 빌더(Builder)패턴을 응용한다."></a>3. 메서드에 빌더(Builder)패턴을 응용한다.</h4><ul><li>매개변수가 많은데, 그 중 일부는 생략해도 되는 경우 도움이 된다.</li></ul><br><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Effective Java (3rd Edition)</li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-51&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-51&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 51&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Make defensive copies when needed</title>
    <link href="https://kodakyung.github.io/2019/04/10/programming-java-effective-java-2019-04-10-java-make-defensive-copies-when-needed/"/>
    <id>https://kodakyung.github.io/2019/04/10/programming-java-effective-java-2019-04-10-java-make-defensive-copies-when-needed/</id>
    <published>2019-04-09T15:00:00.000Z</published>
    <updated>2020-03-19T01:05:44.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-50"><a href="#Effective-Java-Item-50" class="headerlink" title="Effective Java Item 50"></a>Effective Java Item 50</h2><blockquote><p>적시에 방어적 복사본을 만들라</p></blockquote><ul><li>자바는 비교적 안전한 언어이지만, <code>불변식</code>이 깨질 수 있다는 가정하에 최대한 방어적으로 프로그래밍해야한다. </li><li>어떤 객체든 허락없이 외부에서 내부를 수정하는 일은 불가해야한다. </li><li>가변 타입으로 작성된 코드도 불변식을 깨지지 않게 하기 위해 필요하다.</li><li>자기 자신 외에는 가변 필드에 접근할 수 없도록해야 완벽한 캡슐화이다.</li></ul><h3 id="가변-매개변수를-받는-경우"><a href="#가변-매개변수를-받는-경우" class="headerlink" title="가변 매개변수를 받는 경우"></a>가변 매개변수를 받는 경우</h3><ul><li>책의 <a href="https://github.com/WegraLee/effective-java-3e-source-code/blob/master/src/effectivejava/chapter8/item50/Period.java#L15" target="_blank" rel="noopener">Period</a> 객체를 보면 불변 같아 보이지만 생성자로 받는 <code>Date</code>가 가변이기 때문에 불변식이 깨진다.</li><li>불변식을 유지하기 위해 간단하게는 대신할 수 있는 <code>불변 아이템</code>을 사용하거나 가변 매개변수를 각각 <code>방어적으로 복사</code>해야한다.</li></ul><h4 id="방어적-복사-defensive-copy"><a href="#방어적-복사-defensive-copy" class="headerlink" title="방어적 복사(defensive copy)"></a>방어적 복사(defensive copy)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Period</span><span class="params">(Date start, Date end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 생성자에서 방어적 복사 수행</span></span><br><span class="line">    <span class="comment">// 가변 인자를 받아서 새 객체를 생성해 복사한다.</span></span><br><span class="line">    <span class="keyword">this</span>.start = <span class="keyword">new</span> Date(start.getTime()); </span><br><span class="line">    <span class="keyword">this</span>.end = <span class="keyword">new</span> Date(end.getTime());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 방어적 복사를 진행한 뒤 유효성을 검사한다.</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.start.compareTo(<span class="keyword">this</span>.end) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="keyword">this</span>.start + <span class="string">" after "</span> + <span class="keyword">this</span>.end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>반드시 매개변수 유효성 검사를 하기 전에 방어적 복사를 해야한다. </li><li>TOCTOU(time-of-check/time-of-use) 공격. 즉, 유효성 검사 후 복사를 실행하는 사이에 원본 객체가 수정될 위험이 있기 때문이다.</li><li>생성자 뿐만 아니라 접근자(setter)에서도 Date 객체를 반환한다면 공격당할 수 있기 때문에 setter에서도 방어적 복사를 해주는 것이 좋다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 접근자에서 방어적 복사 수행</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date(start.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="clone-사용-여부"><a href="#clone-사용-여부" class="headerlink" title="clone 사용 여부"></a>clone 사용 여부</h4><ul><li>매개 변수가 불변 객체가 아닐 경우 방어적 복사본을 만드는 데 <code>clone</code>을 사용하면 안된다.</li><li>악의 적인 하위 클래스가 clone을 정의한 경우 공격받을 수 있기 때문이다.</li><li>그 외에도 Item13의 이유로 clone 사용을 지양하는 것이 좋다. </li></ul><h3 id="그래서-방어적복사를-언제-해야하는데"><a href="#그래서-방어적복사를-언제-해야하는데" class="headerlink" title="그래서 방어적복사를 언제 해야하는데?"></a>그래서 방어적복사를 언제 해야하는데?</h3><ul><li>메서드나 생성자나 클라이언트가 제공한 객체의 참조를 내부에 저장하는 경우 객체가 변경될 가능성이 있는지 생각해야한다.</li><li>변경될 수 있는 객체라면 변경된 후 클래스가 문제 없이 동작할지 고려해본다.</li><li>이 때 확신할 수 없다면 복사본을 만들어 저장해라</li><li>반대로 내부 객체를 외부에 전달할 때 안심할 수 없다면 방어적 복사를 해야한다. </li><li>내부에서 사용하는 배열을 외부에 반환할 때는 항상 방어적 복사를 해라.(Item15 참고)</li></ul><h3 id="방어적-복사를-생략하는-경우"><a href="#방어적-복사를-생략하는-경우" class="headerlink" title="방어적 복사를 생략하는 경우"></a>방어적 복사를 생략하는 경우</h3><ul><li>해당 클래스와 클라이언트가 상호 신뢰할 수 있을 때<ul><li>통제권을 이전하기 위한 메서드나 생성자의 경우 호출 후 더이상 객체를 직접 수정하지 않는다고 문서에 명시한다.</li></ul></li><li>불변식이 깨져도 그 영향이 호출한 클라이언트에만 그칠때<ul><li>ex) Wrapper Class</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>Effective Java (3rd Edition)</li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-50&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-50&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 50&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Prefer side-effect-free functions in streams</title>
    <link href="https://kodakyung.github.io/2019/03/23/programming-java-effective-java-2019-03-23-java-prefer-side-effect-free-functions-in-streams/"/>
    <id>https://kodakyung.github.io/2019/03/23/programming-java-effective-java-2019-03-23-java-prefer-side-effect-free-functions-in-streams/</id>
    <published>2019-03-22T15:00:00.000Z</published>
    <updated>2020-03-19T01:05:37.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-46"><a href="#Effective-Java-Item-46" class="headerlink" title="Effective Java Item 46"></a>Effective Java Item 46</h2><blockquote><p>스트림에서는 부작용 없는 함수를 사용하라.</p></blockquote><h3 id="스트림-패러다임"><a href="#스트림-패러다임" class="headerlink" title="스트림 패러다임"></a>스트림 패러다임</h3><ul><li>스트림은 <code>함수형 프로그래밍</code> 패러다임이다. </li><li>스트림을 통해 <code>표현력</code>, <code>속도</code>, <code>병렬성</code>을 얻을 수 있다. </li><li>계산을 <code>일련의 변환</code>으로 재구성한다.</li><li>각 변환 단계를 가능한 이전 단계의 결과를 받아 처리하는 <strong>순수 함수</strong>여야한다.</li><li><strong>순수 함수란 오직 입력만이 결과에 영향을 주는 함수이다.</strong><ul><li>가변 상태를 참조하지 않고 함수 스스로도 다른 상태를 변경하지 않는다.</li></ul></li><li>즉 스트림 연산에 사용되는 함수 객체는 모두 <code>side effect</code>가 없어야한다. </li><li>스트림의 <code>for each</code>는 스트림 계산 결과를 보여주는 용도로만 사용하는 것이 좋다. </li></ul><h3 id="스트림의-수집기-Collector"><a href="#스트림의-수집기-Collector" class="headerlink" title="스트림의 수집기(Collector)"></a>스트림의 수집기(Collector)</h3><ul><li><code>java.util.stream.Collectors</code></li><li>수집기가 생성하는 객체는 일반적으로 컬렉션이다. </li><li><code>Collector</code>를 통해 스트림의 원소들을 쉽게 원소 하나(컬렉션)로 모을 수 있다. </li><li>수집기는 <code>toList()</code>, <code>toSet()</code>, <code>toCollection(collectionFactory)</code>로 <code>리스트</code>, <code>집합</code>, <code>프로그래머가 지정한 컬렉션 타입</code>을 반환한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; freq;</span><br><span class="line">...</span><br><span class="line">List&lt;String&gt; topTen = freq.keySet().stream() <span class="comment">// (1)</span></span><br><span class="line">    .sorted(comparing(freq::get).reversed()) <span class="comment">// (2)</span></span><br><span class="line">    .limit(<span class="number">10</span>)</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure><ol><li>Map에서 key를 뽑아내 stream으로 만든다.</li><li>sorted에 비교자 생성 메서드인 comparing으로 비교 기준을 넘긴다. </li><li>단어 10개까지 뽑아서</li><li>List로 변경해 반환한다.</li></ol><ul><li>나머지 메소드들은 대부분 스트림을 맵으로 취합하는 기능을 가진다. 스트림의 각 원소는 키 하나와 값 하나에 연관되어있지만 <strong>다수의 스트림 원소가 같은 키에 연관될 수 있다.</strong> </li></ul><h3 id="맵-수집기-Map-Collector"><a href="#맵-수집기-Map-Collector" class="headerlink" title="맵 수집기(Map Collector)"></a>맵 수집기(Map Collector)</h3><ul><li><p>가장 간단한 맵 수집기는 <code>toMap(keyMapper, valueMapper)</code> 인자 2개를 받는 메소드이다.</p></li><li><p>스트림 원소를 <strong>키에 맵핑하는 함수</strong>와 <strong>값에 맵핑하는 함수</strong>를 인수로 받는다. </p></li><li><p>이 경우는 스트림의 각 원소가 고유한 키에 매핑되어 있을 때 적절하다. </p></li><li><p>더 복잡한 형태는 <code>toMap(keyMapper, valueMapper, mergeMethod)</code> 3가지를 인자로 받는 메소드로 처리한다.</p></li><li><p>병합 함수는 <code>BinaryOperator&lt;T&gt;</code>로 같은 <code>&lt;T&gt;</code> 형태의 두개의 파라미터를 받아서 람다식대로 계산하고 계산 후 결과 값도 <code>&lt;T&gt;</code> 형태로 반환한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Artist, Album&gt; topHits = albums.collect(</span><br><span class="line">  toMap(Album::artist, a-&gt;a, maxBy(comparing(Album::sales)));</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>책에서는 병합 함수로 <code>BinaryOperator</code>에서 정적 임포트한 <code>maxBy</code>라는 정적 팩터리 메소드를 사용한다.</li><li><code>maxBy</code>는 <code>Comparator&lt;T&gt;</code>를 입력 받아 <code>BinaryOperator&lt;T&gt;</code>를 반환한다. </li><li><code>comparing</code>이 비교자 생성 메서드로 키 추출 함수로 <code>Album::sales</code>를 넘겨 비교자를 반환한다.</li></ul></li><li><p>가장 복잡한 경우는 <code>toMap(keyMapper,valueMapper, mergeMethod, MapFactory)</code> 네가지 인자를 받는다. </p></li><li><p>네번째 인수로 받는 맵 팩터리는 특정 맵 구현체(TreeMap 등)를 직접 지정할 수 있다.</p></li></ul><h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h3><ul><li><p>인수로 분류 함수를 받고 입력받은 원소가 속한 카테고리를 반환한다. 그리고 이 카테고리가 맵의 키로 쓰인다.</p></li><li><p>가장 간단한 형태는 분류 함수 하나를 인수로 받아 맵을 생성하는 것이다. <code>groupingBy(classifier)</code></p></li><li><p>이때 반환된 맵에는 각 값마다 해당 카테고리에 속한 원소들을 담은 리스트가 있다. <code>Map&lt;CategoryType, List&lt;DataType&gt;&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">words.collect(groupingBy(word -&gt; alp))</span><br></pre></td></tr></table></figure></li><li><p>반환되는 수집기가 리스트외에 특정 형태로 지정하고 싶다면(위의 반환형이 List가 아닌 다른 자료 형태이길 원한다면) 다운스트림(downstream) 수집기도 표기해야한다. <code>groupingBy(classifier, downstream)</code></p></li><li><p><code>toSet()</code>을 사용하면 <code>Set</code>으로 <code>toCollection(collectionFactory)</code>을 사용하면 원하는 컬렉션 타입을 선택할 수 있다. </p></li><li><p><code>counting()</code>을 사용하는 경우 해당 카테고리에 속한 원소의 값과 매핑한 맵을 얻는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; freq = words</span><br><span class="line">  .collect(groupingBy(String::toLowerCase, counting()));</span><br></pre></td></tr></table></figure><ul><li><code>counting</code> 메소드를 사용해 개수를 반환하기 때문에 <code>Long</code>으로 반환된다. </li></ul></li></ul><h3 id="joining"><a href="#joining" class="headerlink" title="joining"></a>joining</h3><ul><li><code>CharSequence</code> 인스턴스 스트림에만 적용이 가능한 메소드이다.</li><li>매개 변수 없는 <code>joining()</code>은 원소들을 연결(concatenate)하는 역할을 한다.</li><li>매개 변수 하나인 <code>joining(delimiter)</code>은 구분자를 받아 연결 부위에 구분자를 삽입한다. </li><li>매개변수 3개인 <code>joining</code>은 구분자와 접두문자(prefix)와 접미문자(suffix)도 지정할 수 있다.</li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-46&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-46&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 46&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Prefer method references to lambdas</title>
    <link href="https://kodakyung.github.io/2019/02/21/programming-java-effective-java-2019-02-21-java-prefer-method-references-to-lambdas/"/>
    <id>https://kodakyung.github.io/2019/02/21/programming-java-effective-java-2019-02-21-java-prefer-method-references-to-lambdas/</id>
    <published>2019-02-20T15:00:00.000Z</published>
    <updated>2020-03-19T01:05:27.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-43"><a href="#Effective-Java-Item-43" class="headerlink" title="Effective Java Item 43"></a>Effective Java Item 43</h2><blockquote><p>람다보다는 메소드 참조를 사용하라</p></blockquote><br><h3 id="lambda-VS-method-reference"><a href="#lambda-VS-method-reference" class="headerlink" title="lambda VS method reference"></a>lambda VS method reference</h3><ul><li>함수 객체를 람다보다 <strong>간결</strong>하게 표현할 수 있는 것이 <code>method reference</code>(메소드 참조)이다.</li><li>이 중 <em>람다의 코드가 의미 없이 길다</em>면 또는 <em>이미 구현된 라이브러리</em>로 메소드 참조를 할 수 있다면, 메소드 참조를 사용하는 것이 낫다.</li><li>그리고 메소드 참조를 사용하는 경우 매개변수를 제거하므로, 람다의 매개변수 이름이 있어야 코드의 의미가 명확해진다면 람다를 사용하는 것이 낫다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.merge(key, <span class="number">1</span>, (count, incr) -&gt; count+incr); <span class="comment">// lambda</span></span><br><span class="line">map.merge(key, <span class="number">1</span>, Integer::sum); <span class="comment">// method reference</span></span><br></pre></td></tr></table></figure><ul><li>항상 메소드 참조가 람다보다 간결한 것은 아니다. </li><li>메소드 참조의 경우 Class나 Obejct 이름을 항상 써야하기 때문에 <strong>같은 클래스에 있는 메소드</strong>를 사용한다면 람다 표현을 사용하는 것이 더 간결하다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service.execute(GoshThisClassNameIsHumongous::action); <span class="comment">// method reference</span></span><br><span class="line">service.execute(()-&gt;action()); <span class="comment">// lambda</span></span><br></pre></td></tr></table></figure><h2 id="method-reference의-사용"><a href="#method-reference의-사용" class="headerlink" title="method reference의 사용"></a>method reference의 사용</h2><ul><li>메소드 참조를 사용하는 경우 (1) 기존에 구현된 라이브러리를 사용하거나(ex-위의 <code>Integer::sum</code>은 Integer 클래스의 static sum 메소드를 사용한 것)</li><li>lambda 표현이 길어지는 경우(보통 3줄을 넘어가지 않는 것이 좋다) (2) 따로 메소드를 작성해 람다 대신 메소드 참조를 사용한다. </li></ul><h2 id="method-reference의-유형"><a href="#method-reference의-유형" class="headerlink" title="method reference의 유형"></a>method reference의 유형</h2><ol><li>정적 메소드 참조</li></ol><ul><li><code>Class::staticMethod</code> 형식으로 사용한다. </li><li>ex) <code>Integer::parseInt</code>는 <code>str-&gt;Integer.parseInt(str)</code>과 같다</li></ul><ol start="2"><li>한정적 인스턴스 메소드 참조</li></ol><ul><li><code>object::instanceMethod</code></li><li>(1)의 정적 메소드 참조와 비슷하다. </li><li>즉, 함수 객체가 받는 인수와 참조 되는 메소드가 받는 인수가 같다.</li><li>ex) <code>Instant.now()::isAfter</code>은 <code>Instant then = Instant.now(); \n t-&gt;then.isAfter(t)</code>와 같다.</li></ul><ol start="3"><li>비한정적 인스턴스 메소드 참조</li></ol><ul><li>수신 객체를 한정하지 않는 다는 의미해서 비한정적 메소드 참조이다.</li><li>따라서 함수 객체가 받는 인수와 참조되는 메소드가 받는 인수가 다르다.</li><li>그래서 함수 객체를 적용하는 시점에 수신 객체를 알려준다. </li><li>ex) <code>String::toLowerCase</code>은 <code>str-&gt;str.toLowerCase()</code>와 같다.</li></ul><ol start="4"><li>클래스 생성자 메소드 참조</li></ol><ul><li>생성자 레퍼런스와 메소드 레퍼런스는 거의 흡사하다. </li><li>생성자 종류가 많을 경우 문맥으로 파악한다.</li></ul><ol start="5"><li>배열 생성자 메소드 참조</li></ol><br><ul><li>결과적으로 method reference를 사용하면 메소드의 모든 매개변수가 사라진다. 그러므로 lambda를 사용할 때와 같이 사용하려는 자바 라이브러리에 대한 정확한 이해가 필요하다. </li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-43&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-43&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 43&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Use instance fields instead of ordinals</title>
    <link href="https://kodakyung.github.io/2019/02/20/programming-java-effective-java-2019-02-20-java-use-instance-fields-instead-of-ordinals/"/>
    <id>https://kodakyung.github.io/2019/02/20/programming-java-effective-java-2019-02-20-java-use-instance-fields-instead-of-ordinals/</id>
    <published>2019-02-19T15:00:00.000Z</published>
    <updated>2020-03-19T01:05:22.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-35"><a href="#Effective-Java-Item-35" class="headerlink" title="Effective Java Item 35"></a>Effective Java Item 35</h2><blockquote><p>ordinal 메서드 대신 인스턴스 필드를 사용하라 </p></blockquote><br><h2 id="ordinal-method"><a href="#ordinal-method" class="headerlink" title="ordinal method"></a>ordinal method</h2><ul><li>enum 타입에 제공되는 메소드로 열거 타입에서 몇번째 위치인지를 반환한다. </li><li>enum 타입과 연결된 정수가 필요할 때 이 메소드를 사용한다면 코드도 직관적이지 않고 쓰이지 않는 값도 많아질 것이다. </li></ul><h2 id="ordinal-대신-인스턴스-필드에-저장"><a href="#ordinal-대신-인스턴스-필드에-저장" class="headerlink" title="ordinal 대신 인스턴스 필드에 저장"></a>ordinal 대신 인스턴스 필드에 저장</h2><ul><li>따라서 ordinal 대신 열거 타입 상수에 연결된 값은 인스턴스 필드에 저장하는 것이 좋다. </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Ensemble &#123;</span><br><span class="line">    SOLO(<span class="number">1</span>), DUET(<span class="number">2</span>), TRIO(<span class="number">3</span>), QUARTET(<span class="number">4</span>), QUINTET(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfMusicians; </span><br><span class="line">    Ensemble(<span class="keyword">int</span> size) &#123; <span class="keyword">this</span>.numverOfMusicials = size; &#125;</span><br><span class="line">    <span class="comment">// 생성자에서 인스턴스 필드에 초기화 한다.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfMusicians</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numberOfMusicians;&#125;</span><br><span class="line">    <span class="comment">// 메소드에서 인스턴스 필드에 저장된 값은 반환한다. </span></span><br><span class="line">    <span class="comment">// ordinal 메소드를 사용하지 않는다. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-35&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-35&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 35&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Use bounded wildcards to increase API flexibility</title>
    <link href="https://kodakyung.github.io/2019/01/31/programming-java-effective-java-2019-01-31-java-use-bounded-wildcards-to-increase-api-flexibility/"/>
    <id>https://kodakyung.github.io/2019/01/31/programming-java-effective-java-2019-01-31-java-use-bounded-wildcards-to-increase-api-flexibility/</id>
    <published>2019-01-30T15:00:00.000Z</published>
    <updated>2020-03-19T01:05:10.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-31"><a href="#Effective-Java-Item-31" class="headerlink" title="Effective Java Item 31"></a>Effective Java Item 31</h2><blockquote><p>한정적 와일드카드를 사용해 API 유연성을 높여라</p></blockquote><br><ul><li>한정적 와일드 카드가 필요한 이유는 제네릭의 매개변수화 타입(<code>List&lt;String&gt;</code>, <code>List&lt;Integer&gt;</code> 등)이 불공변이기 때문이다. </li><li>불공변이라는 얘기는 서로 상위 타입도 하위 타입도 아닌 각자 다른 타입이라는 의미이다.</li><li>따라서 책의 예시와 같이 <code>Stact&lt;E&gt;</code>에 <code>Stact&lt;Number&gt;</code>를 선언후 Integer 타입을 넣으면 <code>incompatible types</code>라는 에러가 발생한다. </li><li>보다 제네릭을 유연하게 사용하기 위해 한정적 와일드카드가 필요하다.</li></ul><h3 id="lt-extends-T-gt"><a href="#lt-extends-T-gt" class="headerlink" title="&lt;? extends T&gt;"></a>&lt;? extends T&gt;</h3><ul><li>T의 하위 타입을 허용한다는 의미이다. </li><li>push 메소드와 같이 원소를 생산하는 메소드의 매개변수에 사용한다. </li><li>ex) 위처럼 <code>Number</code>로 생성 후 <code>Integer</code>로 받는게 가능해진다.</li></ul><h3 id="lt-super-T-gt"><a href="#lt-super-T-gt" class="headerlink" title="&lt;? super T&gt;"></a>&lt;? super T&gt;</h3><ul><li>T의 상위 타입을 허용한다는 의미이다. </li><li>pop 메소드와 같이 원소를 소비하는 메소드의 매개변수에 사용한다. </li><li>ex) <code>Stack&lt;Number&gt;</code> 원소를 <code>Collection&lt;Object&gt;</code>로 꺼내고 싶은 경우 </li></ul><h3 id="한정적-와일드카드-사용-규칙"><a href="#한정적-와일드카드-사용-규칙" class="headerlink" title="한정적 와일드카드 사용 규칙"></a>한정적 와일드카드 사용 규칙</h3><ul><li>입력 매개변수가 생산자나 소비자의 역할만 한다면 입력 매개변수에 와일드카드 타입을 사용해 유연성을 높이는 것이 좋다. </li><li>입력 매개변수가 생산자와 소비자 역할을 동시에 한다면 정확한 타입을 지정하는 것이 좋다. </li><li>PECS : producer-extends, consumer-super</li><li>생산자라면 <code>&lt;? extends T&gt;</code>, 소비자라면 <code>&lt;? super T&gt;</code>를 사용 </li><li>메소드의 반환 타입은 한정적 와일드 카드 타입을 사용하면 안된다. 클라이언트 쪽에서도 와일드 카드 타입을 써야하기 때문.</li><li>사용자가 와일드 카드 타입을 신경써야한다면 그 메소드는 잘못 짜여진 메소드이다. </li><li>자바 7까지는 명시적 타입 인수를 사용해야한다. </li></ul><h3 id="Comparator를-직접-구현하지-않은-경우의-한정적-와일드-카드"><a href="#Comparator를-직접-구현하지-않은-경우의-한정적-와일드-카드" class="headerlink" title="Comparator를 직접 구현하지 않은 경우의 한정적 와일드 카드"></a>Comparator를 직접 구현하지 않은 경우의 한정적 와일드 카드</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;E&gt;&gt; <span class="function">E <span class="title">max</span><span class="params">(List&lt;E&gt; list)</span></span></span><br></pre></td></tr></table></figure><ul><li>기존 코드를 PECS에 맞춰 변경해보면</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Comparable&lt;? <span class="keyword">super</span> E&gt;&gt; <span class="function">E <span class="title">max</span><span class="params">(List&lt;? extends E&gt; list)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>Comparable</code>은 E 인스턴스를 소비해 natural ordering에 해당하는 정수를 생산한다. </li><li>따라서 <code>Comparable</code>은 소비자의 역할이므로 <code>&lt;? super E&gt;</code>로 인스턴스를 변경한다. </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;ScheduledFuture&lt;?&gt;&gt; scheduledFutures = ... ;</span><br></pre></td></tr></table></figure><ul><li>이렇게 복잡한 선언을 하는 이유는 위의 리스트와 같이 <strong>Comparable(or Comparator)를 직접 구현하지 않고 직접 구현한 다른 타입을 extends 한 경우를 지원하기 때문이다.</strong></li><li>ScheduledFuture는 직접 Comparator를 구현하지 않고 Comparator를 구현한 상위 타입을 extends 하고있다. </li><li><code>Comparable&lt;? super E&gt;</code>로 명시하지 않으면 ScheduledFuture 뿐 아니라 그 상위 클래스의 인스턴스와도 비교할 수 있기 때문에 에러가 발생한다. </li></ul><h3 id="타입-매개변수와-와일드카드-lt-E-gt-vs-lt-gt"><a href="#타입-매개변수와-와일드카드-lt-E-gt-vs-lt-gt" class="headerlink" title="타입 매개변수와 와일드카드 &lt;E&gt; vs &lt;?&gt;"></a>타입 매개변수와 와일드카드 &lt;E&gt; vs &lt;?&gt;</h3><pre><code class="java"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>; <span class="comment">// (1)</span><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="comment">// (2)</span></span></code></pre><ul><li>이 메서드를 정의할 때 <code>&lt;E&gt;</code>와 <code>&lt;?&gt;</code>는 parameter에서 같은 역할을 한다. </li><li>이 책의 필자는 public api인 경우 좀 더 깔끔한 선언을 위해 두번째 방식을 추천하고 있다.</li><li>하지만 두번째 방식의 경우 원소를 꺼낸 뒤 다시 넣을 때 에러가 날 수 있다. - List&lt;?&gt;는 null 외에 아무 값도 넣을 수 없기 때문 (parameter에서 모든 인자를 받는 역할을 함)</li><li>따라서 public api를 와일드카드(?)를 사용하고 내부적으로 값을 넣고 변경해야한다면, 와일드카드 타입의 실제 타입을 알려주는 도우미 메서드를 작성하는 것이 좋다. </li><li>도우미 메서드는 (1)의 메소드 선언과 같다. </li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-31&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-31&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 31&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Don&#39;t use raw types</title>
    <link href="https://kodakyung.github.io/2019/01/28/programming-java-effective-java-2019-01-28-java-don-t-use-raw-types/"/>
    <id>https://kodakyung.github.io/2019/01/28/programming-java-effective-java-2019-01-28-java-don-t-use-raw-types/</id>
    <published>2019-01-27T15:00:00.000Z</published>
    <updated>2020-03-19T01:04:56.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-26"><a href="#Effective-Java-Item-26" class="headerlink" title="Effective Java Item 26"></a>Effective Java Item 26</h2><blockquote><p>로 타입은 사용하지 말라. </p></blockquote><br><h3 id="제네릭-Generic"><a href="#제네릭-Generic" class="headerlink" title="제네릭(Generic)"></a>제네릭(Generic)</h3><ul><li>제네릭을 사용하는 이유는 <code>컬렉션이 담을 수 있는 타입</code>을 컴파일러에 알려주기 위한 것. </li><li>제네릭 지원 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야했고, 잘못된 객체를 넣은 경우 형변환 오류가 발생했다. </li><li>제네릭을 통해 컴파일러는 형변환 코드 추가 가능, 잘못된 객체 삽입 차단 등의 기능을 수행하며, 코드를 좀 더 명확하게 해준다. </li></ul><br><h3 id="용어-정리"><a href="#용어-정리" class="headerlink" title="용어 정리"></a>용어 정리</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; <span class="comment">// (1)(3)</span></span><br><span class="line">T <span class="comment">// (2)</span></span><br><span class="line">List&lt;String&gt; <span class="comment">// (4)</span></span><br><span class="line">List <span class="comment">// (5)</span></span><br></pre></td></tr></table></figure><ul><li>(1) 제네릭 클래스 / 제네릭 인터페이스 : 클래스와 인터페이스 선언에 타입 매개 변수(type parameter)(2)가 쓰인 것.</li><li>(3) 제네릭 타입(generic type) : (1)의 두가지를 합쳐서 일컫는 말 </li><li>(4) 매개변수화 타입(parameterized type) : <del>이 제네릭 타입은 매개변수를 정의한다.</del>고 책에 나와있는데 정확히 말하면 제네릭 타입에서 매개변수가 지정된 타입을 의미하는 것 같다. (4)는 원소의 타입이 String인 리스트를 뜻하는 매개변수화 타입. </li><li>(5) 로 타입(raw type) : 제네릭 타입 정의 시 함께 정의되는 타입. 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않은 타입을 일컬음. 제네릭이 생기기 전(Java5 이전) 코드와 호환을 위해 사용됨. <strong>제네릭 타입에 속하지 않는다.</strong> </li></ul><br><h3 id="로-타입의-문제점"><a href="#로-타입의-문제점" class="headerlink" title="로 타입의 문제점"></a>로 타입의 문제점</h3><ul><li>잘못된 타입을 넣어도, 컴파일러 에러가 발생하지 않고 런타임 에러가 발생한다. </li><li>제네릭 타입이 아니기 때문에 제네릭의 안정성, 표현력을 사용할 수 없다. </li></ul><br><h3 id="매개변수화-타입을-지정했을-때-장점"><a href="#매개변수화-타입을-지정했을-때-장점" class="headerlink" title="매개변수화 타입을 지정했을 때 장점"></a>매개변수화 타입을 지정했을 때 장점</h3><ul><li>잘못된 타입을 체크해 컴파일러에서 에러를 보여준다. </li><li>컬렉션에서 원소를 꺼내는 모든 곳에서 형변환을 추가하고, 절대 실패하지 않음을 보장한다. </li></ul><br><h3 id="로-타입을-사용하는-이유"><a href="#로-타입을-사용하는-이유" class="headerlink" title="로 타입을 사용하는 이유"></a>로 타입을 사용하는 이유</h3><ul><li><strong>Java5 이전 코드와의 호환성 때문</strong></li></ul><br><h3 id="List-vs-List-lt-Object-gt-로-타입과-임의-객체-허용"><a href="#List-vs-List-lt-Object-gt-로-타입과-임의-객체-허용" class="headerlink" title="List vs List&lt;Object&gt; : 로 타입과 임의 객체 허용"></a>List vs List&lt;Object&gt; : 로 타입과 임의 객체 허용</h3><ul><li>오른쪽은 모든 타입을 허용한다고 컴파일러에 의사를 전달한 것.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(List list)</span></span>&#123; ... &#125;; <span class="comment">// (1)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(List&lt;Object&gt; list)</span></span>&#123; ... &#125;; <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><ul><li>(1)에는 <code>List&lt;String&gt;</code> 매개변수를 넘길 수 있지만, (2)에는 넘길 수 없다. </li><li><code>List&lt;String&gt;</code>은 로타입인 <code>List</code>의 하위 타입이지만, <code>List&lt;Object&gt;</code>의 하위 타입이 아니기 때문에 불가능하다. </li><li>따라서 (2)와 달리 (1)을 사용하는 경우 타입 안정성을 잃게 된다. </li></ul><br><h3 id="List-vs-List-lt-gt-로-타입과-비한정적-와일드-카드-타입"><a href="#List-vs-List-lt-gt-로-타입과-비한정적-와일드-카드-타입" class="headerlink" title="List vs List&lt;?&gt; : 로 타입과 비한정적 와일드 카드 타입"></a>List vs List&lt;?&gt; : 로 타입과 비한정적 와일드 카드 타입</h3><ul><li>비한정적 와일드카드 타입(unbounded wildcard type)은 제네릭 타입을 쓰면서 실제 타입 매개변수를 지정하고 싶지 않은 경우에 사용한다. </li><li>왼쪽은 안전하지 않고 오른쪽은 안전하다.</li><li>로 타입의 경우 아무 원소를 넣을 수 있어 위험하고,</li><li>비한정적 와일드 카드 타입의 경우 null외에 어떤 원소도 넣을 수 없다. </li></ul><br><h4 id="비한정적-와일드-카드-타입"><a href="#비한정적-와일드-카드-타입" class="headerlink" title="비한정적 와일드 카드 타입"></a>비한정적 와일드 카드 타입</h4><ul><li>비한정적 와일드 카드 타입은 원소를 넣는 용도가 아닌 클래스나 메소드에서 어떤 제네릭 타입도 매개변수로 받기 위해 쓰이는 것 같다. </li><li>예를 들면 <code>List&lt;String&gt;</code>이 <code>List&lt;Object&gt;</code>의 하위 타입이 아니기 때문에 파라미터가 <code>List&lt;Object&gt;</code>일때 <code>List&lt;String&gt;</code>을 인자로 받는 것은 불가능하다. </li><li>이 때 비한정적 와일드 카드 타입(<code>List&lt;?&gt;</code>)을 쓰는 경우 가능하다. </li><li>그리고 특정 타입의 하위 타입으로만 제한하고 싶다면 한정적 와일드 카드를 사용한다. (<code>List&lt;? extends parentClass&gt;</code>)</li></ul><br><h3 id="로-타입을-쓰는-경우"><a href="#로-타입을-쓰는-경우" class="headerlink" title="로 타입을 쓰는 경우"></a>로 타입을 쓰는 경우</h3><ol><li>class 리터럴에는 제네릭말고 로 타입으로 표기 <ul><li>ex) <code>List&lt;String&gt;.class</code> (X) / <code>List.class</code> (O)</li></ul></li><li>instanceof 연산자로 제네릭 타입을 비교할 때 <ul><li>ex) <code>o instanceof Set&lt;String&gt;</code> (X) / <code>o instanceof Set</code> (O)</li><li>둘다 가능하지만 런타임 제네릭 타입 정보를 확인할 수 없기 때문에 왼쪽의 코드는 의미없다. </li></ul></li></ol><br><h4 id="클래스-리터럴"><a href="#클래스-리터럴" class="headerlink" title="클래스 리터럴"></a>클래스 리터럴</h4><ul><li>리터럴은 변수에 넣는 변하지 않는 데이터를 의미한다. <ul><li>ex) int i = 1; 에서 1 해당</li></ul></li><li>String은 Class 클래스의 인스턴스 </li><li>문자열 리터럴은 <code>클래스 String</code>의 인스턴스를 나타내는 표기 </li><li>클래스 리터럴은 (Hashtable.class 등) <code>클래스 Class</code>의 인스턴스를 나타내는 표기 </li></ul><br><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul><li><a href="https://multifrontgarden.tistory.com/104" target="_blank" rel="noopener">Java Generic</a></li><li><a href="https://code.i-harness.com/ko-kr/q/20f894" target="_blank" rel="noopener">Java 클래스 리터럴</a></li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-26&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-26&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 26&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Limit source files to a single top-level class</title>
    <link href="https://kodakyung.github.io/2019/01/27/programming-java-effective-java-2019-01-27-java-limit-source-files-to-a-single-top-level-class/"/>
    <id>https://kodakyung.github.io/2019/01/27/programming-java-effective-java-2019-01-27-java-limit-source-files-to-a-single-top-level-class/</id>
    <published>2019-01-26T15:00:00.000Z</published>
    <updated>2020-03-19T01:04:48.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-25"><a href="#Effective-Java-Item-25" class="headerlink" title="Effective Java Item 25"></a>Effective Java Item 25</h2><blockquote><p>톱 레벨 클래스는 한 파일에 하나만 담으라. </p></blockquote><br><ul><li>한 파일에 여러가지의 톱 레벨 클래스를 담아도 컴파일 에러가 발생하진 않는다.</li><li>하지만, <strong>컴파일러에 따라 동작이 달라질 수 있다.</strong></li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(A.NAME + B.NAME);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A.java</span></span><br><span class="line">Class A &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"aaa"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Class B &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"bbb"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B.java</span></span><br><span class="line">Class A &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"ccc"</span>;</span><br><span class="line">&#125;</span><br><span class="line">Class B &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">"ddd"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>여기서 <code>Main.java</code>, <code>B.java</code> 순으로 컴파일 한다면 컴파일 오류를 </li><li><code>Main.java</code> <code>A.java</code> 순으로 컴파일 되면 “aaabbb” 출력을 </li><li><code>B.java</code>, <code>Main.java</code> 순으로 컴파일 되면 “cccddd”를 출력할 것이다. </li></ul><br><ul><li>차라리 오류가 발생하는 것이 운이 좋은 것이며, 상황에 따라 동작이 달라지는 것은 오류를 발견하기도 어렵다.</li></ul><br><ul><li>따라서 한 파일에 담긴 여러 개의 톱 레벨 클래스를 <code>파일 별로 분리</code>하거나 </li><li>정 같은 파일에 담고 싶다면 <code>정적 멤버 클래스</code>로 선언하는 것이 좋다. </li><li>다른 클래스에 딸린 부차적인 클래스라면 정적 멤버 클래스 선언이 더 낫다.</li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-25&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-25&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 25&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Prefer class hierarchies to tagged classes</title>
    <link href="https://kodakyung.github.io/2019/01/24/programming-java-effective-java-2019-01-24-java-prefer-class-hierarchies-to-tagged-classes/"/>
    <id>https://kodakyung.github.io/2019/01/24/programming-java-effective-java-2019-01-24-java-prefer-class-hierarchies-to-tagged-classes/</id>
    <published>2019-01-23T15:00:00.000Z</published>
    <updated>2020-03-19T01:04:40.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-23"><a href="#Effective-Java-Item-23" class="headerlink" title="Effective Java Item 23"></a>Effective Java Item 23</h2><blockquote><p>태그 달린 클래스보다는 클래스 계층구조를 활용하라 </p></blockquote><br><h3 id="태그-달린-클래스란"><a href="#태그-달린-클래스란" class="headerlink" title="태그 달린 클래스란 ?"></a>태그 달린 클래스란 ?</h3><ul><li>이 책에서 말하는 태그 달린 클래스는 <code>enum</code>으로 타입을 결정하고, 타입별로 쓰이는 필드와 메소드가 다른데 한 클래스에 모든 코드가 있는 경우를 일컫는다. </li><li>즉, 한 클래스에서 태그(enum)에 따라 동작을 달리하는 코드를 의미한다. </li></ul><br><h3 id="태그-달린-클래스의-단점"><a href="#태그-달린-클래스의-단점" class="headerlink" title="태그 달린 클래스의 단점"></a>태그 달린 클래스의 단점</h3><ul><li>열거타입, 태그 필드, switch문 등 <code>필요 없는 코드</code>가 많아 진다. </li><li>위의 이유로 <code>메모리</code>도 낭비하게 된다. </li><li>또한 여러 코드가 혼합되어 있어 <code>가독성</code>이 나쁘다. </li><li>프로그래머가 코드를 잘못 작성해도 <code>런타임에서 에러</code>를 확인할 수 있다. </li><li>새로운 타입을 추가하는 경우 코드를 <code>전체적</code>으로 수정해야한다. </li><li><strong>태그 클래스를 클래스 계층 구조를 흉내낸 것이기 때문에 클래스 계층 구조로 변경해주는 것이 좋다.</strong></li></ul><br><h3 id="태그-클래스를-클래스-계층-구조로"><a href="#태그-클래스를-클래스-계층-구조로" class="headerlink" title="태그 클래스를 클래스 계층 구조로"></a>태그 클래스를 클래스 계층 구조로</h3><ul><li>계층 구조의 루트가 될 <code>추상 클래스</code>를 정의한다. </li><li>태그 값에 따라 달라지는 부분을 <code>추상 메소드</code>로 선언한다. </li><li>그리고 태그 값과 상관 없이 동작이 일정한 메소드는 루트 클래스의 <code>일반 메소드</code>로 추가한다. </li><li>모든 하위 클래스에서 공통으로 사용되는 필드도 추상(루트) 클래스로 올린다. </li><li>그리고나서 루트 클래스를 <code>extends</code>한 구체 클래스를 의미별로 정의하면 된다. </li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-23&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-23&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 23&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Minimize mutability</title>
    <link href="https://kodakyung.github.io/2019/01/21/programming-java-effective-java-2019-01-21-java-minimize-mutability/"/>
    <id>https://kodakyung.github.io/2019/01/21/programming-java-effective-java-2019-01-21-java-minimize-mutability/</id>
    <published>2019-01-20T15:00:00.000Z</published>
    <updated>2020-03-19T01:04:33.128Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-17"><a href="#Effective-Java-Item-17" class="headerlink" title="Effective Java Item 17"></a>Effective Java Item 17</h2><blockquote><p>변경가능성을 최소화하라.</p></blockquote><p><code>Immutable Class</code>는 간단히 변경 불가능한 클래스를 의미한다.<br>Immutable Class의 모든 정보는 객체의 생명 주기 동안 값이 고정되어야 한다. (자바 라이브러리의 <code>String</code>, <code>BigInteger</code>, <code>BigDecimal</code> 등)</p><h3 id="Five-rules-of-immutable-class"><a href="#Five-rules-of-immutable-class" class="headerlink" title="Five rules of immutable class"></a>Five rules of immutable class</h3><ol><li>Don’t provide method that modify the object’s state (known as mutators).<blockquote><p>객체의 상체를 변경시키는 메소드(변경자)를 제공하지 않는다. </p></blockquote></li><li>Ensure that the class can’t be extended.<blockquote><p>클래스를 확장할 수 없게 한다. </p></blockquote></li><li>Make all fields final. <blockquote><p>모든 필드를 final로 한다. </p></blockquote></li><li>Make all fields private.<blockquote><p>모든 필드를 private로 한다.</p></blockquote></li><li>Ensure exclusive access to any mutable components.<blockquote><p>변경 가능한 모든 컴포넌트에 독점적으로 access하게 한다.<br>즉, Immutable Class 자신만 접근 가능하도로 해야한다. </p></blockquote></li></ol><ul><li>mutable object가 있다면 클라이언트에서 참조할 수 없도록 해야한다. </li><li>접근자가 그 필드를 반환해서도 안된다. </li><li>기존에 객체 참조를 넘기던 생성자, 접근자, <code>readObject</code>에서는 방어적 복사를 사용해야한다. </li></ul><h3 id="함수형-프로그래밍"><a href="#함수형-프로그래밍" class="headerlink" title="함수형 프로그래밍"></a>함수형 프로그래밍</h3><ul><li>피연산자에 함수를 적용해 결과를 반환하지만, 피연산자 자체를 변경되지 않는 패턴</li><li>해당 메소드가 상태를 변경시키지 않는점을 강조하기 위해 이름을 동사(add) 대신 전치사(plus)를 사용해야한다. </li></ul><h3 id="불변-객체의-장점"><a href="#불변-객체의-장점" class="headerlink" title="불변 객체의 장점"></a>불변 객체의 장점</h3><ul><li>함수형 프로그래밍을 하면 코드 내 불변 비율이 높아진다.</li><li>불변 객체가 더 단순하고 오류가 적고, 상태가 일정하다. </li><li>불변 객체는 기본적으로 <code>thread-safe</code> 하고 따로 동기화하지 않아도 된다. </li><li>따라서 안심하고 공유할 수 있다. </li></ul><h3 id="불변-객체의-단점"><a href="#불변-객체의-단점" class="headerlink" title="불변 객체의 단점"></a>불변 객체의 단점</h3><ul><li>값이 다르면 항상 새로운 객체로 만들어야 한다. </li></ul><h3 id="불변-객체의-성능-문제"><a href="#불변-객체의-성능-문제" class="headerlink" title="불변 객체의 성능 문제"></a>불변 객체의 성능 문제</h3><ul><li>원하는 객체가 완성하기까지 단계가 많고, 중간 단계가 버려진다면 <code>성능 문제</code>가 생길 수 있다. 이에 대처하기 위해서는</li></ul><ol><li>불변 클래스에서 다단계 연산(<code>multistep operation</code>)을 예측해 기본 기능으로 제공하거나</li><li>가변 동반 클래스(<code>companion class</code>)를 <code>package-private</code> or <code>public</code>으로 제공한다.</li></ol><ul><li>2에 해당하는 것은 <code>String</code>과 <code>StringBuilder</code>가 있다. </li></ul><h3 id="더-유연한-방식의-불변-클래스"><a href="#더-유연한-방식의-불변-클래스" class="headerlink" title="더 유연한 방식의 불변 클래스"></a>더 유연한 방식의 불변 클래스</h3><ul><li>가장 쉬운 방법은 <code>클래스</code>에 <code>final</code> 선언 </li><li>다른 방법으로는 모든 <code>생성자</code>를 <code>private</code> or <code>package-private</code> 하고 <code>public 정적 팩토리 메소드</code>를 제공하는 방법. </li></ul><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><ol><li>클래스는 꼭 필요한 경우가 아니면 <code>불변</code>이어야 한다. </li><li>불변으로 만들 수 없는 클래스라도 <code>변경할 수 있는 부분은 최소화</code>하는 것이 좋다. </li><li>다른 이유가 있지 않다면 모든 필드는 <code>private final</code>이어야 한다. </li><li>생성자는 불변식 설정이 모두 완료된, <code>초기화가 완전히 끝난 상태</code>의 객체를 생성해야 한다. <ul><li>생성자와 정적 팩토리 메소드 외에 초기화 메소드를 public으로 제공하면 안됨.</li><li>객체를 재활용할 목적의 메소드도 안됨.(setter 등)</li></ul></li></ol><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-17&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-17&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 17&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Use interfaces only to define types</title>
    <link href="https://kodakyung.github.io/2019/01/18/programming-java-effective-java-2019-01-18-java-use-interfaces-only-to-define-types/"/>
    <id>https://kodakyung.github.io/2019/01/18/programming-java-effective-java-2019-01-18-java-use-interfaces-only-to-define-types/</id>
    <published>2019-01-17T15:00:00.000Z</published>
    <updated>2020-03-19T01:04:26.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-22"><a href="#Effective-Java-Item-22" class="headerlink" title="Effective Java Item 22"></a>Effective Java Item 22</h2><blockquote><p>인터페이스는 타입을 정의하는 용도로만 사용하라</p></blockquote><br><ul><li>인터페이스를 <code>implements</code> 한다는 것은 해당 인터페이스의 기능을, 상속 받은 클래스에서 구현해 제공한다는 의미이다.</li><li>인터페이스는 (<code>default method</code>를 제외하고) 구체적인 로직이 없다.</li><li>따라서 <strong>인터페이스의 사용은 인터페이스에서 제공하는 기능을 사용할 수 있는 특정 타입을 지정하는 것과 같다.</strong></li><li>인터페이스의 잘못된 사용은 <code>상수 인터페이스</code>를 사용하는 것이다.</li></ul><br><h3 id="상수-인터페이스"><a href="#상수-인터페이스" class="headerlink" title="상수 인터페이스"></a>상수 인터페이스</h3><ul><li>상수 인터페이스란 <code>static final field</code>만 있는 상수의 용도로 사용하는 인터페이스이다.</li><li>상수 인터페이스를 사용해 클래스의 상수를 대체한다면, 해당 인터페이스에 종속되는 결과를 낳는다. </li><li>또한 어떤 상수가 이 클래스에 사용하는지 불필요한 정보를 제공해 캡슐화를 해친다. </li><li>따라서 해당 클래스에서 필요한 상수라면 상수 인터페이스 구조보다는 클래스 내부 구현을 하는 것이 옳다.</li><li>그외에는 상수 인터페이스를 대체해 <code>열거(enum)타입</code>에 적합하다면 열거 타입을, 아니면 인스턴스화 할 수 없는 <code>유틸리티 클래스</code>로 구현하는 것이 좋다. </li></ul><br><h3 id="정적-임포트-static-import"><a href="#정적-임포트-static-import" class="headerlink" title="정적 임포트(static import)"></a>정적 임포트(static import)</h3><ul><li>유틸리티 클래스에 정의된 상수를 사용하려면 항상 클래스 이름까지 명시해야한다.</li><li>정적 임포트를 하면 클래스 이름을 생략할 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> className;</span><br></pre></td></tr></table></figure><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-22&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-22&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 22&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Design interfaces for posterity</title>
    <link href="https://kodakyung.github.io/2019/01/17/programming-java-effective-java-2019-01-17-java-design-interfaces-for-posterity/"/>
    <id>https://kodakyung.github.io/2019/01/17/programming-java-effective-java-2019-01-17-java-design-interfaces-for-posterity/</id>
    <published>2019-01-16T15:00:00.000Z</published>
    <updated>2020-03-19T01:04:19.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-21"><a href="#Effective-Java-Item-21" class="headerlink" title="Effective Java Item 21"></a>Effective Java Item 21</h2><blockquote><p>인터페이스는 구현하는 쪽을 생각해 설계하라. </p></blockquote><br><ul><li>자바 8부터 <code>default method</code>가 추가되면서 <code>기존 인터페이스</code>에 <code>기능을 추가</code>하는 일이 가능해졌다.</li></ul><br><ul><li>하지만 디폴트 메소드를 추가하는 경우 <code>기존 인터페이스 구현체</code>와 <code>오류 없이 연동</code>되는 것을 기대하기 어렵다. </li><li>만약, 어쩔 수 없이 추가해야한다면 가능한 모든 상황에서 <code>불변식</code>을 해치지 않는 디폴트 메소드를 작성해야한다. </li></ul><br><ul><li><code>자바 플랫폼 라이브러리</code>에서는 이런 문제를 예방하기 위한 조치들이 적용되었다.</li><li>예를 들면 구현한 인터페이스의 디폴트 메소드를 재정의하고, 다른 메소드에서는 디폴트 메소드를 호출하기 전에 필요한 수업을 수행하도록 하는 것이다. </li><li>자바 플랫폼에 속하지 않는 기존 컬렉션 구현체들은 위와 같이 언어 차원의 인터페이스 변화에 맞게 수정될 기회가 없었고 실제로 수정되지 않는 것도 있다.</li></ul><br><ul><li><strong>따라서 디폴트 메소드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.</strong></li><li>문제는 여러가지로 발생할 수 있다. 구현된 디폴트 메소드가 불변식을 해치는 경우, 다른 하위 구현체와 연동되지 않는 경우(synchoronize를 고려하지 않았다던지), 이름이 겹치는 경우 등</li></ul><br><ul><li>기존 인터페이스에 디폴트 메소드로 새 메소드를 추가하는 일은 가급적 피해야한다.</li><li>인터페이스를 릴리즈한 후에 인터페이스를 수정하는 것이 위험하기 때문에 <code>꼭 릴리즈 전에 테스트</code>해야한다. </li><li>하지만 새로운 인터페이스를 만든다면 디폴트 메소드는 표준적인 메소드 구현을 제공하는 좋은 도구가 된다.(아이템 20 참고)</li></ul><br><ul><li><strong>즉, 디폴트 메소드(default method)는 기존 인터페이스에 새로운 메소드를 추가하기 위한 기능이 아니라고 생각하는 것이 좋다.</strong></li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-21&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-21&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 21&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Favor composition over inheritance</title>
    <link href="https://kodakyung.github.io/2019/01/13/programming-java-effective-java-2019-01-13-java-favor-composition-over-inheritance/"/>
    <id>https://kodakyung.github.io/2019/01/13/programming-java-effective-java-2019-01-13-java-favor-composition-over-inheritance/</id>
    <published>2019-01-12T15:00:00.000Z</published>
    <updated>2020-03-19T01:04:12.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-18"><a href="#Effective-Java-Item-18" class="headerlink" title="Effective Java Item 18"></a>Effective Java Item 18</h2><blockquote><p>상속보다는 컴포지션을 사용하라 </p></blockquote><ul><li><code>상속(extends)</code>을 목적으로 설계되고, 문서화가 잘 된 클래스가 아니라면 상속하지 않는 것이 좋다. </li><li>특히 다른 패키지의 <code>구체 클래스를 상속</code>하는 것은 위험하다.</li></ul><br><h3 id="상속의-문제점"><a href="#상속의-문제점" class="headerlink" title="상속의 문제점"></a>상속의 문제점</h3><ul><li>상속은 상위 클래스의 구현에 따라 하위 클래스의 동작이 결정되기 때문에 캡슐화를 깨뜨린다.</li><li>위의 이유로 상위 클래스만 수정한 경우에 수정하지 않은 다른 클래스들의 오동작 할 수 있다. </li><li><strong>따라서 상속을 고려한 설계와 문서화가 필요하다(아이템 19)</strong></li></ul><br><ul><li>클래스 내에서 자신의 다른 부분을 사용하는 <code>자기사용(self-use)</code>은 클래스의 내부 구현 방식이다.</li><li>이런 방식은 다음에 코드가 그대로 유지될 지 알 수 없다.</li><li>따라서 이 방식에 의존한 상속은 위험하다. </li></ul><br><ul><li>구현하지 않고 상속 후 새 메소드만 추가하더라도 추후에 상위 클래스에 추가된 메소드와 겹치는 경우 문제가 발생할 수 있다. </li></ul><br><h3 id="상속-문제를-해결하기-위한-컴포지션-Composition"><a href="#상속-문제를-해결하기-위한-컴포지션-Composition" class="headerlink" title="상속 문제를 해결하기 위한 컴포지션(Composition)"></a>상속 문제를 해결하기 위한 컴포지션(Composition)</h3><ul><li><code>컴포지션(Composition)</code>은 기존 클래스를 extends 하는 대신 새로운 클래스를 만들고 <code>새 클래스의 private 필드</code>로 기존 클래스의 인스턴스를 참조하게 하는 <code>구조</code>이다.</li><li>즉 새로운 클래스가 기존 클래스의 구성요소로 쓰인다.</li></ul><h3 id="전달-Forwarding-클래스-메소드"><a href="#전달-Forwarding-클래스-메소드" class="headerlink" title="전달(Forwarding) 클래스/메소드"></a>전달(Forwarding) 클래스/메소드</h3><ul><li>새 클래스에서 기존 클래스에 해당하는 메소드를 호출해 결과를 반환한다.</li><li>위의 방식은 해당 클래스의 내부 구현 방식의 영향에서 벗어날 수 있다.</li><li>이런 <code>방식</code>을 <code>전달(forwarding)</code>이라 하며 이런 메소드들을 <code>전달 메소드(forwarding method)</code>라 한다. </li></ul><h3 id="래퍼-클래스-Wrapper-Class"><a href="#래퍼-클래스-Wrapper-Class" class="headerlink" title="래퍼 클래스(Wrapper Class)"></a>래퍼 클래스(Wrapper Class)</h3><ul><li>구현하려하는 클래스의 전달 클래스를 작성한 뒤 <code>extends</code>해서 새로운 기능을 덧씌울 수 있다.</li><li>이때 이런 클래스를 다른 인스턴스를 감싸고 있다는 의미에서 래퍼 클래스라고 한다.</li><li>또한 새로운 기능을 덧씌우기 때문에 <code>데코레이터 패턴(Decorator pattern)</code>이라고도 한다.</li><li>컴포지션과 전달을 함께 쓰고, 래퍼 객체가 내부 객체에 자신의 참조를 넘기는 경우를 <code>위임(delegation)</code>이라고도 한다.</li><li>래퍼 클래스는 콜백 프레임워크에서 주의해야한다. </li></ul><br><ul><li>A 클래스를 B 클래스가 상속하기 전에, B가 정말 A가 아니라면(is-a) 상속하면 안된다.</li><li>즉 A 클래스는 B의 구성요소가 아니라 구현 방법 중 하나 인 것.</li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-18&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-18&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 18&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Prefer interfaces to abstract classes</title>
    <link href="https://kodakyung.github.io/2019/01/12/programming-java-effective-java-2019-01-12-java-prefer-interfaces-to-abstract-classes/"/>
    <id>https://kodakyung.github.io/2019/01/12/programming-java-effective-java-2019-01-12-java-prefer-interfaces-to-abstract-classes/</id>
    <published>2019-01-11T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-20"><a href="#Effective-Java-Item-20" class="headerlink" title="Effective Java Item 20"></a>Effective Java Item 20</h2><blockquote><p>추상 클래스보다는 인터페이스를 우선하라</p></blockquote><br><h3 id="추상-클래스-vs-인터페이스"><a href="#추상-클래스-vs-인터페이스" class="headerlink" title="추상 클래스 vs 인터페이스"></a>추상 클래스 vs 인터페이스</h3><ul><li>추상 클래스의 경우 추상 클래스가 정의한 타입을 구현하기 위해 해당 클래스의 하위 클래스가 되어야한다.</li><li>자바는 단일 상속만 제공하기 때문에 추상 클래스는 제약이 있다.</li><li>인터페이스를 사용하는 경우 기존 클래스에도 손쉽게 새로운 인터페이스를 추가할 수 있다.</li><li>계층 구조가 없는 타입 프레임워크를 만들 수 있다. </li><li>개념을 계층적으로 표현하기 어려운 경우 적합하다. </li><li>Java 8부터 <code>default method</code>가 추가되어서 구현 방법이 명백한 경우 그것을 디폴트 메소드로 제공하는 것이 좋다. </li><li>디폴트 메소드 제공시 <code>@implSpec</code> JavaDoc 태그를 붙여 문서화해주는 것이 좋다. </li><li>디폴트 메소드는 Object 메소드를 제공해서는 안된다. (equals, hashcode 등)</li></ul><br><h3 id="추상-골격-구현-클래스"><a href="#추상-골격-구현-클래스" class="headerlink" title="추상 골격 구현 클래스"></a>추상 골격 구현 클래스</h3><ul><li>템플릿 메서드 패턴으로 인터페이스와 추상 클래스의 장점을 함께 사용하기도 한다.</li><li>이때 추상 클래스를 추상 골격 구현(skeletal implementation)이라 한다.</li><li>인터페이스의 이름 앞에 <code>Abstract</code>를 붙인다. (관례)</li><li>인터페이스는 타입과 디폴트 메소드를 정의하고 추상 골격 구현 클래스가 구체적인 나머지 메소드를 구현한다.</li><li>따라서 추상 골격 클래스를 <code>extends</code> 하는 것만으로 인터페이스를 구현하는 대다수의 일이 완료된다. </li></ul><br><ul><li>인터페이스 / 추상 골격 구현 클래스를 분리하는 구조는 <code>상황에 따라 선택</code>할 수 있어서 좋은 구조이다.</li><li>기본적으로 추상 클래스를 extends 하는 것만으로 인터페이스에 대한 구현이 끝나지만 클래스를 상속받을 수 없는 경우라도 인터페이스를 직접 구현할 수 있고 디폴트 메소드는 그대로 implements 할 수 있다.</li><li>또는 우회해서 인터페이스를 implements 한 클래스에서 골격 추상 클래스를 <code>private 내부 클래스</code>로 정의해 사용하는 방법이 있다. </li></ul><br><h3 id="골격-구현-클래스-작성-순서"><a href="#골격-구현-클래스-작성-순서" class="headerlink" title="골격 구현 클래스 작성 순서"></a>골격 구현 클래스 작성 순서</h3><ol><li>인터페이스에서 다른 메소드 들의 구현에 사용되는 기반 메소드 선정 </li><li>1의 기반 메소드를 사용해 직접 구현할 수 있는 경우 인터페이스 디폴트 메소드로 제공<br>: Object 메소드는 제공해선 안된다.</li><li>기반 or 디폴트 메소드 외에 메소드로 만들 메소드가 있다면 골격 구현 클래스에 남은 메소드를 작성한다.<br>: 모두 기반 or 디폴트 메소드라면 골격 구현 클래스를 만들 필요가 없다. </li></ol><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-20&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-20&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 20&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - Design and document for inheritance or else prohibit it</title>
    <link href="https://kodakyung.github.io/2019/01/11/programming-java-effective-java-2019-01-11-java-design-and-document-for-inheritance/"/>
    <id>https://kodakyung.github.io/2019/01/11/programming-java-effective-java-2019-01-11-java-design-and-document-for-inheritance/</id>
    <published>2019-01-10T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-Item-19"><a href="#Effective-Java-Item-19" class="headerlink" title="Effective Java Item 19"></a>Effective Java Item 19</h2><blockquote><p>상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라</p></blockquote><br><h3 id="상속용-클래스"><a href="#상속용-클래스" class="headerlink" title="상속용 클래스"></a>상속용 클래스</h3><ul><li>상속용 클래스는 <code>재정의할 수 있는 메소드</code>들을 <code>내부</code>적으로 <code>어떻게 이용</code>하는지 문서로 남겨야한다. </li><li><code>public</code>, <code>protected</code> 메소드 중 <code>final이 아닌 모든 재정의 가능한 메소드</code>는 재정의 가능 여부를 명시해 주어야 한다. </li></ul><br><h3 id="API-문서-명시"><a href="#API-문서-명시" class="headerlink" title="API 문서 명시"></a>API 문서 명시</h3><ul><li>API 문서 설명에 <code>Implementation Requirements</code>로 시작하는 절은 그 메소드의 내부 동작 방식을 설명한다. </li><li>메소드 주석에 <code>@implSpec</code> 태그를 붙이면 JavaDoc이 자동으로 생성해준다. </li><li><code>@implSpec</code> 태그는 커스텀 태그로 이름을 따로 지정할 수 있다. </li></ul><br><h3 id="상속을-고려한-클래스-설계"><a href="#상속을-고려한-클래스-설계" class="headerlink" title="상속을 고려한 클래스 설계"></a>상속을 고려한 클래스 설계</h3><ul><li>클래스 내부 동작 과정 중 끼어들 수 있는 hook 부분을 <code>protected</code> 메소드 형태로 공개하기도 한다. 또는 protected 필드로 공개하기도 한다. </li><li>예를 들면 <code>java.util.AbstractList</code>의 <code>clear</code> 메소드를 고성능으로 만들기 쉽게 하기 위해서 <code>removeRange</code>메소드를 제공해주는 것과 같다. </li><li>protected 메소드의 공개 여부를 결정하는데 가장 좋은 방법은 클래스를 직접 만들고 사용해보는 것이다.</li></ul><br><ul><li><strong>상속용 클래스의 생성자는 재정의 가능한 메소드를 호출하면 안된다.</strong></li><li>상속 받은 하위 클래스에서 재정의 하기 전에 상위 클래스의 생성자가 먼저 실행되기 때문에 의도하지 않은 결과가 발생할 수 있다.  </li></ul><br><ul><li><code>Cloneable</code>, <code>Serializable</code> 인터페이스를 상속한 경우에도 주의해야한다.</li><li><code>clone</code>, <code>readObject</code> 메소드의 경우에도 생성자와 비슷한 동작을 하기 때문에 재정의 가능 메소드를 호출해선 안된다. </li><li>Serializable을 구현한 상속용 클래스가 <code>readResolve</code>나 <code>writeReplace</code> 메소드를 구현한다면 하위 클래스에서 무시되지 않도록 protected로 선언 해야한다. </li></ul><br><h3 id="상속용으로-설계되지-않았다면"><a href="#상속용으로-설계되지-않았다면" class="headerlink" title="상속용으로 설계되지 않았다면.."></a>상속용으로 설계되지 않았다면..</h3><ul><li>상속용으로 설계되지 않은 클래스는 상속을 금하는 것이 좋다. </li><li>(1) 클래스를 <code>final</code>로 선언하거나 (2) 모든 생성자를 <code>private</code>/<code>package-private</code>로 선언하고 <code>public 정적 팩터리</code>를 만드는 두가지 방법이 있다. </li><li>상속을 꼭 허가해야 한다면 재정의 가능 메소드를 클래스 내부에서 사용하지 않게 문서로 남겨두어야 한다.</li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-Item-19&quot;&gt;&lt;a href=&quot;#Effective-Java-Item-19&quot; class=&quot;headerlink&quot; title=&quot;Effective Java Item 19&quot;&gt;&lt;/a&gt;Effective Java Item 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Test - Stub</title>
    <link href="https://kodakyung.github.io/2018/12/05/server-test-2018-12-05-test-stub/"/>
    <id>https://kodakyung.github.io/2018/12/05/server-test-2018-12-05-test-stub/</id>
    <published>2018-12-04T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.694Z</updated>
    
    <content type="html"><![CDATA[<h2 id="스텁-Stub-이란"><a href="#스텁-Stub-이란" class="headerlink" title="스텁(Stub)이란?"></a>스텁(Stub)이란?</h2><p>호출자를 실제 구현물로부터 격리시킬 목적으로 런타임에 실제 코드 대신 삽입되는 코드 조각이다. 실제 코드의 일부를 독립적으로 테스트하기 위해 쓰인다.<br>스텁은 로직이 없고 값만을 반환하기 때문에, 테스트 시 무조건 정해진 값을 반환한다고 가정한 경우 사용할 수 있다.<br>행위에 대한 검증은 mock을 이용한다. </p><h3 id="스텁을-사용하는-경우"><a href="#스텁을-사용하는-경우" class="headerlink" title="스텁을 사용하는 경우"></a>스텁을 사용하는 경우</h3><ul><li>시스템이 너무 복잡하고 깨지기 쉬워 수정이 불가한 경우</li><li>하부 시스템 간의 통합 테스트처럼 포괄적인 테스트를 수행하는 경우</li></ul><blockquote><p>스텁을 이용한 테스트의 신뢰도는 높은 편이다. 왜냐하면 대상 객체를 수정할 필요가 없어 production용 제품과 동일하기 때문이다.</p></blockquote><h3 id="스텁의-단점"><a href="#스텁의-단점" class="headerlink" title="스텁의 단점"></a>스텁의 단점</h3><ul><li>스텁은 대체하려는 코드와 동일한 로직을 갖추어야하므로 검증할 시스템이 복잡할수록 제작하기 어렵다.</li><li>제작이 복잡해 스텁 자체를 디버깅하는 상황도 발생한다.</li><li>복잡성 때문에 유지보수가 어려울 수 있다.</li><li>상세한(fine-grained) 테스트에 적합하지 않다.</li><li>상황에 따라 다른 스텁 정책이 요구된다.</li></ul><blockquote><p>일반적으로 포괄적인 코드 블록을 대체하는 것에 적합하다.<br>파일 시스템, 서버와의 커넥션, 데이터베이스 등 외부 시스템 전체를 대체하는데 주로 사용한다.<br>특정 메소드 하나를 대체하는 경우는 mock 객체로 상세한 테스트를 진행하는 것이 좋다.</p></blockquote><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;스텁-Stub-이란&quot;&gt;&lt;a href=&quot;#스텁-Stub-이란&quot; class=&quot;headerlink&quot; title=&quot;스텁(Stub)이란?&quot;&gt;&lt;/a&gt;스텁(Stub)이란?&lt;/h2&gt;&lt;p&gt;호출자를 실제 구현물로부터 격리시킬 목적으로 런타임에 실제 코드 
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Test" scheme="https://kodakyung.github.io/categories/server/test/"/>
    
    
      <category term="Test" scheme="https://kodakyung.github.io/tags/test/"/>
    
      <category term="Stub" scheme="https://kodakyung.github.io/tags/stub/"/>
    
  </entry>
  
  <entry>
    <title>Spring Data JPA - Query Method</title>
    <link href="https://kodakyung.github.io/2018/11/25/server-orm-2018-11-25-spring-data-jpa-query/"/>
    <id>https://kodakyung.github.io/2018/11/25/server-orm-2018-11-25-spring-data-jpa-query/</id>
    <published>2018-11-24T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="쿼리-메소드-Query-Method"><a href="#쿼리-메소드-Query-Method" class="headerlink" title="쿼리 메소드 (Query Method)"></a>쿼리 메소드 (Query Method)</h2><ul><li>메소드 이름만으로 쿼리를 생성하는 기능.</li><li>인터페이스에 메소드를 선언만 하면 해당 메소드 이름으로 적절한 JPQL 쿼리를 생성해 실행한다.</li></ul><br><h3 id="스프링-데이터-JPA가-제공하는-쿼리-메소드-기능"><a href="#스프링-데이터-JPA가-제공하는-쿼리-메소드-기능" class="headerlink" title="스프링 데이터 JPA가 제공하는 쿼리 메소드 기능"></a>스프링 데이터 JPA가 제공하는 쿼리 메소드 기능</h3><ol><li>메소드 이름으로 <code>쿼리 생성</code></li><li>메소드 이름으로 JPA <code>NamedQuery 호출</code></li><li><code>@Query</code> 어노테이션 사용해 리포지토리 인터페이스에 <code>쿼리 직접 정의</code></li></ol><blockquote><p>이 세가지 기능들만으로도 필요한 대부분의 쿼리 기능을 개발할 수 있다.</p></blockquote><br><h4 id="1-메소드-이름으로-쿼리-생성"><a href="#1-메소드-이름으로-쿼리-생성" class="headerlink" title="1. 메소드 이름으로 쿼리 생성"></a>1. 메소드 이름으로 쿼리 생성</h4><ul><li>예) 이메일과 이름으로 회원을 조회하려면<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Memeber</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Member&gt; <span class="title">findByEmailAndName</span><span class="params">(String email, String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>인터페이스에 정의한 <code>findByEmailAndName</code>를 실행하면 스프링 JPA가 메소드 이름을 분석해 JPQL을 생성하고 실행한다.</p><ul><li>아래와 같은 SQL이 실행된다.<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Member</span> m <span class="keyword">where</span> m.email = ?<span class="number">1</span> <span class="keyword">and</span> m.name = ?<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><p>정해진 규칙에 따라 이름을 지어야한다.</p><blockquote><p><a href="https://docs.spring.io/spring-data/jpa/docs/1.8.0.RELEASE/reference/html/" target="_blank" rel="noopener">참고</a></p></blockquote><br><h4 id="2-메소드-이름으로-JPA-NamedQuery-호출"><a href="#2-메소드-이름으로-JPA-NamedQuery-호출" class="headerlink" title="2. 메소드 이름으로 JPA NamedQuery 호출"></a>2. 메소드 이름으로 JPA NamedQuery 호출</h4><ul><li><p>스프링 데이터 JPA는 메소드 이름으로 JPA NamedQuery를 호출할 수 있다.  </p></li><li><p>JPA NamedQuery는 쿼리에 이름을 부여해 사용하는 방법을 칭한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@NamedQuery</span>(</span><br><span class="line">  name=<span class="string">"Member.findByUsername"</span>,</span><br><span class="line">  query=<span class="string">"select m from Member m where m.username = :username"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>위와 같이 어노테이션에 쿼리를 정의할 수 있다.</p></li></ul><br><ul><li>또는 xml에 쿼리를 정의할 수 있다.<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">named-query</span> <span class="attr">name</span>=<span class="string">"Member.findByUsername"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">query</span>&gt;</span><span class="tag">&lt;<span class="name">CDATA[</span></span></span><br><span class="line"><span class="tag">      <span class="attr">select</span> <span class="attr">m</span></span></span><br><span class="line"><span class="tag">      <span class="attr">from</span> <span class="attr">Member</span> <span class="attr">m</span></span></span><br><span class="line"><span class="tag">      <span class="attr">where</span> <span class="attr">m.username</span> = <span class="string">:username</span></span></span><br><span class="line"><span class="tag">      ]&gt;</span><span class="tag">&lt;/<span class="name">query</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">named-query</span>&gt;</span></span><br><span class="line">  ```  </span><br><span class="line">- 위와 같은 방법들로 Named 네이티브 쿼리도 지원한다.</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">- 정의한 NamedQuery를 직접 호출하려면 아래와 같이 작성한다.</span><br><span class="line">  ```java</span><br><span class="line">  pulic class MemberRepository &#123;</span><br><span class="line">    public List<span class="tag">&lt;<span class="name">Member</span>&gt;</span> findByUsername(String username) &#123;</span><br><span class="line">      ...</span><br><span class="line">      List<span class="tag">&lt;<span class="name">Member</span>&gt;</span> resultList =</span><br><span class="line">        em.createNamedQuery("Member.findByUsername", Member.class)</span><br><span class="line">          .setParameter("username", "회원1")</span><br><span class="line">          .getResultList();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><br><ul><li><p>스프링 데이터 JPA를 사용하면 메소드 이름만으로 NamedQuery를 호출할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123; <span class="comment">// 여기 선언한 Member 도메인 클래스</span></span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Member&gt; <span class="title">findByUsername</span><span class="params">(@Param(<span class="string">"username"</span>)</span> String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>&quot;도메인 클래스 + . + 메소드 이름&quot;</code>으로 NamedQuery를 찾기 때문에 Member.findByUsername이라는 NamedQuery를 찾아 실행하게 된다.</p></li></ul><br><h4 id="3-Query-어노테이션-사용해-리포지토리-인터페이스에-쿼리-직접-정의"><a href="#3-Query-어노테이션-사용해-리포지토리-인터페이스에-쿼리-직접-정의" class="headerlink" title="3. @Query 어노테이션 사용해 리포지토리 인터페이스에 쿼리 직접 정의"></a>3. @Query 어노테이션 사용해 리포지토리 인터페이스에 쿼리 직접 정의</h4><ul><li><p>리포지토리 메소드에 직접 쿼리를 정의하는 경우 @Query 어노테이션 사용</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select m from Member m where m.username= ?1"</span>)</span><br><span class="line">  <span class="function">Member <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>위 방법은 실행할 메소드에 정적 쿼리를 직접 작성해서 이름 없는 NamedQuery이다.</p></li></ul><br><ul><li>Native SQL을 사용하려면 @Query 어노테이션에 nativeQuery = true 옵션을 준다.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(value=<span class="string">"SELECT * FROM MEMBER USERNAME = ?0"</span>, nativeQuery = <span class="keyword">true</span>)</span><br><span class="line">  <span class="function">Member <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><br><h3 id="파라미터-바인딩"><a href="#파라미터-바인딩" class="headerlink" title="파라미터 바인딩"></a>파라미터 바인딩</h3><p>스프링 데이터 JPA는 위치 기반 파라미터 바인딩과 이름 기반 파라미터 바인딩을 모두 지원한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Member</span> m <span class="keyword">where</span> m.username = ?<span class="number">1</span> // 위치 기반</span><br><span class="line"><span class="keyword">select</span> m <span class="keyword">from</span> <span class="keyword">Member</span> m <span class="keyword">where</span> m.username = :<span class="keyword">name</span> // 이름 기반</span><br></pre></td></tr></table></figure><p>이름 기반 파라미터 바인딩을 사용하려면 <code>@Param(org.springframework.data.repository.query.Param)</code> 어노테이션을 사용해야한다. 코드 가독성과 유지 보수를 위해 이름 기반 파라미터 바인딩을 사용하는 것이 좋다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Member</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Query</span>(<span class="string">"select m from Member m where m.username = :name"</span>)</span><br><span class="line">  <span class="function">Member <span class="title">findByUsername</span><span class="params">(@Param(<span class="string">"name"</span>)</span> String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="반환-타입"><a href="#반환-타입" class="headerlink" title="반환 타입"></a>반환 타입</h3><p>스프링 데이터 JPA의 반환 타입은 유연해서, 결과가 한 건 이상이면 컬렉션 인터페이스를, 한 건이면 반환 타입을 지정해주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Member&gt; <span class="title">findByName</span><span class="params">(String name)</span></span>; <span class="comment">// Collection (1)</span></span><br><span class="line"><span class="function">Member <span class="title">findByEmail</span><span class="params">(String email)</span></span>; <span class="comment">// return type (2)</span></span><br></pre></td></tr></table></figure><p>만약 조회 결과가 없다면 (1)은 빈 컬렉션을, (2)는 null을 반환한다.<br>(2)와 같이 작성하고 반환 결과가 2건 이상이면 <code>javax.persistence.NonUniqueResultException</code> 예외가 발생한다.<br>그리고 한 건을 조회 했을 때 JPA 내부에서 <code>Query.getSingleResult()</code>를 호출하는데, 이 메소드는 조회 결과가 없으면 <code>javax.persistence.NoResultException</code> 예외가 발생한다. 이 예외가 발생했을 때 스프링 데이터 JPA는 예외를 무시하고 null을 반환한다.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;쿼리-메소드-Query-Method&quot;&gt;&lt;a href=&quot;#쿼리-메소드-Query-Method&quot; class=&quot;headerlink&quot; title=&quot;쿼리 메소드 (Query Method)&quot;&gt;&lt;/a&gt;쿼리 메소드 (Query Method)&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="ORM" scheme="https://kodakyung.github.io/categories/server/orm/"/>
    
    
      <category term="Spring" scheme="https://kodakyung.github.io/tags/spring/"/>
    
      <category term="Hibernate" scheme="https://kodakyung.github.io/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>JPA - Cascade</title>
    <link href="https://kodakyung.github.io/2018/11/16/server-orm-2018-11-16-jpa-cascade/"/>
    <id>https://kodakyung.github.io/2018/11/16/server-orm-2018-11-16-jpa-cascade/</id>
    <published>2018-11-15T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.691Z</updated>
    
    <content type="html"><![CDATA[<p>영속성 전이와 고아 객체</p><h2 id="영속성-전이-Transitive-Persistence"><a href="#영속성-전이-Transitive-Persistence" class="headerlink" title="영속성 전이(Transitive Persistence)"></a>영속성 전이(Transitive Persistence)</h2><ul><li>연관된 객체를 함께 저장하거나 함께 삭제할 수 있는 JPA에서 제공하는 기능.</li><li>특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶은 경우 사용.</li><li><code>CASCADE</code> 옵션</li></ul><blockquote><p>즉, 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장할 수 있다.</p></blockquote><br><ul><li>CASCADE 설정이 없는 경우</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// save parent</span></span><br><span class="line">Parent parent = <span class="keyword">new</span> Parent();</span><br><span class="line">em.persist(parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// save child1</span></span><br><span class="line">Child child1 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.setParent(parent); <span class="comment">// child1 &gt; parent 연관관계 설정</span></span><br><span class="line">parent.getChildren().add(child1); <span class="comment">// parent &gt; child1</span></span><br><span class="line">em.persist(child1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// save child2</span></span><br><span class="line">Child child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child2.setParent(parent); <span class="comment">// child2 &gt; parent</span></span><br><span class="line">parent.getChildren().add(child2); <span class="comment">// parent &gt; child2</span></span><br><span class="line">em.persist(child2);</span><br></pre></td></tr></table></figure><ul><li>JPA에서 Entity를 저장할 때 연관된 모든 엔티티가 영속 상태여야 하기 때문에 관련된 모든 엔티티를 각각 영속화했다.</li></ul><br><h3 id="영속성-전이-저장"><a href="#영속성-전이-저장" class="headerlink" title="영속성 전이: 저장"></a>영속성 전이: 저장</h3><ul><li>CASCADE 설정</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"parent"</span>, cascade = CascadeType.PERSIST) <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;Child&gt;();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(1) 부모를 영속화할 때 연관된 자식들도 함께 영속화 하는 옵션이다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Child child1 = <span class="keyword">new</span> Child();</span><br><span class="line">Child child2 = <span class="keyword">new</span> Child();</span><br><span class="line"></span><br><span class="line">Parent parent = <span class="keyword">new</span> Parent();</span><br><span class="line">child1.setParent(parent); <span class="comment">// 연관관계 설정</span></span><br><span class="line">child2.setParent(parent); <span class="comment">// 연관관계 설정</span></span><br><span class="line">parent.getChildren().add(child1);</span><br><span class="line">parent.getChildren().add(child2);</span><br><span class="line"></span><br><span class="line">em.persist(parent) <span class="comment">// 부모, 자식 한번에 저장</span></span><br></pre></td></tr></table></figure><br><h3 id="영속성-전이-삭제"><a href="#영속성-전이-삭제" class="headerlink" title="영속성 전이: 삭제"></a>영속성 전이: 삭제</h3><ul><li>CASCADE 설정이 없는 경우  </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Parent findParent = em.find(Parent.class, <span class="number">1l</span>);</span><br><span class="line">Child findChild1 = em.find(Child.class, <span class="number">1l</span>);</span><br><span class="line">Child findChild2 = em.find(Child.class, <span class="number">2l</span>);</span><br><span class="line"></span><br><span class="line">em.remove(findChild1);</span><br><span class="line">em.remove(findChild2);</span><br><span class="line">em.remove(findParent);</span><br></pre></td></tr></table></figure><ul><li><p>각각 엔티티를 하나씩 제거해야한다.</p></li><li><p>CASCADE 설정(<code>CascadeType.REMOVE</code>)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent findParent = em.find(Parent.class, <span class="number">1l</span>);</span><br><span class="line">em.remove(findParent);</span><br></pre></td></tr></table></figure><ul><li>연관된 엔티티를 모두 삭제한다(내부적으로 DELETE SQL을 3번 호출한다)</li><li>CascadeType.REMOVE를 설정하지 않고 위 코드를 실행하면 <code>외래키 무결성 예외</code>가 발생한다.</li></ul><br><h3 id="CASCADE-종류"><a href="#CASCADE-종류" class="headerlink" title="CASCADE 종류"></a>CASCADE 종류</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CascadeType &#123;</span><br><span class="line">  ALL,      <span class="comment">// 모두 적용</span></span><br><span class="line">  PERSIST,  <span class="comment">// 영속</span></span><br><span class="line">  MERGE,    <span class="comment">// 병합</span></span><br><span class="line">  REMOVE,   <span class="comment">// 삭제</span></span><br><span class="line">  REFRESH,  <span class="comment">// REFRESH</span></span><br><span class="line">  DETACH    <span class="comment">// DETACH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>여러 속성을 같이 사용할 수 있다.</li><li>PERSIST, REMOVE는 em.persist(), em.remove()할 때 전이가 일어나는 것이 아닌 flush할 때 전이가 발생한다.</li></ul><br><h2 id="고아-객체-ORPHAN"><a href="#고아-객체-ORPHAN" class="headerlink" title="고아 객체(ORPHAN)"></a>고아 객체(ORPHAN)</h2><p>부모 Entity와 연관관계가 끊어진 자식 Entity를 자동으로 삭제하는 기능을 고아 객체 제거라 한다.<br>즉, 부모 Entity의 컬렉션에서 자식 Entity의 참조만 제거하면 자식 Entity가 자동으로 삭제된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span> <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@OneToMany</span>(mappedBy = <span class="string">"parent"</span>, orphanRemoval = <span class="keyword">true</span>) <span class="comment">// (1)</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Child&gt; children = <span class="keyword">new</span> ArrayList&lt;Child&gt;();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent parent1 = em.find(Parent.class, id);</span><br><span class="line">parent1.getChildren().remove(<span class="number">0</span>); <span class="comment">// 자식 Entity를 컬렉션에서 제거</span></span><br></pre></td></tr></table></figure><ul><li>실행 결과 SQL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span>=?</span><br></pre></td></tr></table></figure><ul><li>고아 객체 제거 기능은 flush 시점에 적용된다.</li></ul><br><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><ul><li>참조가 제거된 엔티티는 다른 곳에서 참조하지 않으므로 삭제한다.</li><li>참조하는 곳이 하나일 때만 사용해야 한다.</li><li>따라서 <code>@OneToOne</code>, <code>@OneToMany</code>에서만 사용가능하다.</li><li>부모 객체를 제거하면 자식도 같이 제거된다. ( = <code>CascadeType.REMOVE</code>)</li></ul><br><h2 id="영속성-전이-고아-객체-생명주기"><a href="#영속성-전이-고아-객체-생명주기" class="headerlink" title="영속성 전이 + 고아 객체, 생명주기"></a>영속성 전이 + 고아 객체, 생명주기</h2><ul><li><p><code>CascadeType.All</code> + <code>orphanRemoval = true</code>를 동시에 사용한다면 ?</p><blockquote><p>부모 엔티티를 통해 자식 엔티티 생명주기를 관리할 수 있다.</p></blockquote></li><li><p>자식을 저장하려면 부모에 등록만 하면 된다.</p></li><li><p>자식을 삭제하려면 부모에서 제거하면 된다.</p></li></ul><br><ul><li>참고<blockquote><p>영속성 전이는 DDD의 Aggregate Root 구현시 편리하다.</p></blockquote></li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;영속성 전이와 고아 객체&lt;/p&gt;
&lt;h2 id=&quot;영속성-전이-Transitive-Persistence&quot;&gt;&lt;a href=&quot;#영속성-전이-Transitive-Persistence&quot; class=&quot;headerlink&quot; title=&quot;영속성 전이(Transi
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="ORM" scheme="https://kodakyung.github.io/categories/server/orm/"/>
    
    
      <category term="Hibernate" scheme="https://kodakyung.github.io/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>JPA - Proxy / Eager &amp; Lazy Loading</title>
    <link href="https://kodakyung.github.io/2018/11/15/server-orm-2018-11-15-jpa-proxy/"/>
    <id>https://kodakyung.github.io/2018/11/15/server-orm-2018-11-15-jpa-proxy/</id>
    <published>2018-11-14T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.690Z</updated>
    
    <content type="html"><![CDATA[<p>프록시와 즉시로딩, 지연로딩</p><h2 id="프록시-Proxy"><a href="#프록시-Proxy" class="headerlink" title="프록시(Proxy)"></a>프록시(Proxy)</h2><ul><li><p>프록시를 사용하면 연관된 객체를 DB에서 처음부터 조회하는 것이 아니라, 실제 사용하는 시점에 DB에서 조최할 수 있다(<code>Lazy Loading</code>). 하지만 자주 함께 사용하는 객체들은 조인을 사용해서 함께 조회하는 것이 효과적이다(<code>Eager Loading</code>). 이를 즉시 로딩과 지연 로딩 두 가지 방식으로 사용할 수 있다.</p></li><li><p>지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신 DB 조회를 지연할 수 있는 가짜 객체가 필요하다. 이를 프록시 객체라 한다.</p></li></ul><blockquote><p>JPA 지연 로딩의 구현 방법을 JPA 구현체에 위임했기 때문에 JPA마다 다르다.<br>참고하는 자료는 Hibernate 기준으로 작성되었다.</p></blockquote><br><h3 id="프록시-기초"><a href="#프록시-기초" class="headerlink" title="프록시 기초"></a>프록시 기초</h3><ul><li><p>JPA에서 식별자로 Entity 하나를 조회할 경우</p><blockquote><p>EntityManager.find()</p></blockquote><ul><li>이렇게 엔티티를 조회하면 엔티티 사용여부와 상관없이 DB를 직접 조회하게 된다.</li></ul></li><li><p>사용 시점까지 Entity 조회를 미루고 싶은 경우</p><blockquote><p>EntityManager.getReference()</p></blockquote><ul><li>이 메소드를 호출하면 JPA가 DB를 바로 조회하지 않고 엔티티 객체를 생성하지도 않는다. 대신 DB 접근을 위임한 프록시 객체를 반환한다.</li><li>Proxy { Entity target = null / getId() / getName()}</li></ul></li></ul><br><h4 id="프록시의-특징"><a href="#프록시의-특징" class="headerlink" title="프록시의 특징"></a>프록시의 특징</h4><h5 id="프록시의-구조"><a href="#프록시의-구조" class="headerlink" title="프록시의 구조"></a>프록시의 구조</h5><ul><li>프록시 클래스는 실제 클래스를 상속 받아 만들어지기 때문에 실제 클래스와 겉 모양이 같다. 따라서 사용자는 실제 객체인지 프록시 객체인지 구분하지 않고 사용할 수 있다.</li><li>ex) Entity가 id, name, getId(), getName()으로 되어있다면 Proxy는 Entity target, getId(), getName()으로 되어있음</li></ul><h5 id="프록시-위임"><a href="#프록시-위임" class="headerlink" title="프록시 위임"></a>프록시 위임</h5><ul><li>프록시 객체는 실제 객체에 대한 참조(<code>target</code>)를 보관하고, 프록시 객체의 메소드를 호출할 때 프록시 객체가 실제 객체의 메소드를 호출한다.</li></ul><h4 id="프록시-객체의-초기화"><a href="#프록시-객체의-초기화" class="headerlink" title="프록시 객체의 초기화"></a>프록시 객체의 초기화</h4><ul><li><p>프록시 객체는 실제 사용될 때(ex-member.getName() 등) DB를 조회해 실제 엔티티 객체를 생성하는데 이것이 프록시 객체의 초기화이다.</p></li><li><p>예제</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entity</span></span><br><span class="line"><span class="comment">// MemberProxy 반환</span></span><br><span class="line">Member member = em.getReference(Member.class, <span class="string">"id"</span>);</span><br><span class="line">member.getName(); <span class="comment">// (1) getName();</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Proxy</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberProxy</span> <span class="keyword">extends</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  Member target = <span class="keyword">null</span>; <span class="comment">// 실제 엔티티 참조</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// (2) 초기화 (영속성 컨텍스트로) 요청</span></span><br><span class="line">      <span class="comment">// (3) DB 조회</span></span><br><span class="line">      <span class="comment">// (4) 실제 엔티티 생성 및 참조 보관</span></span><br><span class="line">      <span class="keyword">this</span>.target = ... ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (5) target.getName();</span></span><br><span class="line">    <span class="keyword">return</span> target.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(2) 실제 엔티티가 생성되어 있지 않으면 영속성 컨텍스트에 <code>엔티티 생성을 요청</code>하는데 이것을 <code>프록시 초기화</code>라 한다.</li><li>(3) 영속성 컨텍스트가 DB를 조회해 실제 엔티티 객체를 생성한다.</li><li>(4) 그리고 생성한 실제 엔티티 객체의 참조를 <code>target</code> 변수에 보관한다.</li></ul><br><h4 id="프록시의-특징-1"><a href="#프록시의-특징-1" class="headerlink" title="프록시의 특징"></a>프록시의 특징</h4><ul><li>처음 사용할 때 한 번만 초기화 된다.</li><li>프록시 객체를 초기화한다고해서 프록시 객체가 실제 엔티티로 바뀌는 것은 아니고, 프록시 객체 초기화 후 프록시 객체를 통해 실제 엔티티에 접근할 수 있는 것이다.</li><li>프록시 객체는 원본 엔티티를 상속받은 객체이므로 타입 체크 시 주의해서 사용해야한다.</li><li>영속성 컨텍스트에 찾는 엔티티가 이미 있다면 DB를 조회할 필요가 없으므로 <code>em.getReference()</code>를 호출해도 실제 엔티티를 반환한다.</li><li>초기화는 영속성 컨텍스트의 도움을 받아야 가능하기 때문에, <code>준영속 상태</code>의 프록시를 초기화하면 문제가 생긴다.<ul><li><code>org.hibernate.LazyInitializationException</code> Hibernate의 예외 발생</li></ul></li></ul><br><h4 id="준영속-상태와-초기화"><a href="#준영속-상태와-초기화" class="headerlink" title="준영속 상태와 초기화"></a>준영속 상태와 초기화</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MemberProxy 반환</span></span><br><span class="line">Member member = em.getReference(Member.class, <span class="string">"id"</span>);</span><br><span class="line">transaction.commit();</span><br><span class="line">em.close(); <span class="comment">// 영속성 컨텍스트 종료</span></span><br><span class="line"></span><br><span class="line">member.getName(); <span class="comment">// 준영속 상태 초기화 시도 &gt; 예외 발생</span></span><br></pre></td></tr></table></figure><br><h3 id="프록시와-식별자"><a href="#프록시와-식별자" class="headerlink" title="프록시와 식별자"></a>프록시와 식별자</h3><ul><li>Entity를 Proxy로 조회할 때 식별자(Primary Key)값을 파라미터로 전달한다. 이 때 프록시 객체는 이 식별자 값을 보관한다. 따라서 식별자 값을 조회하는 Entity.getId()를 호출해도 프록시를 초기화하지 않는다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Member member = em.getReference(Member.class, <span class="string">"id"</span>); <span class="comment">// 식별자 보관</span></span><br><span class="line">member.getId(); <span class="comment">// 초기화되지 않는다.</span></span><br></pre></td></tr></table></figure><ul><li>엔티티 접근 방식을 <code>@Access(AccessType.PROPERTY))</code>로 설정한 경우에만 초기화하지 않는다.</li><li>엔티티 접근 방식을 <code>@Access(AccessType.FIELD))</code>로 설정하면 id만 조회하는지 아닌지 구분할 수 없어서 프록시 객체를 초기화한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Member member = em.find(Member.class, <span class="string">"member_id"</span>);</span><br><span class="line">Team team = em.getReference(Team.class, <span class="string">"team_id"</span>); <span class="comment">// sql을 실행하지 않는다.</span></span><br><span class="line">member.setTeam(team);</span><br></pre></td></tr></table></figure><br><h3 id="프록시-확인"><a href="#프록시-확인" class="headerlink" title="프록시 확인"></a>프록시 확인</h3><ul><li>JPA의 <code>PersistenceUnitUtil.isLoaded(Object entity)</code> 메소드를 사용하면 프록시 인스턴스 초기화 여부를 알 수 있다. 결과는 boolean 값이다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isLoad = em.getEntityManager.Factory()</span><br><span class="line">                    .getPersistenceUnitUtil().isLoaded(entity);</span><br><span class="line"><span class="comment">// Or boolean isLoad = emf.getPersistenceUnitUtil.isLoaded(entity);</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"isLoad = "</span> + isLoad); <span class="comment">// 초기화 여부</span></span><br></pre></td></tr></table></figure><ul><li>조회한 엔티티가 프록시인지 아닌지 확인하려면 클래스명을 출력해보면된다. 클래스 명 뒤에 <code>..javassist..</code>가 있다면 프록시이다. 출력은 라이브러리에 따라 달라질 수 있다.</li></ul><br><h2 id="즉시-로딩과-지연-로딩"><a href="#즉시-로딩과-지연-로딩" class="headerlink" title="즉시 로딩과 지연 로딩"></a>즉시 로딩과 지연 로딩</h2><blockquote><p>member1이 team1에 소속되어 있는 경우</p></blockquote><h3 id="즉시-로딩"><a href="#즉시-로딩" class="headerlink" title="즉시 로딩"></a>즉시 로딩</h3><ul><li>엔티티를 조회할 때 연관된 엔티티도 함께 조회한다.</li><li>ex) <code>em.find(Member.class, &quot;member1&quot;);</code> 호출 시 회원 엔티티와 연관된 팀 엔티티도 함께 조회.</li><li>설정 : <code>@ManyToOne(fetch = FetchType.EAGER)</code></li></ul><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@ManyToOne</span>(fetch = FetchType.EAGER)</span><br><span class="line">  <span class="meta">@JoinColumn</span>(name = <span class="string">"TEAM_ID"</span>)</span><br><span class="line">  <span class="keyword">private</span> Team team;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Member member = em.find(Member.class, <span class="string">"member1"</span>); <span class="comment">// (1)</span></span><br><span class="line">Team team = member.getTeam(); <span class="comment">// (2) 객체 그래프 탐색</span></span><br></pre></td></tr></table></figure><ul><li>(1) 회원을 조회하는 순간 팀도 함께 조회한다.</li><li>(1)(2) 쿼리를 여러번 실행하는 것이 아닌, 보통 최적화를 위해 <code>join</code>쿼리를 사용해 쿼리 한번에 두 엔티티를 조회한다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  m.memeber_id <span class="keyword">as</span> member_id,</span><br><span class="line">  m.team_id <span class="keyword">as</span> team_id,</span><br><span class="line">  m.username <span class="keyword">as</span> username,</span><br><span class="line">  t.team_id <span class="keyword">as</span> team_id,</span><br><span class="line">  t.name <span class="keyword">as</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  <span class="keyword">member</span> m <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> team t <span class="comment">-- (1) outer join</span></span><br><span class="line">    <span class="keyword">on</span> m.team_id = t.team_id</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  m.member_id = <span class="string">'member1'</span></span><br></pre></td></tr></table></figure><h4 id="Null-제약-조건"><a href="#Null-제약-조건" class="headerlink" title="Null 제약 조건"></a>Null 제약 조건</h4><ul><li><p>현재 회원 테이블의 team_id 외래키에 null값이 허용되어 있기 때문에 외부 조인(outer join)을 사용한다.</p></li><li><p>최적화를 위해 내부 조인(inner join)을 사용하려면 외래키에 <code>not null</code> 제약 조건을 걸어야 한다.</p></li><li><p>그리고 JPA에 알려주는 설정을 해야한다.</p></li><li><p><code>@JoinColumn(nullable = true)</code> : null 허용, 외부 조인 사용, 기본값</p></li><li><p><code>@JoinColumn(nullable = false)</code> : null 허용하지 않음, 내부 조인 사용</p></li><li><p><code>@ManyToOne(fetch = FetchType.EAGER, optional = false)</code> : 이 설정도 내부 조인을 사용한다.</p></li></ul><blockquote><p>선택적 관계면 외부 조인, 필수 관계면 내부 조인을 사용</p></blockquote><br><h3 id="지연로딩"><a href="#지연로딩" class="headerlink" title="지연로딩"></a>지연로딩</h3><ul><li>연관된 엔티티를 실제 사용할 때 조회한다.</li><li>ex) <code>member.getTeam().getName()</code>과 같이 조회한 팀 엔티티를 실제 사용하는 시점에 JPA가 SQL을 호출해 팀 엔티티를 조회한다.</li><li>설정 : <code>@ManyToOne(fetch = FetchType.LAZY)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="meta">@ManyToOne</span>(fetch = FetchType.LAZY)</span><br><span class="line">  <span class="meta">@JoinColumn</span>(name = <span class="string">"team_id"</span>)</span><br><span class="line">  <span class="keyword">private</span> Team team;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Member member = em.find(Member.class, <span class="string">"member1"</span>); <span class="comment">// (1)</span></span><br><span class="line">Team team = member.getTeam(); <span class="comment">// (2) 객체 그래프 탐색</span></span><br><span class="line">team.getName(); <span class="comment">// (3) 팀 객체 실제 사용</span></span><br></pre></td></tr></table></figure><ul><li>(1)에서 회원 조회시 회원만 조회하고 회원의 팀 변수에(<code>Member.team</code>)에 프록시 객체를 넣는다.</li><li>(2)에서 반환하는 것은 프록시 객체이다.</li><li>이 프록시 객체가 실제 사용될 때(3)까지 데이터 로딩을 미룬다.</li><li>즉 데이터가 필요한 순간에 데이터베이스를 조회해서 프록시 객체를 초기화한다.</li></ul><br><ul><li>(1) 호출 시 실행되는 SQL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">member</span></span><br><span class="line"><span class="keyword">where</span> member_id = <span class="string">'member1'</span></span><br></pre></td></tr></table></figure><ul><li>(3) 호출 시 실행되는 SQL</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> team</span><br><span class="line"><span class="keyword">where</span> team_id = <span class="string">'team1'</span></span><br></pre></td></tr></table></figure><br><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul><li>지연 로딩(Lazy Loading) : 연관된 엔티티를 프록시로 조회. 프록시를 실제 사용할 때 초기화하면서 DB를 조회한다.</li><li>즉시 로딩(Eager Loading) : 연관된 엔티티를 즉시 조회, Hibernate라면 가능한 SQL join을 사용해 한번에 조회한다.</li></ul><br><h3 id="지연-로딩의-활용"><a href="#지연-로딩의-활용" class="headerlink" title="지연 로딩의 활용"></a>지연 로딩의 활용</h3><h4 id="프록시와-컬렉션-래퍼"><a href="#프록시와-컬렉션-래퍼" class="headerlink" title="프록시와 컬렉션 래퍼"></a>프록시와 컬렉션 래퍼</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Member member = em.find(Member.class, <span class="string">"member1"</span>);</span><br><span class="line">List&lt;Order&gt; orders = member.getOrders(); <span class="comment">// (1)</span></span><br><span class="line">System.out.println(<span class="string">"orders = "</span> + orders.getClass().getName()); <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><ul><li><p>Hibernate는 Entity를 영속 상태로 만들 때 Entity에 컬렉션이 있으면 컬렉션을 추적, 관리할 목적으로 원본 컬렉션을 Hibernate가 제공하는 내장 컬렉션으로 변경한다. 이를 컬렉션 래퍼라 한다.</p></li><li><p>(2)의 출력 결과는 <code>org.hibernate.collection.internal.PersistentBag</code>이다.</p></li><li><p>Entity 지연 로딩할 때는 프록시 객체를 사용해 지연 로딩을 수행한다. 하지만 컬렉션은 컬렉션 래퍼가 지연 로딩을 수행한다. 컬랙션 래퍼는 컬렉션에 대한 프록시 역할을 한다.</p></li><li><p>(1)을 호출해도 컬렉션이 초기화되지 않는다. <code>member.getOrders.get(0)</code>과 같이 실제 데이터를 조회할 때 DB에서 조회해서 초기화한다.</p></li></ul><br><h4 id="JPA-기본-Fetch-전략"><a href="#JPA-기본-Fetch-전략" class="headerlink" title="JPA 기본 Fetch 전략"></a>JPA 기본 Fetch 전략</h4><ul><li>@ManyToOne, @OneToOne : FetchType.EAGER</li><li>@OneToMany, @ManyToMany : FetchType.LAZY</li></ul><blockquote><p>기본적으로 연관된 엔티티가 하나면 즉시 로딩, 컬렉션이면 지연 로딩</p></blockquote><ul><li>개발 시 모든 연관관계에 지연 로딩을 사용하고, 앱 개발이 완료 단계가 되었을 때 실제 사용 상황을 보고 필요한 곳만 즉시 로딩을 사용하도록하는 것이 좋다.<ul><li>SQL을 직접 사용할 경우 이런식의 변경은 어렵다.</li></ul></li></ul><h4 id="컬렉션에-FetchType-EAGER-사용-시-주의점"><a href="#컬렉션에-FetchType-EAGER-사용-시-주의점" class="headerlink" title="컬렉션에 FetchType.EAGER 사용 시 주의점"></a>컬렉션에 FetchType.EAGER 사용 시 주의점</h4><ul><li>컬렉션을 하나 이상 즉시 로딩하는 것은 좋지 않다.</li><li>컬렉션 즉시 로딩은 항상 외부조인(outer join)을 사용한다.</li></ul><br><h4 id="기본-조인-전략-정리"><a href="#기본-조인-전략-정리" class="headerlink" title="기본 조인 전략 정리"></a>기본 조인 전략 정리</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- @ManyToOne, @OneToOne</span><br><span class="line">  - (optional = false) : inner join</span><br><span class="line">  - (optional = true) : outer join</span><br><span class="line">- @OneToMany, @ManyToMany</span><br><span class="line">  - (optional = false) : outer join</span><br><span class="line">  - (optional = true) : outer join</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>자바 ORM 표준 JPA 프로그래밍</li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;프록시와 즉시로딩, 지연로딩&lt;/p&gt;
&lt;h2 id=&quot;프록시-Proxy&quot;&gt;&lt;a href=&quot;#프록시-Proxy&quot; class=&quot;headerlink&quot; title=&quot;프록시(Proxy)&quot;&gt;&lt;/a&gt;프록시(Proxy)&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;프록시를 사용하
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="ORM" scheme="https://kodakyung.github.io/categories/server/orm/"/>
    
    
      <category term="Hibernate" scheme="https://kodakyung.github.io/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>JPA 테스트의 특징</title>
    <link href="https://kodakyung.github.io/2018/11/10/server-test-2018-11-10-jpa-junit-test/"/>
    <id>https://kodakyung.github.io/2018/11/10/server-test-2018-11-10-jpa-junit-test/</id>
    <published>2018-11-09T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JPA-TEST"><a href="#JPA-TEST" class="headerlink" title="JPA TEST"></a>JPA TEST</h2><p>JPA는 <code>엔티티 매핑</code> / <code>API 호출</code> 두 부분으로 나뉜다.  </p><ol><li>처음에는 객체가 어떻게 DB 테이블에 매핑되는지 정의한다.<ul><li>보통 자바 Annotation 이용</li></ul></li><li>다음으로 EntityManager 객체를 이용해 이 객체들을 DB에 저장하거나 읽어온다.<ul><li>JPA 쿼리를 사용해 객체를 만들고 지우고 전달하는 등의 작업</li></ul></li></ol><p>따라서 위의 두가지를 독립적으로 테스트해야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 올바르게 매핑되었는지 검증하는 테스트.</span><br><span class="line">2. 영속 코드 자체(예-DAO 등)를 위한 단위 테스트.</span><br></pre></td></tr></table></figure><h2 id="임베디드-데이터베이스"><a href="#임베디드-데이터베이스" class="headerlink" title="임베디드 데이터베이스"></a>임베디드 데이터베이스</h2><p> 임베디드 데이터베이스의 경우 애플리케이션이 사용할 데이터베이스와 100% 호환이 되지 않을 수있다는 단점이 있다. 하지만 JPA를 사용하면 일반적인 경우 호환성에 문제가 생기진 않는다. JPA 벤더가 SQL 코드를 생성하기 때문이다. <strong>따라서 단위 테스트에 임베디드 데이터베이스(H2 등)을 사용하는 것이 좋다.</strong><br> 프로젝트는 기본적으로 임베디드 데이터베이스를 사용하고, 데이터베이스를 쉽게 변경 가능하도록 만드는 것이 좋다. 개발자는 임베디드데이터베이스를 이용하고 공식 빌드에서 실제 DB로 교체하는 등으로 사용한다.</p><h2 id="위임-수준-commitment-level"><a href="#위임-수준-commitment-level" class="headerlink" title="위임 수준(commitment level)"></a>위임 수준(commitment level)</h2><h3 id="JPA-연산의-특징"><a href="#JPA-연산의-특징" class="headerlink" title="JPA 연산의 특징"></a>JPA 연산의 특징</h3><ul><li>트랜잭션 안에서 발생</li><li>보통 벤더별로 특화된 세션으로 전이됨</li><li>트랜잭션과 세션 생명주기 관리에 의존적임</li><li>객체는 캐싱되고, 새로운 SQL명령은 지연관계 설정 시마다 발행.</li></ul><h3 id="트랜잭션-커밋-방식"><a href="#트랜잭션-커밋-방식" class="headerlink" title="트랜잭션 커밋 방식"></a>트랜잭션 커밋 방식</h3><ul><li>비용이 비쌈</li><li>DB를 영구적으로 변경시킴.</li></ul><h3 id="트랜잭션-롤백-방식"><a href="#트랜잭션-롤백-방식" class="headerlink" title="트랜잭션 롤백 방식"></a>트랜잭션 롤백 방식</h3><ul><li>따라서 테스트 케이스의 tearDown 도중에 트랜잭션을 롤백한다.</li><li>많은 프레임워크가 이 방식을 따름(Spring의 TestContext 등)</li></ul><br>하지만 임베디드 데이터베이스를 사용한다면 트랜잭션 커밋 방식을 사용해도 괜찮다.<hr><ul><li>임베디드 데이터 베이스는 속도가 빠르다. 매번 전체 DB를 새로 만들어도 괜찮을 정도.</li><li>필요하면 tearDown 중 데이터베이스를 정리할 수 있다. 임베디드 DB에선 저렴한 연산.</li><li>트랜잭션을 롤백하면 JPA 벤더가 DB 실제 SQL을 전송하지 않을 수 있다.<ul><li>이 경우 테스트 케이스는 통과하지만 실제 환경에서 실패하게 된다.</li></ul></li><li>JPA 트랜잭션이나 세션 밖에서 영구 저장된 객체의 동작을 테스트해보길 원할경우 사용할 수 있다.</li></ul><hr><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li>Junit in Action</li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JPA-TEST&quot;&gt;&lt;a href=&quot;#JPA-TEST&quot; class=&quot;headerlink&quot; title=&quot;JPA TEST&quot;&gt;&lt;/a&gt;JPA TEST&lt;/h2&gt;&lt;p&gt;JPA는 &lt;code&gt;엔티티 매핑&lt;/code&gt; / &lt;code&gt;API 호출&lt;/code&gt;
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Test" scheme="https://kodakyung.github.io/categories/server/test/"/>
    
    
      <category term="Test" scheme="https://kodakyung.github.io/tags/test/"/>
    
      <category term="JPA" scheme="https://kodakyung.github.io/tags/jpa/"/>
    
      <category term="Junit" scheme="https://kodakyung.github.io/tags/junit/"/>
    
  </entry>
  
  <entry>
    <title>Git - .gitignore 설정 후 적용되지 않는 경우</title>
    <link href="https://kodakyung.github.io/2018/11/09/troubleshooting-2018-11-09-git-gitignore-setting/"/>
    <id>https://kodakyung.github.io/2018/11/09/troubleshooting-2018-11-09-git-gitignore-setting/</id>
    <published>2018-11-08T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.717Z</updated>
    
    <content type="html"><![CDATA[<p>git에 업로드 되는 파일을 막는 <code>.gitignore</code>를 설정한 후에도 설정이 적용되지 않는 경우</p><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> git rm -r --cached .</span><br><span class="line"><span class="meta">&gt;</span> git add .</span><br><span class="line"><span class="meta">&gt;</span> git commit -m "commit_message"</span><br></pre></td></tr></table></figure><p>위 코드 사용시 설정이 적용된다.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;git에 업로드 되는 파일을 막는 &lt;code&gt;.gitignore&lt;/code&gt;를 설정한 후에도 설정이 적용되지 않는 경우&lt;/p&gt;
&lt;br&gt;

&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/categories/troubleshooting/"/>
    
    
      <category term="Git" scheme="https://kodakyung.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java - Comparable / Comparator</title>
    <link href="https://kodakyung.github.io/2018/11/04/programming-java-effective-java-2018-11-04-java-comparable-comparator/"/>
    <id>https://kodakyung.github.io/2018/11/04/programming-java-effective-java-2018-11-04-java-comparable-comparator/</id>
    <published>2018-11-03T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-규칙-12"><a href="#Effective-Java-규칙-12" class="headerlink" title="Effective Java 규칙 12"></a>Effective Java 규칙 12</h2><blockquote><p>Comparable 구현을 고려하라</p></blockquote><h2 id="Comparable-compareTo"><a href="#Comparable-compareTo" class="headerlink" title="Comparable.compareTo"></a>Comparable.compareTo</h2><ul><li>Object의 equals와 비슷하지만, 단순 동치성 검사 외에 순서 비교가 가능하며, 좀 더 일반적이다.</li><li>Comparable 인터페이스를 구현하는 클래스의 객체들은 자연적 순서(natural ordering)을 갖게된다.</li></ul><blockquote><p>Arrays.sort(a);</p></blockquote><ul><li><p>Comparable을 구현한 객체들은 정렬, 최대/최소 계산 등을 하기 쉽다.</p></li><li><p>Comparable을 구현한 클래스는 Comparable 인터페이스를 이용하도록 작성된 컬렉션 구현체와 전부 연동이 가능하다. 이들은 자바 플랫폼 라이브러리에 포함된 <code>거의 모든 값 클래스(value class)</code>에 해당된다.  </p></li><li><p>알파벳 순서, 값의 크기, 시간적 선후관계 등 명확한 <code>자연적 순서</code>를 따르는 값 클래스를 구현할 때는 Comparable 인터페이스 구현을 반드시 고려야해야한다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compareTo의-일반-규약"><a href="#compareTo의-일반-규약" class="headerlink" title="compareTo의 일반 규약"></a>compareTo의 일반 규약</h3><ul><li>compareTo의 일반 규약은 <a href="https://kodakyung.github.io/2018/10/26/old-post-EffectiveJava-2018-10-26-java-equals-method-override/">equals</a>와 비슷하다.</li><li>이 메소드는 this 객체와 주어진 객체를 비교한다.<ul><li>Comparable.compareTo는 비교할 클래스에 implements한 뒤 override한다.</li></ul></li><li>this 객체의 값이 인자로 주어진 객체보다 작으면 음수, 크면 양수, 같으면 0을 반환.</li><li>인자로 전달된 객체의 자료형이 this 객체와 비교 불가능한 자료형인 경우에는 <code>ClassCastException</code> 예외를 던진다.</li><li>equals와 마찬가지로 compareTo 규약을 만족하면서 클래스를 계승하여 새로운 값 컴포넌트를 추가할 방법은 없다.</li><li>우회 방법은 equals와 같이, 원래 클래스를 계승하는 것이 아닌 원래 클래스 객체를 필드로 포함하는 새로운 클래스를 만들고, 원래 클래스 객체를 반환하는 view 메소드를 추가한다.</li><li>보통 객체 사이에 자연적 순서가 존재하기만 하면 이 규약을 만족한다.</li></ul><br><ol><li><p>compareTo를 구현시 모든 x와 y에 대해 sgn(x.compareTo(y)) == -sgn(y.compareTo(x))가 만족되도록 해야한다.</p><blockquote><ul><li>반사성</li><li>객체 참조를 비교하는 방향을 뒤집어도 객체 간 대소 관계는 같아야한다.  </li><li>ex) 첫 번째 객체가 두 번째 객체보다 작다면 두 번째 객체는 첫 번째 객체보다 큰 객체여야함.</li></ul></blockquote></li><li><p>(x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0) 이면, x.compareTo(z) &gt; 0를 성립한다.</p><blockquote><ul><li>대칭성</li><li>first 객체가 second 객체보다 크고, second 객체가 third 객체보다 클 경우, first 객체는 반드시 third 객체보다 커야한다.</li></ul></blockquote></li><li><p>(x.compareTo(y) == 0) 이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))의 관계가 모든 z에 대해 성립하도록 해야한다.</p><blockquote><ul><li>추이성</li><li>비교 결과 같다고 판정된 모든 객체 각각을 다른 어떤 객체와 비교할 경우, 그 비교 결과는 전부 동일해야 한다.</li></ul></blockquote></li><li><p>필수는 아니지만 (x.compareTo(y) == 0) == (x.equals(y))를 만족하도록 구현해야하며, 그렇지 않은 클래스는 반드시 그 사실을 명시해주어야한다.</p><blockquote><ul><li>동치성  </li><li>컬렉션 인터페이스(Collection, Set, Map)와 같은 인터페이스들은 일반 규약이 equals 기반으로 작성되었지만, 실제 동치성은 equals 대신 compareTo를 통해 검사하기 때문에 (4) 항목을 만족하지 않는 경우 오동작할 수 있다.</li></ul></blockquote></li></ol><h4 id="서로-다른-객체의-비교"><a href="#서로-다른-객체의-비교" class="headerlink" title="서로 다른 객체의 비교"></a>서로 다른 객체의 비교</h4><ul><li>equals와 달리 서로 다른 클래스에 적용될 필요가 없다.</li><li>비교 대상인 객체가 서로 다른 클래스인 경우 <code>ClassCastException</code>을 던지는 것이 허용된다는 의미이다.</li><li>compareTo가 속한 클래스가 제네릭인 경우에도, 적절한 형인자가 선언되었다면 제대로 동작할 것이다.</li><li>compareTo 규약에서 서로 다른 클래스의 비교를 금지하지는 않지만 버전 1.6 이상의 플랫폼 라이브러리에 속한 모든 클래스가 비교를 허용하지 않는다.</li></ul><h4 id="Side-Effect"><a href="#Side-Effect" class="headerlink" title="Side Effect"></a>Side Effect</h4><p>hashCode 규약을 따르지 않는 클래스는 해시를 써서 구현한 클래스를 오동작 시킬 수 있는 것처럼, compareTo 규약을 준수하지 않는 클래스는 <code>비교 연산에 기반한 클래스들</code>을 오동작시킬 수 있다.</p><ul><li><code>TreeSet</code>, <code>TreeMap</code>와 같은 <code>sorted collection</code></li><li><code>Arrays</code>, <code>Collections</code> 같은 <code>유틸리티 클래스</code>들이 해당.</li><li>탐색과 정렬 알고리즘을 포함하는 클래스  </li></ul><h3 id="compareTo-vs-equals"><a href="#compareTo-vs-equals" class="headerlink" title="compareTo vs equals"></a>compareTo vs equals</h3><ul><li>Comparable 인터페이스는 자료형을 인자로 받는 제네릭 인터페이스므로, compareTo 메소드의 인자 자료형은 컴파일 시간에 정적으로 결정된다.</li><li>따라서 인자로 받은 객체의 자료형을 검사하거나 형 변환할 필요가 없다.</li><li>잘못된 자료형 객체를 인자로 넘기면 아예 컴파일이 되지 않는다.</li><li>null이 인자로 전달되는 경우에도 <code>NullPointerException</code> 예외를 발생시켜야하며, 실제로 자동으로 예외가 발생한다.</li></ul><h3 id="compareTo의-비교방식"><a href="#compareTo의-비교방식" class="headerlink" title="compareTo의 비교방식"></a>compareTo의 비교방식</h3><ul><li>compareTo는 동치성 검사가 아닌 순서 비교.</li><li>객체 참조 필드는 compareTo 메소드를 재귀적으로 호출해 비교한다.</li><li>비교할 필드가 Comparable을 구현하지 않거나 특이한 순서 관계를 사용해야하는 경우 Comparator를 명시적으로 사용할 수 있다.</li><li>Comparator를 직접 작성할 수도 있고, 작성된 Comparator를 사용할 수도 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveString</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">CaseInsensitiveString</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(CaseInsensitiveString cis)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> String.CASE_INSENSITIVE_ORDER.compare(s, cis.s);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CaseInsensitiveString 클래스는 Comparable<caseinsensitivestring>을 구현하고 있다. 따라서 CaseInsensitiveString 객체 참조만 비교할 수 있다.</caseinsensitivestring></li><li>compareTo의 인자는 Object가 아닌 CaseInsensitiveString이다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.class</span></span><br><span class="line"><span class="comment">// public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String Class가 Comparable을 implements한 후 compareTo를 Override한 것</span></span><br><span class="line"><span class="comment">// 일반적인 순서를 비교하고 있다.</span></span><br><span class="line"><span class="comment">// ex) s.compareTo("string"); // s는 String 객체</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String Class 내부에 static으로 선언된 Comparator</span></span><br><span class="line"><span class="comment">// 인자가 String이라면 String.class의 Comparator.compare을 이용해 비교할 수 있다.</span></span><br><span class="line"><span class="comment">// 특이한 순서 관계를 따로 구현한 것</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER</span><br><span class="line">                                         = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveComparator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">String</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    ..</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n1 = s1.length();</span><br><span class="line">      <span class="keyword">int</span> n2 = s2.length();</span><br><span class="line">      <span class="keyword">int</span> min = Math.min(n1, n2);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = s1.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> c2 = s2.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">          c1 = Character.toUpperCase(c1);</span><br><span class="line">          c2 = Character.toUpperCase(c2);</span><br><span class="line">          <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            c1 = Character.toLowerCase(c1);</span><br><span class="line">            c2 = Character.toLowerCase(c2);</span><br><span class="line">            <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">              <span class="comment">// No overflow because of numeric promotion</span></span><br><span class="line">              <span class="keyword">return</span> c1 - c2;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> n1 - n2;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Integer.class</span></span><br><span class="line"><span class="comment">// public final class Integer extends Number implements Comparable&lt;Integer&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparable.compareTo</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer anotherInteger)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> compare(<span class="keyword">this</span>.value, anotherInteger.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이름이 compare인 것.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x &lt; y) ? -<span class="number">1</span> : ((x == y) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>정수형의 기본자료형 필드는 관계연산자 &lt;,&gt;를 이용해 비교한다.</li><li>부동소수점 필드는 Double.compare나 Float.compare를 사용한다.</li><li>배열 필드는 원소마다 적용해야한다.</li><li>클래스에 선언된 중요 필드가 여러 개인 경우, 가장 중요한 필드부터 차례로 비교하고, 비교결과가 0이 아닌 경우 비교를 중단하고 결과를 반환한다. 모든 필드가 같을 때 0을 반환한다.</li></ul><h3 id="Comparable-vs-Comparator"><a href="#Comparable-vs-Comparator" class="headerlink" title="Comparable vs Comparator"></a>Comparable vs Comparator</h3><ul><li>일반적으로 Comparable의 compareTo는 비교 기준이 하나일 경우 비교할 대상인 클래스에 Comparable을 상속 받아 compareTo를 구현한다.</li><li>compareTo 메소드는 같은 객체 타입 하나의 인자를 받아 비교한다. 따라서 여러 비교 기준을 적용할 수 없다.</li><li>Comparator의 compare는 비교 기준이 여러개일 경우 적용할 수 있다. Comparator용 클래스를 생성한 뒤 Comparator를 implements 후 내부에 compare을 구현한다.</li><li>이때 compare 내부에 여러 비교 조건을 적용할 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Fruit o1, Fruit o2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(n)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> o1.price - o2.price; <span class="comment">// ASC Price</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> o2.price - o1.price; <span class="comment">// DESC Price</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> o1.getName().compareTo(o2.getName()); <span class="comment">// ASC Name</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> o2.getName().compareTo(o1.getName()); <span class="comment">// DESC Name</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Comparator 객체를 생성할 때 받는 n값(1,2,3,4)을 통해 조건을 선택한다.</p></li><li><p>이때 enum 객체를 이용하면 코드를 좀 더 명확하게 작성할 수 있다.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Compare &#123;BY_NAME_ASC, BY_NAME_DESC, BY_PRICE_ASC, BY_PRICE_DESC&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Compare cp;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Fruit o1, Fruit o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(cp)&#123;</span><br><span class="line"><span class="keyword">case</span> BY_PRICE_ASC: <span class="keyword">return</span> o1.price - o2.price; <span class="comment">// ASC Price</span></span><br><span class="line"><span class="keyword">case</span> BY_PRICE_DESC: <span class="keyword">return</span> o2.price - o1.price; <span class="comment">// DESC Price</span></span><br><span class="line"><span class="keyword">case</span> BY_NAME_ASC: <span class="keyword">return</span> o1.getName().compareTo(o2.getName()); <span class="comment">// ASC Name</span></span><br><span class="line"><span class="keyword">case</span> BY_NAME_DESC: <span class="keyword">return</span> o2.getName().compareTo(o1.getName()); <span class="comment">// DESC Name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TestComparator cp = <span class="keyword">new</span> TestComparator(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 코드가 명확하지 않음</span></span><br><span class="line">TestComparator cp2 = <span class="keyword">new</span> TestComparator(Compare.BY_NAME_DESC);</span><br><span class="line"><span class="comment">// 어떤 비교 기준인지 명시적으로 확인할 수 있다.</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(비교할_객체); <span class="comment">// 비교할 객체의 natural ordering의 따라 sort함</span></span><br><span class="line">Arrays.sort(비교할_객체, Comparator_객체); <span class="comment">// 특정 기준으로 비교할 수 있음</span></span><br></pre></td></tr></table></figure><ul><li>Comparable.compareTo든 Comparator.compare든 모든 필드에 대한 조건을 넣어주는 것이 좋다.</li><li>한 가지 필드에 대한 조건만 구현하는 경우 나머지 조건에 대해 의도하지 않은 결과가 나올 수 있기 때문이다.</li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-규칙-12&quot;&gt;&lt;a href=&quot;#Effective-Java-규칙-12&quot; class=&quot;headerlink&quot; title=&quot;Effective Java 규칙 12&quot;&gt;&lt;/a&gt;Effective Java 규칙 12&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - equals method 재정의</title>
    <link href="https://kodakyung.github.io/2018/10/26/programming-java-effective-java-2018-10-26-java-equals-method-override/"/>
    <id>https://kodakyung.github.io/2018/10/26/programming-java-effective-java-2018-10-26-java-equals-method-override/</id>
    <published>2018-10-25T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-규칙-8"><a href="#Effective-Java-규칙-8" class="headerlink" title="Effective Java 규칙 8"></a>Effective Java 규칙 8</h2><blockquote><p>equals를 재정의할 때는 일반 규약을 따르라</p></blockquote><h2 id="모든-객체의-공통-메소드"><a href="#모든-객체의-공통-메소드" class="headerlink" title="모든 객체의 공통 메소드"></a>모든 객체의 공통 메소드</h2><p><code>Object</code>는 객체 생성이 가능한 클래스(<code>concrete class</code>)지만 기본적으로는 <code>계승</code>해서 사용하도록 설계된 클래스이다. Object에 정의된 <code>비-final 메소드</code>(equals, hashCode, toString, clone, finalize)에는 재정의(<code>override</code>)하도록 설계된 메소드이기 때문에, 명시적인 일반 규약(<code>general contract</code>)가 있다.  </p><p>따라서 이 메소드들을 재정의하는 클래스는 그 규약을 따라주어야하며, 그렇지 않은 경우 <code>HashMap</code>, <code>HashSet</code>과 같이 해당 규약에 의존하는 클래스와 사용시 문제가 생긴다.</p><br><h3 id="equals-재정의가-필요-없는-경우"><a href="#equals-재정의가-필요-없는-경우" class="headerlink" title="equals 재정의가 필요 없는 경우"></a>equals 재정의가 필요 없는 경우</h3><ul><li>각각의 객체가 고유한 경우<ul><li>값(value) 대신 활성 객체(active entity)를 나타내는 Thread 같은 경우.</li></ul></li><li>클래스에 논리적 동일성(logical equality) 검사 방법이 있든 없든 상관 없는 경우<ul><li>java.util.Random 클래스는 난수를 발생 시키는데 일반적으로 두 난수가 같은지 비교할 필요가 없기 때문에.</li></ul></li><li>상위 클래스에서 재정의한 equals가 하위 클래스에서 사용하기 적합한 경우<ul><li>대부분의 Set 클래스는 AbstractSet의 equals 메소드를 그대로 사용한다. Map 또한 마찬가지.</li></ul></li><li>클래스가 private 또는 package-private으로 선언되고, equals 메소드를 호출할 일이 없는 경우<ul><li>이런 경우 필요는 없지만, 실수로 equals를 호출할 경우를 대비해 재정의해준다.</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Boolean <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(); <span class="comment">// 호출되면 안되는 메소드를 호출했다는 뜻.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="equals-재정의가-필요한-경우"><a href="#equals-재정의가-필요한-경우" class="headerlink" title="equals 재정의가 필요한 경우"></a>equals 재정의가 필요한 경우</h3><ul><li>객체 동일성(object equality)가 아닌 논리적 동일성(logic equality)의 개념을 지원하는 클래스인 경우.</li><li>상위 클래스의 equals가 하위 클래스의 필요를 충족하지 못할 때.<ul><li>값 클래스(value class)가 대체로 해당됨</li><li>예) Integer, Date ,,</li></ul></li></ul><h4 id="equals-메소드를-재정의할-필요가-없는-값-클래스"><a href="#equals-메소드를-재정의할-필요가-없는-값-클래스" class="headerlink" title="equals 메소드를 재정의할 필요가 없는 값 클래스"></a>equals 메소드를 재정의할 필요가 없는 값 클래스</h4><ul><li>개체 통제 기능을 사용해 값마다 최대 하나의 객체만 존재하도록 제한한 클래스</li><li>열거 자료형(enum)</li><li>해당 클래스들은 객체의 동일성이 곧 논리적 동일성이다.</li></ul><br><h3 id="equals-메소드를-정의할-때-준수해야할-일반-규약-JavaSE6-기준"><a href="#equals-메소드를-정의할-때-준수해야할-일반-규약-JavaSE6-기준" class="headerlink" title="equals 메소드를 정의할 때 준수해야할 일반 규약(JavaSE6 기준)"></a>equals 메소드를 정의할 때 준수해야할 일반 규약(JavaSE6 기준)</h3><ul><li>반사성 : null 아닌 참조 x가 있을 때, x.equals(x)는 true를 반환.<ul><li>모든 객체는 자기 자신과 같아야 한다.</li></ul></li><li>대칭성 : null 아닌 참조 x와 y가 있을 때, x.equals(y)는 y.equals(x)가 true일 때만 true를 반환.<ul><li>두 객체에게 서로 같은지 물으면 같은 답이 나와야 한다.</li></ul></li><li>추이성 : null 아닌 참조 x,y,z가 있을 때, x.equals(y)가 true고, y.equals(z)가 true면 x.equals(z)도 true.</li><li>일관성 : null 아닌 참조 x, y가 있을 때, equals를 통해 비교되는 정보에 아무 변화가 없다면, x.equals(y) 호출 결과는 호출 횟수에 상관없이 항상 같아야 한다.</li><li>null 아닌 참조 x에 대해서, x.equals(null)은 항상 false이다.</li></ul><br><h3 id="대칭성-위반한-사례"><a href="#대칭성-위반한-사례" class="headerlink" title="대칭성 위반한 사례"></a>대칭성 위반한 사례</h3><p>: 대칭성은 x.equals(y)가 true이면 y.equals(x)도 true인 것.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CaseInsensitiveString</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String s;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CaseInsensitiveString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.s = s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 대칭성 위반</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> CaseInsensitiveString) <span class="comment">// (1)</span></span><br><span class="line">      <span class="keyword">return</span> s.equalsIgnoreCase(</span><br><span class="line">        ((CaseInsensitiveString) o).s);</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> String) <span class="comment">// (2) 이 방향으로만 정상 동작함.</span></span><br><span class="line">      <span class="keyword">return</span> s.equalsIgnoreCase((String) o);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CaseInsensitiveString cis = <span class="keyword">new</span> CaseInsensitiveString(<span class="string">"Polish"</span>);</span><br><span class="line">String s = <span class="string">"polish"</span>;</span><br><span class="line"></span><br><span class="line">cis.equals(s); <span class="comment">// (3) true</span></span><br><span class="line">s.equals(cis); <span class="comment">// (4) false</span></span><br></pre></td></tr></table></figure><p>CaseInsensitiveString 객체의 equals 메소드는 CaseInsensitiveString 객체(1)와 String 객체(2) 둘다 비교 할 수 있다.<br>하지만 String의 equals는 String을 인자로만 받고 CaseInsensitiveString 클래스를 모르기 때문에 return값은 항상 false이다.(4)</p><br><h3 id="추이성-위반한-사례"><a href="#추이성-위반한-사례" class="headerlink" title="추이성 위반한 사례"></a>추이성 위반한 사례</h3><p>: x,y,z가 있을 때 x와 y가 같고, y와 z가 같으면 x와 z도 같아야한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// (1)</span></span><br><span class="line">    Point p = (Point) o;</span><br><span class="line">    <span class="keyword">return</span> p.x == x &amp;&amp; p.y == y; <span class="comment">// (2)</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 클래스를 계승(상속)해 필드를 추가하는 경우, equals를 재정의해야한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line"></span><br><span class="line">  <span class="function">pulbic <span class="title">ColorPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, Color color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y);</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 대칭성 위반</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// (3)</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint) o).color = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">ColorPoint cp = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>, <span class="number">2</span>, Color.RED);</span><br></pre></td></tr></table></figure><p>p.equals(cp)는 ColorPoint가 Point의 instance가 될 수 있어서 (1)은 통과하지만, Point 객체로 형변환 후, Point에 있는 필드만 비교하기 때문에 (2) true가 나온다.<br>cp.equals(p)는 Point 객체가 ColorPoint의 instance가 될 수 없기 때문에(3) 항상 false가 반환된다.</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 추이성 위반</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// o가 Point객체면 color는 비교하지 않음</span></span><br><span class="line">  <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> o.equals(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// o가 ColorPoint면 모든 정보를 비교</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.equals(o) &amp;&amp; ((ColorPoint)o).color == color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 대칭성은 보존되지만 추이성이 깨진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ColorPoint p1 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>,<span class="number">2</span>,Color.RED);</span><br><span class="line">Point p2 = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">ColorPoint p3 = <span class="keyword">new</span> ColorPoint(<span class="number">1</span>,<span class="number">2</span>,Color.BLUE);</span><br><span class="line"></span><br><span class="line">p1.equals(p2); <span class="comment">// (1) true</span></span><br><span class="line">p2.equals(p3); <span class="comment">// (2) true</span></span><br><span class="line">p1.equals(p3); <span class="comment">// (3) false</span></span><br></pre></td></tr></table></figure><p>(1)과 (2)의 경우 color 필드를 무시해서 true가 되지만, (3)의 경우 color를 비교해서 false가 된다.</p><ul><li>상위 클래스에 없는 새로운 값 컴포넌트를 하위 클래스에 추가하는 상황이라면, equals에게 비교할 새로운 정보가 추가되어야 한다.</li><li>이 때 <em>상위 클래스가 변경 불가능(Immutable Class)한 객체라면, 객체 지향 언어에서 동치 관계를 구현할 때 발생하는 본질적 문제로, equals 규약을 어기지 않을 방법이 없다.</em></li><li>getClass를 사용하는 경우 리스코프 대체 원칙이 적용되지 않아서 무조건 false가 출력된다.<ul><li>HashSet 같은 컬렉션은 객체 포함 여부를 판단할 때 equals를 사용하기 때문.</li><li>CounterPoint 객체는 어떤 Point 객체와도 같은 수 없기 때문.</li></ul></li></ul><h4 id="equals-규약-위반하지-않으며-값-컴포넌트-추가"><a href="#equals-규약-위반하지-않으며-값-컴포넌트-추가" class="headerlink" title="equals 규약 위반하지 않으며 값 컴포넌트 추가"></a>equals 규약 위반하지 않으며 값 컴포넌트 추가</h4><ul><li>계승(상속)하는 대신 구성하라.</li><li>Point를 계승해 ColorPoint를 만드는 것이 아닌, ColorPoint안에 <code>private Point</code> 필드를 두고 <code>public view</code> 메소드를 하나 만드는 것.</li><li>이 view 메소드는 ColorPoint가 가리키는 위치를 Point 객체로 반환한다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Point point;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Color color;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// ColorPoint의 Point 뷰 반환</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Point <span class="title">asPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> point;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(o <span class="keyword">instanceof</span> ColorPoint)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    ColorPoint cp = (ColorPoint) o;</span><br><span class="line">    <span class="keyword">return</span> cp.point.equals(point) &amp;&amp; cp.color.equals(color);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java.sql.Timestamp는 java.util.Date를 계승해 nanoseconds 필드를 추가한 것.</li><li>Timestamp 클래스의 equals는 대칭성을 위반해 Timestamp와 Date객체를 같은 컬렉션에 보관하거나 섞어쓰면 문제가될 수 있다.</li></ul><br><h3 id="일관성"><a href="#일관성" class="headerlink" title="일관성"></a>일관성</h3><ul><li>일단 같다고 판정된 객체들은 추후 변경되지 않는 한 계속 같아야 한다.</li><li>변경 가능한 객체들 간의 동치 관계는 시간에 따라 달라질 수 있지만, 변경 불가능한 객체들 간의 동치 관계는 시간에 따라 달라질 수 없다.</li><li>신뢰성이 보장되지 않는 자원들을 비교하는 equals 구현을 삼가라.<ul><li>예를 들면 URL에 대한 equals</li><li>equals 메소드는 메모리에 존재하는 객체들만 사용해서 결정적 계산을 수행하도록 구현되어야한다.</li></ul></li></ul><br><h3 id="Null에-대한-비-동치성-Non-nullity"><a href="#Null에-대한-비-동치성-Non-nullity" class="headerlink" title="Null에 대한 비 동치성(Non-nullity)"></a>Null에 대한 비 동치성(Non-nullity)</h3><ul><li>모든 객체는 null과 같아선 안된다.<ul><li>예) o.equals(null) 의 결과가 true가 되면 안된다.</li></ul></li><li>equals 내부에서 <code>null 조건</code>을 명시적으로 검사해서 <code>NullPointerException</code>이 발생하지 않도록 한다.</li><li>인자와의 비교를 위해 equals 메소드는 인자를 먼저 형변환해야한다.</li><li>형변환 이전에 instanceof 연산자를 사용해 인자의 자료형을 먼저 검사해야한다.</li></ul><br><h2 id="좋은-equals-메소드를-구현하기-위해-따라야할-지침들"><a href="#좋은-equals-메소드를-구현하기-위해-따라야할-지침들" class="headerlink" title="좋은 equals 메소드를 구현하기 위해 따라야할 지침들"></a>좋은 equals 메소드를 구현하기 위해 따라야할 지침들</h2><ol><li><code>== 연산자</code>를 사용해 equals 인자가 자기 자신인지 검사한다.<ul><li>그렇다면 true를 반환한다. 성능 최적화가 이루어진다.</li></ul></li><li><code>instanceof</code> 연산자를 사용해 인자의 자료형을 정확히 검사한다.<ul><li>그렇지 않다면 false를 반환한다.</li></ul></li><li><code>equals</code> 인자를 정확한 자료형으로 변환한다.<ul><li>그 앞에 instanceof 연산자를 사용했으므로 형변환은 반드시 성공한다.</li></ul></li><li>“중요” 필드 각각이 인자로 주어진 객체의 해당 필드와 일치하는지 검사한다.<ul><li>필드가 모두 일치하는 경우에만 true를 반환</li><li>인터페이스라면 인터페이스 메소드를 통해, 클래스라면 권한이 있다면 직접 접근도 가능</li><li>float나 double이외의 기본 자료형은 ==로</li><li>float는 Float.compare로 double은 Double.compare로</li><li>Null이 허용되는 객체의 경우 내부적으로 null check를 따로 해주어야 한다.</li></ul></li><li>equals 메소드 구현을 끝냈다면, 대칭성, 추이성, 일관성 세 속성이 만족되는지 검토하라.<ul><li>단위 테스트(unit test)를 진행한다.</li></ul></li></ol><h4 id="null이-허용되는-객체의-경우"><a href="#null이-허용되는-객체의-경우" class="headerlink" title="null이 허용되는 객체의 경우"></a>null이 허용되는 객체의 경우</h4><p>equals 메소드는 내부에 NullPointerException이 발생하면 안되기 때문에, Null 여부를 검사를 따로 해주어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(field == <span class="keyword">null</span> ? o.field == <span class="keyword">null</span> : field.equals(o.field))</span><br></pre></td></tr></table></figure><p>NullPointerException을 피하기 위해 null 여부를 확인하고 이 후에 값을 비교한다.</p><br><h2 id="equals-구현시-주의해야할-사항-몇-가지들"><a href="#equals-구현시-주의해야할-사항-몇-가지들" class="headerlink" title="equals 구현시 주의해야할 사항 몇 가지들"></a>equals 구현시 주의해야할 사항 몇 가지들</h2><ol><li>equals를 구현할 때는 hashCode도 재정의하라.</li><li>equals 메소드의 인자형을 Object에서 다른 것으로 바꾸지 마라.<ul><li>Object equals의 인자는 Object이기 때문에 다른 타입의 인자를 쓰면 Override 하지 못한다.</li><li>@Override 어노테이션을 사용하면 위와 같은 실수를 줄일 수 있다.</li></ul></li></ol><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li>instanceof  <ul><li><a href="https://programmers.co.kr/learn/questions/505" target="_blank" rel="noopener">https://programmers.co.kr/learn/questions/505</a></li></ul></li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-규칙-8&quot;&gt;&lt;a href=&quot;#Effective-Java-규칙-8&quot; class=&quot;headerlink&quot; title=&quot;Effective Java 규칙 8&quot;&gt;&lt;/a&gt;Effective Java 규칙 8&lt;/h2&gt;&lt;bloc
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - 종료자(finalizer)</title>
    <link href="https://kodakyung.github.io/2018/10/25/programming-java-effective-java-2018-10-25-java-finalizer/"/>
    <id>https://kodakyung.github.io/2018/10/25/programming-java-effective-java-2018-10-25-java-finalizer/</id>
    <published>2018-10-24T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-규칙-7"><a href="#Effective-Java-규칙-7" class="headerlink" title="Effective Java 규칙 7"></a>Effective Java 규칙 7</h2><blockquote><p>종료자 사용을 피하라</p></blockquote><h3 id="종료자란"><a href="#종료자란" class="headerlink" title="종료자란 ?"></a>종료자란 ?</h3><p><strong>Object.finalize()</strong><br>객체를 생성 하고 사용한 뒤 JVM의 가비지 컬렉션이 자동으로 메모리를 정리할 때 호출되는 메소드<br>프로그래머가 종료자를 직접 사용하는 것은 예측 불가능하고, 위험하고, 불필요하다.  </p><h3 id="종료자-사용시-단점들"><a href="#종료자-사용시-단점들" class="headerlink" title="종료자 사용시 단점들."></a>종료자 사용시 단점들.</h3><ul><li>즉시 실행된다는 보장이 없다.</li><li>종료 시점이 JVM마다 다르다.</li><li>객체 메모리 반환이 오히려 지연된다.</li><li>자바는 프로그램 종료될 때까지 객체가 남은 상태로 종료되어도 괜찮다.</li><li>종료자 안에서 무점검 예외가 발생해도 경고 문구가 출력되지 않는다.</li><li>종료자 사용시 프로그램 성능이 오히려 떨어진다.</li></ul><h2 id="명시적-종료-메소드-termination-method"><a href="#명시적-종료-메소드-termination-method" class="headerlink" title="명시적 종료 메소드 (termination method)"></a>명시적 종료 메소드 (termination method)</h2><blockquote><p>Q. 파일이나 스레드 처럼 명시적으로 반환하거나 삭제해야하는 자원을 포함하는 객체의 클래스는 어떻게 작성해야하는가?<br>A. 명시적인 종료 메소드(termination method)를 정의하고. 더이상 필요하지 않은 객체라면 클라이언트가 해당 메소드를 호출하게 한다.</p></blockquote><ul><li>유효하지 않은 객체임을 표시하는 private 필드를 하나 두고, 모든 메소드 앞에 해당 필드를 검사하는 코드를 둬서, 이미 종료된 객체에 메소드를 호출하면 <code>IllegalStateException</code>이 던져지도록.</li><li>예) OutputSteam, InputStream, java.sql.Connection에 정의된 close 메소드</li><li>java.util.Timer의 cancle 메소드</li><li>java.awt의 Graphics.dispose, Window.dispose</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object closeLock = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (closeLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      closed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">      channel.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd.closeAll(<span class="keyword">new</span> Closeable() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        close0();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>명시적 종료 메소드는 보통 <code>try-finally</code> 문과 함께 쓰이지만 자바 7에 <code>try with resource</code>문이 생겨서 이를 보통 쓴다. 리소스가 자동으로 해제된다.</li></ul><h2 id="종료자를-정말-써야하는-경우"><a href="#종료자를-정말-써야하는-경우" class="headerlink" title="종료자를 정말 써야하는 경우"></a>종료자를 정말 써야하는 경우</h2><ol><li>명시적 종료 메소드 호출을 잊을 경우에 대비하는 안전망의 역할<ul><li>이런 경우 자원 반환이 늦어지더라도 어쨌든 반환이 되는 것이 더 좋기 때문에. 종료자가 언제 호출될지 모르는 것은 마찬가지이다. 종료자가 반환되지 않은 자원을 발견하게 될 경우 반드시 경로 메세지를 로그로 남겨야한다.</li><li>종료자로 이런 안전망을 구현하려하는 경우 추가적인 비용을 감당하면서 구현할 가치가 있는 일인지 신중하게 생각해보아야 함.</li></ul></li><li>네이티브 피어(native peer)와 연결된 객체를 다룰 때.</li></ol><h3 id="네이티브-피어란"><a href="#네이티브-피어란" class="headerlink" title="네이티브 피어란?"></a>네이티브 피어란?</h3><p>JNI와 같이 일반적인 자바 객체가 아닌 경우, 가비지 콜렉터가 알 수 없고, 자바측 피어 객체(Java peer)가 반환될 때 같이 반환할 수도 없다. 네이티브 피어가 중요한 자원을 점유하고 있는 것이 아니라면 종료자를 사용하는 것이 적합하다.  </p><p>즉시 종료해야하는 경우 명시적인 종료 메소드를 클래스에 추가해야한다.</p><p>이때 종료자 연결이 자동으로 이루지지 않으므로, 수동 종료자 연결을 해주어야한다.</p><h3 id="수동-종료자-연결"><a href="#수동-종료자-연결" class="headerlink" title="수동 종료자 연결"></a>수동 종료자 연결</h3><p>Object 아닌 어떤 클래스가 종료자를 갖고 있고 하위 클래스가 해당 메소드를 재정의하는 경우, 하위 클래스 종료자는 상위 클래스 종료자를 명시적으로 호출해야한다. 그렇지 않으면 상위 클래스 종료자는 절대 호출되지 않는다.<br>하위 클래스 종료자는 try문 상위 클래스 종료자는 finally문에서 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 수동 종료자 연결(Manual finalizer chaining</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    .. <span class="comment">// 하위 클래스의 상태 종료</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.finalize();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="종료-보호자-패턴-finalizer-guardian"><a href="#종료-보호자-패턴-finalizer-guardian" class="headerlink" title="종료 보호자 패턴(finalizer guardian)"></a>종료 보호자 패턴(finalizer guardian)</h3><p>종료되어야 하는 객체의 클래스 안에 종료자를 정의하는 대신, 익명 클래스 안에 종료자를 정의한다. 이 익명 클래스로 만든 객체를 <code>종료 보호자</code>라한다. 종료되어야 하는 객체 안에 하나씩 넣는다.<br>종료 보호자 바깥 객체에는 종료 보호자를 참조하는 private 필드가 있고, 따라서 바깥 객체에 대한 모든 참조가 사라지면 종료 보호자의 종료자도 실행 가능한 상태가 된다.</p><ul><li>객체에 대한 모든 참조가 사라지면 GC이 객체를 삭제하려고 finalize()를 실행하기 때문</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 종료 보호자 숙어(Finallaizer Guardian idiom)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 이 객체를 바깥 객체(Foo)를 종료 시키는 역할만 수행</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object finalizerGuardian = <span class="keyword">new</span> Object() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      ... <span class="comment">// 바깥 Foo 객체를 종료 시킴</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 기법은 종료자가 있는 비-final 클래스를 구현할 때 반드시 고려해야한다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ol><li>자원 반환에 대한 최종적 안정장치를 구현하거나, 중요하지 않은 네이티브 자원을 종료시키려는 것이 아니라면 종료자는 사용하지 말아라.</li><li>굳이 종료자를 사용하게 되었다면 super, finalize 호출을 하라.</li><li>자원 반환 안전망을 구현하는 경우 종료자가 호출될 때마다 클라이언트 코드가 잘못되었음을 알리는 로그를 남겨라.</li><li>하위 클래스 정의가 가능한 public 클래스에 종료자를 추가해야한다면, 하위 클래스에서 실수로 super.finalize 호출을 잊어도 문제가 없도록 종료 보호자 패턴을 도입할지 고려해보자.</li></ol><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li>종료자<ul><li><a href="http://plposer.tistory.com/72" target="_blank" rel="noopener">http://plposer.tistory.com/72</a></li><li><a href="https://wedul.tistory.com/262?category=648587" target="_blank" rel="noopener">https://wedul.tistory.com/262?category=648587</a></li></ul></li><li>try with resource<ul><li><a href="http://javacan.tistory.com/entry/my-interesting-java7-five-features" target="_blank" rel="noopener">http://javacan.tistory.com/entry/my-interesting-java7-five-features</a></li></ul></li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-규칙-7&quot;&gt;&lt;a href=&quot;#Effective-Java-규칙-7&quot; class=&quot;headerlink&quot; title=&quot;Effective Java 규칙 7&quot;&gt;&lt;/a&gt;Effective Java 규칙 7&lt;/h2&gt;&lt;bloc
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>토크ON세미나 - OAuth2.0</title>
    <link href="https://kodakyung.github.io/2018/10/24/web-2018-10-24-talkonseminar-oauth2/"/>
    <id>https://kodakyung.github.io/2018/10/24/web-2018-10-24-talkonseminar-oauth2/</id>
    <published>2018-10-23T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.770Z</updated>
    
    <content type="html"><![CDATA[<p>Date 2018.10.24 Wed / Time PM 1:00~6:00 / Place SK플래닛 T아카데미</p><h1 id="페이스북-구글-로그인-하기로-배우는-OAuth"><a href="#페이스북-구글-로그인-하기로-배우는-OAuth" class="headerlink" title="페이스북. 구글 로그인 하기로 배우는 OAuth"></a>페이스북. 구글 로그인 하기로 배우는 OAuth</h1><p>OAuth는 인터넷 사용자들이 비밀번호를 제공하지 않고, 웹사이트 상의 자신들의 정보에 대한 접근권한을 특정 웹사이트나 애플리케이션에 제한적으로 부여할 수 있는 개방형 표준 인증기술.</p><p>이번 세미나는 OAuth의 동작순서 및 원리에 대해 알아보고, 서버쪽 기술 없이 자바스크립트만을 가지고 페이스북, 구글로 로그인하기 기능 구현, 이렇게 수집된 인증을 바탕으로 API 호출 등 OAuth 활용 방법에 대해 살펴 본다.</p><blockquote><p>자세한 내용 <a href="https://tacademy.skplanet.com/front/tacademy/courseinfo/campus.action?classIndex=1576" target="_blank" rel="noopener">링크</a> 참고</p></blockquote><h2 id="세미나-목표"><a href="#세미나-목표" class="headerlink" title="세미나 목표"></a>세미나 목표</h2><ul><li>OAuth의 본질적인 원리를 이해 후 이를 바탕으로 Low Level로 구현.</li><li>Facebook과 Google의 SDK를 이용해 실 서비스를 구현해본다.</li></ul><br><h2 id="OAuth의-구조"><a href="#OAuth의-구조" class="headerlink" title="OAuth의 구조"></a>OAuth의 구조</h2><p>: User / My / Their 3자가 필요하다.</p><ul><li>My : 내가 구현하고자 하는 서비스</li><li>User : 내 서비스를 사용하는 사용자 <em>// 기본적으로 My-User의 양자 관계</em></li><li>Their : facebook, google 같은 기존 서비스</li></ul><h2 id="OAuth를-사용하는-목적"><a href="#OAuth를-사용하는-목적" class="headerlink" title="OAuth를 사용하는 목적"></a>OAuth를 사용하는 목적</h2><p>가장 큰 문제는 <code>보안(인증)</code>의 문제  </p><ul><li>가장 쉬운 방법은 Their의 ID/PW를 아는 것.</li><li>My에 Their의 정보를 제공한다. <em>// 좋지 않은 방법</em><ol><li>모든 서비스에 권한 부여</li><li>무기한 사용 가능</li></ol></li><li>ID/PW가 아닌 <code>임시 비밀번호</code>를 발급 받아서 진행<ol><li>임시 비밀번호를 Their가 랜덤하게 복잡하게 만들 수 있다.</li><li>Their의 기능이 A,B,C.. 여러개일 때, 일부 기능에 대해서만 사용할 수 있도록 제어가 가능하다.</li><li>기간을 부여해 일시적으로 사용하도록 제어할 수 있다.</li></ol></li><li>이 임시 비밀번호를 <code>access token</code>이라 한다.<ul><li><strong>이걸 얻어내면 OAuth를 할 줄 아는 것 !!</strong></li><li>My가 <code>access token</code>을 제출함으로써 Their의 일부 기능을 일정 기간동안 권한을 받아 사용할 수 있는 것.</li></ul></li></ul><h2 id="OAuth의-용어"><a href="#OAuth의-용어" class="headerlink" title="OAuth의 용어"></a>OAuth의 용어</h2><ul><li>My : Client</li><li>User : Resource Owner (정보의 소유자)</li><li>Their : Resource Server (정보의 제공자)</li><li>원래 하나가 더 있지만 우선 세 개로 설명할 예정.</li></ul><h2 id="OAuth를-얻기-위한-절차"><a href="#OAuth를-얻기-위한-절차" class="headerlink" title="OAuth를 얻기 위한 절차"></a>OAuth를 얻기 위한 절차</h2><ul><li>My Service를 Their Service에 등록(<code>register</code>)하는 절차가 필요</li><li>양자가 교환하는 정보가 있다.</li></ul><p><img src="/images/2018-10-24/2018-10-24-01.png" alt="OAuth 과정"></p><blockquote><p>출처 : 생활코딩 이고잉님</p></blockquote><p>(1) <code>Resource Server</code>는 <code>Client id</code>를 생성 <em>// 공개되어도 괜찮다.</em><br>(2) <code>Resource Server</code>는 <code>Client secret</code>를 생성 <em>// 공개되면 안된다.</em><br>(3) <code>Client</code>에게 <code>Resource Server</code>가 <code>Client id/secret</code>을 알려준다<br>(4)-1 <code>Client</code>는 <code>access token</code>을 <strong>어디</strong>로 배달해줄 것인가? 배송지를 알려준다.<br>      (<code>redirect uri</code> : 배송지 정보)<br>      (My가 redirect uri를 구현해 Server에게 알려주어야함)<br>(4)-2 <code>Resource Server</code>에 <code>redirect uri</code>를 등록해준다.<br>(5) <code>Resource Owner</code>가 <code>client</code>에 접속했을 때 <code>Resource Owner</code>에게 로그인 요청을 준다.<br>      (권한 승인 요청) <em>// 사용자에게 링크를 제공</em><br>(6) <code>Resource Owner</code>가 승인하면, <code>Resource Server</code>에게 <code>client_id</code>를 전송하고 승인 여부를 물어본다.<br>(7) <code>Resource Server</code>는 <code>user_id</code>에 <code>Resource Owner</code> 정보를 등록하고 <code>Resource Owner</code>에 <code>access_token</code>을 발급해준다.<br>(8) <code>client</code>는 발급받은 <code>access_token</code>을 이용해 Resource Server의 API를 이용한다.  </p><blockquote><p>My = Client = C<br>User = Resource Owner = RO<br>Their = Resource Server = RS</p></blockquote><br><h2 id="Facebook으로-로그인"><a href="#Facebook으로-로그인" class="headerlink" title="Facebook으로 로그인"></a>Facebook으로 로그인</h2><h3 id="Facebook-OAuth-기본-설정"><a href="#Facebook-OAuth-기본-설정" class="headerlink" title="Facebook OAuth 기본 설정"></a>Facebook OAuth 기본 설정</h3><ul><li>facebook developer 사이트 접속</li><li>내 앱 생성 &gt; 로그인하기 &gt; 웹 선택</li><li>대시보드 &gt; 기본설정에서 App id와 secret이 발급된 것을 확인할 수 있다.</li></ul><p><img src="/images/2018-10-24/2018-10-24-02.png" alt="Facebook OAuth 기본 설정"></p><br><p>오늘 세미나는 server-side가 아닌 javascript를 이용해 <code>client-side</code>에서 제어하는 것을 중점으로 실습할 것.<br>따라서 secret code는 현재 실습에서는 사용하지 않는다.<br>server-side를 이용한 서비스를 구축할 때 사용할 것.  </p><blockquote><p>Q. User가 access token을 발급 받나요?<br>A. User가 클릭만 하면 발급을 받지만, User가 알게 되는 것은 아니다.</p></blockquote><br><h3 id="개발-환경"><a href="#개발-환경" class="headerlink" title="개발 환경"></a>개발 환경</h3><ul><li>Node.js</li><li>npm</li><li>local-web-server : 경량화된 웹 서버, 손쉽게 https 개발 환경을 구축할 수 있음.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br><span class="line">npm install -g local-web-server // 전역으로 npm 설치</span><br><span class="line">ws --https // https로 웹 서버 실행, facebook이 개발환경에서도 https를 강제하기 때문</span><br><span class="line">// https://localhost:8000 접속 가능</span><br><span class="line">// 이것을 facebook에 redirect uri 값으로 등록한다.</span><br></pre></td></tr></table></figure><p><img src="/images/2018-10-24/2018-10-24-03.png" alt="Facebook OAuth redirect uri 등록"></p><br><h3 id="Facebook-Login-요청-구현"><a href="#Facebook-Login-요청-구현" class="headerlink" title="Facebook Login 요청 구현"></a>Facebook Login 요청 구현</h3><blockquote><p>keyword : facebook developer login</p></blockquote><p>: Login 요청을 구현한다는 것은, User(Resource Owner)에게 승인 받는 버튼, 링크를 만든다는 것이다.</p><ul><li>구현 방법 3가지<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 위젯을 이용한다. (간단한 방식)</span><br><span class="line">2. SDK(Software Development Kit)</span><br><span class="line">3. 직접 구현 &gt; 로그인 flow 직접 빌드</span><br></pre></td></tr></table></figure></li></ul><ul><li>우리는 원리를 이해하기 위해 3번으로 진행하지만 보안상의 이슈가 발생할 수 있기 때문에 실 서버환경에서는 SDK를 이용해 개발해야한다.</li></ul><br><h3 id="Facebook-Login-Flow-직접-빌드"><a href="#Facebook-Login-Flow-직접-빌드" class="headerlink" title="Facebook Login Flow 직접 빌드"></a>Facebook Login Flow 직접 빌드</h3><blockquote><p>참고 링크 : <a href="https://developers.facebook.com/docs/facebook-login/manually-build-a-login-flow" target="_blank" rel="noopener">facebook for developer - 로그인 플로 직접 빌드</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https://www.facebook.com/v3.2/dialog/oauth?</span><br><span class="line">  client_id=&#123;app-id&#125;</span><br><span class="line">  &amp;redirect_uri=&#123;redirect-uri&#125;</span><br><span class="line">  &amp;state=&#123;state-param&#125;</span><br><span class="line">  &amp;response_type=token</span><br><span class="line">  // 바로 access_token으로 받기위한 설정</span><br><span class="line">  // 설정하지 않는 경우 code로 받게 된다.</span><br></pre></td></tr></table></figure><p>redirect-uri를 직접 등록하면 문제가 생길 수 있다. <code>uri encode</code> 도구를 이용해 인코딩해 넣는다. state-param은 보안 관련, 우선 넘어간다.</p><br><img width="302" alt="OAuth 권한 승인 창" src="/images/2018-10-24/2018-10-24-05.png"><p>설정을 끝낸 뒤 링크를 누르면 인증 팝업 창이 뜬다.</p><br><ul><li>위의 과정은 내부적으로 이렇게 동작한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. client가 웹사이트를 방문한 User(RO)에게 (인증) 주소를 준다.</span><br><span class="line">2. Client가 주소를 누르면 해당 Request는 RS에게 전달된다.</span><br><span class="line">2-1. Request에는 client_id는 ~고 redirect_uri는 ~라는 정보를 담아 전송한다.</span><br><span class="line">2-2. 이때 RS에서 redirect_uri를 확인하고, 등록하지 않은 redirect_uri는 RS가 거절한다.</span><br><span class="line">3. 이후 RS가 access_token을 랜덤하게 생성한다.</span><br><span class="line">4. RS에서 user_id가 ~인 사람의 access_token이라 저장한다. (어떤 user에 token을 발급했는지 저장)</span><br><span class="line">5. 이 후 access_token을 RO(정확히 말하면 사용자라기 보다는 사용하고 있는 웹페이지)를 통해 Client에게 전달한다.</span><br></pre></td></tr></table></figure></li></ul><br><ul><li><p>로그인에 성공하면 아래와 같은 <code>리디렉션 URI</code>가 호출된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://localhost:8000/fb-low.html?#state=1234&amp;access_token=&#123;access_token_value&#125;&amp;expires_in=&#123;value&#125;&amp;reauthorize_required_in=&#123;value&#125;&amp;data_access_expiration_time=&#123;value&#125;</span><br></pre></td></tr></table></figure></li><li><p>uri의 <code>access_token</code>을 알게되면 facebook api를 호출할 수 있다.</p></li><li><p><code>state</code>는 보안과 관련 있는 필드이다. facebook 서버에게 access_token을 요청하는 링크를 만들어서 사용자가 클릭하면 페이스북 서버로 갔다가 준 결과가 위의 링크인데, 이때 내가 요청한 것이 온게 맞는지 확인하기 위해서 state를 통해 확인한다. 응답하는 RS는 state 값을 똑같이 돌려주도록 약속되어 있기 때문에 내가 설정한 값과 다른 값이 오면 잘못된 것이다. (SDK는 자동으로 처리해준다)</p></li><li><p><code>expires_in</code> : 유효기간</p></li></ul><br><h3 id="Facebook-API-사용"><a href="#Facebook-API-사용" class="headerlink" title="Facebook API 사용"></a>Facebook API 사용</h3><ol><li>access_token을 얻는다 (SDK를 이용하지 않고)</li><li>access_token으로 Facebook API를 가져와서 현재 사용자의 이름을 출력한다.</li></ol><ul><li>우선 uri에서 access_token 값만을 추출해야한다.</li></ul><blockquote><p>[검사]-console</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.href.match(<span class="string">'access_token=([^&amp;]*)'</span>);</span><br></pre></td></tr></table></figure><ul><li>location.href : 현재 열어놓은 웹페이지의 주소를 가져온다.</li><li>.match : 매칭되는 문자열(value)을 추출</li><li>^$ : and가 아니다(부정)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.href.match(<span class="string">'access_token=([^&amp;]*)'</span>)[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><ul><li>2번째 값임을 확인한 뒤 출력해본다</li></ul><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(atr)&#123; <span class="comment">// js의 null은 false, 값이 있으면 true</span></span><br><span class="line">  <span class="keyword">var</span> access_token = atr[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'access_token :'</span>, access_token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/2018-10-24/2018-10-24-06.png" alt="가져온 access token"></p><ul><li>access_token을 가져온 것을 확인하였다.</li></ul><br>- access_token 획득 후 Facebook API 서버에 접속해 유저 이름을 가져와야한다.<blockquote><p>keyword : facebook user graph api</p></blockquote><ul><li>Facebook에서 제공하는 그래프 API 탐색기를 통해 손쉽게 시뮬레이션 할 수 있다.</li></ul><blockquote><p>참고 링크 : <a href="https://developers.facebook.com/tools/explorer/" target="_blank" rel="noopener">facebook for developer - 그래프 API 탐색기</a></p></blockquote><dl><dt>: 내가 생성한 앱의 토큰을 받아서 API를 적용해볼 수 있다.</dt><dd>어떤 정보를 가져오고 싶은지 구체적인 필드를 적용해 볼 수 있다.</dd></dl><br><ul><li>받아오고 싶은 정보의 필드를 설정한 뒤 하단의 [코드 받기]-[cURL]를 참고한다.</li><li>해당 URL에 접속하면 설정한 정보를 받아올 수 있다.  </li></ul><p><em>// 모든 필드를 여기서 선택한다고 정보를 가져올 수 있는 것은 아니다. 추가적인 권한이나 설정같은 것이 필요한 경우가 많다.</em></p><p><img src="/images/2018-10-24/2018-10-24-07.png" alt="URL로 받아온 정보들"></p><br><ul><li>ajax를 이용해 정보를 가져와보자.</li><li><code>fetch().then(){}</code>을 이용한다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 웹브라우저는 fetch의 url에 접속한다.</span><br><span class="line">2. 이후 then의 함수를 호출한다.</span><br><span class="line">3. 이때 첫번째 인자로 어떤 값을 인자로 넘긴다. 이 인자는 여러가지가 될 수 있다. 그 정보를 받아서 사용하기 쉽도록 가공하는 코드를 function 내부에 작성하면 된다.</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(atr)&#123;</span><br><span class="line">  <span class="keyword">var</span> access_token = atr[<span class="number">1</span>];</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'access_token :'</span>, access_token);</span><br><span class="line"></span><br><span class="line">  fetch(<span class="string">"&#123;https://graph.facebook.com/을 통해 알아낸 URI&#125;"</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">raw</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> raw.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.name, result.id);</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'#welcome'</span>).innerHTML = <span class="string">'Welcome, '</span>+result.name;</span><br><span class="line">    <span class="comment">// #welcome : id값이 welcome인 태그를 선택.</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>받아온 정보를 <code>json</code>으로 가공해서 현재 로그인한 사용자의 이름을 출력하는 코드이다.</p><ul><li>위의 코드는 연습용 코드로 보안상의 문제가 있다.</li></ul><br><h3 id="Facebook-SDK를-이용한-구현"><a href="#Facebook-SDK를-이용한-구현" class="headerlink" title="Facebook SDK를 이용한 구현"></a>Facebook SDK를 이용한 구현</h3><blockquote><p>keyword : facebook sdk javascript<br>참고링크 : <a href="https://developers.facebook.com/docs/javascript/quickstart" target="_blank" rel="noopener">빠른 시작: Javascript용 Facebook SDK</a></p></blockquote><ul><li>SDK란 ? (Software Development Kit)<br>Application이 제공하는 도구.<br>API를 직접 호출하지 않고 도구를 통해 간접적으로 API를 제어하는 것.</li></ul><br>우선 SDK를 사용하기 위해서는 웹페이지에 로드시켜야한다.- 기본 설정<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">window</span>.fbAsyncInit = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    FB.init(&#123;</span><br><span class="line">      appId            : <span class="string">'your-app-id'</span>,</span><br><span class="line">      autoLogAppEvents : <span class="literal">true</span>,</span><br><span class="line">      xfbml            : <span class="literal">true</span>,</span><br><span class="line">      version          : <span class="string">'v3.2'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">d, s, id</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> js, fjs = d.getElementsByTagName(s)[<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">if</span> (d.getElementById(id)) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">     js = d.createElement(s); js.id = id;</span><br><span class="line">     js.src = <span class="string">"https://connect.facebook.net/en_US/sdk.js"</span>;</span><br><span class="line">     fjs.parentNode.insertBefore(js, fjs);</span><br><span class="line">   &#125;(<span class="built_in">document</span>, <span class="string">'script'</span>, <span class="string">'facebook-jssdk'</span>));</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>: 직접 만든 Facebook 앱의 ID를 <code>your-app-id</code>에 대체해야 한다.</p><br>- 위와 같이 로그인 후 로그인한 사용자의 이름을 출력하는 기능을 SDK로 구현.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 로그인 상태를 체크해서 동작하는 함수</span></span><br><span class="line">FB.getLoginStatus(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"response.state : "</span>+response.status);</span><br><span class="line"><span class="comment">// statusChangeCallback(response);</span></span><br><span class="line"><span class="keyword">if</span>(response.status == <span class="string">'connected'</span>)&#123;</span><br><span class="line">  <span class="comment">// 로그인되었을 때 처리</span></span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'#authBtn'</span>).value = <span class="string">"Logout"</span>;</span><br><span class="line">  <span class="comment">// Welcome message 출력</span></span><br><span class="line">  FB.api(</span><br><span class="line">    <span class="string">'/me/'</span>,</span><br><span class="line">    <span class="string">'GET'</span>,</span><br><span class="line">    &#123;<span class="string">"fields"</span>:<span class="string">"id,name,email"</span>&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Insert your code here</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'API : '</span>, response);</span><br><span class="line">      <span class="built_in">document</span>.querySelector(<span class="string">'#welcome'</span>).innerHTML = <span class="string">'Welcome, '</span>+response.name;</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 로그인되지 않았을 때 처리</span></span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'#authBtn'</span>).value = <span class="string">"Login"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>참고 링크 : <a href="https://developers.facebook.com/docs/javascript/examples" target="_blank" rel="noopener">facebook for developer - Javascript SDK - Examples</a>  </p></blockquote><br><h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p>어떤 기능에 대해 유효한가를 나타낸다.<br>페이스북은 기본적으로 ID와 이름 권한을 획득할 수 있다.<br>만약 사용자의 email 정보를 가져오고싶다면 scope를 추가해아한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FB.login(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'Welcome'</span>);</span><br><span class="line">  location.reload();</span><br><span class="line">&#125;), &#123;<span class="attr">scope</span>: <span class="string">'public_profile,email'</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>로그인 시 scope 옵션을 통해 권한을 추가 요청한다.  </li></ul><br><p><img src="/images/2018-10-24/2018-10-24-08.png" alt="그래프 API 탐색기로 정보 가져오기"></p><ul><li>그래프 API 탐색기를 통해 추가한 scope 기능을 받아오는 법을 확인한다.</li></ul><br><ul><li>증분 권한 ?<br>권한을 한번에 추가하는 것이 아니라 필요할 때마다 하나씩 추가하도록 하는 것. 증분 권한을 사용하는 것이 권장사항.</li></ul><img width="400" alt="증분 권한" src="/images/2018-10-24/2018-10-24-09.png"><p>위와 같이 필요한 기능을 그때그때 승인을 받는다.</p><br><h2 id="Google로-로그인"><a href="#Google로-로그인" class="headerlink" title="Google로 로그인"></a>Google로 로그인</h2><h3 id="Google-SDK-사용-설정"><a href="#Google-SDK-사용-설정" class="headerlink" title="Google SDK 사용 설정"></a>Google SDK 사용 설정</h3><blockquote><p>keyword : google cloud console</p></blockquote><ol><li>Google Cloud Console에서 프로젝트를 생성한다.  </li></ol><ul><li>Google API 서비스를 사용하려면 프로젝트에서 해당 기능을 활성화 시켜야한다.</li></ul><ol start="2"><li><p>OAuth 클라이언트 아이디 생성</p><ul><li>API 및 서비스 &gt; 사용자 인증 정보 &gt; OAuth 클라이언트 ID<br><img src="/images/2018-10-24/2018-10-24-10.png" alt="OAuth 클라이언트 아이디 생성"></li></ul></li><li><p>consent screen(동의 화면) 설정<br><img src="/images/2018-10-24/2018-10-24-11.png" alt="consent screen(동의 화면) 설정"></p><ul><li>애플리케이션 이름, 로고 등을 설정한다.</li></ul></li><li><p>(3)이후 (2)를 진행한다.<br><img src="/images/2018-10-24/2018-10-24-12.png" alt="OAuth 클라이언트 아이디 생성"></p><ul><li>Domain과 리디렉션 URI를 입력한다.</li></ul></li></ol><br><h3 id="Google-SDK-API를-이용한-Login-구현"><a href="#Google-SDK-API를-이용한-Login-구현" class="headerlink" title="Google SDK API를 이용한 Login 구현"></a>Google SDK API를 이용한 Login 구현</h3><blockquote><p>keyword : google login web SDK</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'init'</span>);</span><br><span class="line">    gapi.load(<span class="string">'auth2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// oauth2가 로드된 후 실행되는 함수</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'auth2 loaded'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;    </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="https:/</span><span class="regexp">/apis.google.com/</span>js/platform.js?onload=init<span class="string">" async defer&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">// 앞의 .js 파일 로딩이 끝나면 init 함수를 호출한다는 의미</span></span><br></pre></td></tr></table></figure><p>위 코드를 실행시키면 init이 출력된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'init'</span>);</span><br><span class="line">    gapi.load(<span class="string">'auth2'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// oauth2가 로드된 후 실행되는 함수</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'auth2 loaded'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> gauth = gapi.auth2.init(&#123; <span class="comment">// Auth setup, GoogleAuth object restores the user's sign-in state from the previous session.</span></span><br><span class="line">    client_id: <span class="string">'&#123;내가 생성한 project id&#125;'</span></span><br><span class="line">  &#125;);</span><br><span class="line">  gauth.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 성공한다면 앞의 파라매터, 실패한다면 뒤의 파라매터 호출</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'init success'</span>);</span><br><span class="line">    <span class="keyword">var</span> isLogined = gauth.isSignedIn.get();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'isLogined : '</span>, isLogined);</span><br><span class="line">    <span class="keyword">if</span>(isLogined)&#123;</span><br><span class="line">      <span class="comment">// 로그인 됨</span></span><br><span class="line">      <span class="built_in">document</span>.querySelector(<span class="string">'#authBtn'</span>).value = <span class="string">'Logout'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 로그인 안됨</span></span><br><span class="line">      <span class="built_in">document</span>.querySelector(<span class="string">'#authBtn'</span>).value = <span class="string">'Login'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'init fail'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;    </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><br><blockquote><p>Q. 실 서비스중 에러가 발생하면 어떡해야하는가?<br>A. 예를 들어 access_token이 만료가 되었다면, 다시 요청하는 UI를 만든다던지.. 실제 서비스할 때는 추가적으로 작업할 것들이 많다.</p></blockquote><br><ul><li>Google의 다른 기능을 사용하고 싶다면</li></ul><ol><li>해당 기능의 페이지로 가서 활성화 시킨다.</li><li>google drive keyword로 검색 (scope), 사용 방법을 찾아보자.</li></ol><br><h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>: 이번 세미나에서는 client-side로 OAuth 기능을 구현하였다. 이는 보안 문제가 발생할 수 있다.  </p><br><ul><li>server-side로 구현한다면 실습 내용에서 조금 더 추가되는 과정이 있다.</li></ul><ol><li>RO가 RS에 접속해서, C에게 ~기능을 달라고 요청(권한 허용 링크 클릭)하면<ul><li>server-side에서 구현시 client-side처럼 access_token을 바로 주지 않는다.</li></ul></li><li>RS가 RO에게 <code>authorization code</code>값을 준다. 그리고 어떤 <code>client</code>에게 발급했는지 기록한다.</li><li>RO는 <code>authorization code</code>를 받아서 <code>client</code>로 보낸다.<ul><li>client는 authorization code를 알게 된다.</li></ul></li><li><code>Client</code>는 RS에 직접 접속해서 <code>client_id</code>와 <code>client_secret</code>, <code>authorization_code</code> 세 값을 RS에게 보내면서 <code>access_token</code>을 요청한다.</li><li>RS는 <code>authorization_code</code>를 발급했는지 확인하고 어떤 <code>client_id</code>에 발급했는지 확인한다.<ul><li>이후 <code>access_token</code>을 발행하고 <code>authorization_code</code>를 지운다.</li></ul></li><li>이후 <code>client</code>에게 <code>access_token</code>을 응답한다.</li><li>이후 Client(Server) 쪽에 <code>access_token</code>을 보관하고(DB 등) 여러가지 작업을 처리하게된다.</li></ol><br><ul><li>RS에서 RO의 아이디를 저장해서 Client에 넘겨줄 수도 있다.<br>: RS에서 <code>access_token</code>을 통해 <code>user_id</code>를 얻었다는 것은 우리 서버에서 <code>식별자</code>로 사용할 수 있다는 의미이다. (만약 Client에 저장한다면 id 그대로 저장하지 않고 facebook_id 등 변조해서 저장하는 것이 좋다)<br>: 이 아이디를 얻어냈다는 것 자체가 페이스북 인증에 성공했다는 것이기 때문에 해당 식별자의 주인이라는 것을 확인할 수 있다.<br>: 이를 이용하는 것이 ~로 로그인하기 기능이다.  </li></ul><br><ul><li>access_token을 발급한 뒤 만료됐을 때 <code>refresh</code>를 해야한다.  <blockquote><dl><dt>keyword : refresh token<br>: <code>access_token</code>을 발급 받을 때 보통 <code>refresh_token</code>을 함께 준다.</dt><dd><code>access_token</code>이 만료 되었을 때 <code>refresh_token</code>을 RS에 주면서 <code>access_token</code>을 재발급 받는다. 이는 시스템마다 다를 수 있다.</dd></dl></blockquote></li></ul><br><ul><li>여기서 추가적으로 공부하고 싶다면,<br>생활코딩에서 Cookie -&gt; Session -&gt; Passport -&gt; Multi user -&gt; google, facebook 로그인 순으로 공부를 추천.</li></ul><br><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><blockquote><p><a href="https://github.com/koda93/TIL/commit/9bddad4a0b6d15a00a92f5d1216bba80cffc1725" target="_blank" rel="noopener">실습 코드 repository</a></p></blockquote><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Date 2018.10.24 Wed / Time PM 1:00~6:00 / Place SK플래닛 T아카데미&lt;/p&gt;
&lt;h1 id=&quot;페이스북-구글-로그인-하기로-배우는-OAuth&quot;&gt;&lt;a href=&quot;#페이스북-구글-로그인-하기로-배우는-OAuth&quot; c
      
    
    </summary>
    
      <category term="Web" scheme="https://kodakyung.github.io/categories/web/"/>
    
    
      <category term="OAuth2" scheme="https://kodakyung.github.io/tags/oauth2/"/>
    
      <category term="Web" scheme="https://kodakyung.github.io/tags/web/"/>
    
      <category term="Authrization" scheme="https://kodakyung.github.io/tags/authrization/"/>
    
      <category term="Tacademy" scheme="https://kodakyung.github.io/tags/tacademy/"/>
    
  </entry>
  
  <entry>
    <title>Fish Shell - Alias 설정</title>
    <link href="https://kodakyung.github.io/2018/10/24/system-shell-2018-11-08-fish-shell-alias/"/>
    <id>https://kodakyung.github.io/2018/10/24/system-shell-2018-11-08-fish-shell-alias/</id>
    <published>2018-10-23T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.696Z</updated>
    
    <content type="html"><![CDATA[<p>일반적으로 <code>bash</code>와 같은 쉘들은 <code>alias</code> 명령을 통해 <code>alias</code>를 지정해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># ~/.bashrc</span></span><br><span class="line"><span class="built_in">alias</span> name=<span class="string">"#statement"</span></span><br></pre></td></tr></table></figure><br><p>fish shell은 <code>alias</code>가 따로 존재하지 않고 함수(<code>function</code>)로 이를 처리한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env fish</span></span><br><span class="line">&gt; <span class="keyword">function</span> name</span><br><span class="line">  <span class="comment">#statements</span></span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p><img src="/images/2018-11-08/01.png" alt="fish shell  function alias example"></p><br><p>fish의 인수는 숫자가 매겨진 변수(<code>$1</code>)가 아닌 <code>$argv</code> 단일 목록으로 전달된다.</p><p><img src="/images/2018-11-08/02.png" alt="fish shell  function alias argv example"></p><br><p><code>function</code>을 영구적으로 저장하고 싶다면 <code>~/.config/fish/functions/</code>경로에 <code>function_name.fish</code> 파일을 생성해야한다.</p><p><img src="/images/2018-11-08/03.png" alt="fish 파일 생성"><br><img src="/images/2018-11-08/04.png" alt="fish 파일 확인"><br><img src="/images/2018-11-08/05.png" alt="명령어 실행 확인"></p><br><p>전체 함수의 목록은 아래 명령어로 확인할 수 있다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env fish</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">functions</span></span></span><br></pre></td></tr></table></figure><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;일반적으로 &lt;code&gt;bash&lt;/code&gt;와 같은 쉘들은 &lt;code&gt;alias&lt;/code&gt; 명령을 통해 &lt;code&gt;alias&lt;/code&gt;를 지정해준다.&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
      <category term="System" scheme="https://kodakyung.github.io/categories/system/"/>
    
      <category term="Shell" scheme="https://kodakyung.github.io/categories/system/shell/"/>
    
    
      <category term="Fish Shell" scheme="https://kodakyung.github.io/tags/fish-shell/"/>
    
      <category term="Shell" scheme="https://kodakyung.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Java - Private 생성자</title>
    <link href="https://kodakyung.github.io/2018/10/15/programming-java-effective-java-2018-10-15-java-private-constructor/"/>
    <id>https://kodakyung.github.io/2018/10/15/programming-java-effective-java-2018-10-15-java-private-constructor/</id>
    <published>2018-10-14T15:00:00.000Z</published>
    <updated>2020-03-19T01:14:24.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-규칙-4"><a href="#Effective-Java-규칙-4" class="headerlink" title="Effective Java 규칙 4"></a>Effective Java 규칙 4</h2><blockquote><p>객체 생성을 막을 때는 private 생성자를 사용하라.</p></blockquote><h3 id="유틸리티-클래스-Utility-Class"><a href="#유틸리티-클래스-Utility-Class" class="headerlink" title="유틸리티 클래스 (Utility Class)"></a>유틸리티 클래스 (Utility Class)</h3><ul><li><p>정적 메서드나 필드만 모은 클래스로 객체를 생성할 필요가 없는 구조로 이루어진 클래스.</p></li><li><p>객체 지향적이지 않다는 비판이 있지만 필요한 특정 경우가 존재한다.</p></li></ul><h3 id="유틸리티-클래스를-만드는-경우"><a href="#유틸리티-클래스를-만드는-경우" class="headerlink" title="유틸리티 클래스를 만드는 경우"></a>유틸리티 클래스를 만드는 경우</h3><ul><li>자바의 기본 자료형 값에 적용되는 메소드를 모아둘 때 (예 - <code>java.lang.Math</code>)</li><li>배열에 적용되는 메소드를 모아둘 때 (예 - <code>java.util.Arrays</code>)</li><li>특정 인터페이스를 구현하는 객체를 만드는 팩토리 메소드 (예 - <code>java.util.Collections</code>)</li><li><code>final</code> 클래스에 적용할 메소드를 모아놓을 때 (final 클래스는 계승할 수 없다. )</li></ul><h3 id="private-생성자의-사용"><a href="#private-생성자의-사용" class="headerlink" title="private 생성자의 사용"></a>private 생성자의 사용</h3><p>이런 유틸리티 클래스는 객체를 만들지 않고 사용하지만, 생성자를 생략하면 컴파일러가 자동으로 public 기본 생성자(<code>default constructor</code>)를 만든다.</p><p>이런 상황을 막기 위해 클래스를 <code>abstract</code>로 선언한다면, 하위 클래스를 정의하는 순간 객체 생성이 가능해진다.</p><p>따라서 기본 생성자의 생성을 막고 객체 생성을 막기 위해서는 <code>private 생성자</code>를 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilityClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 기본 생성자가 자동 생성되지 못하게하여 객체 생성을 방지</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UtilityClass</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>private</code>이므로 클래스 외부에서 객체를 생성하지 못한다. <code>AssertionError</code>는 필수는 아니지만 클래스 내에서 실수로 생성자를 호출하는 것을 알 수 있기 위해 삽입한다.</p><p>코드 내에서 명시적으로 확인할 수 없으니 주석으로 표시해주는 것이 바람직하다.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-규칙-4&quot;&gt;&lt;a href=&quot;#Effective-Java-규칙-4&quot; class=&quot;headerlink&quot; title=&quot;Effective Java 규칙 4&quot;&gt;&lt;/a&gt;Effective Java 규칙 4&lt;/h2&gt;&lt;bloc
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java - 싱글턴 패턴(Singleton Pattern)</title>
    <link href="https://kodakyung.github.io/2018/10/14/programming-java-effective-java-2018-10-14-java-singleton-pattern/"/>
    <id>https://kodakyung.github.io/2018/10/14/programming-java-effective-java-2018-10-14-java-singleton-pattern/</id>
    <published>2018-10-13T15:00:00.000Z</published>
    <updated>2020-03-19T01:14:07.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Effective-Java-규칙-3"><a href="#Effective-Java-규칙-3" class="headerlink" title="Effective Java 규칙 3"></a>Effective Java 규칙 3</h2><blockquote><p>private 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계하라</p></blockquote><h2 id="Singleton-이란"><a href="#Singleton-이란" class="headerlink" title="Singleton 이란 ?"></a>Singleton 이란 ?</h2><blockquote><p>객체를 하나만 만들 수 있는 클래스<br>보통 유일할 수 밖에 없는 시스템 컴포넌트를 나타낸다.</p></blockquote><h3 id="Singleton을-구현하는-방법"><a href="#Singleton을-구현하는-방법" class="headerlink" title="Singleton을 구현하는 방법"></a>Singleton을 구현하는 방법</h3><ol><li>private 생성자의 이용</li><li>정적 팩터리 메소드 이용 // <em>JDK 1.5 이전의 구현 방식</em></li><li>enum 자료형의 사용 // <em>Effective Java의 추천 방식</em></li><li>Initialization on demand holder idiom // <em>현재 많이 쓰이는 방식</em></li></ol><h3 id="1-private-생성자-이용"><a href="#1-private-생성자-이용" class="headerlink" title="1. private 생성자 이용"></a>1. private 생성자 이용</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis(); <span class="comment">// (1)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// (2)</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) <code>private 생성자</code>는 (1)의 Elvis.INSTANCE를 초기화할 때 한번 호출 된다. 생성자가 private이므로 한번 생성된 후에는 다시 객체가 생성되지 않는다.</p><h3 id="2-static-factory-method-이용"><a href="#2-static-factory-method-이용" class="headerlink" title="2. static factory method 이용"></a>2. static factory method 이용</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis(); <span class="comment">// (1)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">// (2)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTACE; &#125; <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1)에서 객체를 생성 한 뒤 (3)의 <code>getInstance</code>에서 항상 같은 참조를 반환한다. (2) 생성자가 <code>private</code>이므로 외부에서 <code>new</code> 연산자로 객체를 생성하지 못한다.</p><p>1과 2 방식 모두 <code>Eagar Initialization</code>으로 객체가 사용되기 전에 미리 생성한다. 항상 싱글톤 객체가 필요하거나 객체 생성비용이 크지 않을 때 사용한다. 이 방식들은 <code>thread safe</code>하지 않다. 또한 Java의 <code>reflection</code> 기능을 통해 <code>private</code> 생성자를 호출하여 싱글톤 패턴을 깨드릴 수 있다.</p><h3 id="Lazy-Initialization"><a href="#Lazy-Initialization" class="headerlink" title="Lazy Initialization"></a>Lazy Initialization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitialization</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> fianl LazyInitialization INSTANCE; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LazyInitialization</span> <span class="params">()</span> </span>&#123;&#125; <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyInitialization <span class="title">getInstance</span> <span class="params">()</span></span>&#123; <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (INSTACE == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> LazyInitialization();</span><br><span class="line">    <span class="keyword">return</span> INSTACE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LazyInitialization 방식은 객체가 사용되는 시점에 (3) 객체를 만들어서 반환한다. 이 방식 또한 <code>thread safe</code>하지 않으며 <code>reflection</code> 으로 패턴을 깨뜨릴 수 있다.</p><h3 id="Thread-Safe-Initialization"><a href="#Thread-Safe-Initialization" class="headerlink" title="Thread Safe Initialization"></a>Thread Safe Initialization</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeInitialization</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadSafeInitialization instance; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeInitialization</span> <span class="params">()</span> </span>&#123;&#125; <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> ThreadSafeInitialization <span class="title">getInstance</span> <span class="params">()</span> </span>&#123; <span class="comment">// (3)</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> ThreadSafeInitialization();</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>thread safe</code>하기 위해 (3)<code>synchronized</code>를 사용했다. <code>multi thread</code> 문제는 해소됐지만, 수많은 스레드들이 <code>getInstance</code>를 호출한다면 프로그램의 성능 저하가 일어날 수 있다.</p><h3 id="3-enum-자료형의-사용"><a href="#3-enum-자료형의-사용" class="headerlink" title="3. enum 자료형의 사용"></a>3. enum 자료형의 사용</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumInitialization &#123;</span><br><span class="line">  INSTACE;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumInitialization <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTACE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enum 자료형을 사용하는 경우 직렬화(Serializable) 클래스를 만들어도 문제가 없으며, reflection 공격에도 안전하다. 또한 instance가 생성될 때 multi thread에도 안전하다.</p><h3 id="4-Initialization-on-demand-holder-idiom"><a href="#4-Initialization-on-demand-holder-idiom" class="headerlink" title="4. Initialization on demand holder idiom"></a>4. Initialization on demand holder idiom</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationOnDemandHolderIdom</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">InitializationOnDemandHolderIdom</span> <span class="params">()</span> </span>&#123;&#125; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">singletonHolder</span> </span>&#123; <span class="comment">// (2)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InitializationOnDemandHolderIdom instance = <span class="keyword">new</span> InitializationOnDemandHolderIdom(); <span class="comment">// (3)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InitializationOnDemandHolderIdom <span class="title">getInstance</span><span class="params">()</span></span>&#123; <span class="comment">// (4)</span></span><br><span class="line">    <span class="keyword">return</span> singletonHolder.instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>holder를 이용한 초기화 방식으로 클래스 내부에 (2) 내부 클래스에 instance를 생성한다. (4)의 <code>getInstance</code>가 호출될 때 내부 클래스가 참조되며 instance가 (3) static final로 선언되어 있어서 처음 클래스가 로드될 때 최초 한번 객체가 생성된다. 클래스가 생성되는 순간은 <code>thread safe</code>하기 때문에 multi thread 문제에도 안전하다. 현재 Java의 singleton은 이 방식을 많이 사용한다.</p><h3 id="참고-자료"><a href="#참고-자료" class="headerlink" title="참고 자료"></a>참고 자료</h3><ul><li><a href="https://blog.seotory.com/post/2016/03/java-singleton-pattern" target="_blank" rel="noopener">java singleton pattern</a></li><li><a href="http://limkydev.tistory.com/67" target="_blank" rel="noopener">[Design_Pattern] Singleton(싱글톤)의 고도화</a></li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Effective-Java-규칙-3&quot;&gt;&lt;a href=&quot;#Effective-Java-규칙-3&quot; class=&quot;headerlink&quot; title=&quot;Effective Java 규칙 3&quot;&gt;&lt;/a&gt;Effective Java 규칙 3&lt;/h2&gt;&lt;bloc
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Effective Java" scheme="https://kodakyung.github.io/tags/effective-java/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
      <category term="Design Pattern" scheme="https://kodakyung.github.io/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>STS - The selection cannot be run on any server.</title>
    <link href="https://kodakyung.github.io/2018/09/29/troubleshooting-2018-09-29-sts-cannot-be-run-on-server/"/>
    <id>https://kodakyung.github.io/2018/09/29/troubleshooting-2018-09-29-sts-cannot-be-run-on-server/</id>
    <published>2018-09-28T15:00:00.000Z</published>
    <updated>2020-03-19T01:36:46.386Z</updated>
    
    <content type="html"><![CDATA[<p>STS(Eclipse)로 Gradle 프로젝트 생성 후 서버를 찾을 수 없을 경우</p><h2 id="에러-화면"><a href="#에러-화면" class="headerlink" title="에러 화면"></a>에러 화면</h2><blockquote><p>The selection cannot be run on any server.</p></blockquote><img width="518" alt="에러 메세지" src="/images/2018-09-29/01.png"><h2 id="프로젝트-설정-변경"><a href="#프로젝트-설정-변경" class="headerlink" title="프로젝트 설정 변경"></a>프로젝트 설정 변경</h2><ul><li>프로젝트 우클릭-&gt;[Properties]-&gt;[Project Facets]</li></ul><img width="298" alt="프로젝트 우클릭" src="/images/2018-09-29/02.png"><ul><li><code>Dynamic Web Module</code>과 <code>Java</code> 버전에 맞춰서 추가</li></ul><img width="984" src="/images/2018-09-29/03.png"><h2 id="이후-서버-실행-시-에러-발생한-경우"><a href="#이후-서버-실행-시-에러-발생한-경우" class="headerlink" title="이후 서버 실행 시 에러 발생한 경우"></a>이후 서버 실행 시 에러 발생한 경우</h2><blockquote><p>Project facet Cloud Foundry Standalone Application version 1.0 is not supported.</p></blockquote><img width="539" src="/images/2018-09-29/04.png"><ul><li>위와 같은 [Project Facets]에 들어가서<br><code>Cloud Foundry Standalone Application</code>을 체크 해제한다.</li></ul><img width="641" src="/images/2018-09-29/05.png"><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;STS(Eclipse)로 Gradle 프로젝트 생성 후 서버를 찾을 수 없을 경우&lt;/p&gt;
&lt;h2 id=&quot;에러-화면&quot;&gt;&lt;a href=&quot;#에러-화면&quot; class=&quot;headerlink&quot; title=&quot;에러 화면&quot;&gt;&lt;/a&gt;에러 화면&lt;/h2&gt;&lt;blockqu
      
    
    </summary>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/categories/troubleshooting/"/>
    
    
      <category term="Spring" scheme="https://kodakyung.github.io/tags/spring/"/>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/tags/troubleshooting/"/>
    
      <category term="STS" scheme="https://kodakyung.github.io/tags/sts/"/>
    
  </entry>
  
  <entry>
    <title>Refactoring과 Test/TDD</title>
    <link href="https://kodakyung.github.io/2018/09/24/server-test-2018-09-24-refactoring-and-tdd/"/>
    <id>https://kodakyung.github.io/2018/09/24/server-test-2018-09-24-refactoring-and-tdd/</id>
    <published>2018-09-23T15:00:00.000Z</published>
    <updated>2020-03-19T01:34:09.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="리팩토링이란"><a href="#리팩토링이란" class="headerlink" title="리팩토링이란 ?"></a>리팩토링이란 ?</h2><p>중복을 제거하고 읽기 좋은 코드를 구현하기 위해 구조를 변경하는 것.<br>소스코드의 가독성을 높이고 유지보수를 편하게 하기 위해서 소스코드의 구조를 변경하는 것. 기능상의 결과가 변경되는 것은 아니다.</p><h3 id="3원칙을-생각하면서-리팩토링을-연습하자"><a href="#3원칙을-생각하면서-리팩토링을-연습하자" class="headerlink" title="3원칙을 생각하면서 리팩토링을 연습하자"></a>3원칙을 생각하면서 리팩토링을 연습하자</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 메소드는 한 가지 책임만 가지도록 구현</span><br><span class="line">2. 인덴트 깊이를 1단계로 유지</span><br><span class="line">3. else를 사용하지 마라</span><br></pre></td></tr></table></figure><ul><li>복잡도가 쉽게 증가하는 원인 : 요구사항의 복잡도가 높은 것이 가장 큰 원인.  <ul><li>리팩토링을 통해 소스코드를 깔끔하게 구현하는 연습을 함으로써 낮춘다.</li></ul></li></ul><h3 id="리팩토링-과정"><a href="#리팩토링-과정" class="headerlink" title="리팩토링 과정"></a>리팩토링 과정</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 요구사항을 작은 단위로 나누어 구현가능한 상태로 만드는 작업</span><br><span class="line">2. 하나의 요구사항을 완료한 뒤 리팩토링을 하고 넘어갈 것.</span><br><span class="line">  - 구현 -&gt; 테스트를 통한 결과 확인 -&gt; 리팩토링</span><br></pre></td></tr></table></figure><h3 id="테스트"><a href="#테스트" class="headerlink" title="테스트"></a>테스트</h3><ul><li>테스트 코드가 있다면, 리팩토링을 통해 프로덕션 코드를 변경하더라도 테스트 코드를 통해 바로 검증할 수 있다.</li><li>따라서 리팩토링을 통해 소스코드를 개선하려면 테스트코드가 있어야한다. 테스트와 리팩토링을 함께 연습하는 것이 중요하다.</li></ul><h3 id="추가-학습"><a href="#추가-학습" class="headerlink" title="추가 학습"></a>추가 학습</h3><ul><li>TDD를 바로 연습하는 것도 좋지만, 우선 JUnit으로 테스트를 검증하는 방식으로 진행하다가 도전해보자.</li><li>TDD와 리팩토링을 연습할 때 외부 의존관계가 많은 코드(웹 UI, DB 연결된 코드 등)부터 하기보다는 이전에 구현해봤던 기능이나, 외부 의존관계가 없는 코드부터 시작하는 것이 좋다.</li><li>연습하기 가장 좋은 코드는 알고리즘이나 유틸리티 성격의 코드이다.</li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;리팩토링이란&quot;&gt;&lt;a href=&quot;#리팩토링이란&quot; class=&quot;headerlink&quot; title=&quot;리팩토링이란 ?&quot;&gt;&lt;/a&gt;리팩토링이란 ?&lt;/h2&gt;&lt;p&gt;중복을 제거하고 읽기 좋은 코드를 구현하기 위해 구조를 변경하는 것.&lt;br&gt;소스코드의 가독
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Test" scheme="https://kodakyung.github.io/categories/server/test/"/>
    
    
      <category term="Test" scheme="https://kodakyung.github.io/tags/test/"/>
    
      <category term="TDD" scheme="https://kodakyung.github.io/tags/tdd/"/>
    
      <category term="Refactoring" scheme="https://kodakyung.github.io/tags/refactoring/"/>
    
  </entry>
  
  <entry>
    <title>WEB - HTTP</title>
    <link href="https://kodakyung.github.io/2018/09/21/web-2018-09-21-web-http/"/>
    <id>https://kodakyung.github.io/2018/09/21/web-2018-09-21-web-http/</id>
    <published>2018-09-20T15:00:00.000Z</published>
    <updated>2020-03-19T01:37:32.510Z</updated>
    
    <content type="html"><![CDATA[<p>WEB의 구성 요소중 하나인 HTTP의 기본 개념</p><h2 id="HTTP-HyperText-Trasfer-Protocol"><a href="#HTTP-HyperText-Trasfer-Protocol" class="headerlink" title="HTTP (HyperText Trasfer Protocol)"></a>HTTP (HyperText Trasfer Protocol)</h2><ul><li>웹의 구성 요소</li></ul><hr><ol><li>HTML</li><li>URL &amp; URI</li><li>Web Browser &amp; Web Server</li><li>HTTP</li></ol><hr><p>이 때 Client가 Server에게 HTML을 달라고 요청하는 것을 <code>Request</code>,<br>Server가 HTML을 주면서 응답하는 것을 <code>Response</code>라 한다.</p><p>사용하고 있는 인터넷 브라우저의 [검사]- [Network] 탭을 통해 웹 브라우저와 웹 서버가 주고받은 http 코드를 볼 수 있다.<br>[Headers]를 통해 <code>Request Headers</code>/<code>Response Headers</code>를 확인할 수 있다. 웹 브라우저가 웹 서버에게 요청한 데이터와 웹서버가 응답한 데이터이다.</p><ul><li>Request Headers : 방식(GET/POST 등), HTTP 버전, 접속 HOST 등</li><li>Response Headers : HTTP 버전, 응답(200,400 등), Content-Length, Content-Type 등 을 표시</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 웹브라우저는 사용자가 요청한 정보를 Header라는 텍스트 정보를 만들어서 웹 서버에게 대신 물어보는 역할을 한다.  </span><br><span class="line">2. 웹 서버는 자신이 가진 정보를 보내주면서 응답 헤더를 보낸다.  </span><br><span class="line">3. 그리고 웹 브라우저는 서버에게 받는 정보를 그려주는 역할을 한다.</span><br></pre></td></tr></table></figure><h2 id="Request-Message"><a href="#Request-Message" class="headerlink" title="Request Message"></a>Request Message</h2><blockquote><p>Request Header 형식에 대해 검색한다면<br>&gt; http request header format</p></blockquote><img width="734" alt="http request header format" src="/images/2018-09-21/01.png"><h3 id="Request-Header의-구성-요소"><a href="#Request-Header의-구성-요소" class="headerlink" title="Request Header의 구성 요소"></a>Request Header의 구성 요소</h3><ol><li>Request Line + Request Headers = Request Message Header</li><li>Blank Line 으로 구분</li><li>실제 전송하는 내용 = Body(= Payload)</li></ol><h3 id="Request-Line"><a href="#Request-Line" class="headerlink" title="Request Line"></a>Request Line</h3><p>전송 방식을 나타낸다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- GET : 데이터를 웹서버로부터 가져올 때</span><br><span class="line">- POST : 데이터 전송할 때</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><p><strong>HTTP/1.1 메소드</strong></p><ul><li><dl><dt>GET : 리소스 획득</dt><dd>리퀘스트 URI로 식별된 리소드를 가져올 수 있도록 요구한다. 소스가 텍스트면 그대로 반환, GGI같은 프로그램이면 실행해서 출력된 내용을 반환한다.</dd></dl></li><li><dl><dt>POST : 엔티티 전송</dt><dd>GET으로도 엔티티를 전송할 수 있지만 일반적으로 POST를 사용한다.</dd></dl></li><li><dl><dt>PUT : 파일 전송</dt><dd>파일을 전송하기 위해 사용된다. 하지만 HTTP/1.1 PUT자체에는 인증 기능이 없어서 누구든지 파일 업로드가 가능해 보안 상의 문제가 있다. 웹 애플리케이션 등의 인증 기능과 함께 쓰거나 REST와 같은 웹끼리 연계하는 설계 방식을 사용할 때 이용하는 경우가 있다.</dd></dl></li><li><dl><dt>HEAD : 메세지 헤더 취득</dt><dd>GET과 같은 기능이지만 메세지 바디를 돌려주지 않는다. URI 유효성과 리소스 갱신 시간등을 확인하는 목적 등으로 사용된다.</dd></dl></li><li><dl><dt>DELETE : 파일 삭제</dt><dd>파일을 삭제하기 위해 사용된다. PUT 메소드와 반대로 동작하며 리퀘스트 URI로 지정된 리소스의 삭제를 요구한다. 단점과 이용또한 PUT과 마찬가지로 인증 기능이 없다.</dd></dl></li><li><dl><dt>OPTIONS : 제공하고 있는 메소드의 문의</dt><dd>리퀘스트 URI로 지정한 메소드가 제공하고 있는 메소드를 조사하기 위해 사용한다.</dd></dl></li><li><dl><dt>TRACE : 경로 조사</dt><dd>WEB 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백(loop-back)을 발생시킨다. 리퀘스트를 보낼 때 <code>Max-Forward</code>라는 헤더 필드에 수치를 포함시켜 서버를 통과할 때마다 수치를 줄여간다. 0이 된 곳을 끝이로 리퀘스트를 수신한 측해서 상태 코드 200 OK response를 돌려준다.<br>클라이언트는 TRACE 메소드를 사용함으로써 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있다.<br>하지만 TRACE 메소드는 XST와 같은 보안상의 문제가 있기 때문에 보통 사용되지 않는다.</dd></dl></li><li><dl><dt>CONNECT : 프록시에 터널링 요구</dt><dd>TCP 통신을 터널링 시키기 위해 사용된다. 주로 SSL이나 TLS 등의 프로토콜로 암호화된 것을 터널링 시키기 위해서 사용된다.</dd></dl><ul><li>CONNECT 메소드 양식<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT 프록시 서버 : 포트 HTTP 버전</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="Request-Headers"><a href="#Request-Headers" class="headerlink" title="Request Headers"></a>Request Headers</h3><ul><li>Host : 요청하는 웹서버의 주소로 필수로 기입되어있어야 한다.  <ul><li>웹 호스팅 서비스(Web hosting service) : 인터넷 호스팅 서비스의 일종으로 개인과 단체가 월드 와이드 웹을 통하여 웹사이트를 제공하는 것을 뜻한다.</li><li>가상 호스트 : 하나의 웹서버가 여러개의 도메인을 서비스할 수 있는데, 그런 경우에 A라는 웹서버가 <code>A.com B.com C.com</code> 호스팅을 하고, 각 주소별로 다른 웹사이트라면 HOST에 적힌 주소에 따라서 다른 정보를 보내줄 수 있다.</li></ul></li><li>Post : 한대의 컴퓨터에 여러개의 서버가 설치될 수 있는데 포트번호로 구분한다.</li><li>User-Agent : 웹 브라우저의 다른 표현. 사용자의 OS 환경도 확인할 수 있다. 사용자 정보를 수집하거나 bot을 확인 후 차단할 수 있다.</li><li>Accept-Encoding : 전송하는 데이터 양이 많은 경우 압축해서 보내고 받아서 풀어서 사용한다. 웹 브라우저가 어떤 압축 방식을 지원하는지 알려준다.</li><li>If-Modified-Since : 데이터를 요청할 때마다 다운로드 받는 것은 비효율적이으로 데이터를 요청할 때마다 항상 다운 받지 않는다. 따라서 내가 갖고 있는 파일을 마지막으로 언제 다운로드받은 것인지 웹서버에게 알려주고 웹 서버가 응답할 때 최신 여부를 비교해서 전송 또는 비전송 여부를 결정한다.</li></ul><h2 id="Response-Message"><a href="#Response-Message" class="headerlink" title="Response Message"></a>Response Message</h2><blockquote><p>HTTP 응답 메세지 형식에 대해 검색한다면<br>&gt; http response header format</p></blockquote><img width="519" alt="http response header format" src="/images/2018-09-21/02.png"><h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><p>: HTTP version, status code(응답 결과), phrase(응답 결과를 풀어쓴 것)를 보여준다.</p><ul><li>예) HTTP/1.1 200 OK</li></ul><h4 id="Http-status-code"><a href="#Http-status-code" class="headerlink" title="Http status code"></a>Http status code</h4><ul><li><p>1xx : Information // 리퀘스트를 받아들여 처리중</p></li><li><p>2xx : Success // 리퀘스트를 정상적으로 처리했음</p><ul><li>200 OK<br>: 클라이언트가 보낸 리퀘스트를 서버가 정상 처리 했음</li><li>201 Created</li><li>204 No Content<br>: 서버가 리퀘스트를 받아서 처리하는데 성공했지만 돌려줄 리소스가 없는 경우</li><li>206 Partial Content<br>: Range에 의해서 범위가 지정된 리퀘스트에 의해 서버가 부분적으로 GET 리퀘스트를 받았음을 나타낸다.<br>리스폰스에는 Content-Range로 지정된 범위의 엔티티가 포함된다.</li></ul></li><li><p>3xx : Redirection // 리퀘스트를 완료하기 위해서 추가동작이 필요</p></li><li><p>4xx : Client Errors // 서버는 리퀘스트 이해 불가능</p><ul><li>400 Bad Request<br>: 리퀘스트 구문이 잘못되었음. 브라우저는 이것을 200 OK와 같은 취급을 한다.</li><li>401 Unauthorized<br>: 송신한 리퀘스트에 HTTP인증 정보가 필요한다는 것을 나타낸다.</li><li>403 Forbidden<br>: 접속하면 안되는 곳을 접속했을 때</li><li>404 Not Found<br>: 어떤 주소를 요청했는데 서버에 없는 경우</li></ul></li><li><p>5xx : Server Errors // 서버의 리퀘스트 처리 실패</p><ul><li>500 Internel Server Error<br>: 서버에서 리퀘스트를 처리하는 도중에 에러가 발생함.</li><li>503 Service Unavaliable<br>: 일시적으로 서버가 과부하 상태이거나 점검 중이기때문에 현재 리퀘스트를 처리할 수 없음을 나타냄.</li></ul></li></ul><h4 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h4><ul><li>Content-Type : text/HTML  <ul><li>웹 브라우저가 Content-Type을 보고 HTML로 해석해서 보여준다.</li></ul></li><li>Content-Length : 전체 크기(Byte)</li><li>Content-Encoding : 압축 방식을 알려준다.</li><li>Last-Modified : 이 정보가 마지막으로 수정된 날짜를 보여준다.</li></ul><h4 id="웹브라우저와-웹-서버의-커뮤니케이션-과정"><a href="#웹브라우저와-웹-서버의-커뮤니케이션-과정" class="headerlink" title="웹브라우저와 웹 서버의 커뮤니케이션 과정"></a>웹브라우저와 웹 서버의 커뮤니케이션 과정</h4><ol><li>웹 브라우저가 Request Headers를 생성하고</li><li>추가로(POST인 경우 등) 한줄 띄우고 웹서버로 전송할 정보를 담아서</li><li>메세지를 만든 다음에 인터넷을 통해 웹서버로 보낸다.</li><li>웹서버는 메세지를 해석해서 응답메세지를 만든다.(Response Headers)</li><li>그리고 한줄 띄우고 실제 HTML코드를 합쳐서 인터넷을 통해 요청한 컴퓨터로 보낸다.</li><li>웹브라우저는 이를 통해 헤더와 본문을 참조해서 사용자에게 화면을 보여준다.</li></ol><h2 id="앞으로-공부할-주제"><a href="#앞으로-공부할-주제" class="headerlink" title="앞으로 공부할 주제"></a>앞으로 공부할 주제</h2><ul><li>HTTP와 HTTPS(Http Secure)의 차이(SSL)</li><li>Cache(저장) : 데이터를 항상 새로 받아오지 않고 따로 저장해둠으로써 속도를 향상시킨다.<ul><li>문제점 : 내용이 갱신되었을 때 웹 브라우저가 알아채지 못한다.(F5가 캐시 갱신)</li><li>해결하기 위한 테크닉 : cache-control / pragma / application cache 등 - 성능 향상에 관심이 있다면 살펴볼 문제</li></ul></li><li>개인화 : 이전 로그인 기록을 웹사이트 / 웹브라우저가 기억하고 있는 것 Cookie 이용</li><li>Cookie : 쿠키값을 웹 브라우저에 설정하면 접속할때마다 설정된 쿠키값을 서버에 전송 함으로써 사용자의 상태를 유지, 식별할 수 있다.</li><li>web storage : 쿠키보다 발전되고 안전한 기술.</li><li>proxy server : 웹 브라우저와 웹 서버 사이에 중계 서버를 두어서 중간에 있는 서버가 캐시를 대신해주거나 보안과 관련된 공격을 막아주거나 사용자의 요청을 여러대로 분산하는 경우 등의 역할을 한다.</li><li>Network Monitoring : 가장 간단한 툴은 웹 브라우저에 개발자 도구의 [네트워크] 모니터링 기능. 또는 Wireshark. 컴퓨터의 모든 네트워크 트래픽을 볼 수 있다.</li></ul><blockquote><p>출처 : 생활코딩 - HTTP</p></blockquote><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WEB의 구성 요소중 하나인 HTTP의 기본 개념&lt;/p&gt;
&lt;h2 id=&quot;HTTP-HyperText-Trasfer-Protocol&quot;&gt;&lt;a href=&quot;#HTTP-HyperText-Trasfer-Protocol&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Web" scheme="https://kodakyung.github.io/categories/web/"/>
    
    
      <category term="생활코딩" scheme="https://kodakyung.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"/>
    
      <category term="Web" scheme="https://kodakyung.github.io/tags/web/"/>
    
      <category term="HTTP" scheme="https://kodakyung.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>WEB - OAuth2.0</title>
    <link href="https://kodakyung.github.io/2018/09/20/web-2018-09-20-web-oauth2/"/>
    <id>https://kodakyung.github.io/2018/09/20/web-2018-09-20-web-oauth2/</id>
    <published>2018-09-19T15:00:00.000Z</published>
    <updated>2020-03-19T01:37:36.214Z</updated>
    
    <content type="html"><![CDATA[<p>OAuth2.0 인증 시스템의 원리</p><h2 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h2><p>OAuth에는 세 개의 참여자가 등장한다.</p><ol><li>mine : 내 서비스</li><li>User : 1의 사용자</li><li>Thier : 연동하려는 서비스</li></ol><p>(1)이 (2)를 통해 (3) 서비스를 사용한다면, (3)의 서비스에 접근할 수 있도록 허가를 받아야한다. (2)에게 ID, PW를 전달 받아서 저장해서 (1)에서 (3) 접속할 때 사용한다면 간단하지만 위험할 것이다.  </p><p>따라서 OAuth를 이용해야한다. OAuth는 <code>accessToken</code>이라는 일종의 비밀번호를 발급해 사용하기 때문에 안전하게 내 서비스와 외부 서비스를 상호작용할 수 있다.</p><ul><li><p>장점  </p><ol><li>전달하는 것이 아이디와 비밀번호가 아니다.</li><li>(3)의 서비스의 필요한 부분만 부분적으로 허가를 받아서 사용할 수 있음</li><li>액세스 토큰을 통해 (3)에 접근해서 CRUD 작업을 할 수 있음</li></ol></li></ul><h2 id="accessToken을-얻어내는-핵심-원리에-대해"><a href="#accessToken을-얻어내는-핵심-원리에-대해" class="headerlink" title="accessToken을 얻어내는 핵심 원리에 대해"></a>accessToken을 얻어내는 핵심 원리에 대해</h2><h3 id="Role"><a href="#Role" class="headerlink" title="Role"></a>Role</h3><ol><li>mine -&gt; <code>Client</code></li><li>User -&gt; <code>Resource Owner</code></li><li>Thier -&gt; <code>Resource Server</code> : 데이터를 가지고 있는 서버<br>+ <code>Authrization Server</code> : 인증 관련 서버</li></ol><p>Resource Server와 Authorization Server는 다르지만 우선 여기서는 Resource Server와 같이 설명한다.</p><h3 id="등록하는-절차"><a href="#등록하는-절차" class="headerlink" title="등록하는 절차"></a>등록하는 절차</h3><p>Client가 RS를 이용하기 위해서는 RS서버의 승인을 사전에 받아놓아야 한다.<br>이를 등록(register)이라 한다.</p><p>RS마다 각각 다르지만 일반적으로 아래 세개는 동일하다.</p><ol><li>Client ID<br>: (1)을 식별하는 식별자 아이디</li><li>Client Secret<br>: (1)의 비밀번호, 외부에 노출되면 안된다.</li><li>Authorized redirect URIs<br>: RS가 권한을 부여하는 과정에서 Authorized Code를 주는데 이 주소로 전달하게 된다. 해당 주소가 아닌 곳에서 요청이 들어오면 무시한다.</li></ol><h3 id="Resource-Owner의-승인"><a href="#Resource-Owner의-승인" class="headerlink" title="Resource Owner의 승인"></a>Resource Owner의 승인</h3><p>등록하게 되면 RS는 <code>Client Id</code>/ <code>Client Secret</code> / <code>redirect URL</code>을 알게 되고,<br>Client는 <code>Client Id</code>/ <code>Client Secret</code>을 알게 된다. 이때 Client는 redirect URL에 해당하는 페이지는 구현해놓고 있어야한다.</p><p>RS의 기능이 4개라면, (A,B,C,D)<br>Client는 B와 C의 기능만 필요하다면, 최소한의 기능만 인증받는 것이 좋다.</p><blockquote><p>이하 Resource Server = RS<br>Resource Owner = RO<br>Client = C 또는 Client로 표기</p></blockquote><ul><li>인증 과정</li></ul><ol><li><p>RO는 C에 접속한다.</p></li><li><p>접속하는 과정에서 RS에 접속이 필요하다면</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(예)페이스북으로 로그인하기..</span><br><span class="line">or 페이스북의 어떤 기능이 필요하다는 화면</span><br></pre></td></tr></table></figure><p>을 통해 사용자의 동의를 구한다.<br>이때 보이는 로그인 버튼은 단순히 <code>Resource Server</code>, <code>Client Id</code>, <code>사용하려는 기능(scope)</code>, <code>redirect id</code>값을 링크로 제공해주면 된다.</p></li><li><p>(2)를 통해 RO가 RS에 접속하면<br>로그인 되어있지 않은 경우 로그인 요청을 한다. 로그인이 되어 있다면 <code>client id</code>/<code>redirect id</code>를 확인해서, 같다면 scope에 해당하는 권한을 C에게 줄것인지 확인하는 메세지를 RO에게 보내게 된다.</p></li><li><p>RO가 확인 후 허용한다면 허용 정보를 RS에게 보낸다. 그러면 특정 유저가 어떤 기능을 허용하는데 동의한다는 정보를 RS에 저장하게된다. (DB 등)</p></li></ol><h3 id="Resource-Server의-승인"><a href="#Resource-Server의-승인" class="headerlink" title="Resource Server의 승인"></a>Resource Server의 승인</h3><ol><li><p>위의 과정 이후 accessToken을 발급하기 전에 임시 비밀번호인 <code>Authrization Code</code>를 RS가 RO에게 보낸다.</p></li><li><p>RO는 RS가 보낸 패킷의 Location 헤더 값에 의해서 C의 주소로 이동하게 된다(<code>redirect</code>). 이때 C에게 Authrization Code를 알려준다.  </p></li><li><p>이제 Client는 Authrization Code로 RS에 직접 접속하게 된다. 이때 <code>Authrization Code</code>, <code>redirect id</code>, <code>client secret</code> 정보를 RS에게 보낸다.</p></li><li><p>RS는 Authrization Code를 보고 Client를 식별한다.</p></li></ol><h3 id="accessToken-발급"><a href="#accessToken-발급" class="headerlink" title="accessToken 발급"></a>accessToken 발급</h3><ol><li>RS는 accessToken을 발급한다. 그리고 accessToken을 C에 응답한다.</li><li>이 accessToken을 C는 내부적으로 저장한다.</li></ol><h3 id="API-호출"><a href="#API-호출" class="headerlink" title="API 호출"></a>API 호출</h3><p>= Resource Server 핸들링</p><p>Client가 Resource Server url에 접속하면 데이터를 보여준다.<br>즉 URL이 API처럼 되는 것.<br><strong>-&gt; 이 URL은 accessToken이 있어야 제대로 출력된다.<br>따라서 accessToken은 절대 남에게 공개하면 안된다.</strong></p><p>API 핸들링 방식은 RS마다 다르므로 공식 문서를 찾아봐야한다.</p><ul><li>구글 api 사용 방법을 검색</li></ul><blockquote><p>google api accessToken oauth</p></blockquote><p>구글은 accessToken을 Query Parameter로 보내거나 헤더의 Authorization에 Bearer로 보내는 두가지 방식을 사용한다.</p><p>두가지 방식 중 헤더 값으로 Bearer를 보내는 방식이 더 선호된다.</p><p>이 때 curl을 통해 좀 더 손쉽게 보낼 수 있음.</p><blockquote><p>curl은 웹페이지를 다운로드 받는 프로그램</p></blockquote><h3 id="Refresh-Token"><a href="#Refresh-Token" class="headerlink" title="Refresh Token"></a>Refresh Token</h3><p>accessToken은 수명이 존재한다. 일반적으로 1~2시간, 길면 60~90일 등 수명이 끝나면 api가 정보를 주지 않는다.  </p><p>수명이 끝나면 accessToken을 다시 발급 받아야 하는데 그때마다 사용자에게 인증을 받기 힘들다면 refresh token을 사용하면 된다.</p><ul><li>refresh token에 대해 검색</li></ul><blockquote><p>oauth 2.0 rfc<br>rfc: 인터넷 관련된 표준안</p></blockquote><p>위의 문서에서 Oauth-&gt;refresh token 항목을 참고하자.</p><p>보통 accessToken을 발급할 때 refresh token도 발급 받는 경우가 많다.<br>만료 됐을 때 refresh token을 보내면서 accessToken을 다시 발급 받는다. 이때 refresh token을 같이 다시 발급 받는 경우도 있다.</p><p>리소스 서버마다 refreshing 방법이 다르기 때문에 메뉴얼을 참고해야한다.</p><h2 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h2><p>Federated Identity : Login with Google과 같은 기술. OAuth를 사용한다.</p><br><blockquote><p>출처: <a href="https://opentutorials.org/course/3405" target="_blank" rel="noopener">생활코딩 - OAuth</a></p></blockquote><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OAuth2.0 인증 시스템의 원리&lt;/p&gt;
&lt;h2 id=&quot;OAuth2&quot;&gt;&lt;a href=&quot;#OAuth2&quot; class=&quot;headerlink&quot; title=&quot;OAuth2&quot;&gt;&lt;/a&gt;OAuth2&lt;/h2&gt;&lt;p&gt;OAuth에는 세 개의 참여자가 등장한다.&lt;/p&gt;
      
    
    </summary>
    
      <category term="Web" scheme="https://kodakyung.github.io/categories/web/"/>
    
    
      <category term="OAuth2" scheme="https://kodakyung.github.io/tags/oauth2/"/>
    
      <category term="생활코딩" scheme="https://kodakyung.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"/>
    
      <category term="Web" scheme="https://kodakyung.github.io/tags/web/"/>
    
      <category term="Authrization" scheme="https://kodakyung.github.io/tags/authrization/"/>
    
  </entry>
  
  <entry>
    <title>STS - CLI 환경에서 git pull/clone 후 STS에서 프로젝트 import 하기</title>
    <link href="https://kodakyung.github.io/2018/09/11/server-spring-2018-09-11-import-project-from-sts-after-git-pull-clone-in-cli/"/>
    <id>https://kodakyung.github.io/2018/09/11/server-spring-2018-09-11-import-project-from-sts-after-git-pull-clone-in-cli/</id>
    <published>2018-09-10T15:00:00.000Z</published>
    <updated>2020-03-19T01:33:57.374Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Mac Terminal에서 기존 프로젝트 git Clone</li><li>이후 STS에서 프로젝트 import</li><li>프로젝트 import 이후 프로젝트 실행 안되는 경우</li></ul><h2 id="CLI-환경에서-Git-Clone-후-STS에서-프로젝트-import-하기"><a href="#CLI-환경에서-Git-Clone-후-STS에서-프로젝트-import-하기" class="headerlink" title="CLI 환경에서 Git Clone 후 STS에서 프로젝트 import 하기"></a>CLI 환경에서 Git Clone 후 STS에서 프로젝트 import 하기</h2><p>clone 한 프로젝트 상위 폴더에서 STS 실행 -&gt; [Package Explorer] 우클릭 -&gt; [import] -&gt; [General]-[Projects from Folder or Archive] -&gt; 프로젝트 폴더 선택</p><h2 id="import-후-Server에서-프로젝트-인식이-안되는-경우"><a href="#import-후-Server에서-프로젝트-인식이-안되는-경우" class="headerlink" title="import 후 Server에서 프로젝트 인식이 안되는 경우"></a>import 후 Server에서 프로젝트 인식이 안되는 경우</h2><ul><li>Server 우클릭 -&gt; [Add and Remove]<img width="302" src="/images/2018-09-11/01.png"></li></ul><p>-&gt; [there are no resources that can be added or removed from the server] error<br><img width="516" src="/images/2018-09-11/02.png"></p><br><blockquote><p>프로젝트가 웹 프로젝트가 아니기 때문, 따라서 프로젝트 설정을 변경해주어야 함.</p></blockquote><br><ul><li>프로젝트 우클릭 -&gt; [Properties]<img width="298" src="/images/2018-09-11/03.png"></li></ul><p>-&gt; [Project Facets] -&gt; Dynamic Web Module, Java, Javascript 선택 -&gt; aplly<br><img width="781" src="/images/2018-09-11/04.png"></p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Mac Terminal에서 기존 프로젝트 git Clone&lt;/li&gt;
&lt;li&gt;이후 STS에서 프로젝트 import&lt;/li&gt;
&lt;li&gt;프로젝트 import 이후 프로젝트 실행 안되는 경우&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;CLI-환경에서-G
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Spring" scheme="https://kodakyung.github.io/categories/server/spring/"/>
    
    
      <category term="Spring" scheme="https://kodakyung.github.io/tags/spring/"/>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/tags/troubleshooting/"/>
    
      <category term="STS" scheme="https://kodakyung.github.io/tags/sts/"/>
    
  </entry>
  
  <entry>
    <title>Java equals method, instanceof, @Override</title>
    <link href="https://kodakyung.github.io/2018/08/28/programming-java-2018-08-28-java-equals-method-instanceof-override/"/>
    <id>https://kodakyung.github.io/2018/08/28/programming-java-2018-08-28-java-equals-method-instanceof-override/</id>
    <published>2018-08-27T15:00:00.000Z</published>
    <updated>2020-03-19T01:06:31.211Z</updated>
    
    <content type="html"><![CDATA[<ul><li>equals method</li><li>instanceof</li><li>@Override</li></ul><h2 id="equals-method"><a href="#equals-method" class="headerlink" title="equals method"></a>equals method</h2><p>Object 클래스는 모든 Java 클래스의 최고 상위 부모 클래스이다.<br>따라서 Object 클래스의 메소드는 모든 Java 클래스가 상속 받는다.</p><p>Object 클래스에 equals 메소드가 정의 되어 있는데,<br>equals 메소드는 기본적으로 객체의 내부 값이 동일한지 비교할 때 사용한다.<br>객체를 == 연산자로 비교한다면 객체 내부 값이 동일한지 비교하는 것이 아닌 두 참조가 같은 객체를 가리키고 있는지 검사한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">s1.equals(s2); <span class="comment">// (1) true</span></span><br><span class="line">s1 == s2; <span class="comment">// (2) false</span></span><br></pre></td></tr></table></figure><p>참조 변수 s1, s2 변수가 참조하는 객체의 내부 값이 동일하기 때문에 (1)은 true가 된다.<br>하지만 == 연산자는 같은 참조를 가리키고 있는지 검사하는 것이므로 false가 된다.</p><h2 id="equality-identity"><a href="#equality-identity" class="headerlink" title="equality / identity"></a>equality / identity</h2><p>equality : 두 객체의 내부 값이 같은지 비교<br>identity : 하나의 객체인지 비교</p><h2 id="equals-method를-재정의-해야하는-이유"><a href="#equals-method를-재정의-해야하는-이유" class="headerlink" title="equals method를 재정의 해야하는 이유"></a>equals method를 재정의 해야하는 이유</h2><p>자주 사용하는 클래스의 경우 equals method가 재정의 되어 있지만, 새 클래스를 구현하는 경우 equals method를 재정의해야 의도한대로(equality 비교) equals를 사용할 수 있다.<br>Object 클래스에서 상속되는 equals 메소드는 identity를 비교하는 방식으로 구현되어 있기 때문이다.<br>따라서 모든 멤버 변수 값이 같은지 비교하는 형태로 equals 메소드를 재정의 해야한다.</p><h2 id="instanceof-연산자"><a href="#instanceof-연산자" class="headerlink" title="instanceof 연산자"></a>instanceof 연산자</h2><p>객체가 속한 클래스를 확인할 때 <code>instanceof</code> 연산자를 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> String); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>참조 변수 s가 String 클래스 객체를 가리키므로 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object s = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> String); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Java에서는 부모 클래스 타입의 참조 변수가 자식 클래스 객체를 가리킬 수 있다.<br>위 코드에서는 참조 변수 s가 String 클래스 객체를 가리키므로 결과는 true이다.</p><h2 id="Override-Annotation"><a href="#Override-Annotation" class="headerlink" title="@Override Annotation"></a>@Override Annotation</h2><p>부모 클래스의 메소드를 자식 클래스에서 재정의(<code>Override</code>)할 때 이 어노테이션을 붙여준다. 생략가능하지만 붙여주는 것이 좋다.</p><h3 id="Override-Annotation의-장점"><a href="#Override-Annotation의-장점" class="headerlink" title="@Override Annotation의 장점"></a>@Override Annotation의 장점</h3><p>(1) 부모 클래스의 메소드와 재정의하는 메소드를 자동으로 검사한다.<br>부모 클래스의 메소드를 자식 클래스에서 재정의 하는 경우, 메소드 이름, 파라미터 수와 타입, 리턴 타입이 일치해야한다. 어노테이션을 붙이면 이 부분을 자동으로 검사해준다.<br>(2) 부모 클래스의 메소드를 재정의하는 것을 명시적으로 확인이 가능해서 코드 코드 읽는데 편리하다.</p><h2 id="equals-method-재정의"><a href="#equals-method-재정의" class="headerlink" title="equals method 재정의"></a>equals method 재정의</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Person&#123; <span class="comment">// 사용자가 정의한 클래스</span></span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123; <span class="comment">// (1)</span></span><br><span class="line">    <span class="keyword">if</span>((obj <span class="keyword">instanceof</span> Person) == <span class="keyword">false</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// (2)</span></span><br><span class="line">    Person p = (Person)obj;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age; <span class="comment">// (3)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(1) 부모 클래스의 파라미터 타입과 일치해야하기 때문에 Object 객체를 받는다.<br>(2) <code>instanceof</code> 메소드로 Person 객체가 아니라면 false를 리턴한다.<br>(3) 해당 줄의 this.name이 null일 경우 <code>NullPointerException</code>이 발생할 수 있기 때문에 수정이 필요하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.name == <span class="keyword">null</span> ? p.name == <span class="keyword">null</span> : <span class="keyword">this</span>.name.equals(p.name)) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br></pre></td></tr></table></figure><p>첫번째로 null 값을 한번 더 체크 하는 방식으로 수정할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.name, p.name) &amp;&amp; <span class="keyword">this</span>.age == p.age;</span><br></pre></td></tr></table></figure><p>두번째로 Object 클래스의 equals 메소드를 활용해 구현한다.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;equals method&lt;/li&gt;
&lt;li&gt;instanceof&lt;/li&gt;
&lt;li&gt;@Override&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;equals-method&quot;&gt;&lt;a href=&quot;#equals-method&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java 기본 자료형과 참조형 / String Class</title>
    <link href="https://kodakyung.github.io/2018/08/27/programming-java-2018-08-27-java-primary-refference-type/"/>
    <id>https://kodakyung.github.io/2018/08/27/programming-java-2018-08-27-java-primary-refference-type/</id>
    <published>2018-08-26T15:00:00.000Z</published>
    <updated>2020-03-19T01:06:21.176Z</updated>
    
    <content type="html"><![CDATA[<ul><li>reference type vs value type</li><li>String Class</li></ul><h2 id="Java-소스-파일과-패키지-규칙"><a href="#Java-소스-파일과-패키지-규칙" class="headerlink" title="Java 소스 파일과 패키지 규칙"></a>Java 소스 파일과 패키지 규칙</h2><ul><li>자바 소스 파일하나에 public 클래스는 한개만 들어있어야 한다</li><li>public 클래스 이름과 소스 코드 파일명이 정확히 일치해야함.</li><li>클래스가 속한 패키지 이름과 소스코드 파일이 위치한 폴더 이름이 대소문자까지 일치해야함.</li><li>JSP프로젝트 에서는 클래스는 반드시 어떤 패키지 아래 있어야 한다.</li></ul><h2 id="String-Class"><a href="#String-Class" class="headerlink" title="String Class"></a>String Class</h2><ul><li>Java 문자열은 대표적인 String 클래스</li><li>String 객체는 생성된 후 문자열 값이 수정될 수 없다. (Immutable Object)</li><li>String Class의 문자열 수정 메소드는 문자열을 수정하는 것이 아닌, 새 문자열을 만들어 수정된 새 문자열 객체를 리턴한다.</li></ul><h3 id="String-Class-알아야-할-필수-메소드"><a href="#String-Class-알아야-할-필수-메소드" class="headerlink" title="String Class 알아야 할 필수 메소드"></a>String Class 알아야 할 필수 메소드</h3><ul><li>char charAt(int index)</li><li>int compareTo(String s)</li><li>int compareToIgnoreCase(String s)</li><li>boolean contains(CharSequence s)</li><li>boolean endWith(String s)</li><li>boolean equals(Object s)</li><li>boolean equalsIgnoreCase(Object s)</li><li>static String format(String format, Object … args)</li><li>int indexOf(String s)</li><li>boolean isEmpty()</li><li>int lastIndexOf(String s)</li><li>int length</li><li>boolean matches(String regex)</li><li>String replace(CharSequence s1, CharSequence s2)</li><li>String replaceAll(String regex, String s2)</li><li>String[] split(String regex)</li><li>boolean startsWith(String s)</li><li>String substring(int beginIndex)</li><li>String substring(int beginIndex, int endIndex)</li><li>String toLowerCase()</li><li>String toUpperCase()</li><li>String trim()</li><li>static String valueOf(int i)</li><li>static String valueOf(Double d)</li></ul><blockquote><p>참고 : <a href="https://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">Java7 Reference</a></p></blockquote><h2 id="Immutable-Object"><a href="#Immutable-Object" class="headerlink" title="Immutable Object"></a>Immutable Object</h2><ul><li>대표적으로 String 객체.</li><li>String 객체는 생성된 뒤 문자열 값을 수정할 수 없다.</li><li>String의 수정 메소드는 this 문자열을 수정하는 것이 아니라 수정한 내용으로 새 문자열 객체를 만들어서 return 한다.</li></ul><h2 id="Value-Object"><a href="#Value-Object" class="headerlink" title="Value Object"></a>Value Object</h2><ul><li>기본 자료형과 같은 방식으로 사용할 수 있도록 만들어진 객체.<blockquote><p>ex) int -&gt; Integer</p></blockquote></li></ul><h2 id="Object-Class"><a href="#Object-Class" class="headerlink" title="Object Class"></a>Object Class</h2><ul><li>Java 언어에서 모든 클래스의 부모 클래스</li></ul><h3 id="Object-Class-알아야할-필수-메소드"><a href="#Object-Class-알아야할-필수-메소드" class="headerlink" title="Object Class 알아야할 필수 메소드"></a>Object Class 알아야할 필수 메소드</h3><ul><li>protected Object clone()</li><li>boolean equals(Object obj)</li><li>protected void finalize()</li><li>Class&lt;?&gt; getClass()</li><li>int hashCode()</li><li>String toString()</li></ul><h2 id="value-type"><a href="#value-type" class="headerlink" title="value type"></a>value type</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>변수에 값이 대입되는 자료형을 값 타입(value type)이라 함.<br>java의 기본 자료형은 모두 value type이다.</p><h2 id="reference-type"><a href="#reference-type" class="headerlink" title="reference type"></a>reference type</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure><p>객체를 가리키는 주소같은 것을 참조(reference)라 하며,<br>변수에 값이 아닌 참조가 대입되는 자료형을 참조 타입(reference type)이라 한다.</p><p>Java 클래스의 객체는 모두 참조 타입이다.<br>Java의 문자열은 String Class에 속해서 참조 타입이다.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;reference type vs value type&lt;/li&gt;
&lt;li&gt;String Class&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Java-소스-파일과-패키지-규칙&quot;&gt;&lt;a href=&quot;#Java-소스-파일과-패키지-규칙&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Java" scheme="https://kodakyung.github.io/categories/programming/java/"/>
    
    
      <category term="Java" scheme="https://kodakyung.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>코딩야학 Javascript 12일차</title>
    <link href="https://kodakyung.github.io/2018/08/25/programming-javascript-2018-08-25-codingyahac-javascript-12/"/>
    <id>https://kodakyung.github.io/2018/08/25/programming-javascript-2018-08-25-codingyahac-javascript-12/</id>
    <published>2018-08-24T15:00:00.000Z</published>
    <updated>2020-03-19T01:09:18.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="스터디에서-다룬-내용"><a href="#스터디에서-다룬-내용" class="headerlink" title="스터디에서 다룬 내용"></a>스터디에서 다룬 내용</h3><p><a href="https://opentutorials.org/course/3085/18856" target="_blank" rel="noopener">생활코딩 WEB2 Javascript ~라이브러리와 프래임워크 </a></p><h2 id="파일로-쪼개서-정리"><a href="#파일로-쪼개서-정리" class="headerlink" title="파일로 쪼개서 정리"></a>파일로 쪼개서 정리</h2><p>script 코드를 여러 html에 적용하는 경우<br><code>공통된 script 코드</code>를 <code>.js</code> 파일로 만들어 분리한 뒤 해당 html의 <code>script 태그</code>에 적용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"colors.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>웹브라우저 검사의 [Network] 탭을 보면 웹페이지를 로딩하기 위해 필요한 파일 목록이 보이는데 여기에 <code>colors.js</code>가 있는 것을 확인할 수 있다.</p><p>.js로 파일을 추가해 정리하면, 작성한 코드를 재사용할 수 있으며, 변화를 동시에 반영할 수 있다. 따라서 유지보수가 편리해진다. 또한 코드의 의미를 파일의 이름을 통해 확인할 수 있다.</p><p>js 파일을 분리하는 경우 브라우저에 어플리케이션을 로드할 때 웹서버에 추가로 접근하게 된다. (html과 js 파일 각각 받아오기 때문)<br>비효율적이게 보이지만 이런 방식을 사용하는 것이 훨씬 효율적이다. 왜냐하면 <code>cache</code>를 이용해 파일을 다운로드해 두기 때문이다.</p><h2 id="Library-amp-Framework-라이브러리와-프레임워크"><a href="#Library-amp-Framework-라이브러리와-프레임워크" class="headerlink" title="Library &amp; Framework (라이브러리와 프레임워크)"></a>Library &amp; Framework (라이브러리와 프레임워크)</h2><p>소프트웨어를 혼자 다 만드는 경우는 거의 없다.<br>타인이 만들어 둔 기능을 가져다 쓰는 경우가 대부분이다.</p><h3 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h3><p>내가 만들고자 하는 부품들을 재사용 하기 쉽도록 정리정돈 해둔 것. 부품을 가져오는 느낌.</p><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><p>만들고자하는 것이 있을 때 그것이 무엇이냐에 따라서(게임, 웹, 채팅 …) 그것을 만들기 위해 언제나 필요한 공통적인 것을 프레임워크가 제공하고 필요한 달라지는 부분만 우리가 수정해 제작할 수 있도록 하는 반제품과 같은 것.</p><p>= 다른 사람과 협력하기 위한 모델들이라는 면에서 Library와 Framework는 같다.</p><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>직접 JS를 사용하는 것보다 생산성이 훨씬 올라간다.</p><ul><li>jQuery를 사용하는 방법  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 파일을 직접 다운로드 해 프로젝트 폴더에 포함시킨다.  </span><br><span class="line">  : 따로 서버에 파일을 올리는 등 추가 작업이 필요.</span><br><span class="line">2. CDN 이용 (Content Delivery Network)  </span><br><span class="line">  : 자기들의 서버에 파일을 보관하고 우리는 src 태그를 이용해 가져다 사용할 수 있다.</span><br></pre></td></tr></table></figure><ul><li>처리해야할 태그들이 여러개 있을 때 반복문을 이용하지만,<br><code>jQuery</code>를 이용하면 반복문을 쓰지않고 할 수 있다.</li></ul><blockquote><p>jQuery css 검색</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alist = <span class="built_in">document</span>.querySelectorAll(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;alist.length)&#123;</span><br><span class="line">  alist[i].style.color = color;</span><br><span class="line">  i = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">$(<span class="string">'a'</span>).css(<span class="string">'color'</span>,color);</span><br></pre></td></tr></table></figure><p>$라는 이름의 함수를 이용한다. 해당 웹페이지의 모든 a 태그를 jquery로 제어한다는 의미이다.<br>검색 결과를 바탕으로 jquery로 css를 사용하기 위해 <code>.css</code>를 이용한다. 첫번째 인자로 <code>a 태그의 color</code>값을, 두번째 인자로 <code>파라매터로 들어온 color</code>를 받는다. 위의 javascript 코드와 같은 동작을 한다.</p><h2 id="UI-vs-API"><a href="#UI-vs-API" class="headerlink" title="UI vs API"></a>UI vs API</h2><h3 id="UI-User-Interface"><a href="#UI-User-Interface" class="headerlink" title="UI(User Interface)"></a>UI(User Interface)</h3><p>사용자가 시스템을 조작하기 위해 사용하는 인터페이스를 UI라 한다.</p><h3 id="API-Application-programming-Interface"><a href="#API-Application-programming-Interface" class="headerlink" title="API(Application programming Interface)"></a>API(Application programming Interface)</h3><p>Application을 만들기 위해서 프로그래밍을 할 때 사용하는 조작장치를 의미.</p><h2 id="수업을-마치며"><a href="#수업을-마치며" class="headerlink" title="수업을 마치며"></a>수업을 마치며</h2><p>이제 필요한 것은 공부보다는 실습, 실습보다는 프로젝트.<br>시작이 늦어질수록 공부를 많이할 수록 자신의 코드를 긍정하기 어렵다.</p><p>자신의 프로젝트를 시작할 때 모든 개념을 총동원하려고 하지 말아라. 필수불가결한 최소한의 도구 만을 이용해 문제를 해결하도록 해보자.</p><p>(는 프로그래밍을 처음 시작한 사람에게 해당하는 말인 것 같다.)</p><p>최소한의 것으로 해결되지 않는 순간이 올 때 조건문, 함수, 객체 등을 신중하게 도입해가며 사용해봐라.</p><p>또 다시 한계를 만났을 때 실습을 멈추고 공부를 시작해라.</p><h3 id="추천-검색어"><a href="#추천-검색어" class="headerlink" title="추천 검색어"></a>추천 검색어</h3><ul><li>document<br>웹페이지의 어떤 태그를 삭제하거나 자식 태그를 추가하고 싶다면, document 객체를 살펴보자</li><li>DOM(Document Object Model)<br>document에서도 찾을 수 없다면 DOM으로 수색범위를 넓혀보자. document 객체는 DOM의 일부이다.</li><li>window<br>웹브라우저 자체를 제어해야한다면 window 객체를 찾아보자. 현재 열려있는 웹페이지의 주소, 새창을 연다면, 웹브라우저의 화면 크기를 자바스크립트를 통해 알아야한다면.</li><li>ajax<br>웹페이지를 리로드하지 않고 정보를 변경하고 싶다면. 현대적인 웹앱의 필수 기술.</li><li>cookie<br>웹페이지가 리로드 되어도 현재 상태를 유지하고 싶다면 cookie를 학습. cookie를 통해 사용자를 위한 개인화된 서비스를 제공할 수 있다.</li><li>offline web application<br>인터넷이 끊겨도 동작하는 웹페이지를 만들고 싶다면, 이 키워드를 찾아보자.</li><li>webRTC<br>화상통신 웹앱을 만들고 싶으면,</li><li>speech<br>사용자의 음성을 인식하고 음성으로 정보를 전달하고 싶다면 speech API를 찾아보자.</li><li>webGL<br>3차원 그래픽으로 게임과 같은 것을 만들고 싶으면 찾아보라.</li><li>webVR<br>가상현실에 관심이 많다면,<br>…</li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;스터디에서-다룬-내용&quot;&gt;&lt;a href=&quot;#스터디에서-다룬-내용&quot; class=&quot;headerlink&quot; title=&quot;스터디에서 다룬 내용&quot;&gt;&lt;/a&gt;스터디에서 다룬 내용&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://opentutorials.org
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/categories/programming/javascript/"/>
    
    
      <category term="생활코딩" scheme="https://kodakyung.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>코딩야학 Javascript 11일차</title>
    <link href="https://kodakyung.github.io/2018/08/24/programming-javascript-2018-08-24-codingyahac-javascript-11/"/>
    <id>https://kodakyung.github.io/2018/08/24/programming-javascript-2018-08-24-codingyahac-javascript-11/</id>
    <published>2018-08-23T15:00:00.000Z</published>
    <updated>2020-03-19T01:09:12.677Z</updated>
    
    <content type="html"><![CDATA[<h3 id="스터디에서-다룬-내용"><a href="#스터디에서-다룬-내용" class="headerlink" title="스터디에서 다룬 내용"></a>스터디에서 다룬 내용</h3><p><a href="https://opentutorials.org/course/3085/18853" target="_blank" rel="noopener">생활코딩 WEB2 Javascript ~객체 </a></p><h2 id="객체"><a href="#객체" class="headerlink" title="객체"></a>객체</h2><ul><li><p><strong>간단히 정의하면, 정리정돈의 수단</strong></p></li><li><p>함수를 통해 로직의 이름을 부여하는 것도 좋은 전략이다.</p></li><li><p>document도 객체이다.</p></li><li><p>querySelector 또한 document에 속해있는 함수이다.</p></li><li><p>객체에 속해 있는 함수는 메소드라 한다.</p></li><li><p>배열은 정보를 담는 그릇, 정보가 순서대로 정보가 저장된다.</p></li><li><p>객체는 순서 없이 정보를 저장하는 그릇이다.</p></li></ul><h3 id="객체-쓰기와-읽기"><a href="#객체-쓰기와-읽기" class="headerlink" title="객체 쓰기와 읽기"></a>객체 쓰기와 읽기</h3><ul><li><p>객체 생성 및 가져오기</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coworkers = &#123;</span><br><span class="line">  <span class="string">"programmer"</span>:<span class="string">"koda"</span>,</span><br><span class="line">  <span class="string">"designer"</span>:<span class="string">"sso"</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"programmer : "</span>+coworkers.programmer);</span><br></pre></td></tr></table></figure></li><li><p>객체에 데이터 추가</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">coworkers[<span class="string">"data scientist"</span>] = <span class="string">"yangpa"</span>;</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"data scientist : "</span>+coworkers[<span class="string">"data scientist"</span>]+<span class="string">"&lt;br&gt;"</span>);</span><br></pre></td></tr></table></figure></li></ul><p>위와 같이 띄어쓰기가 있는 데이터도 추가가 가능하다.</p><h3 id="객체와-반복문"><a href="#객체와-반복문" class="headerlink" title="객체와 반복문"></a>객체와 반복문</h3><ul><li>생성된 객체에 어떤 데이터가 있는지 모조리 가져와야할 때</li></ul><blockquote><p>검색어 javascript object iterate</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> coworkers)&#123;</span><br><span class="line">  <span class="built_in">document</span>.write(key+<span class="string">'&lt;br&gt;'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>coworkers에 있는 key 값을 가져오는 코드이며 순서를 보장하지 않는다.<br><code>&quot;programmer&quot;:&quot;koda&quot;</code>의 programmer가 <code>key</code>에 해당한다. (배열은 인덱스라 표현 - 순서가 있음)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> coworkers)&#123;</span><br><span class="line">  <span class="built_in">document</span>.write(coworkers[key]+<span class="string">'&lt;br&gt;'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>객체를 생성할 때 배열의 형식을 이용하지만 인덱스의 자리에 키값을 넣는다. 따라서 접근할 때 <code>key</code>로 접근한다.</p><h3 id="객체-프로퍼티와-메소드"><a href="#객체-프로퍼티와-메소드" class="headerlink" title="객체 프로퍼티와 메소드"></a>객체 프로퍼티와 메소드</h3><p>객체는 데이터를 담을 수 있다. 문자, 배열, 숫자 등<br>객체는 <code>함수</code>도 담을 수 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">coworkers.showAll = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(key+<span class="string">' : '</span>+<span class="keyword">this</span>[key]+<span class="string">'&lt;br&gt;'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">coworkers.showAll();</span><br></pre></td></tr></table></figure><p>객체에 소속된 함수를 만들 수 있다. 이를 <code>메소드</code>라 한다.<br>객체에 소속된 변수는 <code>프로퍼티</code>라 한다.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;스터디에서-다룬-내용&quot;&gt;&lt;a href=&quot;#스터디에서-다룬-내용&quot; class=&quot;headerlink&quot; title=&quot;스터디에서 다룬 내용&quot;&gt;&lt;/a&gt;스터디에서 다룬 내용&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://opentutorials.org
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/categories/programming/javascript/"/>
    
    
      <category term="생활코딩" scheme="https://kodakyung.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>코딩야학 Javascript 10일차</title>
    <link href="https://kodakyung.github.io/2018/08/23/programming-javascript-2018-08-23-codingyahac-javascript-10/"/>
    <id>https://kodakyung.github.io/2018/08/23/programming-javascript-2018-08-23-codingyahac-javascript-10/</id>
    <published>2018-08-22T15:00:00.000Z</published>
    <updated>2020-03-19T01:09:07.336Z</updated>
    
    <content type="html"><![CDATA[<h3 id="스터디에서-다룬-내용"><a href="#스터디에서-다룬-내용" class="headerlink" title="스터디에서 다룬 내용"></a>스터디에서 다룬 내용</h3><p><a href="https://opentutorials.org/course/3085/18883" target="_blank" rel="noopener">생활코딩 WEB2 Javascript ~함수의 활용 </a></p><h2 id="학습할-내용"><a href="#학습할-내용" class="headerlink" title="학습할 내용"></a>학습할 내용</h2><ul><li>함수의 기본 문법</li><li>Parameter, Argument</li><li>return</li></ul><h3 id="함수의-기본-문법"><a href="#함수의-기본-문법" class="headerlink" title="함수의 기본 문법"></a>함수의 기본 문법</h3><p>반복문을 사용할 수 없는 경우 (연속적이지 않다면)<br>함수가 필요하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">'&lt;li&gt;2-1&lt;/li&gt;'</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">'&lt;li&gt;2-2&lt;/li&gt;'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Parameter-amp-Argument-매개변수와-인자"><a href="#Parameter-amp-Argument-매개변수와-인자" class="headerlink" title="Parameter &amp; Argument (매개변수와 인자)"></a>Parameter &amp; Argument (매개변수와 인자)</h3><p>자판기, 수학적인 함수 입력과 출력이 존재. 프로그래밍의 함수또한 마찬가지이다.  </p><p>입력값에 따라 다른 값을 출력하고 싶다면 매개변수와 인자를 이용 한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onePlusOne</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="number">1</span>+<span class="number">1</span>+<span class="string">'&lt;br&gt;'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  onePlusOne();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">left, right</span>) </span>&#123; <span class="comment">// left, right는 Parameter</span></span><br><span class="line">    <span class="built_in">document</span>.write(left+right+<span class="string">'&lt;br&gt;'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sum(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 5, 2와 3은 Argument</span></span><br><span class="line">  sum(<span class="number">3</span>,<span class="number">4</span>); <span class="comment">// 7</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Return-출력"><a href="#Return-출력" class="headerlink" title="Return (출력)"></a>Return (출력)</h3><ul><li><p>표현식이란 ?  </p><ul><li>1+1의 결과 값 2 : 1+1은 2에 대한 표현식</li><li>1===1의 결과 값 true : true는 1===1에 대한 표현식</li></ul></li><li><p>return을 이용해 표현식을 이용함으로써 함수의 활용도를 높일 수 있다.</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params">left, right</span>)</span>&#123; <span class="comment">// 5에 대한 표현식이 되도록.</span></span><br><span class="line">  <span class="keyword">return</span> left+right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.write(sum2(<span class="number">2</span>,<span class="number">3</span>)+<span class="string">'&lt;br/&gt;'</span>);</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;div style="color:red"&gt;'</span>+sum2(<span class="number">2</span>,<span class="number">3</span>)+<span class="string">'&lt;/div&gt;&lt;br/&gt;'</span>);</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">'&lt;div style="font-size:3rem;"&gt;'</span>+sum2(<span class="number">2</span>,<span class="number">3</span>)+<span class="string">'&lt;/div&gt;'</span>);</span><br></pre></td></tr></table></figure><h3 id="함수의-활용"><a href="#함수의-활용" class="headerlink" title="함수의 활용"></a>함수의 활용</h3><p>onclick안의 <code>this</code>는 이벤트 안의 태그를 가르키도록 되어있다<br>독립된 함수의 <code>this</code>는 해당 태그가 아닌 전역 객체를 가리키게 되어 있다. 웹브라우저 전역 객체는 <code>window</code>이다.</p><p>따라서 태그에서 함수를 실행시킬때 <code>this 매개변수</code>를 주고<br>함수에서 (관례적으로)<code>self</code>라는 이름으로 받는다.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;스터디에서-다룬-내용&quot;&gt;&lt;a href=&quot;#스터디에서-다룬-내용&quot; class=&quot;headerlink&quot; title=&quot;스터디에서 다룬 내용&quot;&gt;&lt;/a&gt;스터디에서 다룬 내용&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://opentutorials.org
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/categories/programming/javascript/"/>
    
    
      <category term="생활코딩" scheme="https://kodakyung.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>코딩야학 Javascript 9일차</title>
    <link href="https://kodakyung.github.io/2018/08/22/programming-javascript-2018-08-22-codingyahac-javascript-9/"/>
    <id>https://kodakyung.github.io/2018/08/22/programming-javascript-2018-08-22-codingyahac-javascript-9/</id>
    <published>2018-08-21T15:00:00.000Z</published>
    <updated>2020-03-19T01:09:01.879Z</updated>
    
    <content type="html"><![CDATA[<h3 id="스터디에서-다룬-내용"><a href="#스터디에서-다룬-내용" class="headerlink" title="스터디에서 다룬 내용"></a>스터디에서 다룬 내용</h3><p><a href="https://opentutorials.org/course/3085/18882" target="_blank" rel="noopener">생활코딩 WEB2 Javascript ~함수예고 </a></p><blockquote><p>7~8일차 내용은 생략함.</p></blockquote><h2 id="배열과-반복문의-활용"><a href="#배열과-반복문의-활용" class="headerlink" title="배열과 반복문의 활용"></a>배열과 반복문의 활용</h2><ul><li><code>Document.querySelector(&#39;a&#39;)</code> : a 태그에 대한 쿼리를 하나만 가져온다.</li></ul><ul><li>검색</li></ul><blockquote><p>Javascript get element by css selector multiple</p></blockquote><ul><li><p>검색 결과 : <code>Document.querySelectorAll(&#39;a&#39;)</code> : 결과에 대해 배열로 가져온다.</p></li><li><p>위 코드를 이용해 반복문으로 태그를 하나하나 꺼내서 스타일 속성을 지정할 수 있다.</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alist = <span class="built_in">document</span>.querySelectorAll(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;alist.length)&#123;</span><br><span class="line">  alist[i].style.color = <span class="string">'powderblue'</span>;</span><br><span class="line">  i = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="함수를-활용한-리팩토링"><a href="#함수를-활용한-리팩토링" class="headerlink" title="함수를 활용한 리팩토링"></a>함수를 활용한 리팩토링</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">nightDayHandler</span>(<span class="params">self</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> target = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span><br><span class="line">        <span class="keyword">if</span>(self.value === <span class="string">'night'</span>)&#123;</span><br><span class="line">          target.style.backgroundColor = <span class="string">'black'</span>;</span><br><span class="line">          target.style.color = <span class="string">'white'</span>;</span><br><span class="line">          self.value = <span class="string">'day'</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> alist = <span class="built_in">document</span>.querySelectorAll(<span class="string">'a'</span>);</span><br><span class="line">          <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span>(i&lt;alist.length)&#123;</span><br><span class="line">            alist[i].style.color = <span class="string">'powderblue'</span>;</span><br><span class="line">            i = i+<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          target.style.backgroundColor = <span class="string">'white'</span>;</span><br><span class="line">          target.style.color = <span class="string">'black'</span>;</span><br><span class="line">          self.value = <span class="string">'night'</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> alist = <span class="built_in">document</span>.querySelectorAll(<span class="string">'a'</span>);</span><br><span class="line">          <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span>(i&lt;alist.length)&#123;</span><br><span class="line">            alist[i].style.color = <span class="string">'blue'</span>;</span><br><span class="line">            i = i+<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    ...</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;input type="button" value="night" onclick="nightDayHandler(this);"&gt;</span></span><br></pre></td></tr></table></figure><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;스터디에서-다룬-내용&quot;&gt;&lt;a href=&quot;#스터디에서-다룬-내용&quot; class=&quot;headerlink&quot; title=&quot;스터디에서 다룬 내용&quot;&gt;&lt;/a&gt;스터디에서 다룬 내용&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://opentutorials.org
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/categories/programming/javascript/"/>
    
    
      <category term="생활코딩" scheme="https://kodakyung.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>코딩야학 Javascript 5,6일차</title>
    <link href="https://kodakyung.github.io/2018/08/17/programming-javascript-2018-08-17-codingyahac-javascript-5-6/"/>
    <id>https://kodakyung.github.io/2018/08/17/programming-javascript-2018-08-17-codingyahac-javascript-5-6/</id>
    <published>2018-08-16T15:00:00.000Z</published>
    <updated>2020-03-19T01:08:57.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="스터디에서-다룬-내용"><a href="#스터디에서-다룬-내용" class="headerlink" title="스터디에서 다룬 내용"></a>스터디에서 다룬 내용</h3><p><a href="https://opentutorials.org/course/3085/18878" target="_blank" rel="noopener">생활코딩 WEB2 Javascript ~조건문의 활용 </a></p><h2 id="비교-연산자와-블리언"><a href="#비교-연산자와-블리언" class="headerlink" title="비교 연산자와 블리언"></a>비교 연산자와 블리언</h2><p><code>document.write()</code> : 화면에 출력</p><ul><li><p>=== : 동등 비교 연산자, 이항 연산자 좌항과 우항이 같으면 <code>True</code>, 아니면 <code>False</code> 출력.</p></li><li><p>Boolean : True와 False를 묶어서 Boolean이라 함.</p></li><li><p>데이터 타입의 종류 :<br>Number, 문자열 String, Boolean</p></li></ul><ul><li>Number는 많다.</li><li>String도 많다.</li><li>Boolean은 단 두개로 이루어진 데이터 타입</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.write(<span class="number">1</span>===<span class="number">1</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>1===2<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.write(<span class="number">1</span>===<span class="number">2</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>1&amp;lt;2<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.write(<span class="number">1</span>&lt;<span class="number">2</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>1&amp;lt;1<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.write(<span class="number">1</span>&lt;<span class="number">1</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>결과</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1===1</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">1===2</span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">1&lt;2</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">1&lt;1</span><br><span class="line">false</span><br></pre></td></tr></table></figure><ul><li>1&lt;2<br>html에서 &lt;가 문법이기 때문에 <code>&amp;lt;</code>이 &lt;와 같다.</li></ul><h2 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a>조건문</h2><p>if문의 뒤에 따라오는 괄호 안에 <code>Boolean</code>타입이 오면 <code>true</code>나 <code>false</code>가 온다.<br><code>Boolean</code>값에 따라 실행되는 코드가 바뀐다.</p><img width="257" alt="if-true" src="/images/2018-08-17/01.png"><img width="142" alt="if-true 결과" src="/images/2018-08-17/02.png"><img width="282" alt="if-false" src="/images/2018-08-17/03.png"><img width="164" alt="if-false 결과" src="/images/2018-08-17/04.png"><h2 id="조건문의-활용"><a href="#조건문의-활용" class="headerlink" title="조건문의 활용"></a>조건문의 활용</h2><p>Q. 현재 이 버튼의 <code>value</code> 값이 무엇인지 어떻게 알아내는가 ?</p><blockquote><p>Console 이용</p></blockquote><img width="528" alt="console" src="/images/2018-08-17/05.png"><p>Q. <code>value</code>에 접근하려면 어떻게 해야할까 ?</p><blockquote><p>키워드 : Javascript element get value</p></blockquote><ul><li>검색 결과 : <code>.value property</code> 이용</li></ul><img width="481" alt="value property" src="/images/2018-08-17/06.png"><img width="338" alt="value property2" src="/images/2018-08-17/07.png"><br><ul><li>조건문을 이용해 night 버튼 수정</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"night_day"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"night"</span> <span class="attr">onclick</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">if(document.querySelector('#night_day').value === 'night')&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  document.querySelector('body').style.backgroundColor = 'black';</span></span></span><br><span class="line"><span class="tag"><span class="string">  document.querySelector('body').style.color = 'white';</span></span></span><br><span class="line"><span class="tag"><span class="string">  document.querySelector('#night_day').value = 'day';</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125;else&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">  document.querySelector('body').style .backgroundColor = 'white';</span></span></span><br><span class="line"><span class="tag"><span class="string">  document.querySelector('body').style.color = 'black';</span></span></span><br><span class="line"><span class="tag"><span class="string">  document.querySelector('#night_day').value = 'night';</span></span></span><br><span class="line"><span class="tag"><span class="string">&#125;</span></span></span><br><span class="line"><span class="tag"><span class="string">"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>: night 버튼을 누르면 배경이 검정색, 글씨가 하얀색이 되고 <code>value</code>는 day로 바뀐다. day 버튼을 누르면 반대로 동작한다.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;스터디에서-다룬-내용&quot;&gt;&lt;a href=&quot;#스터디에서-다룬-내용&quot; class=&quot;headerlink&quot; title=&quot;스터디에서 다룬 내용&quot;&gt;&lt;/a&gt;스터디에서 다룬 내용&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://opentutorials.org
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/categories/programming/javascript/"/>
    
    
      <category term="생활코딩" scheme="https://kodakyung.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>코딩야학 Javascript 4일차</title>
    <link href="https://kodakyung.github.io/2018/08/16/programming-javascript-2018-08-16-codingyahac-javascript-4/"/>
    <id>https://kodakyung.github.io/2018/08/16/programming-javascript-2018-08-16-codingyahac-javascript-4/</id>
    <published>2018-08-15T15:00:00.000Z</published>
    <updated>2020-03-19T01:08:52.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="스터디에서-다룬-내용"><a href="#스터디에서-다룬-내용" class="headerlink" title="스터디에서 다룬 내용"></a>스터디에서 다룬 내용</h3><p><a href="https://opentutorials.org/course/3085/18876" target="_blank" rel="noopener">생활코딩 WEB2 Javascript ~프로그램, 프로그래밍, 프로그래머 </a></p><h2 id="제어할-태그-선택하기"><a href="#제어할-태그-선택하기" class="headerlink" title="제어할 태그 선택하기"></a>제어할 태그 선택하기</h2><p>night 버튼을 누르면 검정색 배경, day 버튼을 누르면 흰색 배경으로 돌아오도록 코드를 작성해보자.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> =<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"night"</span> <span class="attr">onclick</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> =<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"day"</span> <span class="attr">onclick</span>=<span class="string">""</span>&gt;</span></span><br></pre></td></tr></table></figure><p>버튼을 클릭했을때 body 태그에 스타일 속성을 동적으로 동작하도록 넣으려고 한다.</p><p><strong>Q. Javascript로 body 태그를 선택하도록 하려면 어떻게 해야할까 ?</strong></p><blockquote><p>키워드 : Javascript select tag by css selector</p></blockquote><ul><li>검색 결과<img width="494" alt="검색 결과" src="/images/2018-08-16/01.png"></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.html"</span>&gt;</span>WEB<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"night"</span> <span class="attr">onclick</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    document.querySelector('#target')</span></span></span><br><span class="line"><span class="tag"><span class="string">  "</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.html"</span>&gt;</span>WEB<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"night"</span> <span class="attr">onclick</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">    document.querySelector('body')</span></span></span><br><span class="line"><span class="tag"><span class="string">  "</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>document.querySelector</code>를 이용해 선택한다. <code>class 선택자</code>는 <code>.선택자이름</code> <code>id 선택자</code>는 <code>#선택자 이름</code>, body 태그와 같이 전체 태그를 지정할 때는 태그 명을 입력한다.</p><p><strong>Q. body 태그에 style 속성을 어떻게 넣을 수 있을까 ?</strong></p><blockquote><p>키워드 : Javascript element style</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"background-color:black;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Q. 위의 스타일 속성을 자바스크립트로 넣으려면 ?</strong></p><blockquote><p>Javascript style background color</p></blockquote><img width="801" alt="검색 결과2" src="/images/2018-08-16/02.png"><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.querySelector('body').style.backgroundColor = 'black';</span><br></pre></td></tr></table></figure><ul><li>완성 코드</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"night"</span> <span class="attr">onclick</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">  document.querySelector('body').style.backgroundColor = 'black';</span></span></span><br><span class="line"><span class="tag"><span class="string">  document.querySelector('body').style.color = 'white';</span></span></span><br><span class="line"><span class="tag"><span class="string">"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>night 버튼을 누르면, html/CSS를 동적으로 변경시킨다.</p><h2 id="프로그램-프로그래밍-프로그래머"><a href="#프로그램-프로그래밍-프로그래머" class="headerlink" title="프로그램, 프로그래밍, 프로그래머"></a>프로그램, 프로그래밍, 프로그래머</h2><h3 id="Javascript라는-프로그래밍-언어는-무엇인가"><a href="#Javascript라는-프로그래밍-언어는-무엇인가" class="headerlink" title="Javascript라는 프로그래밍 언어는 무엇인가."></a>Javascript라는 프로그래밍 언어는 무엇인가.</h3><p>JS는 컴퓨터 언어 이면서 컴퓨터 프로그래밍 언어이다.<br>HTML은 컴퓨터 프로그래밍 언어라 하지는 않는다.</p><h3 id="프로그래밍-언어의-보편적인-의미"><a href="#프로그래밍-언어의-보편적인-의미" class="headerlink" title="프로그래밍 언어의 보편적인 의미"></a>프로그래밍 언어의 보편적인 의미</h3><dl><dt>Q. 프로그램이란?</dt><dd>순서가 중심이 되는 것.</dd></dl><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">순서를 만드는 행위 -&gt; 프로그래밍</span><br><span class="line">순서를 만드는 사람 -&gt; 프로그래머</span><br></pre></td></tr></table></figure><p>: SW가 아니어도 많이 사용되는 단어이다.</p><p>순서대로 여러 기능을 작동시키는 것이 컴퓨터를 작동시키는 일반적인 방법이다.<br>순서가 반복되고 그 과정중에 오래 걸리고 자주 반복하고 실수를 한다면,<br>그 문제를 어떻게 극복할 것인가 고민하면서 프로그래밍 언어를 만들었다.</p><p>시간의 순서에 따라서 실행되어야 할 기능을 프로그래밍 언어의 문법에 맞게 글로 적어두는 방식을 고안한 것.<br>그 작업이 필요할 때 그 글을 주고 기능을 수행하도록 하는 것이 바로 프로그램이다.</p><p>html은 웹페이지를 묘사하는 목적으로 사용되고, <em>시간의 순서에 따라 실행되지 않는다.</em><br>js는 사용자와 상호작용하기 위해 고안된 컴퓨터 언어이고,<br><em>따라서 시간의 순서에 따라 웹 브라우저의 여러 기능이 실행되어야 하기 때문에 프로그래밍 언어이다.</em></p><p>지금까지는 단순히 시간을 나열하는 것으로 만족했지만, 조건에 따라 다른 기능이 실행되도록,<br>또는 반복해서 어떤 기능이 실행되도록,<br>코드가 복잡해짐에 따라서 복잡해진 순서를 단순하게 정리정돈하는 방법도 필요해졌다.</p><p>JS뿐만 아니라 컴퓨터 프로그래밍 언어들의 핵심적인 기능들에 해당하는 조건문 반복문 등을 이제 배워보자.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;스터디에서-다룬-내용&quot;&gt;&lt;a href=&quot;#스터디에서-다룬-내용&quot; class=&quot;headerlink&quot; title=&quot;스터디에서 다룬 내용&quot;&gt;&lt;/a&gt;스터디에서 다룬 내용&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://opentutorials.org
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/categories/programming/javascript/"/>
    
    
      <category term="생활코딩" scheme="https://kodakyung.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>코딩야학 Javascript 3일차</title>
    <link href="https://kodakyung.github.io/2018/08/15/programming-javascript-2018-08-15-codingyahac-javascript-3/"/>
    <id>https://kodakyung.github.io/2018/08/15/programming-javascript-2018-08-15-codingyahac-javascript-3/</id>
    <published>2018-08-14T15:00:00.000Z</published>
    <updated>2020-03-19T01:08:48.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="스터디에서-다룬-내용"><a href="#스터디에서-다룬-내용" class="headerlink" title="스터디에서 다룬 내용"></a>스터디에서 다룬 내용</h3><p><a href="https://opentutorials.org/course/3085/18789" target="_blank" rel="noopener">생활코딩 WEB2 Javascript ~CSS 기초 </a></p><h2 id="웹-브라우저를-제어하는-방법에-대한-테크닉들"><a href="#웹-브라우저를-제어하는-방법에-대한-테크닉들" class="headerlink" title="웹 브라우저를 제어하는 방법에 대한 테크닉들"></a>웹 브라우저를 제어하는 방법에 대한 테크닉들</h2><p>JS 이용해 할 수 있는 것들 중 한가지인 웹 브라우저 제어에 대해 알아보자.</p><p>예를 들면 처음부터 배경이 검정색인 것이 아닌, night 버튼 클릭시 배경을 검정색으로 하고 싶으면 JavaScript를 이용 하면 된다.</p><p><code>&lt;body&gt;</code> 태그는 전체를 감싸는 큰 태그이며<br><code>body</code>에 <code>style속성</code>을 사용한다. <strong>style 속성의 속성 값은 CSS만 사용 가능하고<br>CSS는 디자인을 위한 언어이다.</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"background-color:black;color:white;"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>배경은 검정색, 글자색은 하얀색으로 지정하는 코드<br>night 버튼을 클릭했을 때 웹페이지의 style 태그의 속성이 위의 코드로 바뀔 수 있다면, 우리가 원하는 동작을 할 수 있을 것이다.</p><p>코드를 직접 수정한다면(<code>HTML</code>) 항상 검정색 배경으로 할 수 있다.<br>(HTML은 한번 화면에 출력되면 자신이 바꿀 수 없는 정적인 언어이기 때문)<br>우리가 원하는 것은 버튼을 클릭했을 때만 변경되는 것이므로 HTML만 사용할 수는 없다.</p><ul><li><strong>앞으로 알아야할 것.</strong></li></ul><ol><li><p>CSS에 대한 기본 지식<br>style에 들어가는 속성의 값은 CSS이므로 기본적인 문법을 알아야 함.</p></li><li><p>JS를 통해 제어하고자 하는 태그를 선택하는 방법<br>style 속성을 주기 위해서는 속성을 주고자하는 태그가 누구인가를 (body 태그라는 것을) 웹브라우저에게 알려주는 방법을 JS문법으로 어떻게 하는지 알아야함.</p></li></ol><h2 id="CSS-기초-style-속성-property"><a href="#CSS-기초-style-속성-property" class="headerlink" title="CSS 기초 : style 속성(property)"></a>CSS 기초 : style 속성(property)</h2><p>웹 사이트의 디자인을 바꾸고 싶은 태그에 <code>style</code> 속성을 사용하면 된다.<br><code>onclick</code>안에 JS가 오는 것과 마찬가지로 <code>style</code> 속성안에는 CSS가 온다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">"color:powderblue"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure><p><em>html 문법인 style을 통해 웹브라우저에게 이 코드가 CSS라고 알려주는 것.</em></p><p>만약 해당 부분의 배경색도 바꾸고 싶다면, 찾아보자</p><blockquote><p>키워드 추천 : CSS background color property</p></blockquote><p>style이라는 속성에 CSS를 넣으면 디자인을 할 수있다<br>속성이라는 문법의 구조를 알고 있다면 검색을 통해 문제를 해결할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">특정 태그를 CSS라는 언어로 디자인하고 싶다면 style을 사용해라</span><br></pre></td></tr></table></figure><h2 id="CSS-기초-style-태그"><a href="#CSS-기초-style-태그" class="headerlink" title="CSS 기초 : style 태그"></a>CSS 기초 : style 태그</h2><ul><li>div 태그 : 어떤 의미,기능도 없는데 CSS나 JS를 통해 어떤 정보를 제어하고 싶을 때 감싸주는 역할을 함. 사용시 줄바꿈이 된다.  </li><li>span 태그 : div와 같은 용도 이지만 전체를 쓰지 않아서 줄바꿈이 되지 않는다.  </li><li><code>font-weight:bold;</code> : 글씨를 굵게 표기 함.  </li><li>style 태그 : 스크립트 태그 처럼 웹브라우저에게 CSS를 알려주는 태그.  </li></ul><p>JavaScript를 굵은 글씨로 강조하기 위해서 태그 하나하나 style 속성을 넣어도 되지만, class를 이용하면 더 간단히 할 수 있다.<br>class 명을 지정하고 <code>&lt;style&gt;&lt;/style&gt;</code> 태그 사이에 <code>.클래스명{}</code>을 표기하면된다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.js&#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"js"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>클래스명이 js인 모든 태그에 bold가 적용된다. 클래스 명을 가리킬 때는 앞에 .을 붙인다.</p><h2 id="CSS-기초-선택자"><a href="#CSS-기초-선택자" class="headerlink" title="CSS 기초 : 선택자"></a>CSS 기초 : 선택자</h2><p>선택자를 이용하면 태그를 쉽게 지정해 CSS를 적용할 수 있다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">.js&#123;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">#first&#123;</span><br><span class="line">  color:green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"first"</span> <span class="attr">class</span>=<span class="string">"js"</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>.은 클래스 #은 id를 의미한다. 위의 태그는 <code>&lt;span&gt;</code>태그의 JavaScript가 초록색으로 출력된다.</p><p>위의 <code>&lt;span&gt;</code> 태그는 <code>.js</code>와 <code>#first</code>의 영향을 받는다. class는 무언가를 그룹핑하는 것, id는 한가지 대상을 식별하는 용도로 사용한다.<br>class라는 속성은 그룹핑하고 싶은 것을 같은 이름의 클래스로 지정을 하며 반면 id는 한 페이지에서 유일하게 사용해야한다. first가 한번 등장했다면 다시는 동일한 페이지에서 중복해서 사용하지 않아야한다. <em>동작은 정상적으로 되지만 ‘구분’하기 위한 용도라는 규약에 어긋난다.</em></p><p>  <strong>Q. id 선택자와 class 선택자 중에 무엇이 포괄적인가요?</strong><br>  A. class 선택자. id 선택자는 무엇인가를 정확히 타겟팅 하는 것</p><p>class 선택자로 광범위한 효과 처리를 하고,<br>그중에 예외 처리하고 싶은 태그들을 id선택자를 통해 예외적으로 디자인을 변경한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">즉, class 위에 id를 얹어서 디자인하는 것.</span><br></pre></td></tr></table></figure><p>  <strong>Q. 웹페이지에 대한 모든 span에 파란색을 하고 싶다면 ?</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">span &#123;</span><br><span class="line">  color:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  앞에 .이나 #등 아무것도 붙이지 않는다면 해당 페이지의 모든 ~태그에 대해 적용된다.</p><ul><li>각 선택자의 우선순위 :  <blockquote><p>id 선택자 &gt; class 선택자 &gt; 일반 선택자</p></blockquote></li></ul><p><strong>속성을 누구에게 적용할 것인가를 정확히 타겟팅하는 것이 중요하다.</strong></p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;스터디에서-다룬-내용&quot;&gt;&lt;a href=&quot;#스터디에서-다룬-내용&quot; class=&quot;headerlink&quot; title=&quot;스터디에서 다룬 내용&quot;&gt;&lt;/a&gt;스터디에서 다룬 내용&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://opentutorials.org
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/categories/programming/javascript/"/>
    
    
      <category term="생활코딩" scheme="https://kodakyung.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>코딩야학 Javascript 2일차</title>
    <link href="https://kodakyung.github.io/2018/08/14/programming-javascript-2018-08-14-codingyahac-javascript-2/"/>
    <id>https://kodakyung.github.io/2018/08/14/programming-javascript-2018-08-14-codingyahac-javascript-2/</id>
    <published>2018-08-13T15:00:00.000Z</published>
    <updated>2020-03-19T01:08:45.135Z</updated>
    
    <content type="html"><![CDATA[<h3 id="스터디에서-다룬-내용"><a href="#스터디에서-다룬-내용" class="headerlink" title="스터디에서 다룬 내용"></a>스터디에서 다룬 내용</h3><p><a href="https://opentutorials.org/course/3085/18871" target="_blank" rel="noopener">생활코딩 WEB2 Javascript ~변수와 대입연산자 </a></p><h2 id="Javascript의-데이터-타입-자료형"><a href="#Javascript의-데이터-타입-자료형" class="headerlink" title="Javascript의 데이터 타입(자료형)"></a>Javascript의 데이터 타입(자료형)</h2><p>Javascript의 데이터 타입은 대표적으로 숫자와 문자가 있다.</p><ul><li><p>숫자에 사용되는 산술 연산자 : + - / *</p></li><li><p>문자는 “ “(큰 따옴표) 또는 ‘ ‘(작은 따옴표)를 사용해 표기한다.</p><ul><li><code>.length</code>를 사용하면 문자 갯수를 알려줌.<br>이러한 <code>Properties</code>를 찾아서 쓸 줄 아는 것이 중요하다.  </li></ul></li><li><p><strong>Javascript Properties</strong></p><ul><li>검색 키워드: Javascript string<br>: Javascript의 string에 대한 Properties를 찾고싶은 경우</li></ul></li><li><dl><dt>Javascript Method</dt><dd>Properties외에 Method도 존재한다.</dd></dl><ul><li><dl><dt>str.toUpperCase()</dt><dd>소문자였던 문자열이 대문자가 된다.</dd></dl></li><li><dl><dt>str.indexof(‘w’)</dt><dd>찾으려고 하는 문자열을 입력하면 인덱스 번호를 알려준다.</dd></dl></li><li><dl><dt>str.trim()</dt><dd>문자열의 공백을 잘라서 출력한다.</dd></dl></li></ul></li></ul><p>종류가 많기 때문에 외우기보다는 필요한 기능을 잘 찾아서 쓰는 것이 중요하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1+1은 2</span><br><span class="line">&quot;1&quot;+&quot;1&quot;은 &quot;11&quot;</span><br><span class="line">숫자와 문자열을 주의해서 사용해야한다.</span><br></pre></td></tr></table></figure><h2 id="변수와-대입-연산자"><a href="#변수와-대입-연산자" class="headerlink" title="변수와 대입 연산자"></a>변수와 대입 연산자</h2><blockquote><p>웹브라우저의 <code>Console</code>을 통해 실습 진행</p></blockquote><ul><li>변수 : 대입연산자를 통해 값을 바꿀 수 있는 것</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = 1</span><br></pre></td></tr></table></figure><p>여기서 x가 변수(variable)이며, = 가 대입연산자이다.<br>대입연산자는 오른쪽에 있는 항을 왼쪽에 대입한다.</p><ul><li>=(대입연산자) : 대입 연산자에 의해서 왼쪽 항의 변수의 값을 변경한다.</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1=2;</span><br></pre></td></tr></table></figure><p>위의 코드는 에러가 발생한다.<br>1은 값이 바뀔 수 없기 때문에 대입연산자로 값을 변경할 수 없다. 이러한 것을 상수(constant)라 한다.</p><p>변수를 사용할 때 가급적 var을 붙이고 선언하는 것이 좋다.<br>var을 사용한 장,단점이 있지만 우선 var을 붙이고 사용하자.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;스터디에서-다룬-내용&quot;&gt;&lt;a href=&quot;#스터디에서-다룬-내용&quot; class=&quot;headerlink&quot; title=&quot;스터디에서 다룬 내용&quot;&gt;&lt;/a&gt;스터디에서 다룬 내용&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://opentutorials.org
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/categories/programming/javascript/"/>
    
    
      <category term="생활코딩" scheme="https://kodakyung.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>코딩야학 Javascript 1일차</title>
    <link href="https://kodakyung.github.io/2018/08/13/programming-javascript-2018-08-13-codingyahac-javascript-1/"/>
    <id>https://kodakyung.github.io/2018/08/13/programming-javascript-2018-08-13-codingyahac-javascript-1/</id>
    <published>2018-08-12T15:00:00.000Z</published>
    <updated>2020-03-19T01:08:32.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="스터디에서-다룬-내용"><a href="#스터디에서-다룬-내용" class="headerlink" title="스터디에서 다룬 내용"></a>스터디에서 다룬 내용</h3><p><a href="https://opentutorials.org/course/3085/18868" target="_blank" rel="noopener">생활코딩 WEB2 Javascript ~HTML과 Javascript의 만남(Console) </a></p><h2 id="HTML과-Javascript"><a href="#HTML과-Javascript" class="headerlink" title="HTML과 Javascript"></a>HTML과 Javascript</h2><p>HTML은 웹페이지의 정적인 요소만을 표현할 수 있다.<br>Javascript를 이용하면 사용자와 상호작용해 웹페이지를 동적으로 표현할 수 있다. 일반적으로 HTML을 기반으로 웹 페이지를 만든 뒤<br>Javascript를 이용해 사용자와 상호작용하는 웹으로 제작한다.</p><p>웹 브라우저는 한번 출력이 되면 바꿀 수 없다. 크롬의 경우 마우스 오른쪽 클릭 [검사]-[Elements]로 웹페이지 소스코드 확인이 가능하다.<br>Javascript가 동작하면 해당하는 부분의 소스코드가 변경된다.</p><p><code>input</code> tag의 <code>type</code>을 <code>button</code>으로 하면 버튼이 만들어진다. <code>value</code> 속성에 지정한 값이 이름이 된다.<br><strong><code>onclick</code> 속성은 반드시 Javascript를 넣어주어야한다.</strong></p><p>사용자가 <code>onclick</code> 버튼을 클릭했을 때 해당 JS 코드를 실행시킨다.<br><code>document.queryselector</code>로 <code>body</code> 태그를 선택하고 그때 <code>backgroundColor</code>를 변경한다.<br><strong><code>style</code> 속성에는 반드시 CSS 코드가 와야한다.</strong></p><ul><li><p>정리</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. JS는 사용자와 상호작용할 수 있다.</span><br><span class="line">2. HTML은 한번 출력되면 바꿀 수 없다.</span><br><span class="line">3. JS를 이용하면 화면 출력을 변경할 수 있다.</span><br></pre></td></tr></table></figure><p><em>즉, Javascript는 HTML을 제어하는 언어이다.</em></p></li></ul><h2 id="HTML과-JS의-만남-Script-태그"><a href="#HTML과-JS의-만남-Script-태그" class="headerlink" title="HTML과 JS의 만남 : Script 태그"></a>HTML과 JS의 만남 : Script 태그</h2><p>HTML과 JS를 사용하기 위해서는 JS를 사용한다는 표시를 해주어야 한다.<br><code>&lt;script&gt; &lt;/script&gt;</code> 태그로 표기한다.</p><p>HTML의 경우 입력한 내용 그대로 정적으로 출력하지만<br>JS 내부에서는 예를 들면 1+1의 경우 더해서 출력한다.</p><h2 id="HTML과-JS의-만남-이벤트"><a href="#HTML과-JS의-만남-이벤트" class="headerlink" title="HTML과 JS의 만남 : 이벤트"></a>HTML과 JS의 만남 : 이벤트</h2><p>이벤트는 JS가 사용자와 상호작용하는 핵심 요소이다.</p><ul><li>예시<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"hi"</span> <span class="attr">onclick</span>=<span class="string">"alert('hi')"</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>: 사용자가 버튼 클릭 시 경고창(alert)이 출력된다.</p><ul><li>onclick : onclick 속성의 값으로 반드시 JS가 와야한다.<br>onclick 속성의 속성 값(위의 <code>alert(&#39;hi&#39;)</code>)은 웹 브라우저가 기억하고 있다가. onclick 속성이 위치하고 있는 태그를 사용자가 클릭 했을 때 속성 값대로 동작한다.</li></ul><br>웹브라우저 위에서 일어나는 일을 이벤트라 한다.  = 어떤 이벤트가 실행됐을 때 어떤 자바스크립트가 실행되는 것.<ul><li><p>웹브라우저에서 사용되는 이벤트의 종류</p><ul><li><p>무언가를 클릭하는 경우</p></li><li><p>텍스트 박스에 내용이 수정 되었을 때</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onchange</span>=<span class="string">"alert('changed')"</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>주로 쓰이는 이벤트는 총 10~20개 정도 된다.</p></li></ul></li><li><p><strong>! 외우는 것보다 잘 검색하는 것이 중요</strong></p><p>Q. 어떤 키를 눌렀을 때 이벤트가 발생하도록 하고 싶다.</p><blockquote><p>검색 키워드 예시 : Javascript keydown event attribute</p></blockquote></li><li><p>정리</p></li></ul><hr><p>on으로 시작하는 속성들<br>  = event<br>  = 웹브라우저 위에서 일어나는 사건들</p><hr><h2 id="HTML과-JS의-만남-콘솔"><a href="#HTML과-JS의-만남-콘솔" class="headerlink" title="HTML과 JS의 만남 : 콘솔"></a>HTML과 JS의 만남 : 콘솔</h2><p>Javascript를 실행하는 또다른 방법.<br>파일이 아니어도 가볍게 코드를 실행하고 싶은 경우 사용하면 좋다</p><ul><li>웹브라우저에서 (크롬기준)[검사]-[Console]을 이용하면  </li></ul><p><strong>파일을 만들지 않고 JS를 즉석으로 사용할 수 있다.</strong></p><ul><li><p>JS의 length 패키지는 문자열의 단어 갯수를 알려준다.</p></li><li><p>콘솔에서 실행시키는 JS는 웹페이지 안에 삽입된 JS처럼 동작한다.<br>열려있는 웹페이지를 대상으로 동작한다.</p></li><li><p>Elements에서 ESC키를 누르면 Console 창이 하단에 뜬다.<br>한번 실행한 코드는 위쪽 화살표 키를 누르면 다시 실행할 수 있다.</p></li><li><p>정리</p></li></ul><hr><p>간단한 Javascript 코드는 꼭 파일을 만들지 않아도<br>Console 창을 통해 간단하게 실행해볼 수 있다.  </p><hr><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;스터디에서-다룬-내용&quot;&gt;&lt;a href=&quot;#스터디에서-다룬-내용&quot; class=&quot;headerlink&quot; title=&quot;스터디에서 다룬 내용&quot;&gt;&lt;/a&gt;스터디에서 다룬 내용&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://opentutorials.org
      
    
    </summary>
    
      <category term="Programming" scheme="https://kodakyung.github.io/categories/programming/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/categories/programming/javascript/"/>
    
    
      <category term="생활코딩" scheme="https://kodakyung.github.io/tags/%EC%83%9D%ED%99%9C%EC%BD%94%EB%94%A9/"/>
    
      <category term="Javascript" scheme="https://kodakyung.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Docker 스터디 3차</title>
    <link href="https://kodakyung.github.io/2018/07/17/system-docker-2018-07-17-docker-study-3/"/>
    <id>https://kodakyung.github.io/2018/07/17/system-docker-2018-07-17-docker-study-3/</id>
    <published>2018-07-16T15:00:00.000Z</published>
    <updated>2020-03-19T01:34:36.481Z</updated>
    
    <content type="html"><![CDATA[<p>Date 2018.07.17 / Time PM 6:30~8:30 / Place 일만관 2B201</p><h1 id="이번주-스터디-내용"><a href="#이번주-스터디-내용" class="headerlink" title="이번주 스터디 내용"></a>이번주 스터디 내용</h1><p>: <a href="http://pyrasis.com/docker.html" target="_blank" rel="noopener">가장 빨리 만나는 Docker</a> 6장~7장 내용 진행  </p><h2 id="Docker-개인-저장소-구축"><a href="#Docker-개인-저장소-구축" class="headerlink" title="Docker 개인 저장소 구축"></a>Docker 개인 저장소 구축</h2><p>: Docker 서버 = Docker Registry Server<br>일반적으로 Docker Hub에서 Docker 파일을 공유하고 다운 받을 수 있지만 개인 저장소를 따로 구축할 수 있다.</p><p>Docker Hub에서 제공하는 Docker 레지스트리 이미지를 받아서 진행할 수 있다. 이를 컨테이너로 실행해 사용한다. 기존의 Docker 명령어와 같이 push/pull로 이미지를 업로드하고 받을 수 있다.</p><p>아마존 S3를 이용해서도 저장소를 구축할 수 있다.</p><p>보통의 경우 저장소를 따로 구축할 일은 거의 없다.</p><h2 id="Docker-컨테이너-연결"><a href="#Docker-컨테이너-연결" class="headerlink" title="Docker 컨테이너 연결"></a>Docker 컨테이너 연결</h2><p>: Docker 컨테이너를 여러개 만들어 다른 컨테이너끼리 연결하는 경우. Docker에 여러가지 환경 설정을 하는 경우 Docker 하나에 전부 하기 보다는 DB면 DB, 웹서버면 웹서버 등 각각 컨테이너를 만들어 연결해 합친다. 분리해서 설정하는 것이 유지 보수에도 좋다.</p><p><code>—link</code> 옵션을 사용하거나 따로 <code>network</code>를 만들어 연결할 수 있다. <code>—link</code> 옵션의 경우 레거시 코드로 <code>network</code>를 만드는 방식으로 하는 것이 더 좋다. 또한 연결이 늘어날 수록  <code>—link</code>옵션보다는 <code>network</code>를 생성하는 것이 관리에 편리하다.</p><blockquote><p>자세한 내용은 <a href="http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter06/02" target="_blank" rel="noopener">링크</a>를 참고</p></blockquote><p>위 링크와 다르게 <code>sudo docker ps</code>에 연결상태가 출력되지않는다. <code>—link</code>옵션 사용시 해당 컨테이너에, <code>network</code> 생성시 해당 네트워크에 <code>inspect</code>명령어 사용시 연결 상황을 확인할 수 있다.</p><h2 id="Docker-데이터-볼륨"><a href="#Docker-데이터-볼륨" class="headerlink" title="Docker 데이터 볼륨"></a>Docker 데이터 볼륨</h2><p>: Docker의 볼륨은 호스트에서 관리한다. 볼륨 내의 파일은 호스트에 저장되지만 컨테이너에서 접근할 수 있다.<br>DB 등 파일의 변동사항이 많은 경우 볼륨에 따로 빼서 관리를 한다. Docker는 변동사항이 있을 경우 수정하기보다는 부시고 새로 만든다. 따라서 변화할 가능성이 많은 파일 등은 데이터 볼륨에 따로 빼서 관리를 하는 것이 좋다.<br>가상 머신의 공유 폴더와 비슷하다고 생각하면 된다.</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p><strong>CMD와 ENTRYPOINT의 차이점</strong></p><ul><li><p>CMD  </p><blockquote><p>The main purpose of a CMD is to provide defaults for an execting container</p></blockquote></li><li><p>ENTRYPOINT  </p><blockquote><p>An ENTRYPOINT helps you to configure a container that you can run as an executable.</p></blockquote></li></ul><p>두 명령어 다 컨테이너가 실행될 때(run 등) 실행되는 명령어이다.</p><ul><li>ENTRYPOINT와 CMD를 설정한 Dockerfile</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:wheezy</span><br><span class="line">ENTRYPOINT [&quot;/bin/ping&quot;]</span><br><span class="line">CMD [&quot;localhost&quot;]</span><br></pre></td></tr></table></figure><ul><li>매개 변수 없이 이미지 실행</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it test</span><br><span class="line">PING localhost (127.0.0.1): 48 data bytes</span><br><span class="line">56 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.096 ms</span><br><span class="line">56 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.088 ms</span><br><span class="line">56 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.088 ms</span><br><span class="line">^C--- localhost ping statistics ---</span><br><span class="line">3 packets transmitted, 3 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 0.088/0.091/0.096/0.000 ms</span><br></pre></td></tr></table></figure><p>: <code>CMD</code>를 인자로 받아 <code>ENTRYPOINT</code>를 실행한다.</p><ul><li>매개 변수 있는 이미지 실행</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it test google.com</span><br><span class="line">PING google.com (173.194.45.70): 48 data bytes</span><br><span class="line">56 bytes from 173.194.45.70: icmp_seq=0 ttl=55 time=32.583 ms</span><br><span class="line">56 bytes from 173.194.45.70: icmp_seq=2 ttl=55 time=30.327 ms</span><br><span class="line">56 bytes from 173.194.45.70: icmp_seq=4 ttl=55 time=46.379 ms</span><br><span class="line">^C--- google.com ping statistics ---</span><br><span class="line">5 packets transmitted, 3 packets received, 40% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 30.327/36.430/46.379/7.095 ms</span><br></pre></td></tr></table></figure><p>: 매개변수를 인자로 받아서 <code>CMD</code>를 대체한 뒤 <code>ENTRYPOINT</code>를 실행한다.</p><ul><li>CMD만 설정한 Dockerfile</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:wheezy</span><br><span class="line">CMD [&quot;/bin/ping&quot;, &quot;localhost&quot;]</span><br></pre></td></tr></table></figure><ul><li>매개변수 없이 이미지 실행</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it test</span><br><span class="line">PING localhost (127.0.0.1): 48 data bytes</span><br><span class="line">56 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.076 ms</span><br><span class="line">56 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.087 ms</span><br><span class="line">56 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.090 ms</span><br><span class="line">^C--- localhost ping statistics ---</span><br><span class="line">3 packets transmitted, 3 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 0.076/0.084/0.090/0.000 ms</span><br></pre></td></tr></table></figure><p>: <code>CMD</code>에 설정한 실행파일, 매개변수를 그대로 실행한다.</p><ul><li>매개변수 있는 이미지 실행</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it test bash</span><br><span class="line">root@e8bb7249b843:/#</span><br></pre></td></tr></table></figure><p>: <code>run</code> 명령어를 사용하면 <code>CMD</code> 옵션이 무시된다. 즉 매개변수를 변경할 수 없다.</p><blockquote><p>출처 : <a href="https://stackoverflow.com/questions/21553353/what-is-the-difference-between-cmd-and-entrypoint-in-a-dockerfile" target="_blank" rel="noopener">StackOverFlow</a>  </p></blockquote><p>Dockerfile에 <code>CMD</code>만 설정한 경우 실행파일과 매개변수를 변경할 수 없고 그대로 실행한다. (실행시 <code>run</code> 옵션을 사용하면 명령어 전체를 대체할 수 있다.)</p><p><code>ENTRYPOINT</code>와 <code>CMD</code>를 함께 사용하는 경우 <code>ENTRYPOINT</code>가 실행파일, <code>CMD</code>가 디폴트 매개변수와 같게 사용된다. <code>CMD</code>에 입력된 매개변수를 사용하고 싶지 않은 경우 Dockerfile 실행시 매개변수를 따로 입력해주면 <code>ENTRYPOINT</code>에 입력된 실행파일은 그대로 실행되지만 <code>CMD</code>의 매개변수만 변경되어 실행된다.</p><p><code>ENTRYPOINT</code>만 사용하는 경우 매개변수 없이 입력했을 때 <code>ENTRYPOINT</code> 그대로 실행된다. 그리고 매개변수를 같이 입력했을 때 <code>ENTRYPOINT+입력한 매개변수</code>가 실행된다.</p><p><strong>VOLUME</strong> 데이터 볼륨 설정. 보통 당장 사용하지 않더라도 데이터 볼륨은 설정해주는 것이 좋다.<br><strong>USER</strong> 보통은 root 권한으로 다 사용한다.<br><strong>WORKDIR</strong> 리눅의 cd명령과 같은 것<br><strong>ONBUILD</strong> 최초 실행시 실행되는 것이 아니라 이 Dockerfile을 나중에 FROM에서 사용할 때 그 때 실행된다. 예를 들면 <code>apt-get update</code>와 같이 기본적인 명령어 들을 여기에 설정해준다.  </p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Date 2018.07.17 / Time PM 6:30~8:30 / Place 일만관 2B201&lt;/p&gt;
&lt;h1 id=&quot;이번주-스터디-내용&quot;&gt;&lt;a href=&quot;#이번주-스터디-내용&quot; class=&quot;headerlink&quot; title=&quot;이번주 스터디 내용&quot;
      
    
    </summary>
    
      <category term="System" scheme="https://kodakyung.github.io/categories/system/"/>
    
      <category term="Docker" scheme="https://kodakyung.github.io/categories/system/docker/"/>
    
    
      <category term="Docker" scheme="https://kodakyung.github.io/tags/docker/"/>
    
      <category term="Study" scheme="https://kodakyung.github.io/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Docker 스터디 2차</title>
    <link href="https://kodakyung.github.io/2018/07/10/system-docker-2018-07-10-docker-study-2/"/>
    <id>https://kodakyung.github.io/2018/07/10/system-docker-2018-07-10-docker-study-2/</id>
    <published>2018-07-09T15:00:00.000Z</published>
    <updated>2020-03-19T01:34:31.858Z</updated>
    
    <content type="html"><![CDATA[<p>Date 2018.07.10 / Time PM 6:30~8:00 / Place 일만관 2B201</p><h1 id="이번주-스터디-내용"><a href="#이번주-스터디-내용" class="headerlink" title="이번주 스터디 내용"></a>이번주 스터디 내용</h1><p>: <a href="http://pyrasis.com/docker.html" target="_blank" rel="noopener">가장 빨리 만나는 Docker</a> 3장~5장 내용 진행<br>Docker 기본 명령어, Dockerfile</p><h2 id="Docker-기본-명령어"><a href="#Docker-기본-명령어" class="headerlink" title="Docker 기본 명령어"></a>Docker 기본 명령어</h2><blockquote><p>Docker는 항상 root 권한으로 실행해야하기 때문에 sudo를 붙여서 사용한다. 아래 명령어에서는 생략함.</p></blockquote><h3 id="docker-search-lt-name-gt"><a href="#docker-search-lt-name-gt" class="headerlink" title="docker search &lt;name&gt;"></a>docker search &lt;name&gt;</h3><p>도커는 <a href="https://registry.hub.docker.com" target="_blank" rel="noopener">Docker Hub</a>을 통해 이미지를 공유하는데 여기의 이미지를 검색할 수 있는 명령어이다.</p><h3 id="docker-pull-lt-image-gt-lt-tag-gt"><a href="#docker-pull-lt-image-gt-lt-tag-gt" class="headerlink" title="docker pull &lt;image&gt;:&lt;tag&gt;"></a>docker pull &lt;image&gt;:&lt;tag&gt;</h3><p>이미지 다운로드 받는 명령어. latest 설정시 최신 버전을 받을 수 있다.</p><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p>다운받은 이미지 목록을 전부 출력한다.</p><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run   "></a>docker run <option> <image> <runningfile></runningfile></image></option></h3><p>다운받은 이미지로 컨테이너를 생성한다.<br>-i(interactive), -t(Peudo-tty)옵션 사용하면 실행된 셸에 입출력을 할 수 있다. –name 옵션으로 이름 설정이 가능하다.</p><h3 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h3><p>실행 중인 컨테이너 목록을 출력한다. -a 옵션을 사용하면 정지된 컨테이너까지 모두 출력한다.</p><h3 id="docker-start"><a href="#docker-start" class="headerlink" title="docker start "></a>docker start <container></container></h3><p>컨테이너를 시작하는 명령어이다. 컨테이너 이름이나 ID를 사용할 수 있다.</p><h3 id="docker-restart"><a href="#docker-restart" class="headerlink" title="docker restart "></a>docker restart <container></container></h3><p>컨테이너 재시작하는 명령어이다.</p><h3 id="docker-attach"><a href="#docker-attach" class="headerlink" title="docker attach "></a>docker attach <container></container></h3><p>컨테이너에 접속하는 명령. 명령어를 입력할 수는 있지만 외부 애플리케이션을 실행하면 입력할 수 없고 출력만 볼 수 있다.</p><h3 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec   "></a>docker exec <container> <command> <args></args></container></h3><p>외부에서 컨테이너 안에 명령을 실행. 컨테이너가 실행되고 있는 상태에서만 사용가능하다.</p><h3 id="docker-stop"><a href="#docker-stop" class="headerlink" title="docker stop "></a>docker stop <container></container></h3><p>컨테이너 정지하는 명령어이다.</p><h3 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm "></a>docker rm <container></container></h3><p>컨테이너를 삭제하는 명령어이다.</p><h3 id="docker-rmi-lt-image-gt-lt-tags-gt"><a href="#docker-rmi-lt-image-gt-lt-tags-gt" class="headerlink" title="docker rmi &lt;image&gt;:&lt;tags&gt;"></a>docker rmi &lt;image&gt;:&lt;tags&gt;</h3><p>컨테이너 이미지를 삭제하는 명령어이다. 태그를 따로 지정하지 않으면 image 이름에 해당하는 모든 이미지가 삭제된다.</p><h2 id="Docekerfile"><a href="#Docekerfile" class="headerlink" title="Docekerfile"></a>Docekerfile</h2><blockquote><p>파일명 Dockerfile로 생성. FROM, MAINTAINER, RUN, CMD, WORKDIR, EXPOSE 등의 명령어 사용</p></blockquote><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><p><code>docker build &lt;option&gt; &lt;Dockerfile path&gt;</code> 형식. Dockerfile 작성 후 이미지 생성. –tag 옵션으로 태그 지정 가능.</p><h3 id="docker-history-lt-image-gt"><a href="#docker-history-lt-image-gt" class="headerlink" title="docker history &lt;image&gt;"></a>docker history &lt;image&gt;</h3><p>Docker 이미지 히스토리 조회</p><h3 id="docker-cp-lt-container-gt-lt-path-gt-lt-host-path-gt"><a href="#docker-cp-lt-container-gt-lt-path-gt-lt-host-path-gt" class="headerlink" title="docker cp &lt;container&gt;:&lt;path&gt; &lt;host path&gt;"></a>docker cp &lt;container&gt;:&lt;path&gt; &lt;host path&gt;</h3><p>컨테이너에서 파일 복사해 꺼내기</p><h3 id="docker-commit-lt-option-gt-lt-container-gt-lt-image-gt-lt-tag-gt"><a href="#docker-commit-lt-option-gt-lt-container-gt-lt-image-gt-lt-tag-gt" class="headerlink" title="docker commit &lt;option&gt; &lt;container&gt; &lt;image&gt;:&lt;tag&gt;"></a>docker commit &lt;option&gt; &lt;container&gt; &lt;image&gt;:&lt;tag&gt;</h3><p>컨테이너의 변경 사항을 이미지 파일로 생성</p><h3 id="docker-diff-lt-container-gt"><a href="#docker-diff-lt-container-gt" class="headerlink" title="docker diff &lt;container&gt;"></a>docker diff &lt;container&gt;</h3><p>컨테이너에서 변경된 파일 확인</p><h3 id="docker-inspect-lt-image-or-container-gt"><a href="#docker-inspect-lt-image-or-container-gt" class="headerlink" title="docker inspect &lt;image or container&gt;"></a>docker inspect &lt;image or container&gt;</h3><p>Docker 이미지와 컨테이너의 세부 정보 확인. 이름 또는 ID를 사용해도 됨.</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Date 2018.07.10 / Time PM 6:30~8:00 / Place 일만관 2B201&lt;/p&gt;
&lt;h1 id=&quot;이번주-스터디-내용&quot;&gt;&lt;a href=&quot;#이번주-스터디-내용&quot; class=&quot;headerlink&quot; title=&quot;이번주 스터디 내용&quot;
      
    
    </summary>
    
      <category term="System" scheme="https://kodakyung.github.io/categories/system/"/>
    
      <category term="Docker" scheme="https://kodakyung.github.io/categories/system/docker/"/>
    
    
      <category term="Docker" scheme="https://kodakyung.github.io/tags/docker/"/>
    
      <category term="Study" scheme="https://kodakyung.github.io/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Docker 스터디 개요, 1차</title>
    <link href="https://kodakyung.github.io/2018/07/09/system-docker-2018-07-09-docker-study-1/"/>
    <id>https://kodakyung.github.io/2018/07/09/system-docker-2018-07-09-docker-study-1/</id>
    <published>2018-07-08T15:00:00.000Z</published>
    <updated>2020-03-19T01:34:25.652Z</updated>
    
    <content type="html"><![CDATA[<p>Date 2018.07.03 / Time PM 6:30~8:30 / Place 일만관 2B201</p><h2 id="Docker란"><a href="#Docker란" class="headerlink" title="Docker란?"></a>Docker란?</h2><blockquote><p>오픈 소스 컨테이너 프로젝트. 클라우드 환경에서의 설치와 배포에 용이하다.</p></blockquote><h2 id="스터디-개요"><a href="#스터디-개요" class="headerlink" title="스터디 개요"></a>스터디 개요</h2><ul><li>2018년 7월 3일부터 약 6~7주간 진행</li><li>매주 화요일 오후 6시 ~ 8시 스터디 진행</li><li><a href="http://pyrasis.com/docker.html" target="_blank" rel="noopener">가장 빨리 만나는 Docker</a> 교재 사용</li><li>동아리 랩실에서 스터디 진행</li></ul><h2 id="스터디-방식"><a href="#스터디-방식" class="headerlink" title="스터디 방식"></a>스터디 방식</h2><ul><li>각자 미리 주차별로 예습해온다.</li><li>매주 돌아가면서 해당 주차 범위를 공부 후 발표</li><li>매주 돌아가면서 발표자가 아닌 사람이 동아리 위키에 스터디 내용을 기록</li></ul><h2 id="스터디-진도"><a href="#스터디-진도" class="headerlink" title="스터디 진도"></a>스터디 진도</h2><ul><li>1주차 : 스터디 개요 안내, 1~2장</li><li>2주차 : 3~5장</li><li>3주차 : 6~7장</li><li>4주차 : 8~9장</li><li>5주차 : 10~14장</li><li>6주차 : 16~19장</li><li>7주차(미정) : 20~21장</li></ul><h2 id="이번주-스터디-내용"><a href="#이번주-스터디-내용" class="headerlink" title="이번주 스터디 내용"></a>이번주 스터디 내용</h2><ul><li>Docker 소개</li><li>가상머신 개념</li><li>가상머신과 Docker의 차이</li><li>가상머신 이미지와 Immutable Infrastructure</li><li>Docker 이미지와 컨테이너</li><li>Docker의 이미지 구조</li><li>Docker 설치하기</li><li>Docker 사용 사례</li></ul><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://github.com/s-owl/wiki/blob/master/docs/studies/docker-2018.md" target="_blank" rel="noopener">동아리 위키</a>에 보다 상세한 내용 기록</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Date 2018.07.03 / Time PM 6:30~8:30 / Place 일만관 2B201&lt;/p&gt;
&lt;h2 id=&quot;Docker란&quot;&gt;&lt;a href=&quot;#Docker란&quot; class=&quot;headerlink&quot; title=&quot;Docker란?&quot;&gt;&lt;/a&gt;Doc
      
    
    </summary>
    
      <category term="System" scheme="https://kodakyung.github.io/categories/system/"/>
    
      <category term="Docker" scheme="https://kodakyung.github.io/categories/system/docker/"/>
    
    
      <category term="Docker" scheme="https://kodakyung.github.io/tags/docker/"/>
    
      <category term="Study" scheme="https://kodakyung.github.io/tags/study/"/>
    
  </entry>
  
  <entry>
    <title>Netty EmbeddedChannel 이용한 단위 테스트</title>
    <link href="https://kodakyung.github.io/2018/06/01/server-netty-2018-06-01-netty-embeddedchannel-unittest/"/>
    <id>https://kodakyung.github.io/2018/06/01/server-netty-2018-06-01-netty-embeddedchannel-unittest/</id>
    <published>2018-05-31T15:00:00.000Z</published>
    <updated>2020-03-19T01:13:13.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="단위-테스트란"><a href="#단위-테스트란" class="headerlink" title="단위 테스트란?"></a>단위 테스트란?</h3><blockquote><p>다른 모듈이나 데이터베이스 및 네트워크 등 런타임 의존성으로부터 최대한 격리된 가능한 작은 크기의 코드로 테스트하는 것. 테스트를 통해 모든 단위가 정상적으로 작동하는 것을 확인하면 문제가 생겼을 때 원인을 찾기가 수월해진다.</p></blockquote><p>Netty에서는 ChannelHandler가 아주 중요한 요소이다. 네티에서는 <code>EmbeddedChannel</code>을 통해 ChannelHandler의 단위 테스트를 제공한다.</p><p>테스트하는 코드 모듈이나 단위를 보통 런타임 환경 밖에서 실행되므로 이를 실행하기 위한 프레임 워크나 도구가 필요하다. 여기서는 JUnit을 통해 테스트 해본다.</p><br><h2 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h2><p><code>EmbeddedChannel</code>은 인바운드 또는 아웃바운드 데이터를 EmbeddedChannel에 기록하고 <code>ChannelPipeline</code> 끝에 도달하는 항목이 있는지 확인한다. 이를 통해 메세지가 인코딩 또는 디코딩 됐는지 확인할 수 있고 트리거 된 <code>ChannelHandler</code> 작업이 있는지 여부도 알 수 있다.</p><ul><li>EmbeddedChannel 주요 메소드</li></ul><table><thead><tr><th>이름</th><th>역할</th></tr></thead><tbody><tr><td>writeInbound(Object… msgs)</td><td>EmbeddedChannel에 인바운드 메세지를 기록한다. EmbeddedChannel에서 readInbound()를 통해 데이터를 읽을 수 있는 경우 true 반환</td></tr><tr><td>readInbound()</td><td>EmbeddedChannel에서 인바운드 메세지 읽는다. 반환되는 항목은 전체 ChannelPipeline을 통과한 것. 읽을 데이터가 없으면 null 반환</td></tr><tr><td>writeOutbound(Object… msgs)</td><td>EmbeddedChannel에 아웃바운드 메세지를 기록한다. EmbeddedChannel에서 readOutbound()를 통해 데이터를 읽을 수 있는 경우 true를 반환</td></tr><tr><td>writeInbound()</td><td>EmbeddedChannel에서 아웃바운드 메세지를 읽음 반환되는 항목은 전체 ChannelPipeline을 통과한 것. 읽을 항목이 없으면 null 반환</td></tr><tr><td>finish</td><td>EmbeddedChannel을 완료로 표시하고 전체 인바운드 또는 아웃바운드 데이터를 읽을 수 있는 경우 true를 반환한다. 이 메소드는  EmbeddedChannel의 close()를 호출함</td></tr></tbody></table><ul><li>EmbeddedChannel 데이터 흐름</li></ul><img alt="EmbeddedChannel" src="/images/2018-06-01/01.jpg"><p>인바운드 데이터는 <code>ChannelInboundHandler</code>에 의해 처리되고 원격 피어에서 읽은 데이터를 나타낸다. 아웃바운드 데이터는 <code>ChannelOutboundHandler</code>에 의해 처리되고 원격 피어에 기록된 데이터를 나타낸다. 테스트하는 <code>ChannelHandler</code>를 어떻게 구성하느냐에 따라 구체적인 코드는 달라질 수 있다.  </p><p>[그림]은 <code>EmbeddedChannel</code>의 메소드를 이용해 <code>ChannelPipeline</code>에서의 데이터 흐름을 보여준다. 메세지를 <code>Channel</code>에 기록하고 아웃바운드 방향으로 <code>ChannelPipeline</code>을 통과시키는데 <code>writeOutbound()</code>를 이용한다. 그리고 다음 처리된 메세지를 읽고 예상한 결과가 나왔는지 확인하는 데는 <code>readOutbound()</code>를 이용한다. 인바운드 데이터를 테스트할 때는 반대로 사용하면 된다. (<code>xxxInboud</code>)  </p><p>메세지는 <code>ChannelPipeline</code>을 통과하고 해당하는 <code>ChannelInboundHandler</code>나 <code>ChannelOutboundHandler</code>를 통해 처리되는데 메세지가 소비되지 않은 경우 메세지가 처리된 후 <code>readInbound()</code>나 <code>readOutbound()</code>를 통해 이용해 <code>Channel</code>에서 읽을 수 있다.  </p><br><h2 id="EmbeddedChannel을-이용한-ChannelHandler-테스트"><a href="#EmbeddedChannel을-이용한-ChannelHandler-테스트" class="headerlink" title="EmbeddedChannel을 이용한 ChannelHandler 테스트"></a>EmbeddedChannel을 이용한 ChannelHandler 테스트</h2><p>JUnit과 EmbeddedChannel을 이용해 ChannelHandler를 테스트 해보자  </p><h3 id="Junit-Assert"><a href="#Junit-Assert" class="headerlink" title="Junit Assert"></a>Junit Assert</h3><blockquote><p><code>org.junit.Assert</code> 클래스에는 테스트에 이용되는 여러 정적 메소드가 들어있다. 어설션이 실패하면 예외가 발생하고 현재 실행중인 테스트가 종료된다. 다음 import 문으로 사용할 수 있다. <code>import static org.junit.Assert.*;</code> 그리고 다음부터는 직접 Assert 메소드를 호출할 수 있다. <code>assertEquals(buf.readSlice(3), read);</code></p></blockquote><br><h3 id="인바운드-메세지-테스트"><a href="#인바운드-메세지-테스트" class="headerlink" title="인바운드 메세지 테스트"></a>인바운드 메세지 테스트</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedLengthFrameDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 인바운드 바이트를 처리하고 이를 메세지로 디코딩하기 위해서</span></span><br><span class="line">  <span class="comment">// ByteToMessageDecoder를 상속 받음</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> frameLength;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FixedLengthFrameDecoder</span><span class="params">(<span class="keyword">int</span> frameLength)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 생성할 프레임의 길이 지정</span></span><br><span class="line">    <span class="keyword">if</span>(frameLength &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"frameLength must be a positive integer:"</span>+frameLength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.frameLength = frameLength;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="comment">// 다음 프레임을 처리하는 데 충분하게 바이트를 읽을 수 있는지 확인</span></span><br><span class="line">      <span class="keyword">while</span> (in.readableBytes() &gt;= frameLength) &#123;</span><br><span class="line">        ByteBuf buf = in.readBytes(frameLength);</span><br><span class="line">        <span class="comment">// ByteBuf에서 새로운 프레임을 읽음</span></span><br><span class="line">        out.add(buf);</span><br><span class="line">        <span class="comment">// 디코딩 된 메세지의 List에 프레임을 추가함</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteToMessageDecoder</code>는 고정된 3바이트의 프레임을 생성한다. 이 코드는 데이터가 충분히 있는 경우 고정 크기의 프레임을 생성한다. 반면에 읽을 데이터가 충분하지 않으면 다음 데이터를 기다린다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedLengthFrameDecoderTest</span></span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="comment">//JUnit이 메소드를 실행하도록 @Test 어노테이션을 지정해줌</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFrameDecoded</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ByteBuf buf = Unpooled.buffer();</span><br><span class="line">    <span class="comment">// ByteBuf를 생성하고 9바이트 저장</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">      buf.writeByte(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ByteBuf input = buf.duplicate();</span><br><span class="line">    EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">      <span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">3</span>));</span><br><span class="line">      <span class="comment">// EmbeddedChannel을 생성하고 3바이트 길이의 프레임으로 테스트할</span></span><br><span class="line">      <span class="comment">// FixedLengthFrameDecoder를 추가함</span></span><br><span class="line">    assertTrue(channel.writeInbound(input.retain()));</span><br><span class="line">    <span class="comment">// EmbeddedChannel에 바이트를 기록</span></span><br><span class="line">    assertTrue(channel.finish());</span><br><span class="line">    <span class="comment">// Channel을 완료로 표시</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 처리된 메세지를 읽고 각각 3바이트 프레임이 3개인지 확인함</span></span><br><span class="line">    ByteBuf read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line"></span><br><span class="line">    read (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>),read);</span><br><span class="line">    read.release();</span><br><span class="line"></span><br><span class="line">    read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line"></span><br><span class="line">    assertNull(channel.readInbound());</span><br><span class="line">    buf.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>testFrameDecoded()</code> 메소드는 읽을 수 있는 9바이트를 포함하는 ByteBuf 1개가 3바이트를 포함하는 ByteBuf 3개로 디코딩되는지 확인한다. 그리고 <code>writeInbound()</code>를 한번 호출해 ByteBuf는 읽기 가능한 9바이트로 채운다. 그 다음에 finish()를 실행해 EmbeddedChannel을 완료로 표시하고 마지막으로 <code>readInbound()</code>를 호출해 EmbeddedChannel에서 프레임 3개와 null 1개를 읽었다.</p><br><h3 id="아웃바운드-메세지-테스트"><a href="#아웃바운드-메세지-테스트" class="headerlink" title="아웃바운드 메세지 테스트"></a>아웃바운드 메세지 테스트</h3><p>아웃바운드 메세지 테스트도 인바운드와 비슷하다. <code>ChannelOutboundHandler</code>는 메세지를 다른 포맷으로 변환하는 컴포넌트인 인코더 역할을 한다. 아래의 코드로 테스트 해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsIntegerEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// MessageToMessageEncoder를 상속받아 메세지를 다른 포맷으로 인코딩 함</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext channelHandlerContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// 인코딩할 바이트가 충분한지 확인</span></span><br><span class="line">        <span class="keyword">int</span> value = Math.abs(in.readint());</span><br><span class="line">        <span class="comment">// ByteBuf에서 다음 int를 읽고 절대값을 계산</span></span><br><span class="line">        out.add(value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsIntegerEncoderTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEncoded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ByteBuf buf = Unpooled.buffer();</span><br><span class="line">    <span class="comment">// ByteBuf를 생성하고 음의 정수 9개 기록</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">      buf.writeInd(i * -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">      <span class="keyword">new</span> AbsIntegerEncoder());</span><br><span class="line">      <span class="comment">// EmbeddedChannel을 생성하고 테스트할 AbsIntegerEncoder를 추가</span></span><br><span class="line">    assertTrue(channel.writeOutbound(buf));</span><br><span class="line">    <span class="comment">// ByteBuf를 기록하고 readOutbound()가 데이터를 생성하는지 확인</span></span><br><span class="line">    assertTrue(channel.finish());</span><br><span class="line">    <span class="comment">// Channel을 완료로 표시</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성된 값을 읽고 절댓 값을 포함하는지 확인</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">      assertEquals(i, channel.readOutbound());</span><br><span class="line">    &#125;</span><br><span class="line">    assertNull(channel.readOutbound());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>ByteBuf</code>에 4바이트 음의 정수를 기록한다.</li><li><code>EmbeddedChannel</code>을 생성하고 여기에 <code>AbsIntegerEncoder</code>를 할당한다.</li><li><code>EmbeddedChannel</code>의 <code>writeOutbound()</code>를 호출해 ByteBuf를 기록한다.</li><li><code>Channel</code>을 완료로 표시한다.</li><li><code>EmbeddedChannel</code>의 아웃바운드 쪽에서 모든 정수를 읽고 절대값만 생성됐는지 확인한다.</li></ol><br><h2 id="예외-처리-테스트"><a href="#예외-처리-테스트" class="headerlink" title="예외 처리 테스트"></a>예외 처리 테스트</h2><p>데이터 변환외에도 입력이 잘못되거나 데이터가 너무 많은 경우 적절하게 처리해야할 필요가 있다 이런 경우 예외 처리를 따로 해줄 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameChunkDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 인바운드 바이트를 메세지로 디코딩하기 위해 ByteToMessageDecoder를 상속 받음</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxFrameSize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FrameChunkDecoder</span><span class="params">(<span class="keyword">int</span> maxFrameSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.maxFrameSize = maxFrameSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> readableBytes = in.readableBytes();</span><br><span class="line">      <span class="comment">// 생성할 프레임의 최대 허용 길이를 지정</span></span><br><span class="line">      <span class="keyword">if</span> (readableBytes &gt; maxFrameSize) &#123;</span><br><span class="line">        <span class="comment">// 프레임이 너무 큰 경우 폐기하고 TooLongFrameException을 생성함</span></span><br><span class="line">        in.clear();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException();</span><br><span class="line">      &#125;</span><br><span class="line">      ByteBuf buf = in.readBytes(readableBytes);</span><br><span class="line">      <span class="comment">// 그렇지 않은 경우 ByteBuf로부터 새 프레임을 읽음</span></span><br><span class="line">      out.add(buf);</span><br><span class="line">      <span class="comment">// 디코딩된 메세지의 List에 프레임을 추가</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성할 프레임의 최대 허용 길이를 설정하고 프레임의 크기가 이것을 넘어갈 경우 초과하는 바이트가 폐기되고 <code>TooLongFrameException</code>이 발생한다. 이 예외는 파이프라인의 <code>다른 ChannelHandler</code>에서 <code>exceptionCaught()</code>를 이용해 처리하거나 무시할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameChunkDecoderTest</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFrameDecoded</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ByteBuf buf = Unpooled.buffer();</span><br><span class="line">    <span class="comment">// ByteBuf를 생성하고 9바이트를 기록</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">      buf.writeByte(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ByteBuf input = buf.duplicate();</span><br><span class="line"></span><br><span class="line">    EmbeddedChannel channel = <span class="keyword">new</span> EmbeddedChannel(</span><br><span class="line">      <span class="keyword">new</span> FrameChunkDecoder(<span class="number">3</span>));</span><br><span class="line">      <span class="comment">// EmbeddedChannel을 생성하고 프레임 크기가 3인</span></span><br><span class="line">      <span class="comment">// FixedLengthFrameDecoder를 추가</span></span><br><span class="line"></span><br><span class="line">    assertTrue(channel.writeInbound(input.readBytes(<span class="number">2</span>)));</span><br><span class="line">    <span class="comment">// 2바이트를 기록한 후 새로운 프레임이 생성되는지 확인</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      channel.writeInbound(input.readBytes(<span class="number">4</span>));</span><br><span class="line">      <span class="comment">// 4바이트 프레임을 기록하고 예상되는 TooLongFrameException을 포착</span></span><br><span class="line">      Assert.fail();</span><br><span class="line">      <span class="comment">// 예외가 발생하지 않은 경우 이 메소드가 적용되고 테스트가 실패함</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (TooLongFrameException e)&#123;</span><br><span class="line">      <span class="comment">// 예상된 예외</span></span><br><span class="line">    &#125;</span><br><span class="line">    assertTrue(channel.writeInbound(input.readBytes(<span class="number">3</span>)));</span><br><span class="line">    <span class="comment">// 남은 2바이트를 기록하고 프레임이 올바른지 확인</span></span><br><span class="line">    assertTrue(channel.finish());</span><br><span class="line">    <span class="comment">// Channel을 완료로 표시</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성된 메세지를 읽고 값을 확인함</span></span><br><span class="line">    ByteBuf read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.readSlice(<span class="number">2</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line"></span><br><span class="line">    read = (ByteBuf) channel.readInbound();</span><br><span class="line">    assertEquals(buf.skipBytes(<span class="number">4</span>).readSlice(<span class="number">3</span>), read);</span><br><span class="line">    read.release();</span><br><span class="line">    buf.release();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드의 <code>try/catch</code> 블록은 EmbeddedChannel에서 특수하게 작용한다. <code>wrtie*</code> 메소드 중 하나에서 확인된 Exception이 발생하는 경우 이 <code>Exception</code>이 <code>RuntimeException</code>에 래핑된다. 이 방법을 데이터를 처리하는 동안 Exception이 처리됐는지 여부를 쉽게 테스트 할 수 있다. 그리고 이 테스트 방법은 <code>Exception</code>을 생성하는 모든 <code>ChannelHandler</code> 구현에 이용할 수 있다.</p><hr><ul><li>참고 서적<ul><li>네티 인 액션</li></ul></li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;단위-테스트란&quot;&gt;&lt;a href=&quot;#단위-테스트란&quot; class=&quot;headerlink&quot; title=&quot;단위 테스트란?&quot;&gt;&lt;/a&gt;단위 테스트란?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;다른 모듈이나 데이터베이스 및 네트워크 등 런타임 의존성으로부터
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/categories/server/netty/"/>
    
    
      <category term="Network" scheme="https://kodakyung.github.io/tags/network/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty Codec Framework</title>
    <link href="https://kodakyung.github.io/2018/06/01/server-netty-2018-06-02-netty-codec-framework/"/>
    <id>https://kodakyung.github.io/2018/06/01/server-netty-2018-06-02-netty-codec-framework/</id>
    <published>2018-05-31T15:00:00.000Z</published>
    <updated>2020-03-19T01:13:24.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="코덱이란"><a href="#코덱이란" class="headerlink" title="코덱이란?"></a>코덱이란?</h3><blockquote><p>모든 어플리케이션은 네트워크 상에 원시 바이트를 주고 받는다. 바이트 형태의 데이터를 대상 어플리케이션에 맞는 데이터 포맷으로 분석하고 변환하는 것이 필요하다. 이러한 데이터 변환은 인코더와 디코더로 구성된 코덱에 의해 처리된다.</p></blockquote><blockquote><p>일반적으로 동영상 압축 알고리즘을 코덱이라고 부른다. 예를 들면 MPEG 알고리즘으로 압축된 동영상을 재생한다면, 원본 동영상을 MPEG 알고리즘으로 압축하고 시청자는 다시 MPEG 디코더로 압축 해제한 뒤 시청을 할 것 이다.</p></blockquote><br><h2 id="디코더-Decoder"><a href="#디코더-Decoder" class="headerlink" title="디코더(Decoder)"></a>디코더(Decoder)</h2><p>디코더는 네트워크 스트림을 프로그램의 메세지 포맷으로 변환한다. 즉 인바운드 데이터를 처리한다. 디코더는 인바운드 데이터를 다른 포맷으로 변환하는 일을 하므로 <code>ChannelInboundHandler</code>를 상속받는다.  </p><ul><li>Netty의 디코더 클래스<ul><li><code>ByteToMessageDecoder</code> / <code>ReplayingDecoder</code> : 바이트 스트림을 메세지로 디코딩</li><li><code>MessageToMessageDecoder</code> : 메세지를 다른 메세지 유형으로 디코딩</li></ul></li></ul><h3 id="메세지란"><a href="#메세지란" class="headerlink" title="메세지란 ?"></a>메세지란 ?</h3><blockquote><p>특정 어플리케이션에서 의미가 있는 바이트의 시퀀스 구조를 메세지라고 한다. 인코더의 경우 이 메세지를 전송하기에 적합한 (보통 바이트 스트림) 형식으로 변환하고, 디코더는 네트워크 스트림을 다시 프로그램의 메세지 포맷으로 변환한다.</p></blockquote><p>디코더는 인바운드 데이터를 <code>ChannelPipeline</code>의 다음 <code>ChannelInboundHandler</code>를 위해 변환할 때 이용한다. ChannelPipeline은 설계 방식이 체인 형태이기 때문에 복잡한 논리도 여러 디코더를 체인으로 연결해서 쉽게 구현할 수 있다.</p><br><h3 id="ByteToMessageDecoder"><a href="#ByteToMessageDecoder" class="headerlink" title="ByteToMessageDecoder"></a>ByteToMessageDecoder</h3><p>바이트 스트림을 메세지(또는 다른 바이트의 시퀀스)로 디코딩 하는 일반적인 작업을 지원하는 추상 기본 클래스. 원격 피어가 완성된 메세지를 한번에 보낼지 알 수 없으므로 이 클래스는 인바운드 데이터가 처리할 만큼 모일 때까지 버퍼에 저장한다.</p><ul><li>ByteToMessageDecoder API</li></ul><table><thead><tr><th>메소드</th><th>설명</th></tr></thead><tbody><tr><td>decode(ChannelHandlerContext ctx, ByteBuf in, List<obejct> out)</obejct></td><td>decode()는 구현해야하는 유일한 추상 메소드로 들어오는 데이터가 포함된 ByteBuf와 디코딩된 메세지가 추가될 List를 받는다. 이 호출은 더 이상 List에 추가할 항목이 없거나 ByteBuf에 읽을 바이트가 없을 때까지 반복된다. 그 이후 List가 비어있지 않은 경우 그 내용이 파이프라인의 다음 핸들러로 전달된다.</td></tr><tr><td>decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<object> out)</object></td><td>네티가 제공하는 기본 구현은 단순히 decode()를 호출한다. 이 메소드는 Channel이 비활성화될 때 한번 호출된다. 특별한 처리가 필요한 경우 이 메소드를 재정의한다.</td></tr></tbody></table><ul><li>ByteToMessageDecoder를 상속받은 ToIntegerDecoder 클래스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 바이트를 특정 포맷으로 디코딩하기 위해서 ByteToMessageDecoder를 상속받음</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">// 최소 4바이트(int 길이)를 읽을 수 있는지 확인</span></span><br><span class="line">        out.add(in.readInt());</span><br><span class="line">        <span class="comment">// 인바운드 ByteBuf에서 int 하나를 읽고 이를 디코딩된 메세지의 List에 추가</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int를 포함하는 바이트 스트림을 받고 각각 별도로 처리하는 경우, 인바운드 <code>ByteBuf</code>에서 각 int를 읽고 이를 파이프라인의 다음 <code>ChannelInboundHandler</code>로 전달해야한다. 위의 예제는 인바운드 <code>ByteBuf</code>에서 4바이트씩 읽고 이를 int로 디코딩한 후 List로 추가한다. 그리고 List에 추가할 항목이 더 이상 없는 경우 그 내용을 다음 <code>ChannelInboundHandler</code>로 전달한다. 위의 예제는 <code>readableBytes</code> 메소드로 <code>ByteBuf</code>에 읽을 데이터가 있는지 확인하는 과정이 필요하다.</p><br><h3 id="ReplayingDecoder"><a href="#ReplayingDecoder" class="headerlink" title="ReplayingDecoder"></a>ReplayingDecoder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">S</span>&gt; <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span></span></span><br></pre></td></tr></table></figure><p><code>ReplayingDecoder</code>는 <code>ByteToMessageDecoder</code>를 상속받으며 위의 예제와 다르게 약간의 오버헤드를 감수하고 <code>readableBytes</code>를 호출할 필요를 없애준다. 이를 위해 들어오는 <code>ByteBuf</code>를 커스텀 ByteBuf 구현인 <code>ReplayingDecoderBuffer</code>로 래핑하는데 이 동작은 내부적으로 호출이 수행된다.</p><ul><li>ReplayingDecoder를 상속받은 ToIntegerDecoder 클래스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToIntegerDecoder</span> <span class="keyword">extends</span> <span class="title">ReplayingDecoder</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 바이트 스트림을 메세지로 디코딩하기 위해 ReplayingDecoder&lt;Void&gt;를 상속받음</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">  // 들어오는 ByteBuf는 ReplayingDecoderBuffer이다.</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      out.add(in.readInt());</span><br><span class="line">      <span class="comment">// 인바운드 ByteBuf에서 int 하나를 읽고 이를 디코딩된 메세지의 List에 추가함</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ReplayingDecoder의 특징<ul><li>모든 ByteBuf 작업이 지원되는 것은 아니다.<br>지원되지 않는 메소드를 호출하면  <code>UnsupportedOperationException</code>이 발생한다.</li><li><code>ReplayingDecoder</code>는 <code>ByteToMessageDecoder</code>보다 약간 느리다</li></ul></li></ul><br><h3 id="MessageToMessageDecoder"><a href="#MessageToMessageDecoder" class="headerlink" title="MessageToMessageDecoder"></a>MessageToMessageDecoder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">I</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span></span><br></pre></td></tr></table></figure><p>메세지 포맷을 변환하는 클래스이다. 예를 들면 POJO의 한 형식에서 다른 형식으로 바꾸는 등에 이용할 수 있다. 위의 형태에서 매개변수 I는 구현해야하는 유일한 메소드인 <code>decode()</code>에 입력 msg 인수의 형식을 알려준다.</p><ul><li>MessageToMessageDecoder API</li></ul><table><thead><tr><th>메소드</th><th>설명</th></tr></thead><tbody><tr><td>decode(ChannelHandlerContext ctx, I msg, List<object> out)</object></td><td>인바운드 메세지를 다른 포맷으로 디코딩할 때마다 호출된다. 디코딩된 메세지는 파이프라인의 다음 ChannelInboundHandler로 전달된다.</td></tr></tbody></table><ul><li>IntegerToStringDecoder 클래스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringDecoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageDecoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, Integer msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      out.add(String.valueOf(msg));</span><br><span class="line">      <span class="comment">//Integer 메세지를 String 표현으로 변환한 후 출력 List에 추가</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="TooLongFrameException"><a href="#TooLongFrameException" class="headerlink" title="TooLongFrameException"></a>TooLongFrameException</h3><p>네티는 비동기 프레임워크이므로 디코딩할 수 있을 때까지 바이트를 메모리 버퍼에 저장해야한다. 또한 디코더가 메모리를 소진할 만큼 많은 데이터를 저장해서는 안된다. 이 문제를 해결하기 위해서 프레임이 지정한 크기를 초과하면 발생하는 <code>TooLongFrameException</code> 예외를 제공한다.</p><p>이 예외는 <code>ChannelHandler.exceptionCaught()</code>로 포착할 수 있다. 예외를 처리하는 방법은 디코더의 이용자가 결정할 수 있다. HTTP 같은 특정 프로토콜을 이용할 때는 특수한 응답을 반환할 수 있지만 그 밖의 경우에는 연결을 닫는 것이 유일한 방법이다.</p><ul><li>TooLongFrameException 예제</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeByteToMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 인바운드 바이트를 메세지로 디코딩하기 위해 ByteToMessageDecoder를 상속받음</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_FRAME_SIZE = <span class="number">1024</span>;</span><br><span class="line">  <span class="comment">// 최대 바이트 수의 임계값을 설정한다.</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> readable = in.readableBytes();</span><br><span class="line">      <span class="keyword">if</span> (readable &gt; MAX_FRAME_SIZE)&#123;</span><br><span class="line">        <span class="comment">// 버퍼의 바이트 수가 MAX_FRAME_SIZE를 초과하는 지 확인</span></span><br><span class="line">        <span class="comment">// 읽을 수 있는 바이트를 모두 건너뛰고</span></span><br><span class="line">        <span class="comment">// TooLongFrameException을 생성한 후</span></span><br><span class="line">        <span class="comment">// 다른 ChannelHandler에 알림</span></span><br><span class="line">        in.skipBytes(readable);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TooLongFrameException(<span class="string">"Frame Too big"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 필요한 작업을 수행</span></span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ByteToMessageDecoder</code>가 <code>TooLongFrameException</code>을 이용해 <code>ChannelPipeline</code> 내의 다른 <code>ChannelHandler</code>에 프레임 초과를 알리는 코드이다. 이러한 예방책은 프레임 크기가 가변적인 프로토콜을 이용할 때 특히 중요하다.</p><br><h2 id="인코더-Encoder"><a href="#인코더-Encoder" class="headerlink" title="인코더(Encoder)"></a>인코더(Encoder)</h2><p>인코더는 아웃바운드 데이터를 한 포맷에서 다른 포맷으로 변환한다. 즉 아웃바운드 데이터를 처리하므로 <code>ChannelOutboundHandler</code>를 상속받는다.</p><ul><li>Netty의 인코더 클래스<ul><li><code>MessageToByteEncoder</code> : 메세지를 바이트로 인코딩</li><li><code>MessageToMessageDecoder</code> : 메세지를 다른 메세지로 인코딩</li></ul></li></ul><br><h3 id="MessageToByteEncoder"><a href="#MessageToByteEncoder" class="headerlink" title="MessageToByteEncoder"></a>MessageToByteEncoder</h3><p>앞의 <code>ByteToMessageDecoder</code>와 반대로 메세지를 바이트로 변환하는 클래스이다.</p><ul><li>MessageToByteEncoder API</li></ul><table><thead><tr><th>메소드</th><th>설명</th></tr></thead><tbody><tr><td>encode(ChannelHandlerContext ctx, I msg, ByteBuf out)</td><td>encode 메소드는 구현해야하는 유일한 추상 메소드이다. ByteBuf로 인코딩할 아웃바운드 메세지(I 형식)을 전달하고 호출한다. 그런 다음 ByteBuf는 파이프라인의 다음 ChannelOutboundHandler로 전달된다.</td></tr></tbody></table><p>디코더에는 메소드가 두개이지만 인코더인 이 클래스는 메소드가 하나이다. 디코더의 메소드가 두 개인 이유는 <code>Channel</code>이 닫힌 후 마지막 메세지를 생성해야하는 일이 자주 있기 때문이다.(<code>decodeLast()</code> 메소드). 인코더는 연결이 닫힌 후 메세지를 생성할 필요가 없기 때문에 메소드가 하나이다.</p><ul><li>ShortToByteEncoder 클래스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Short</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Short msg, ByteBuf out)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      out.writeShort(msg);</span><br><span class="line">      <span class="comment">// Short를 ByteBuf에 기록함</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Short 인스턴스를 메세지로 받고 이를 Short 기본형으로 인코딩한 후 <code>ByteBuf</code>에 저장하고 이를 파이프라인 내의 다음 <code>ChannelOutboundHandler</code>로 전달한다. 나가는 <code>Short</code>는 <code>ByteBuf</code>에서 2바이트를 차지한다.</p><br><h3 id="MessageToMessageEncoder"><a href="#MessageToMessageEncoder" class="headerlink" title="MessageToMessageEncoder"></a>MessageToMessageEncoder</h3><p>메세지를 아웃바운드 데이터로 인코딩하는 클래스이다.</p><ul><li>MessageToMessageEncoder API</li></ul><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>encode(ChannelHandlerContext ctx, I msg, List<object> out)</object></td><td>encode()는 구현해야하는 유일한 메소드이다. write()로 기록한 각 메세지는 encode()로 전달된 후 하나 이상의 아웃바운드 메세지로 인코딩된다. 그런다음 파이프라인의 다음 ChannelOutboundHandler로 전달된다.</td></tr></tbody></table><ul><li>IntegerToStringEncoder 클래스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerToStringEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToMessageEncoder</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Integer msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    out.add(String.valueOf(msg));</span><br><span class="line">    <span class="comment">// Integer를 String으로 변환하고 List에 추가</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="추상-코덱-클래스"><a href="#추상-코덱-클래스" class="headerlink" title="추상 코덱 클래스"></a>추상 코덱 클래스</h2><p>지금까지 인코더와 디코더를 별개로 다뤘지만 인바운드/아웃바운드 데이터와 메세지 변환을 한 클래스에서 관리할 수 있다. 네티의 추상 코덱 클래스는 디코더와 인코더의 작업을 함께 처리할 수 있다. 이 클래스는 <code>ChannelInboundHandler</code>와 <code>ChannelOutboundHandler</code>를 둘 다 구현한다. 이렇게 구현하는 경우 코드의 재사용성과 확장성은 떨어진다.</p><br><h3 id="ByteToMessageCodec"><a href="#ByteToMessageCodec" class="headerlink" title="ByteToMessageCodec"></a>ByteToMessageCodec</h3><p>바이트를 일종의 메세지(ex-POJO)로 디코딩한 후 다시 인코딩해야하는 경우, <code>ByteToMessageDecoder</code>와 반대 작업을 하는 <code>MessageToByteEncoder</code>를 결합하는 <code>ByteToMessageCodec</code>을 이용하면 된다.</p><ul><li>ByteToMessageCodec API</li></ul><table><thead><tr><th>메소드</th><th>설명</th></tr></thead><tbody><tr><td>decode(ChannelHanlder ctx, ByteBuf in, List<object> out)</object></td><td>이 메소드는 읽을 바이트가 있을 때 호출되고, 인바운드 ByteBuf를 지정한 메세지 포맷으로 변환하고 파이프라인 내의 다음 ChannelInboundHandler로 전달한다.</td></tr><tr><td>decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<object> out)</object></td><td>이 메소드의 기본 구현은 decode()로 위임하는 것이다. 이 메소드는 Channel이 비활성화될 때 한번 호출된다. 특별한 처리가 필요한 경우 이 메소드를 재정의한다.</td></tr><tr><td>encode(ChannelHanlderContext ctx, I msg, ByteBuf out)</td><td>이 메소드를 I 형식의 각 메소드를 인코딩하고 아웃바운드 ByteBuf에 기록한다.</td></tr></tbody></table><br><h3 id="MessageToMessageCodec"><a href="#MessageToMessageCodec" class="headerlink" title="MessageToMessageCodec"></a>MessageToMessageCodec</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageToMessageCodec</span>&lt;<span class="title">INBOUND_IN</span>, <span class="title">OUTBOUND_IN</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>MessageToMessageCodec의 메소드</li></ul><table><thead><tr><th>메소드</th><th>설명</th></tr></thead><tbody><tr><td>protected abstract decode(ChannelHandlerContext ctx, INBOUND_IN msg, List<object> out)</object></td><td>이 메소드는 INBOUND_IN 형식의 메세지를 받으면 이를 OUTBOUND_IN 형식의 메세지로 디코딩한다. 메세지는 ChannelPipeline 내의 다음 ChannelInboundHandler로 전달된다.</td></tr><tr><td>protected abstract encode(ChannelHandlerContext ctx, OUTBOUND_IN msg, List<object> out)</object></td><td>이 메소드는 OUTBOUND_IN 형식의 각 메세지를 처리할 때마다 호출한다. 처리된 메세지는 INBOUND_IN 형식의 메세지로 인코딩된 후 파이프라인 내의 다음 ChannelOutboundHandler로 전달된다.</td></tr></tbody></table><p><code>INBOUND_IN</code> 메세지는 전송을 위한 형식이고 <code>OUTBOUND_IN</code> 메세지는 어플리케이션에서 처리하는 형식으로 생각하면 된다. 해당 코덱은 서로 다른 메세징 API 간에 메세지를 변환하는 경우 사용된다. 이런 패턴은 레거시 메세지 포맷이나 특정 기업의 메세지 포맷을 이용하는 API와 상호운용해야하는 경우에 사용된다.</p><br><h3 id="CombinedChannelDuplexHandler"><a href="#CombinedChannelDuplexHandler" class="headerlink" title="CombinedChannelDuplexHandler"></a>CombinedChannelDuplexHandler</h3><p>디코더와 인코더를 결합해 사용하면 재사용성이 떨어지지만 <code>CombinedChannelDuplexHandler</code>를 이용하면 디코더와 인코더를 단일 유닛으로 배포하면서 재사용성 저하를 방지할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedChannelDuplexHandler</span></span></span><br><span class="line"><span class="class">  &lt;<span class="title">I</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandler</span>,</span></span><br><span class="line"><span class="class">  <span class="title">O</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandler</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 클래스는 <code>ChannelInboundHandler</code>와 <code>ChannelOutboundHandler</code>의 컨테이너 역할을 한다.</p><ul><li>ByteToCharDecoder 클래스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToCharDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(in.readableBytes() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        out.add(in.readChar());</span><br><span class="line">        <span class="comment">// 나가는 List에 Character 객체를 한 개 이상 추가</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 <code>decode()</code>는 <code>ByteBuf</code>에서 한번에 2바이트씩 읽고 <code>Character</code> 객체로 자동 박싱되는 char로 List에 기록한다.</p><ul><li>CharToByteEncoder 클래스</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Character</span>&gt;</span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Character msg,</span></span></span><br><span class="line"><span class="function"><span class="params">    ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      out.writeChar(msg);</span><br><span class="line">      <span class="comment">// Character를 char로 디코딩하고 아웃바운드 ByteBuf로 기록</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CharToByteEncoder</code>는 <code>Character</code>를 다시 바이트로 변환한다. 이 클래스는 char 메세지를 ByteBuf로 인코딩해야하므로 <code>MessageToByteEncoder</code>를 상속받으며, ByteBuf에 직접 기록하는 방법으로 인코딩한다.</p><ul><li>CombinedChannelDuplexHandler&lt;I,O&gt;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CombinedByteCharCodec</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">  <span class="title">CombinedChannelDuplexHandler</span>&lt;<span class="title">ByteToCharDecoder</span>, <span class="title">CharToByteEncoder</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CombinedByteCharCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">new</span> ByteToCharDecoder(), <span class="keyword">new</span> CharToByteEncoder());</span><br><span class="line">    <span class="comment">// 인스턴스를 부모로 전달</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 인코더와 디코더를 이용해 결합해 코덱을 만들 수 있다.  </p><p>이처럼 코덱 클래스 중 하나를 이용해 구현하거나 구현한 코덱을 결합할 수도 있다.</p><hr><ul><li>참고 서적<ul><li>네티 인 액션</li><li>자바 네트워크 소녀 네티  </li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;코덱이란&quot;&gt;&lt;a href=&quot;#코덱이란&quot; class=&quot;headerlink&quot; title=&quot;코덱이란?&quot;&gt;&lt;/a&gt;코덱이란?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;모든 어플리케이션은 네트워크 상에 원시 바이트를 주고 받는다. 바이트 형태의 데이터를
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/categories/server/netty/"/>
    
    
      <category term="Network" scheme="https://kodakyung.github.io/tags/network/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty 채널 이벤트와 이벤트핸들러, 그리고 파이프라인</title>
    <link href="https://kodakyung.github.io/2018/05/25/server-netty-2018-05-25-netty-channel-event-and-eventhandler-and-pipeline/"/>
    <id>https://kodakyung.github.io/2018/05/25/server-netty-2018-05-25-netty-channel-event-and-eventhandler-and-pipeline/</id>
    <published>2018-05-24T15:00:00.000Z</published>
    <updated>2020-03-19T01:12:26.932Z</updated>
    
    <content type="html"><![CDATA[<p>Netty의 <code>ChannelPipeline</code>은 <code>Channel</code>에서 발생한 <code>이벤트</code>가 이동하는 통로이다. 이 통로를 통해 이동하는 이벤트를 처리하는 클래스가 <code>이벤트 핸들러</code>이다. 네티의 <code>이벤트 메소드</code>는 데이터가 수신되면 네티가 자동으로 호출한다.</p><blockquote><p>Netty의 전체적인 구조는 <a href="https://kodakyung.github.io/2018/05/21/old-post-Netty-2018-05-21-Netty-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-Component/">이 게시글</a>을 참고</p></blockquote><p>자바를 이용한 기존의 서버 프로그래밍은 소켓을 이용하고 데이터가 수신하기를 기다린다. 이와 같은 상황일때 프로세스는 아래와 같다.</p><ul><li><strong>기존 자바 네트워크 프로그래밍</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 소켓에 데이터가 있는지 확인한다.</span><br><span class="line">2. (1)에서 데이터가 존재하면 데이터를 읽어들이는 메소드를 호출한다.</span><br><span class="line">3. 읽어들일 데이터가 존재하지 않으면 데이터가 도착할 때까지 기다린다.(blocking)</span><br><span class="line">4. 데이터를 기다리는 중에 네트워크가 끊어지면 에러 처리를 위한 메소드를 호출한다.</span><br></pre></td></tr></table></figure><p>Netty로 네트워크 프로그래밍을 하면 <code>채널 파이프라인</code>과 <code>이벤트 핸들러</code>로 추상화했기 때문에, <em>데이터의 수신 여부, 소켓의 연결 여부에 대한 예외 상황에서 메소드 호출에 관여할 필요가 없다.</em></p><ul><li><strong>Netty 네트워크 프로그래밍</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 부트스트랩으로 네트워크 애플리케이션에 필요한 설정을 지정한다.</span><br><span class="line">2. 부트스트랩에 이벤트 핸들러를 사용하여 채널 파이프라인을 구성한다.</span><br><span class="line">3. 이벤트 핸들러의 데이터 수신 이벤트 메소드에서 데이터를 읽어들인다.</span><br><span class="line">4. 이벤트 핸들러의 네트워크 끊김 이벤트 메소드에서 에러 처리를 한다.</span><br></pre></td></tr></table></figure><p>위 처럼 네티의 <strong>이벤트 루프가 소켓 채널에서 발생한 이벤트에 해당하는 이벤트 메소드를 자동으로 실행한다.</strong> 소켓 채널에 데이터가 수신된 경우 아래와 같은 프로세스로 동작한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 네티의 이벤트 루프가 채널 파이프라인에 등록된 첫 번째 이벤트 핸들러를 가져온다.</span><br><span class="line">2. 이벤트 핸들러에 데이터 수신 이벤트가 구현되어 있으면 실행한다.</span><br><span class="line">3. 데이터 수신 이벤트 메소드가 구현되어 있지 않으면 다음 이벤트 핸들러를 가져온다.</span><br><span class="line">4. (2)를 수행한다.</span><br><span class="line">5. 채널 파이프라인에 등록된 마지막 이벤트 핸들러에 도달할 때까지 (1)을 반복한다.</span><br></pre></td></tr></table></figure><p>데이터를 처리하는 입출력은 네티가 이벤트로 관리하므로 <strong>해당 이벤트에 해당하는 코드만 구현하면 된다.</strong></p><br><h1 id="ChannelPipeline-인터페이스"><a href="#ChannelPipeline-인터페이스" class="headerlink" title="ChannelPipeline 인터페이스"></a>ChannelPipeline 인터페이스</h1><p>Netty의 <code>ChannelPipeline</code>은 <code>Channel</code>과 <code>EventHandler</code> 사이에서 연결 통로 역할을 한다. Channel은 일반적인 소켓 프로그래밍의 <code>소켓</code>과 같다. 이 소켓에서 발생한 <code>이벤트</code>는 <code>채널 파이프라인</code>을 따라 흐른다. 그리고 이 <code>이벤트 핸들러</code>가 이벤트들을 수신하고 처리하는 기능을 한다. 하나의 채널 파이프라인에 여러 이벤트 핸들러를 등록할 수 있다. 종합하면 ChannelPipeline은 소켓 채널에서 발생한 이벤트 처리를 위한 추상화 모델이다.</p><br><h2 id="ChannelPipeline-구성"><a href="#ChannelPipeline-구성" class="headerlink" title="ChannelPipeline 구성"></a>ChannelPipeline 구성</h2><img alt="channelpipline" src="/images/2018-05-25/01.jpeg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 클라이언트 연결에 대응하는 소켓 객체를 생성하고 빈 채널 파이프라인 객체를 생성해서 소켓 채널에 할당한다.</span><br><span class="line">2. 소켓 채널에 등록된 ChannelInitializer 인터페이스 구현체를 가져와서 initChannel 메소드를 호출한다.</span><br><span class="line">3. 소켓 채널 참조로부터 (1)에서 등록한 파이프라인 객체를 가져오고 채널 파이프라인에 입력된 이벤트 핸들러 객체를 등록한다.</span><br></pre></td></tr></table></figure><p>위의 세 단계가 완료되면 채널이 등록됐다는 이벤트가 발생하고 이때부터 클라이언트와 서버간의 데이터 송수신을 위한 이벤트 처리가 시작된다.</p><p><code>ChannelPipeline</code>은 <code>ChannelInboundHandler</code>와 <code>ChannelOutboundHandler</code>가 모두 들어있는 <code>ChannelHandler</code>의 연속이다. 인바운드 이벤트가 트리거 되는 경우 <code>ChannelPipeline</code>의 시작부터 끝까지 전달된다. ChannelPipeline에는 ChannelPipeline 자체를 통해 전파되는 이벤트도 있다.</p><p>인바운드와 아웃바운드의 기준은 상대적이며 시작점을 어디로 기준으로 하느냐에 따라 다르다. 파이프라인은 이벤트를 전파하는 동안 파이프라인의 다음 <code>ChannelHandler</code>가 같은 이동 방향인지 확인한다. 그리고 이동방향이 다르면 <code>ChannelPipeline</code>은 방향이 일치하는 항목이 나올 때까지 <code>ChannelHandler</code>를 건너뛴다.</p><p>ChannelHandler는 ChannelPipeline에 다른 ChannelHandler를 추가 또는 제거하는 방법으로 ChannelPipeline을 실시간으로 수정할 수 있다. 심지어 자기 자신을 ChannelPipeline에서 제거할 수도 있다.</p><ul><li><strong>ChannelPipeline을 수정하는 ChannelHandler 메소드</strong></li></ul><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>addFirst</td><td>ChannelHandler를 ChannelPipeline에 추가한다</td></tr><tr><td>addBefore</td><td></td></tr><tr><td>addAfter</td><td></td></tr><tr><td>addLast</td><td></td></tr><tr><td>remove</td><td>ChannelHandler를 ChannelPipeline에서 제거한다.</td></tr><tr><td>replace</td><td>ChannelPipeline 내의 ChannelHandler를 다른 ChannelHandler로 대체한다.</td></tr></tbody></table><ul><li>ChannelPipeline 수정 예제</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ChannelPipeline pipeline = ..;</span><br><span class="line">FirstHandler firstHandler = <span class="keyword">new</span> FirstHandler();</span><br><span class="line"><span class="comment">// FirstHandler 인스턴스 생성</span></span><br><span class="line">pipeline.addLast(<span class="string">"handler1"</span>, firstHandler);</span><br><span class="line"><span class="comment">// 생성한 인스턴스를 ChannelPipeline에</span></span><br><span class="line"><span class="comment">// "handler1"이라는 이름으로 추가함</span></span><br><span class="line">pipeline.addFirst(<span class="string">"handler2"</span>, <span class="keyword">new</span> SecondHandler());</span><br><span class="line"><span class="comment">// SecondHandler 인스턴스를 ChannelPipeline의</span></span><br><span class="line"><span class="comment">// 첫번째 슬록에 "handler2"라는 이름으로 추가해</span></span><br><span class="line"><span class="comment">// 기존의 "handler1"보다 앞에 배치</span></span><br><span class="line">pipeline.addLast(<span class="string">"handler3"</span>, <span class="keyword">new</span> ThirdHandler());</span><br><span class="line"><span class="comment">// ThirdHandler 인스턴스를 ChannelPipeline의</span></span><br><span class="line"><span class="comment">// 마지막 슬롯에 "handler3"라는 이름으로 추가</span></span><br><span class="line">...</span><br><span class="line">pipeline.remove(<span class="string">"handler3"</span>);</span><br><span class="line"><span class="comment">// 인스턴스 이름으로 지정해 제거</span></span><br><span class="line">pipeline.remove(firstHandler);</span><br><span class="line"><span class="comment">// FirstHandler를 참조해 제거(고유)</span></span><br><span class="line">pipeline.replace(<span class="string">"handler2"</span>, <span class="string">"handler4"</span>, <span class="keyword">new</span> FourthHandler());</span><br><span class="line"><span class="comment">// SecondHandler를 FourthHandler로 대체</span></span><br></pre></td></tr></table></figure><p>반면에 ChannelPipeline에서도 ChannelHandler에 접근이 가능하다.</p><ul><li><strong>ChannelHandler에 접근하는 ChannelPipeline 메소드</strong></li></ul><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>get</td><td>지정한 형식이나 이름에 해당하는 ChannelHandler를 반환한다.</td></tr><tr><td>context</td><td>ChannelHandler에 바인딩된 ChannelHandlerContext를 반환한다.</td></tr><tr><td>names</td><td>ChannelPipeline에 포함된 모든 ChannelHandler의 이름을 반환한다.</td></tr></tbody></table><ul><li><strong>ChannelPipeline의 인바운드 작업</strong>  </li></ul><table><thead><tr><th>메소드 이름</th><th>설명</th></tr></thead><tbody><tr><td>fireChannelRegistered</td><td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelRegistered(ChannelHandlerContext)를 호출한다</td></tr><tr><td>fireChannelUnregistered</td><td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelUnregistered(ChannelHandlerContext)를 호출한다.</td></tr><tr><td>fireChannelActive</td><td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelActive(ChannelHandlerContext)를 호출한다.</td></tr><tr><td>fireChannelInactive</td><td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelInactive(ChannelHandlerContext)를 호출한다.</td></tr><tr><td>fireExceptionCaught</td><td>ChannelPipeline의 다음 ChannelInboundHandler에서 exceptionCaught(ChannelHandlerContext, Throwable)를 호출한다.</td></tr><tr><td>fireUserEventTriggered</td><td>ChannelPipeline의 다음 ChannelInboundHandler에서 userEventTriggered(ChannelHandlerContext, Object)를 호출한다.</td></tr><tr><td>fireChannelRead</td><td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelRead(ChannelHandlerContext, Object msg)를 호출한다.</td></tr><tr><td>fireChannelReadComplete</td><td>ChannelPipeline의 다음 ChannelInboundHandler에서 channelReadComplete(ChannelHandlerContext)를 호출한다.</td></tr></tbody></table><ul><li><strong>ChannelPipeline의 아웃바운드 작업</strong>  </li></ul><table><thead><tr><th>메소드 이름</th><th>설명</th></tr></thead><tbody><tr><td>bind</td><td>Channel을 로컬 주소로 바인딩한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 bind(ChannelHandlerContext, SocketAddress, ChannelPromise)를 호출한다.</td></tr><tr><td>connect</td><td>Channel을 원격 주소로 연결한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 connect(ChannelHandlerContext, SocketAddress, ChannelPromise)를 호출한다.</td></tr><tr><td>disconnect</td><td>Channel 연결을 해제한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 disconnect(ChannelHandlerContext, ChannelPromise)를 호출한다.</td></tr><tr><td>close</td><td>Channel을 닫는다. ChannelPipeline의 다음 ChannelOutboundHandler에서 close(ChannelHandlerContext, ChannelPromise)를 호출한다.</td></tr><tr><td>deregister</td><td>이전에 할당한 EventExcutor(EventLoop)에서 Channel 등록을 해제한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 deregister(ChannelHandlerContext, ChannelPromise)를 호출한다.</td></tr><tr><td>flush</td><td>Channel의 대기 중인 기록을 모두 플러시한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 flush(ChannelHandlerContext)를 호출한다.</td></tr><tr><td>write</td><td>Channel에 메세지를 기록한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 write(ChannelHandlerContext, Objectmsg, ChannelPromise)를 호출한다. (기록을 요청하는 것이며 기반 Socket에 바로 메세지를 기록하는 것은 아니다. Socket으로 기록하려면 flush()나 writeAndFlush()를 호출한다.)</td></tr><tr><td>writeAndFlush</td><td>write()를 호출한 뒤 flush()를 호출하는 편의 메소드</td></tr><tr><td>read</td><td>Channel에서 데이터 읽기를 요청한다. ChannelPipeline의 다음 ChannelOutboundHandler에서 read(ChannelHandlerContext)를 호출한다.</td></tr></tbody></table><br><h1 id="ChannelHandler-인터페이스"><a href="#ChannelHandler-인터페이스" class="headerlink" title="ChannelHandler 인터페이스"></a>ChannelHandler 인터페이스</h1><p><strong>이벤트 핸들러는 네티의 소캣 채널에서 발생한 이벤트를 처리하는 인터페이스다.</strong> 소켓 채널의 이벤트를 인터페이스로 정의하고 이 인터페이스를 상속 받은 이벤트 핸들러를 작성해서 채널 파이프라인에 등록한다. 채널 파이프라인으로 입력되는 이벤트를 이벤트 루프가 가로채어 이벤트에 해당하는 메소드를 수행하는 구조다. 그러므로 <em>네티가 제공하는 이벤트의 종류나 발생 시기를 아는 것이 중요하다.</em></p><h2 id="Channel-수명주기"><a href="#Channel-수명주기" class="headerlink" title="Channel 수명주기"></a>Channel 수명주기</h2><table><thead><tr><th>상태</th><th>설명</th></tr></thead><tbody><tr><td>ChannelUnregistered</td><td>Channel이 생성됐지만 EventLoop에 등록되지 않음</td></tr><tr><td>ChannelRegistered</td><td>Channel이 EventLoop에 등록됨</td></tr><tr><td>ChannelActive</td><td>Channel이 활성화됨(원격 피어로 연결됨). 이제 데이터 주고받기 가능</td></tr><tr><td>ChannelInactive</td><td>Channel이 원격 피어로 연결되지 않음</td></tr></tbody></table><p>일반적인 수명주기는 <code>ChannelRegistered</code> -&gt; <code>ChannelActive</code> -&gt; <code>ChannelInactive</code> -&gt; <code>ChannelUnregistered</code> 순으로 이뤄진다.<br>수명주기 상태 변경이 수행될 때 해당하는 이벤트가 생성된다. 이런 이벤트는 <code>ChannelPipeline</code>에 있는 <code>ChannelHandler</code>로 전달된다.</p><h2 id="ChannelHandler-수명주기"><a href="#ChannelHandler-수명주기" class="headerlink" title="ChannelHandler 수명주기"></a>ChannelHandler 수명주기</h2><table><thead><tr><th>메소드</th><th>설명</th></tr></thead><tbody><tr><td>handlerAdded</td><td>ChannelHandler가 ChannelPipeline에 추가될 때 호출</td></tr><tr><td>handlerRemoved</td><td>ChannelHandler가 ChannelPipeline에서 제거될 때 호출</td></tr><tr><td>exceptionCaught</td><td>ChannelPipeline에서 처리 중에 오류가 발생하면 호출</td></tr></tbody></table><p>위 메소드는 <code>ChannelHandler</code>가 <code>ChannelPipeline</code>에 추가 또는 제거된 후 호출된다. 각 메소드는 <code>ChannelHandlerContext</code> 인수를 받는다.  </p><p><code>ChannelHandler</code>는 하위 인터페이스 <code>ChannelInboundHandler</code>와 <code>ChannelOutboundHandler</code>로 나뉜다.</p><ul><li>ChannelInboundHandler : 모든 유형의 인바운드 데이터와 상태 변경을 처리</li><li>ChannelOutboundHandler : 아웃 바운드 데이터를 처리하고 모든 작업의 가로채기를 허용함</li></ul><br><h2 id="ChannelInboundHandler-인터페이스"><a href="#ChannelInboundHandler-인터페이스" class="headerlink" title="ChannelInboundHandler 인터페이스"></a>ChannelInboundHandler 인터페이스</h2><p>클라이언트가 서버에 접속한 상태에서 서버로 데이터를 보내는 경우, 서버 측에서는 네티가 소켓에 읽을 데이터가 있다는 이벤트를 채널 파이프라인으로 보내게된다. 그러면 채널 파이프라인에 등록된 이벤트 핸들러 중에서 인바운드 이벤트 핸들러가 해당 이벤트에 해당하는 메소드를 수행한다.</p><ul><li>인바운드 이벤트 발생 순서</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 이벤트 루프에 채널 등록(channelRegistered)</span><br><span class="line">2. 채널 활성화(channelActive)</span><br><span class="line">3. 데이터 수신(channelRead)</span><br><span class="line">4. 데이터 수신 완료(channelReadComplete)</span><br><span class="line">5. 채널 비활성화(channelInactive)</span><br><span class="line">6. 이벤트 루프에서 채널 제거(channelUnregistered)</span><br></pre></td></tr></table></figure><table><thead><tr><th>메소드</th><th>설명</th></tr></thead><tbody><tr><td>channelRegistered</td><td>channel이 EventLoop에 등록되고 입출력을 처리할 수 있으면 호출됨</td></tr><tr><td>channelUnregistered</td><td>channel이 EventLoop에서 등록 해제되고 입출력을 처리할 수 없으면 호출됨</td></tr><tr><td>channelActive</td><td>channel의 연결과 바인딩이 완료되어 활성화되면 호출됨</td></tr><tr><td>channelInactive</td><td>channel이 활성 상태에서 벗어나 로컬 피어에 대한 연결이 해제되면 호출됨</td></tr><tr><td>channelReadComplete</td><td>channel에서 읽기 작업이 완료되면 호출됨</td></tr><tr><td>channelRead</td><td>channel에서 데이터를 읽을 때 호출 됨</td></tr><tr><td>channelWritabilityChanged</td><td>channel의 기록 가능 상태가 변경되면 호출된다. OutOfMemoryError를 방지하기 위해서 너무 빠르게 기록되지 않게 하거나 channel이 기록 가능한 상태가 되면 기록을 재개할 수 없다. Channel의 isWritable() 메소드를 호출해 해당 채널의 기록 가능 여부를 감지할 수 있다. 기록 가능 여부를 결정하는 임계값은 Channel.config().setWriteHighWaterMark()와 Channel.config().setWriteLowWaterMark() 메소드로 설정한다.</td></tr><tr><td>userEventTriggered</td><td>POJO가 ChannelPipeline을 통해 전달돼서 ChannelInboundHandler.fireUserEventTriggered()가 트리거되면 호출된다.</td></tr></tbody></table><p>위의 메소드들은 데이터가 수신되거나 연결된 Channel의 상태가 변경될 때 호출된다. 이런 메소드들은 <code>Channel의 수명 주기</code>와 관련이 깊다. 이 중 <code>channelRead</code> 메소드를 Override하는 경우 풀링된 ByteBuf 인스턴스의 메모리를 <code>release()</code> 메소드를 사용해 해제 해야한다.</p><p>매번 리소스 관리하기가 번거로운 경우 <code>SimpleChannelInboundHandler</code>를 상속받아 <code>channelRead0</code> 메소드를 사용하면 리소스를 해제 할 필요가 없다. 대신 메세지를 참조해 활용하는 경우 이 클래스를 사용하면 안된다.</p><ul><li>ChannelInboundHandlerAdapter 상속</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">    ReferenceCountUtil.release(msg);</span><br><span class="line">    <span class="comment">// 리소스 해제를 필수적으로 해줘야함</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SimpleChannelInboundHandler 상속</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDiscardHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 리소스를 해제할 필요 없음</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li><strong>서버와 클라이언트의 channelRegistered 발생 위치</strong></li></ul><table><thead><tr><th align="right">네티 서버</th><th align="left">네티 클라이언트</th></tr></thead><tbody><tr><td align="right"></td><td align="left"><strong>connect() 호출</strong></td></tr><tr><td align="right">생성 및 이벤트 루프 호출</td><td align="left">생성 및 이벤트 루프 등록</td></tr><tr><td align="right">[서버 소켓 채널]</td><td align="left">[클라이언트 소켓 채널]</td></tr><tr><td align="right"><strong>↓</strong></td><td align="left"><strong>↓</strong></td></tr><tr><td align="right"><em>(1)channelRegistered 이벤트</em></td><td align="left"><em>(2)channelRegistered 이벤트</em></td></tr><tr><td align="right"><strong>↓</strong></td><td align="left"><strong>↓</strong></td></tr><tr><td align="right">연결</td><td align="left">요청</td></tr><tr><td align="right">[서버 소켓 채널]<strong>&lt;—–</strong></td><td align="left"><strong>—–</strong>[클라이언트 소켓 채널]</td></tr><tr><td align="right"><strong>↓</strong> accept()</td><td align="left"></td></tr><tr><td align="right">생성 및 이벤트 루프 등록</td><td align="left"></td></tr><tr><td align="right">[클라이언트 소켓 채널]</td><td align="left"></td></tr><tr><td align="right"><em>(3)channelRegistered 이벤트</em></td><td align="left"></td></tr></tbody></table><p><code>channelRegistered</code> 이벤트는 <strong>(1)과 같은 처음 서버 소켓 채널을 생성할 때</strong>, <strong>(3)과 같이 새로운 클라이언트가 서버에 접속해 클라이언트 소켓 채널이 생성될 때</strong> 발생한다. 즉, 서버 소켓 채널에서 발생한 channelRegistered 이벤트와 서버에 연결된 클라이언트 소켓 채널에서 발생한 channelRegistered 이벤트 2가지다. 클라이언트에서는 <strong>(2)와 같이 서버 접속을 위한 connect 메소드를 수행할 때</strong> channelRegistered 이벤트가 발생한다. 즉 channelRegistered 이벤트는 서버 클라이언트 상관 없이 새로운 채널이 생성되는 시점에 발생한다.</p><br><ul><li><strong>channelActive 이벤트</strong><br><code>channelActive</code> 이벤트는 channelRegistered 이벤트 이후에 발생한다. 채널이 생성되고 이벤트 루프에 등록된 후 네티 API를 통해 채널 입출력 상태가 가능하다는 것을 알려준다.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 서버 어플리케이션에 연결된 클라이언트 갯수 세기</span><br><span class="line">- 서버 애플리케이션에 연결된 클라이언트에게 최초 연결에 대한 메세지 전송</span><br><span class="line">- 클라이언트 어플리케이션이 연결된 서버에 최초 메세지를 전달할 때</span><br><span class="line">- 클라이언트 어플리케이션이 서버에 연결된 상태에 대한 작업이 필요할 때</span><br></pre></td></tr></table></figure><p>위의 상황 같이 channelActive 이벤트를 서버 또는 클라이언트가 상대방에 연결한 직후 한번 수행하는 작업을 처리하기에 적합하다.</p><br><h2 id="ChannelOutboundHandler-인터페이스"><a href="#ChannelOutboundHandler-인터페이스" class="headerlink" title="ChannelOutboundHandler 인터페이스"></a>ChannelOutboundHandler 인터페이스</h2><p>아웃바운드 이벤트는 소켓 채널에서 발생한 이벤트 중에서 네티 사용자가 요청한 동작에 해당하는 이벤트를 말한다. 연결 요청, 데이터 전송, 소켓 닫기 등이 해당한다. 아웃바운드 이벤트는 <code>ChannelOutboundHandler</code> 인터페이스로 제공되고 모든 <code>ChannelOutboundHandler</code> 이벤트는 <code>ChannelOutboundHandlerContext</code> 객체를 인수로 받는다. ChannelOutboundHandler는 작업이나 이벤트를 지연하는 기능이 있어 정교하게 요청을 처리할 수 있다. 예를 들면 원격 피어에 대한 기록이 일시 중단된 경우 플러시 작업을 지연하고 나중에 재개할 수 있다.</p><table><thead><tr><th>메소드</th><th>설명</th></tr></thead><tbody><tr><td>bind(ChannelHandlerContext, SocketAddress, ChannelPromise)</td><td>Channel을 로컬 주소로 바인딩 요청, 서버 소켓 채널이 클라이언트의 연결을 대기하는 IP와 포트가 설정되었을 때 발생. 즉 bind 이벤트에서는 서버 소켓 채널이 사용중인 SocketAddress 객체가 인수로 입력된다.</td></tr><tr><td>connect(ChannelHandlerContext, SocketAddress, SocketAddress, ChannelPromise)</td><td>Channel을 원격 피어로 연결 요청 시 호출 됨. 원격지의 SocketAddress 정보와 로컬 SocketAddress 정보가 인수로 입력된다.</td></tr><tr><td>disconnect(ChannelHandlerContext, ChannelPromise)</td><td>Channel을 원격 피어로부터 연결 해제 요청시 호출 됨.</td></tr><tr><td>close(ChannelHandlerContext, ChannelPromise)</td><td>Channel을 닫는 요청 시 호출 됨</td></tr><tr><td>deregister(ChannelHandlerContext, ChannelPromise)</td><td>Channel을 EventLoop에서 등록 해제 요청시 호출됨</td></tr><tr><td>read(ChannelHandlerContext)</td><td>Channel에서 데이터 읽기 요청시 호출됨</td></tr><tr><td>flush(ChannelHandlerContext)</td><td>Channel을 통해 원격 피어로 큐에 있는 데이터의 플러시 요청시 호출</td></tr><tr><td>write(ChannelHandlerContext, Object, ChannelPromise)</td><td>Channel을 통해 원격 피어로 데이터 기록 요청 시 호출됨. 소켓 채널에 기록된 데이터 버퍼가 인수로 입력된다.</td></tr></tbody></table><ul><li>ChannelPromise ? ChannelFuture ?  </li></ul><blockquote><p>ChannelOutboundHandler에 있는 대부분 메소드는 작업이 완료되면 알림을 전달받을 ChannelPromise 인수가 있다. ChannelPromise는 ChannelFuture의 하위 인터페이스로 setSuccess()나 setFailure()와 같은 기록 가능 메소드를 정의해서 ChannelFuture을 읽기전용으로 만든다.</p></blockquote><h3 id="리소스-관리"><a href="#리소스-관리" class="headerlink" title="리소스 관리"></a>리소스 관리</h3><p><code>ChannelInboundHandler.channelRead()</code> 또는 <code>ChannelOutboundHandler.write()</code>를 호출해 데이터를 작업한 경우 리소스 누출이 발생하지 않게 관리해아한다. 네티는 참조 카운팅을 이용해 풀링된 ByteBuf를 관리한다. 따라서 ByteBuf 사용 후 참조 카운트를 조정하는 것이 필요하다.<br>네티가 제공하는 <code>ResourceLeakDetector</code> 클래스를 이용한다.</p><ul><li>리소스 누출 감지 수준</li></ul><table><thead><tr><th>수준</th><th>설명</th></tr></thead><tbody><tr><td>DISABLED</td><td>누출 감지를 비활성화한다. 이 설정은 포괄적인 테스트를 거친 후에만 이용한다.</td></tr><tr><td>SIMPLE</td><td>기본 샘플링 비율 1%를 이용해 발견된 누출을 보고한다. 기본 샘플링 비율은 대부분의 경우에 적합하다</td></tr><tr><td>ADVANCED</td><td>발견된 누출과 메세지에 접근한 위치를 보고한다. 기본 샘플링 비율을 이용한다</td></tr><tr><td>PARANOID</td><td>ADVANCED와 비슷하지만 모든 접근을 샘플링한다. 성능에 큰 영향을 미쳐서 디버깅 단계에서만 사용해야한다.</td></tr></tbody></table><p>자바 시스템 속성을 표에 있는 값 중에 하나로 변경하면 설정할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dio.netty.leakDetectionLevel=ADVANCED</span><br></pre></td></tr></table></figure><br><h2 id="ChannelHandlerContext-인터페이스"><a href="#ChannelHandlerContext-인터페이스" class="headerlink" title="ChannelHandlerContext 인터페이스"></a>ChannelHandlerContext 인터페이스</h2><p><code>ChannelHandlerContext</code>는 <code>ChannelHandler</code>와 <code>ChannelPipeline</code>간의 연결을 나타내며 <code>ChannelHandler</code>는 <code>ChannelPipeline</code>에 추가할 때마다 생성된다. <code>ChannelHandlerContext</code>에는 다양한 메소드가 있다.</p><p><code>ChannelHandlerContext</code>는 두 가지 네티 객체의 상호작용을 도와주는 인터페이스다. 첫번째는 채널에 대한 입출력 처리이며 두번째는 채널 파이프라인에 대한 상호작용이다.  </p><p>첫째 채널에 대한 입출력의 경우 <code>ChannelHandlerContext</code>의 <code>writeAndFlush</code>메소드로 채널에 데이터를 기록하고 <code>close</code> 메소드로 채널의 연결을 종료할 수 있다.    </p><p>두번째 파이프라인에 대한 상호작용은 사용자에 의한 이벤트 발생과 채널 파이프라인에 등록된 이벤트 핸들러의 상태가 변경되는 것 두가지가 있다. 파이프라인에는 여러 이벤트 핸들러는 등록할 수 있고 채널이 초기화될 때 채널 파이프라인의 이벤트 핸들러가 설정된다. <code>ChannelHandlerContext</code>는 채널이 초기화될 때 설정된 채널 파이프라인을 가져오는 메소드를 제공한다. 그래서 <code>ChannelHandlerContext</code>를 통해 설정된 채널 파이프라인을 수정할 수 있다.</p><br><h2 id="예외-처리"><a href="#예외-처리" class="headerlink" title="예외 처리"></a>예외 처리</h2><h3 id="인바운드-예외-처리"><a href="#인바운드-예외-처리" class="headerlink" title="인바운드 예외 처리"></a>인바운드 예외 처리</h3><p>인바운드 이벤트가 처리되는 동안 예외가 발생하면 실행된 <code>ChannelInboundHandler</code>부터 시작해 예외가 <code>ChannelPipeline</code>을 통과하기 시작한다. 이런 인바운드 예외를 처리하기 위해 <code>exceptionCaught</code> 메소드를 재정의한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception</span></span><br></pre></td></tr></table></figure><ul><li>기본 인바운드 예외 처리<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboundExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>모든 인바운드 이벤트는 인바운드 방향으로 진행된다. 예외 또한 마찬가지이다. 따라서 예외 처리 루틴을 채널 파이프라인의 끝부분에 배치하면 채널 파이프라인에 어느 위치에서 예외가 발생하더라도 모두 처리할 수 있다.</p><p>예외 대응 방식은 애플리케이션에 따라 다르지만 Channel을 닫거나 복구를 시도하며, 예외처리를 구현하지 않는 경우 관련 내용을 알리는 로깅을 할 수 있다.</p><ul><li><code>ChannelHandler.exceptionCaught()</code>의 기본 구현은 현재 예외를 다음 파이프라인의 예외로 전달한다.</li><li>예외가 파이프라인 끝에 도달하면 예외가 처리되지 않았음을 알리는 항목이 로깅된다.</li><li>예외를 처리하는 방식을 원하는대로 하고 싶다면 <code>exceptionCaught()</code>를 재정의한다. 예외를 외부로 전파할지 말지 여부는 개발자가 결정할 수 있다.</li></ul><h3 id="아웃바운드-예외-처리"><a href="#아웃바운드-예외-처리" class="headerlink" title="아웃바운드 예외 처리"></a>아웃바운드 예외 처리</h3><p>아웃바운드 작업에서 정상적인 완료와 예외 처리하는 옵션은 <code>ChannelFuture</code>를 이용한다.</p><ul><li>모든 아웃바운드 작업은 <code>ChannelFuture</code>를 반환한다. 작업이 완료되면 <code>ChannelFuture</code>에 등록된 <code>ChannelFutureListener</code>에 성공이나 오류에 대한 알림이 제공된다.</li><li><code>ChannelOutboundHandler</code>의 거의 모든 메소드에는 <code>ChannelPromise</code>가 전달된다. <code>ChannelFuture</code>의 하위 클래스인 <code>ChannelPromise</code>에도 비동기 알림을 위한 수신기를 할당할 수 있다. 그리고 <code>ChannelPromise</code>에도 즉시 알림을 지원하는 쓰기 가능 메소드가 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ChannelPromise <span class="title">setSuccess</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelPromise <span class="title">setFailure</span><span class="params">(Throwable cause)</span></span>;</span><br></pre></td></tr></table></figure><p>여기서 <code>ChannelFutureListener</code>를 추가하려면 <code>ChannelFuture</code> 인스턴스의 <code>addListener(Channel)</code>을 호출해야하는데 두가지 호출 방법이 있다.</p><p>(1) 아웃바운드 작업(write() 등)이 반환하는 <code>ChannelFuture</code>의 <code>addListener()</code>를 호출</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = channel.write(someMessage);</span><br><span class="line">future.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!f.isSuccess())&#123;</span><br><span class="line">      f.cause().printStackTrace();</span><br><span class="line">      f.channel().close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>(2) ChannelOutboundHandler 메소드에 인수로 전달되는 <code>ChannelPromise</code>에 <code>ChannelListener</code>를 추가</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutboundExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ChannelOutboundHandlerAdapter</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span></span>&#123;</span><br><span class="line">    promise.addListener(<span class="keyword">new</span> ChannelFutureListener()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture f)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f.isSuccess())&#123;</span><br><span class="line">          f.cause().printStackTrace();</span><br><span class="line">          f.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예외를 세부적으로 처리하고 싶은 경우 (1)을, 간단하게 예외를 처리하고 싶다면 (2) 구현을 사용하는 것이 좋다.</p><br><h2 id="이벤트-실행-흐름"><a href="#이벤트-실행-흐름" class="headerlink" title="이벤트 실행 흐름"></a>이벤트 실행 흐름</h2><p>위의 내용들을 종합해 <code>ChannelPipeline</code>과 <code>ChannelHandler</code>를 통해 이벤트가 실행되는 과정을 알아보자.</p><ul><li>ChannelPipeline에 여러개의 핸들러 등록</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span>&#123;</span><br><span class="line">        ChannelPipeline p = ch.pipeline();</span><br><span class="line">        p.addLast(<span class="keyword">new</span> EchoServerFirstHandler());</span><br><span class="line">        p.addLast(<span class="keyword">new</span> EchoServerSecondHandler());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ChannelPipeline</code>에 두개의 이벤트 핸들러를 등록했다.</p><ul><li>FirstHandler 이벤트 핸들러</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerFirstHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">    ByteBuf readMessage = (ByteBuf)msg;</span><br><span class="line">    System.out.println(<span class="string">"channelRead:"</span>+readMessage.toString(Charset.defaultCharset()));</span><br><span class="line">    ctx.write(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>채널 파이프라인에 첫번째로 등록된 이벤트 핸들러. <code>channelRead</code> 이벤트 메소드만 구현했다.</p><ul><li>SecondHandler 이벤트 핸들러</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerSecondHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"channelReadComplete 발생"</span>);</span><br><span class="line">    ctx.flush();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">    cause.printStackTrace();</span><br><span class="line">    ctx.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>채널 파이프라인에 두번째로 등록한 이벤트 핸들러. <code>channelReadComplete</code> 이벤트 메소드와 <code>exceptionCaught</code> 이벤트 메소드를 구현했다.</p><ol><li>EchoServer에서 클라이언트 채널이 생성되고 해당 채널의 파이프라인에 <code>ChannelActive</code> 이벤트 발생</li><li>등록된 2개의 이벤트 핸들러에 ChannelActive 이벤트 메소드가 없어서 ChannelActive 이벤트는 무시됨.</li><li>다음으로 <code>channelRead</code> 이벤트가 발생</li><li>채널 파이프라인에 등록된 <code>EchoServerFirstHandler</code>의 <code>channelRead</code> 이벤트 메소드가 수행된다.</li><li>마지막으로 <code>channelReadComplete</code> 이벤트가 발생하고 <code>EchoServerSecondHandler</code>에 구현된 <code>channelReadComplete</code> 이벤트 메소드가 수행된다.</li></ol><ul><li>즉 여러개의 이벤트 핸들러가 등록되어 있을 때 이벤트에 해당하는 이벤트 메소드만 수행된다.  </li></ul><h3 id="만약에-여러개의-핸들러가-같은-이벤트를-처리한다면"><a href="#만약에-여러개의-핸들러가-같은-이벤트를-처리한다면" class="headerlink" title="만약에 여러개의 핸들러가 같은 이벤트를 처리한다면 ?"></a>만약에 여러개의 핸들러가 같은 이벤트를 처리한다면 ?</h3><ul><li>EchoServerSecondHandler 수정</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> channelRead(ChannelHandlerContext ctx, Object msg)&#123;</span><br><span class="line">  ByteBuf readMessage = (ByteBuf) msg;</span><br><span class="line">  System.out.println(<span class="string">"SecondHandler channelRead:"</span></span><br><span class="line">    +readMessage.toString(Charset.defaultCharset()));</span><br><span class="line">    <span class="comment">// channelRead 이벤트 메소드를 추가</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EchoServerSecondHandler에 EchoServerFirstHandler와 같은 이벤트 메소드인 <code>channelRead</code>를 구현해본 뒤 실행하면 두번째 이벤트 핸들러는 실행되지 않는다. 왜냐하면 이벤트에 해당하는 이벤트 메소드가 첫번째 핸들러에서 수행되면서 이벤트가 사라졌기 때문. 즉 하나의 이벤트는 하나의 이벤트 메소드만 수행한다.</p><h3 id="만약에-두번째-이벤트-핸들러의-channelRead-메소드도-수행하고-싶다면"><a href="#만약에-두번째-이벤트-핸들러의-channelRead-메소드도-수행하고-싶다면" class="headerlink" title="만약에 두번째 이벤트 핸들러의 channelRead 메소드도 수행하고 싶다면 ?"></a>만약에 두번째 이벤트 핸들러의 channelRead 메소드도 수행하고 싶다면 ?</h3><ul><li>EchoServerFirstHandler 수정</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> channelRead(ChannelHandlerContext ctx, Object msg)&#123;</span><br><span class="line">  ByteBuf readMessage = (ByteBuf) msg;</span><br><span class="line">  System.out.println(<span class="string">"channelRead:"</span>+readMessage.toString(Charset.defaultCharset()));</span><br><span class="line">  ctx.write(msg);</span><br><span class="line">  ctx.fireChannelRead(msg); <span class="comment">// 이 부분을 추가한다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>다음 이벤트 핸들러로 이벤트를 넘겨주기 위해서 <code>ChannelHandlerContext</code>인터페이스를 사용해서 <code>fireChannelRead</code> 메소드를 이용하였다. 이는 채널 파이프라인에 이벤트를 발생시킨다.</p><hr><ul><li>참고 서적<ul><li>네티 인 액션</li><li>자바 네트워크 소녀 네티  </li></ul></li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Netty의 &lt;code&gt;ChannelPipeline&lt;/code&gt;은 &lt;code&gt;Channel&lt;/code&gt;에서 발생한 &lt;code&gt;이벤트&lt;/code&gt;가 이동하는 통로이다. 이 통로를 통해 이동하는 이벤트를 처리하는 클래스가 &lt;code&gt;이벤트 핸들러&lt;/
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/categories/server/netty/"/>
    
    
      <category term="Network" scheme="https://kodakyung.github.io/tags/network/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty의 데이터 컨테이너(ByteBuf)</title>
    <link href="https://kodakyung.github.io/2018/05/23/server-netty-2018-05-23-netty-datacontainer-bytebuf/"/>
    <id>https://kodakyung.github.io/2018/05/23/server-netty-2018-05-23-netty-datacontainer-bytebuf/</id>
    <published>2018-05-22T15:00:00.000Z</published>
    <updated>2020-03-19T01:11:35.332Z</updated>
    
    <content type="html"><![CDATA[<p>네트워크 데이터의 기본 단위는 항상 바이트다. Java의 ByteBuffer보다 사용하기 쉬운 Netty의 데이터 컨테이너 <code>ByteBuf</code>에 대해 알아보자.  </p><br><h2 id="Java-NIO-ByteBuffer"><a href="#Java-NIO-ByteBuffer" class="headerlink" title="Java NIO ByteBuffer"></a>Java NIO ByteBuffer</h2><p>자바 NIO 바이트 버퍼는 바이트 데이터를 저장하고 읽는 저장소다. 배열을 멤버 변수로 가지고 배열에 대한 읽고 쓰기 메소드를 제공한다. <code>xxxBuffer</code> 형태의 각 데이터별로 버퍼를 제공한다. ByteBuffer는 <code>capacity</code> / <code>position</code> / <code>limit</code> 세가지 속성을 가진다.</p><ul><li><strong>capacity</strong> : 버퍼에 저장할 수 있는 데이터의 최대 크기. 한번 정하면 바꿀 수 없다. 버퍼를 생성할 때 생성자의 인수로 입력된 값이다.</li><li><strong>position</strong> : 읽기 또는 쓰기 작업 중인 위치를 나타낸다. 버퍼 객체가 생성되면 0으로 초기화되고 쓰기(<code>put</code>) 또는 읽기(<code>get</code>) 작업이 수행되면 자동으로 증가한다.</li><li><strong>limit</strong> : 읽고 쓸 수 있는 버퍼 공간의 최대치. <code>limit</code> 메소드로 값을 조절할 수 있지만 <code>capacity</code>보다 크게 설정할 수 없다.</li></ul><br><h2 id="Java-ByteBuffer-생성-및-종류"><a href="#Java-ByteBuffer-생성-및-종류" class="headerlink" title="Java ByteBuffer 생성 및 종류"></a>Java ByteBuffer 생성 및 종류</h2><p>자바의 ByteBuffer는 생성자가 아닌 추상 클래스의 메소드를 통해 생성한다. 아래의 메소드를 이용한다.</p><ul><li><p><strong>allocate</strong> : JVM 힙 영역에 바이트 버퍼를 생성. 이를 보통 <code>힙 버퍼</code>라고 한다. 인수는 앞에서 설명한 <code>capacity</code> 값에 해당하는 버퍼의 크기이다. 바이트 버퍼의 값은 모두 0으로 초기화된다. 힙 버퍼는 풀링이 사용되지 않는 경우 빠른 할당과 해제 속도를 보여준다.</p></li><li><p><strong>allocateDirect</strong> : JVM 힙 영역이 아닌 OS의 커널 영역에 바이트 버퍼를 생성한다. 이를 <code>다이렉트 버퍼</code>라고 한다. <code>allocateDirect</code> 메소드는 <code>ByteBuffer</code> 추상 클래스만 사용할 수 있다. 즉 <code>Direct Buffer</code>는 <code>ByteBuffer</code>로만 생성할 수 있다. 다이렉트 버퍼는 힙 버퍼에 비해 생성 시간은 길지만 더 빠른 IO 성능을 제공한다.</p><p>전송할 데이터가 힙에 할당된 버퍼에 있는 경우 JVM은 소켓을 통해 데이터를 전송하기 전에 내부적으로 버퍼를 다이렉트 버퍼로 복사한다. 다이렉트 버퍼를 사용하면 이런 오버헤드를 줄일 수 있다. 하지만 다이렉트 버퍼의 데이터에 접근하려면 복사본을 만들어야 접근할 수 있다는 단점이 있다.</p></li><li><p><strong>wrap</strong> : 입력된 바이트 배열을 이용해 바이트 버퍼를 생성한다. 입력에 사용된 바이트 배열이 변경되면 wrap을 사용해 생성한 바이트 배열의 값도 변경된다.</p></li></ul><br><h2 id="그외-Java-NIO-ByteBuffer의-특징"><a href="#그외-Java-NIO-ByteBuffer의-특징" class="headerlink" title="그외 Java NIO ByteBuffer의 특징"></a>그외 Java NIO ByteBuffer의 특징</h2><ul><li>Java ByteBuffer는 읽기 / 쓰기 작업시 같은 <code>position</code>의 값이 바뀐다. 읽기 / 쓰기 인덱스가 분리되어 있지 않아서 작업 전환시 <code>flip()</code> 메소드를 사용해야한다. 그리고 다중 스레드 환경에서 바이트 버퍼를 공유하지 않아야한다.</li></ul><br><h1 id="Netty-Architecture-Overview"><a href="#Netty-Architecture-Overview" class="headerlink" title="Netty Architecture Overview"></a>Netty Architecture Overview</h1><img alt="Netty Architecture" src="/images/2018-05-23/01.png"><br><h2 id="Netty-ByteBuf-특징"><a href="#Netty-ByteBuf-특징" class="headerlink" title="Netty ByteBuf 특징"></a>Netty ByteBuf 특징</h2><img width="686" alt="Netty ByteBuf" src="/images/2018-05-23/02.png"><ul><li>별도의 <code>Read Index</code> / <code>Write Index</code>가 있다.</li><li>위의 이유로 <code>flip()</code> 메소드를 사용하지 않아도 된다.</li><li>가변 바이트 버퍼를 사용할 수 있다.</li><li>바이트 버퍼 풀 기능을 제공한다.</li><li>복합 버퍼 사용이 가능하다.(<code>Heap</code> + <code>Direct</code>)</li><li>Java의 ByteBuffer와 Netty의 ByteBuf의 상호 변환이 가능하다.</li></ul><br><h2 id="Netty의-ByteBuf-생성"><a href="#Netty의-ByteBuf-생성" class="headerlink" title="Netty의 ByteBuf 생성"></a>Netty의 ByteBuf 생성</h2><p>네티의 바이트 버퍼는 자바의 바이트 버퍼와 다르게 프레임워크 레벨의 바이트 버퍼 풀을 제공하고 이를 통해 생성된 바이트 버퍼를 재사용한다. Netty의 바이트 버퍼를 바이트 버퍼 풀에 할당하려면 <code>ByteBufAllocator</code> 인터페이스를 사용한다. <code>ByteBufAllocator</code>의 하위 추상 구현체인 <code>PooledByteBufAllocator</code> 클래스로 각 바이트 버퍼를 생성한다.</p><br><h2 id="Pooled-Unpooled-ByteBuf"><a href="#Pooled-Unpooled-ByteBuf" class="headerlink" title="Pooled / Unpooled ByteBuf"></a>Pooled / Unpooled ByteBuf</h2><p>자바의 바이트 버퍼는 데이터 형에 따른 ByteBuffer 생성을 지원했지만 네티는 풀링 여부로 ByteBuf를 구분한다. <code>Unpooled</code> 클래스와 <code>PooledByteBufAllocator</code> 사용해 생성하고 다이렉트 버퍼와 힙 버퍼를 생성하기 위해 <code>directBuffer</code> 메소드와 <code>heapBuffer</code> 메소드를 사용한다.</p><table><thead><tr><th>ByteBuf 종류</th><th>풀링 함</th><th>풀링 안 함</th></tr></thead><tbody><tr><td>힙 버퍼</td><td>PooledHeapByteBuf</td><td>UnpooledHeapByteBuf</td></tr><tr><td>다이렉트 버퍼</td><td>PooledDirectByteBuf</td><td>UnpooledDirectByteBuf</td></tr></tbody></table><p><code>PooledByteBufAllocator</code>는 <code>ByteBuf</code> 인스턴스를 풀링해 성능을 개선하고 메모리 단편화를 최소화한다. <code>UnpooledByteBufAllocator</code>는 <code>ByteBuf</code> 인스턴스를 풀링하지 않고 호출될 때마다 새로운 인스턴스를 반환한다.</p><table><thead><tr><th>생성 방법</th><th>풀링 함</th><th>풀링 안 함</th></tr></thead><tbody><tr><td>힙 버퍼</td><td>ByteBufAllocator.DEFAULT.heapBuffer()</td><td>Unpooled.buffer()</td></tr><tr><td>다이렉트 버퍼</td><td>ByteBufAllocator.DEFAULT.directBuffer()</td><td>Unpooled.directBuffer()</td></tr></tbody></table><ul><li><strong>ByteBuf 생성 예</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = Unpooled.buffer(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 바이트 버퍼 풀을 사용하지 않는 11바이트 크기의 힙 버퍼 생성</span></span><br><span class="line">ByteBuf buf = Unpooled.directBuffer(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 바이트 버퍼 풀을 사용하지 않는 11바이트 크기의 다이렉트 버퍼를 생성</span></span><br><span class="line">ByteBuf buf = PooledByteBufAllocator.DEFAULT.heapBuffer(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 풀링된 11바이트 크기의 힙 버퍼 생성</span></span><br><span class="line">ByteBuf buf = PooledByteBufAllocator.DEFAULT.directBuffer(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// 풀링된 11바이트 크기의 다이렉트 버퍼 생성</span></span><br></pre></td></tr></table></figure><p>크기를 지정하지 않으면 Netty에 지정된 기본 값인 256바이트 크기의 바이트 버퍼가 생성된다.</p><br><h2 id="Read-Write"><a href="#Read-Write" class="headerlink" title="Read / Write"></a>Read / Write</h2><p>ByteBuf의 읽을 수 있는 바이트 세그먼트에 실제 데이터가 저장된다. 이때 새로 할당, 래핑, 복사된 버퍼에서 <code>readerIndex</code>의 기본값은 0이다. read나 skip으로 시작하는 모든 메소드는 현재 <code>readerIndex</code> 위치에 있는 데이터를 읽거나 건너 뛰고 읽은 바이트 수 만큼 <code>readerIndex</code>를 증가시킨다.</p><p>ByteBuf의 기록할 수 있는 바이트 세그먼트는 정의되지 않은 내용이 들어 있고 기록할 수 있는 영역이다. 새로 할당된 버퍼의 <code>writerIndex</code> 기본값은 0이고 write로 시작하는 모든 메소드는 현재 <code>writerIndex</code> 위치부터 데이터를 기록하고 기록한 만큼 <code>writerIndex</code>를 증가시킨다.</p><table><thead><tr><th align="left">readBytes(ByteBuf dest)</th><th align="left">인수의 ByteBuf만큼 읽는다</th></tr></thead><tbody><tr><td align="left">writeBytes(ByteBuf dest)</td><td align="left">인수의 ByteBuf만큼 쓴다.</td></tr></tbody></table><ul><li><p>모든 데이터 읽기</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buffer = ...;</span><br><span class="line"><span class="keyword">while</span>(buffer.isReadable())&#123;</span><br><span class="line">  System.out.println(buffer.readByte());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>데이터 기록</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 버퍼의 기록할 수 있는 바이트를 임의의 정수로 채움</span></span><br><span class="line">ByteBuf buffer = ...;</span><br><span class="line"><span class="keyword">while</span>(buffer.writableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">  buffer.writeInt(random.nextInt());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="읽기-쓰기-작업"><a href="#읽기-쓰기-작업" class="headerlink" title="읽기 / 쓰기 작업"></a>읽기 / 쓰기 작업</h3><p>Netty ByteBuf의 읽기, 쓰기 작업은 두가지로 나뉜다.</p><ul><li><code>get()</code>, <code>set()</code> 작업은 저장한 인덱스에서 시작하고 인덱스를 변경하지 않는다.</li><li><code>read()</code>, <code>write()</code> 작업은 지정한 인덱스에서 시작하고 접근한 바이트 수만큼 인덱스를 증가시킨다.</li></ul><h4 id="자주-쓰이는-get-작업"><a href="#자주-쓰이는-get-작업" class="headerlink" title="자주 쓰이는 get() 작업"></a>자주 쓰이는 get() 작업</h4><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>getBoolean(int)</td><td>지정한 인덱스의 Boolean 값을 반환</td></tr><tr><td>getByte(int)</td><td>지정한 인덱스의 바이트를 반환</td></tr><tr><td>getUnsignedByte(int)</td><td>지정한 인덱스의 부호 없는 바이트 값을 short로 반환</td></tr><tr><td>getMedium(int)</td><td>지정한 인덱스의 24비트 미디엄 int값을 반환</td></tr><tr><td>getUnsignedMedium(int)</td><td>지정한 인덱스의 부호 없는 24비트 미디엄 int 값을 반환</td></tr><tr><td>getInt(int)</td><td>지정한 인덱스의 int값을 반환</td></tr><tr><td>getUnsignedInt(int)</td><td>지정한 인덱스의 부호 없는 int값을 long으로 반환</td></tr><tr><td>getLong(int)</td><td>지정한 인덱스의 long 값을 반환</td></tr></tbody></table><h4 id="자주-쓰이는-set-작업"><a href="#자주-쓰이는-set-작업" class="headerlink" title="자주 쓰이는 set() 작업"></a>자주 쓰이는 set() 작업</h4><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>setBoolean(int, boolean)</td><td>지정한 인덱스의 Boolean 값을 설정</td></tr><tr><td>setByte(int index, int value)</td><td>지정한 인덱스의 바이트 값을 설정</td></tr><tr><td>setMedium(int index, int value)</td><td>지정한 인덱스의 24비트 미디엄 값을 설정</td></tr><tr><td>setInt(int index, int value)</td><td>지정한 인덱스의 int 값을 설정</td></tr><tr><td>setLong(int index, long value)</td><td>지정한 인덱스의 long 값을 설정</td></tr><tr><td>setShort(int index, int value)</td><td>지정한 인덱스의 short 값을 설정</td></tr></tbody></table><ul><li>get()/set() 예제<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Charset utf8 = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Netty !"</span>, utf8);</span><br><span class="line">System.out.println((<span class="keyword">char</span>)buf.getByte(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// 첫번째 문자 'N' 출력</span></span><br><span class="line"><span class="keyword">int</span> readerIndex = buf.readerIndex();</span><br><span class="line"><span class="keyword">int</span> writerIndex = buf.writerIndex();</span><br><span class="line"><span class="comment">// 현재 인덱스들을 저장</span></span><br><span class="line">buf.setByte(<span class="number">0</span>, (<span class="keyword">byte</span>)<span class="string">'B'</span>);</span><br><span class="line"><span class="comment">// 인덱스 0에 있는 바이트를 문자'B'로 변경</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>)buf.getByte(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// 첫번째 문자 'B'를 출력</span></span><br><span class="line"><span class="keyword">assert</span> readerIndex = buf.readerIndex();</span><br><span class="line"><span class="keyword">assert</span> writerIndex = buf.writerIndex();</span><br><span class="line"><span class="comment">// 인덱스가 바뀌지 않았으므로 성공</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="자주-쓰이는-read-작업"><a href="#자주-쓰이는-read-작업" class="headerlink" title="자주 쓰이는 read() 작업"></a>자주 쓰이는 read() 작업</h4><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>readBoolean()</td><td>현재 readerIndex 위치의 Boolean 값을 반환하고 readerIndex를 1만큼 증가시킨다</td></tr><tr><td>readByte()</td><td>현재 readerIndex 위치의 바이트 값을 반환하고 readerIndex를 1만큼 증가시킨다</td></tr><tr><td>readUnsignedByte()</td><td>현재 readerIndex 위치의 short 값을 반환하고 readerIndex를 1만큼 증가시킨다</td></tr><tr><td>readMedium()</td><td>현재 readerIndex 위치의 24비트 미디엄 값을 반환하고 readerIndex를 3만큼 증가시킨다</td></tr><tr><td>readUnsignedMedium()</td><td>현재 readerIndex 위치의 부호 없는 24비트 미디엄 값을 반환하고 readerIndex를 3만큼 증가시킨다</td></tr><tr><td>readInt()</td><td>현재 readerIndex 위치의 int값을 반환하고 readerIndex를 4만큼 증가시킨다</td></tr><tr><td>readUnsignedInt()</td><td>현재 readerIndex 위치의 부호 없는 int값을 long으로 반환하고 readerIndex를 4만큼 증가시킨다</td></tr><tr><td>readLong()</td><td>현재 readerIndex 위치의 long 값을 반환하고 readerIndex를 8만큼 증가시킨다</td></tr><tr><td>readShort()</td><td>현재 readerIndex 위치의 short 값을 반환하고 readerIndex를 2만큼 증가시킨다</td></tr><tr><td>readUnsignedShort()</td><td>현재 readerIndex 위치의 부호 없는 short값을 int로 반환하고 readerIndex를 2만큼 증가시킨다</td></tr><tr><td>readBytes(ByteBuf | byte[] destination, int dstIndex [,int length])</td><td>현재 ByteBuf의 현재 readerIndex로부터 시작하는 바이트를 (length가 지정된 경우 length 바이트 만큼) 대상 ByteBuf또는 byte[]의 대상 dstIndex로부터 전송한다. 로컬 readerIndex는 전송된 바이트 수만큼 증가한다.</td></tr></tbody></table><h4 id="자주-쓰이는-write-작업"><a href="#자주-쓰이는-write-작업" class="headerlink" title="자주 쓰이는 write() 작업"></a>자주 쓰이는 write() 작업</h4><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>writeBoolean(boolean)</td><td>현재 writerIndex 위치에 Boolean값을 기록하고 writerIndex를 1만큼 증가시킨다</td></tr><tr><td>writeByte(int)</td><td>현재 writerIndex 위치에 바이트 값을 기록하고 writerIndex를 1만큼 증가시킨다</td></tr><tr><td>writeMedium(int)</td><td>현재 writerIndex 위치에 미디엄 값을 기록하고 writerIndex를 3만큼 증가시킨다</td></tr><tr><td>writeInt(int)</td><td>현재 writerIndex 위치에 int 값을 기록하고 writerIndex를 4만큼 증가시킨다</td></tr><tr><td>writeLong(long)</td><td>현재 writerIndex 위치에 long값을 기록하고 writerIndex를 8만큼 증가시킨다</td></tr><tr><td>writeShort(int)</td><td>현재 writerIndex 위치에 short값을 기록하고 writerIndex를 2만큼 증가시킨다</td></tr><tr><td>writeBytes(source ByteBuf | byte[] [, int srcIndex, int length])</td><td>지정된 원본(ByteBuf 또는 byte[])의 현재 writerIndex부터 데이터 전송을 시작한다. srcIndex와 length가 지정된 경우 srcIndex부터 시작해 length 바이트 만큼 읽는다. 현재 writerIndex는 기록된 바이트 수만큼 증가한다</td></tr></tbody></table><ul><li>read()/write() 예제<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Charset utf8 = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Netty !"</span>, utf8);</span><br><span class="line"><span class="comment">// 지정한 문자열의 바이트를 저장하는 ByteBuf 생성</span></span><br><span class="line">System.out.println((<span class="keyword">char</span>)buf.readByte());</span><br><span class="line"><span class="comment">// 첫번째 문자 'N'을 출력</span></span><br><span class="line"><span class="keyword">int</span> readerIndex = buf.readerIndex();</span><br><span class="line"><span class="keyword">int</span> writerIndex = buf.writerIndex();</span><br><span class="line"><span class="comment">// 현재 readerIndex/writerIndex 를 저장</span></span><br><span class="line">buf.writeByte((<span class="keyword">byte</span>)<span class="string">'?'</span>);</span><br><span class="line"><span class="comment">// 버퍼에 '?'를 추가</span></span><br><span class="line"><span class="keyword">assert</span> readerIndex == buf.readerIndex();</span><br><span class="line"><span class="keyword">assert</span> writerIndex != buf.writerIndex();</span><br></pre></td></tr></table></figure></li></ul><h4 id="기타-유용한-메소드"><a href="#기타-유용한-메소드" class="headerlink" title="기타 유용한 메소드"></a>기타 유용한 메소드</h4><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>isReadable()</td><td>읽을 수 있는 바이트가 하나 이상이면 true를 반환</td></tr><tr><td>isWritable()</td><td>기록할 수 있는 바이트가 하나 이상이면 true를 반환</td></tr><tr><td>readableBytes()</td><td>읽을 수 있는 바이트 수를 반환</td></tr><tr><td>writableBytes()</td><td>기록할 수 있는 바이트 수를 반환</td></tr><tr><td>capacity()</td><td>ByteBuf가 저장할 수 있는 바이트 수를 반환한다. 이 수를 초과하면 maxCapacity()에 도달할 때까지 용량이 확장된다.</td></tr><tr><td>maxCapacity()</td><td>ByteBuf가 저장할 수 있는 최대 바이트 수를 반환</td></tr><tr><td>hasArray()</td><td>ByteBuf에 힙 버퍼가 있는 경우 true를 반환</td></tr><tr><td>array()</td><td>ByteBuf에 힙 버퍼가 있는 경우 해당 바이트 배열을 반환하며, 그렇지 않으면 <code>UnsupportedOperationException</code>을 발생시킨다.</td></tr></tbody></table><br><h2 id="ByteBufAllocator"><a href="#ByteBufAllocator" class="headerlink" title="ByteBufAllocator"></a>ByteBufAllocator</h2><p>자바 바이트 버퍼는 언어 자체에서 제공하는 버퍼 풀이 없다. 따라서 바이트 버퍼 풀을 이용하려면 객체 풀링을 제공하는 서드파티 라이브러리를 사용하거나 직접 구현해야한다. 네티는 프레임 워크에서 바이트 버퍼 풀을 제공하고 있으며 다이렉트 버퍼와 힙 버퍼를 모두 풀링할 수 있다. 네티의 바이트 버퍼 풀링은 <code>ByteBufAllocator</code>를 사용해 바이트 버퍼를 생성할 때 자동으로 수행된다.</p><p><code>ByteBufAllocator</code>의 참조는 <code>Channel</code>에서 얻거나 <code>ChannelHandler</code>에 바인딩 된 <code>ChannelHandlerContext</code>를 통해 얻을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">ByteBufAllocator allocator = channel.alloc()</span><br><span class="line"><span class="comment">// Channel에서 ByteBufAllocator를 얻음</span></span><br><span class="line">...</span><br><span class="line">ChannelHandlerContext ctx = ...;</span><br><span class="line">ByteBufAllocator allocator2 = ctx.alloc();</span><br><span class="line"><span class="comment">// ChannelHandlerContext에서 ByteBufAllocator를 얻음</span></span><br><span class="line">...</span><br><span class="line">ByteBuf newBuffer = ByteBufAllocator.buffer();</span><br><span class="line"><span class="comment">// ByteBufAllocator의 buffer 메소드를 사용해 생성된 바이트 버퍼</span></span><br><span class="line"><span class="comment">// 똑같이 ByteBufAllocator에서 관리된다.</span></span><br><span class="line"><span class="comment">// 바이트 버퍼를 채널에 기록하거나 명시적으로 release 호출 시 바이트 버퍼 풀로 돌아간다.</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// new Buffer 사용</span></span><br><span class="line">ctx.write(msg);</span><br><span class="line"><span class="comment">// write 메소드 인수로 바이트 버퍼가 입력되면 데이터를 채널에 기록하고 난 뒤 버퍼 풀로 돌아간다.</span></span><br></pre></td></tr></table></figure><h3 id="풀링되지-않은-버퍼"><a href="#풀링되지-않은-버퍼" class="headerlink" title="풀링되지 않은 버퍼"></a>풀링되지 않은 버퍼</h3><p><code>ByteBufAllocator</code>의 참조가 없는 경우, 네티는 풀링되지 않는 ByteBuf 인스턴스를 생성하는 정적 도우미 메서드 <code>Unpooled</code> 클래스를 제공한다.</p><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>buffer</td><td>풀링되지 않은 힙 기반 ByteBuf 반환</td></tr><tr><td>directBuffer</td><td>풀링되지 않은 다이렉트 ByteBuf 반환</td></tr><tr><td>wrappedBuffer</td><td>지정한 데이터를 래핑하는 ByteBuf 반환</td></tr><tr><td>copiedBuffer</td><td>지정한 데이터를 복사하는 ByteBuf 반환</td></tr></tbody></table><p>Unpooled 클래스는 다른 네티 컴포넌트가 필요 없는 네트워킹과 무관한 프로젝트에 ByteBuf를 제공해 확정성 높은 고성능 버퍼 API를 이용할 수 있게 해준다.</p><h3 id="참조-카운팅"><a href="#참조-카운팅" class="headerlink" title="참조 카운팅"></a>참조 카운팅</h3><p>네티는 바이트 버퍼를 풀링하기 위해 바이트 버퍼에 참조수를 기록한다. <code>ReferenceCountUtil</code> 클래스에 정의된 <code>retain</code> 메소드와 <code>release</code> 메소드를 사용할 수 있다 <code>retain</code> 메소드는 참조 수를 증가시키고 <code>release</code> 메소드는 참조 수를 감소 시키고 할당된 메모리가 해제 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = ...;</span><br><span class="line">ByteBufAllocator allocator = channel.alloc();</span><br><span class="line"><span class="comment">// channel에서 ByteBufAllocator를 얻음</span></span><br><span class="line">....</span><br><span class="line">ByteBuf buffer = allocator.directBuffer();</span><br><span class="line"><span class="comment">// ByteBufAllocator로부터 ByteBuf를 할당</span></span><br><span class="line"><span class="keyword">assert</span> buffer.refCnt() = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 참조 카운트가 1인지 확인</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">boolean</span> released = buffer.release();</span><br><span class="line"><span class="comment">// 객체에 대한 참조 카운트를 감소 시킴</span></span><br><span class="line"><span class="comment">// 참조 카운트가 0이 되면 객체가 해제되고 메소드가 true를 반환한다.</span></span><br></pre></td></tr></table></figure><p>참조 카운트가 0일 때 <code>release()</code>를 호출하면 <code>IllegalReferenceCountException</code>이 발생한다.<br>참조 해제는 각 객체가 새로 정의할 수 있다. 예를 들면 클래스의 <code>release()</code> 구현에서 참조 카운트를 현재 값과 상관 없이 0으로 설정하면 모든 활성 참조를 일시에 해제할 수 있다.</p><br><h2 id="기타-작업"><a href="#기타-작업" class="headerlink" title="기타 작업"></a>기타 작업</h2><h3 id="부호-없는-값-읽기"><a href="#부호-없는-값-읽기" class="headerlink" title="부호 없는 값 읽기"></a>부호 없는 값 읽기</h3><p>자바는 부호 없는 데이터 형이 없어서 네티에서는 부호 없는 데이터를 처리하기 위한 메소드를 제공한다. 네티에서는 부호 없는 데이터를 읽을 때 읽을 데이터보다 큰 데이터 형에 할당한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf = Unpooled.buffer(<span class="number">11</span>);</span><br><span class="line">buf.writeShort(-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 빈 바이트 버퍼에 음수 -1 기록 (2byte)</span></span><br><span class="line"></span><br><span class="line">assertEquals(<span class="number">65535</span>, buf.getUnsignedShort(<span class="number">0</span>));</span><br><span class="line"><span class="comment">// -1은 16진수 표기법으로 0xFFFF이고 이를 부호 없는 정수로 표현하면 65535가 된다.</span></span><br><span class="line"><span class="comment">// 이를 4byte로 저장한다.</span></span><br><span class="line"><span class="comment">// getUnsignedShort 메소드로 바이트 버퍼에 저장된 0번째 바이트부터 2바이트 읽어서</span></span><br><span class="line"><span class="comment">// 4바이트 데이터인 int로 읽어들이면 65535가 된다.</span></span><br></pre></td></tr></table></figure><ul><li>부호 없는 데이터 지원 메소드</li></ul><table><thead><tr><th>메소드</th><th>원본 데이터형</th><th>리턴 데이터형</th></tr></thead><tbody><tr><td>getUnsignedByte</td><td>byte</td><td>short</td></tr><tr><td>getUnsignedShort</td><td>short</td><td>int</td></tr><tr><td>getUnsignedMedium</td><td>medium</td><td>int</td></tr><tr><td>getUnsignedInt</td><td>int</td><td>long</td></tr></tbody></table><h3 id="엔디안-변환"><a href="#엔디안-변환" class="headerlink" title="엔디안 변환"></a>엔디안 변환</h3><p>네티의 바이트 버퍼의 기본 엔디안은 자바와 동일하게 <code>빅엔디안</code>이다. <code>리틀 엔디안</code> 바이트 버퍼가 필요한 경우를 <code>order</code> 메소드로 엔디안을 변환할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = Unpooled.buffer();</span><br><span class="line">...</span><br><span class="line">ByteBuf lettleEndianBuf = buf.order(ByteOrder.LITTLE_ENDIAN);</span><br></pre></td></tr></table></figure><p><code>order</code> 메소드로 생성한 바이트 버퍼는 새로운 바이트 버퍼가 아닌 주어진 바이트 버퍼의 내용을 공유하는 <code>파생 버퍼</code>이다. 기존 바이트 버퍼의 배열과 인덱스들을 공유한다. 즉 내용은 같지만 리틀 엔디안으로 접근하는 바이트 버퍼를 생성한다.</p><hr><ul><li>참고 서적<ul><li>네티 인 액션</li><li>자바 네트워크 소녀 Netty</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;네트워크 데이터의 기본 단위는 항상 바이트다. Java의 ByteBuffer보다 사용하기 쉬운 Netty의 데이터 컨테이너 &lt;code&gt;ByteBuf&lt;/code&gt;에 대해 알아보자.  &lt;/p&gt;
&lt;br&gt;

&lt;h2 id=&quot;Java-NIO-ByteBuff
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/categories/server/netty/"/>
    
    
      <category term="Network" scheme="https://kodakyung.github.io/tags/network/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty Network Transport API</title>
    <link href="https://kodakyung.github.io/2018/05/22/server-netty-2018-05-22-netty-network-transport-api/"/>
    <id>https://kodakyung.github.io/2018/05/22/server-netty-2018-05-22-netty-network-transport-api/</id>
    <published>2018-05-21T15:00:00.000Z</published>
    <updated>2020-03-19T01:11:19.939Z</updated>
    
    <content type="html"><![CDATA[<p>Netty가 기본 제공하는 <code>Network Transport API</code> 구현과 사용법에 대해 알아보자.</p><p>실제 네트워크 프로그래밍을 하다보면 예상보다 많은 동시 접속을 지원해야하는데, 이때 <code>blocking</code> 프로그래밍을 했다면 <code>non-blocking</code>으로 바꿔야하는 상황이 생긴다. 기존 자바를 이용한 네트워크 프로그래밍은 블로킹 전송과 논블로킹 전송의 API 차이가 있어서 변경이 쉽지 않았다. 반면에 네티는 공통 API를 사용하기 때문에 변환이 훨씬 간단하다.  </p><br><h2 id="Netty-OIO-블로킹-전송"><a href="#Netty-OIO-블로킹-전송" class="headerlink" title="Netty OIO 블로킹 전송"></a>Netty OIO 블로킹 전송</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OioServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(</span><br><span class="line">      Unpooled.copiedBuffer(<span class="string">"Hi!\r\n"</span>,</span><br><span class="line">      Charset.forName(<span class="string">"UTF-8"</span>)));</span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> OioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      <span class="comment">// ServerBootstrap 생성</span></span><br><span class="line">      b.group(group).channel(OioServerSocketChannel.class)</span><br><span class="line">      <span class="comment">// OioEventLoopGroup을 이용해 블로킹 모드를 허용함(OIO)</span></span><br><span class="line">        .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">          <span class="comment">// 연결이 수락될 때마다 호출 ChannelIntializer를 지정</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">              <span class="comment">// 이벤트를 가로채고 처리할 ChannelInboundHandlerAdapter를 추가</span></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">              </span>&#123;</span><br><span class="line">                ctx.writeAndFlush(buf.duplicate())</span><br><span class="line">                  .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">                <span class="comment">// 클라이언트로 메세지를 출력하고 ChannelFutureListener를 추가해</span></span><br><span class="line">                <span class="comment">// 메세지가 출력되면 연결을 닫음</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      ChannelFuture f = b.bind().sync();</span><br><span class="line">      <span class="comment">// 서버를 바인딩해 연결을 수락</span></span><br><span class="line">      f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">        <span class="comment">// 모든 리소스를 해제</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://kodakyung.github.io/2018/05/11/old-post-Netty-2018-05-11-Maven%EC%9C%BC%EB%A1%9C-Netty-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/">이전 게시글</a>의 <code>start()</code> 메소드 부분이다.</p><br><h2 id="Netty-NIO-비동기-전송"><a href="#Netty-NIO-비동기-전송" class="headerlink" title="Netty NIO 비동기 전송"></a>Netty NIO 비동기 전송</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Hi!\r\n"</span>, Charset.forName(<span class="string">"UTF-8"</span>));</span><br><span class="line">    EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">    <span class="comment">// 논블로킹 모드를 위해 NioEventLoopGroup을 사용</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      <span class="comment">// ServerBootstrap 생성</span></span><br><span class="line">      b.group(group).channel(NioServerSocketChannel.class)</span><br><span class="line">        .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">          <span class="comment">// 연결이 수락될 때마다 호출 ChannelIntializer를 지정</span></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">              <span class="comment">// 이벤트를 가로채고 처리할 ChannelInboundHandlerAdapter를 추가</span></span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">              </span>&#123;</span><br><span class="line">                ctx.writeAndFlush(buf.duplicate())</span><br><span class="line">                  .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">                <span class="comment">// 클라이언트로 메세지를 출력하고 ChannelFutureListener를 추가해</span></span><br><span class="line">                <span class="comment">// 메세지가 출력되면 연결을 닫음</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      ChannelFuture f = b.bind().sync();</span><br><span class="line">      <span class="comment">// 서버를 바인딩해 연결을 수락</span></span><br><span class="line">      f.channel().closeFuture().sync();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">        <span class="comment">// 모든 리소스를 해제</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">...</span><br><span class="line">b.group(group).channel(NioServerSocketChannel.class) ...</span><br></pre></td></tr></table></figure><p>위 두줄을 제외하면 NioServer는 OioServer와 흡사하다. Netty는 어떤 방식을 선택해도 모든 Network Transport의 구현에 동일한 API를 사용하므로 전송 형식을 변경해도 코드는 거의 영향을 받지 않는다. <em>즉, 모든 구현이 <code>Channel</code>, <code>ChannelPipeline</code>, <code>ChannelHandler</code> 인터페이스 기준으로 정의된다.</em></p><br><h2 id="Network-Transport-API"><a href="#Network-Transport-API" class="headerlink" title="Network Transport API"></a>Network Transport API</h2><ul><li><code>Channel</code> 인터페이스는 모든 입출력 작업에 이용되는 전송 API의 핵심이다.</li><li>Channel은 <code>Network Socket</code> 또는 <code>read</code>, <code>write</code>, <code>connect</code>, <code>bind</code>와 같은 I/O 작업에 대한 연결고리이다.</li></ul><img width="619" alt="Interface Channel1" src="/images/2018-05-22/01.png"><p>Channel 인터페이스는 <code>AttributeMap</code>과 <code>java.lang.Comparable</code>을 SuperInterface로 둔다. 그리고 하위 인터페이스로 <code>ServerChannel</code>, <code>AbstractChannel</code> 등이 있다. 이는 Channel의 고유한 정렬 순서를 보장하기 위해서이며, AbstractChannel의 <code>compareTo()</code> 메소드로 두 Channel 인스턴스를 비교할 수 있다.</p><img width="612" alt="Interface Channel2" src="/images/2018-05-22/02.png"><p>Channel 인터페이스는 채널의 현재 상태, 채널의 구성 파라미터(<code>ChannelConfig</code>), 채널이 지원하는 I/O작업, I/O 이벤트 및 요청을 처리하는 <code>ChannelPipeline</code>을 제공한다. (<em>자세한 내용은 <a href="http://netty.io/4.0/api/io/netty/channel/Channel.html" target="_blank" rel="noopener">이 곳</a> 참고</em>)</p><p><code>ChannelPipeline</code>은 인바운드와 아웃바운드 데이터와 이벤트에 적용될 <code>ChannelHandler</code> 인스턴스를 포함한다. 이런 <code>ChannelHandler</code>는 애플리케이션의 상태 변경과 데이터 처리를 담당한다.</p><ul><li><strong>ChannelHandler의 일반적인 용도</strong><ul><li>데이터를 다른 포맷으로 변환</li><li>예외 알림 제공</li><li>Channel의 활성화 또는 비활성화에 대한 알림 제공</li><li>Channel을 EventLoop에 등록/해제할 때 알림 제공</li><li>사용자 정의 이벤트에 대해 알림 제공</li></ul></li></ul><p><code>Pipeline</code>은 유닉스 파이프와 같이 <code>Intercepting Filter</code> 구조이며, 여러 명령이 체인으로 연결되고 한 명령의 출력이 다음 명령의 입력이 된다.</p><br><h2 id="Channel의-메소드"><a href="#Channel의-메소드" class="headerlink" title="Channel의 메소드"></a>Channel의 메소드</h2><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>eventLoop</td><td>Channel에 할당된 EventLoop를 반환</td></tr><tr><td>pipeline</td><td>Channel에 할당된 ChannelPipeline을 반환</td></tr><tr><td>isActive</td><td>Channel이 활성 상태일 때 true 반환. 활성의 의미는 기본 전송에 따라 달라진다. 예를 들어 Socket은 원격 피어로 연결되면 활성 상태지만, Datagram 전송은 열리면 활성 상태다.</td></tr><tr><td>localAddress</td><td>로컬 SocketAddress를 반환</td></tr><tr><td>remoteAddress</td><td>원격 SocketAddress를 반환</td></tr><tr><td>write</td><td>데이터를 원격 피어로 출력. 이 때 데이터는 ChannelPipeline으로 전달되고, flush 되기 전까지 큐에 저장된다.</td></tr><tr><td>flush</td><td>기반 전송으로 이전에 출력된 데이터를 flush 한다.</td></tr><tr><td>writeAndFlush</td><td>write()와 flush()를 모두 호출</td></tr></tbody></table><p>Netty가 제공하는 기능들은 소수의 인터페이스를 통해 사용이 가능하기 때문에 코드를 전반적으로 리팩토링하지 않아도 애플리케이션 리팩토링을 쉽게 할 수 있다.</p><br><h2 id="네티가-제공하는-전송"><a href="#네티가-제공하는-전송" class="headerlink" title="네티가 제공하는 전송"></a>네티가 제공하는 전송</h2><p>Netty는 바로 사용할 수 있는 여러 전송을 기본적으로 제공하는데, 이런 전송이 모든 프로토콜을 지원하는 것은 아니다. 따라서 <strong>애플리케이션에서 이용하는 프로토콜과 호환되는 전송을 선택</strong>해야한다.</p><table><thead><tr><th>이름</th><th>패키지</th><th>설명</th></tr></thead><tbody><tr><td>NIO</td><td>io.netty.channel.socket.io</td><td>java.nio.channels 패키지를 기반으로 이용(셀렉터 기반 방식)</td></tr><tr><td>Epoll</td><td>io.netty.channel.epoll</td><td>epoll()과 논블로킹 입출력을 위해 JNI를 이용함. 이 전송은 SO_REUSEPORT와 마찬가지로 리눅스에서만 이용 가능하며, NIO 전송보다 빠르고 완전한 논블로킹.</td></tr><tr><td>OIO</td><td>io.netty.channel.socket.oio</td><td>java.net 패키지를 기반으로 이용(블로킹 스트림 이용)</td></tr><tr><td>로컬(Local)</td><td>io.netty.channel.local</td><td>VM에서 파이프를 통해 통신하는데 이용되는 로컬 전송</td></tr><tr><td>임베디드(Embedded)</td><td>io.netty.channel.embedded</td><td>실제 네트워크 전송 없이 ChannelHandler를 이용할 수 있게 해주는 임베디드 전송. ChannelHandler 구현을 테스트하는데 유용하다.</td></tr></tbody></table><h3 id="NIO-논블로킹-입출력"><a href="#NIO-논블로킹-입출력" class="headerlink" title="NIO 논블로킹 입출력"></a>NIO 논블로킹 입출력</h3><p>NIO는 모든 입출력 작업에서 완전한 비동기 구현을 제공한다. Netty의 NIO는 JDK의 Selector 기반 API를 사용한다.</p><p><code>Selector</code>는 아래와 같은 Channel의 상태가 변경되면 알림을 받을 수 있는 역할을 한다.</p><ul><li>새로운 Channel이 수락되고 준비됨</li><li>Channel 연결이 완료됨</li><li>Channel에 읽을 데이터가 있음</li><li>Channel을 이용해 데이터를 기록할 수 있음</li></ul><p><code>java.nio.channels.SelectionKey</code> 클래스에 정의된 상수 패턴으로 애플리케이션의 상태 변경을 지정할 수 있다.</p><table><thead><tr><th>이름</th><th>설명</th></tr></thead><tbody><tr><td>OP_ACCEPT</td><td>새로운 연결이 수락되고 Channel이 생성되면 알림</td></tr><tr><td>OP_CONNECT</td><td>연결되면 알림</td></tr><tr><td>OP_READ</td><td>Channel에서 데이터를 읽을 수 있으면 알림</td></tr><tr><td>OP_WRITE</td><td>Channel로 데이터를 기록할 수 있으면 알림. 소켓 버퍼가 완전히 차는 상황을 처리한다. 이런 상황은 원격 피어의 능력보다 데이터가 더 자주 전송될 때 흔히 발생함</td></tr></tbody></table><p><strong>NIO의 내부 흐름은 아래와 같다.</strong></p><ol><li>새로운 채널을 셀렉터에 등록</li><li>셀렉터가 상태 변경을 알림(등록)</li><li>셀렉터에는 이전에 등록한 채널들이 존재함</li><li>상태 변경이 수신되거나 제한 시간이 경과할 때까지 <code>Selector.select()</code>가 차단</li><li>상태 변경이 있는지 검사</li><li>상태 변경이 있으면 모든 상태 변경을 처리</li><li>(5)에서 상태 변경이 없거나 (6)이 완료된 후<br>셀렉터가 실행되는 동일한 스레드에서 다른 작업을 실행</li></ol><p>이러한 과정은 Netty의 사용자 수준 API에 숨겨진다.</p><h3 id="Epoll-리눅스용-네이티브-논블로킹-전송"><a href="#Epoll-리눅스용-네이티브-논블로킹-전송" class="headerlink" title="Epoll 리눅스용 네이티브 논블로킹 전송"></a>Epoll 리눅스용 네이티브 논블로킹 전송</h3><p>고성능 네트워킹 플랫폼으로써 성능 향상을 위해 리눅스 기반의 Epoll API가 발전하였다. 고부하 조건에서 JDK의 NIO구현보다 성능이 훨씬 우수하다. 사용법은 NIO 대신 epoll로 바꾸면 된다.</p><ul><li>제로 카피(Zero-copy)  </li></ul><blockquote><p>제로 카피는 NIO와 Epoll 전송에서만 이용가능한 기능이다. 파일 시스템의 데이터를 커널 공간에서 사용자 공간으로 복사하는 과정을 생략해 빠르고 효과적으로 네트워크로 이동할 수 있게 해준다. 모든 운영체제에서 이 기능을 지원하는 것은 아니다.</p></blockquote><h3 id="OIO-기존-블로킹-입출력"><a href="#OIO-기존-블로킹-입출력" class="headerlink" title="OIO 기존 블로킹 입출력"></a>OIO 기존 블로킹 입출력</h3><p>Netty의 OIO는 <code>java.net</code>의 블로킹 구현에 기반을 두어서 비동기 방식은 아니지만 블로킹 방식의 레거시 코드를 이식해야하는 경우 쓰인다. 우선 Netty의 OIO 전송을 이용하고 다음에 NIO 전송으로 바꿀 수 있다.</p><br><h2 id="로컬-전송"><a href="#로컬-전송" class="headerlink" title="로컬 전송"></a>로컬 전송</h2><p>Netty는 동일한 JVM 내에서 실행되는 클라이언트와 서버간 비동기 통신을 위한 로컬 전송을 제공한다.<br>이 전송에서 <code>서버 Channel</code>과 연결되는 <code>SocketAddress</code>는 실제 네트워크 주소에 바인딩되지 않고 서버가 실행되는 동안 레지스트리에 저장되고, Channel이 닫히면 레지스트리에서 등록이 해제된다.</p><br><h2 id="임베디드-전송-ChannelHandler-테스트"><a href="#임베디드-전송-ChannelHandler-테스트" class="headerlink" title="임베디드 전송(ChannelHandler 테스트)"></a>임베디드 전송(ChannelHandler 테스트)</h2><p>Netty는 <code>ChannelHandler</code>를 다른 ChannelHandler 안에 도우미 클래스로 넣을 수 있는 임베디드 전송을 제공한다. 이 방식을 이용하면 내부 코드를 수정하지 않고 ChannelHandler의 기능을 확장할 수 있다. 이 기능을 통해 단위 테스트를 진행할 수 있다.</p><br><hr><h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><ul><li><a href="https://homoefficio.github.io/2016/08/06/Java-NIO는-생각만큼-non-blocking-하지-않다/" target="_blank" rel="noopener">Java NIO는 생각만큼 non-blocking 하지 않다</a></li><li><a href="http://jakarta.tistory.com/91" target="_blank" rel="noopener">왜 Java NIO는 사용하기 힘든가?</a></li></ul><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Netty가 기본 제공하는 &lt;code&gt;Network Transport API&lt;/code&gt; 구현과 사용법에 대해 알아보자.&lt;/p&gt;
&lt;p&gt;실제 네트워크 프로그래밍을 하다보면 예상보다 많은 동시 접속을 지원해야하는데, 이때 &lt;code&gt;blocking&lt;
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/categories/server/netty/"/>
    
    
      <category term="Network" scheme="https://kodakyung.github.io/tags/network/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty 컴포넌트(Component)</title>
    <link href="https://kodakyung.github.io/2018/05/21/server-netty-2018-05-21-netty-component/"/>
    <id>https://kodakyung.github.io/2018/05/21/server-netty-2018-05-21-netty-component/</id>
    <published>2018-05-20T15:00:00.000Z</published>
    <updated>2020-03-19T01:11:04.400Z</updated>
    
    <content type="html"><![CDATA[<p>Netty의 Component <code>Channel</code>, <code>EventLoop</code>, <code>ChannelFuture</code>, <code>ChannelHandler</code>, <code>ChannelPipeline</code>, <code>Bootstrap</code>에 대해 알아보자.  </p><br><h3 id="Q-컴포넌트-Component-란"><a href="#Q-컴포넌트-Component-란" class="headerlink" title="Q 컴포넌트(Component)란?"></a>Q 컴포넌트(Component)란?</h3><blockquote><p>독립적인 소프트웨어 모듈을 의미하며,<br>  간단히 말하면 유저가 사용하는 시스템에 대한 조작 장치를 의미한다.</p></blockquote><br><h1 id="Netty-Architecture-Overview"><a href="#Netty-Architecture-Overview" class="headerlink" title="Netty Architecture Overview"></a>Netty Architecture Overview</h1><img width="573" alt="Netty Architecture" src="/images/2018-05-21/01.png"><p>위 다이어그램의 <strong>Extensible Event Model / Universal Communication API</strong> 에 해당하는 Netty Component를 알아보자.</p><br><h1 id="Channel-EventLoop-ChannelFuture"><a href="#Channel-EventLoop-ChannelFuture" class="headerlink" title="Channel / EventLoop / ChannelFuture"></a>Channel / EventLoop / ChannelFuture</h1><p>: Netty의 네트워킹 추상화를 담당한 컴포넌트</p><h2 id="Channel-인터페이스"><a href="#Channel-인터페이스" class="headerlink" title="Channel 인터페이스"></a>Channel 인터페이스</h2><p><code>Channel</code>은 간단히 말하면 <strong>소켓(Socket)을 컨트롤</strong> 하는 인터페이스. 자바 기반 네트워크는 기본적으로 <code>Socket</code> 클래스를 사용한다. 기본 입출력 작업인 <code>bind()</code>, <code>connect()</code>, <code>read()</code>, <code>write()</code>는 자바의 기본형을 이용하지만 Netty의 API를 통해 덜 복잡하게 작업할 수 있다. <code>Channel</code>은 Netty의 비동기 I/O 인터페이스이다. 그 외에도 <code>Channel</code>은 다수의 미리 정의된 특수한 구현을 포함한 광범위한 클래스 계층의 루트이다.</p><ul><li><code>EmbeddedChannel</code></li><li><code>LocalServerChannel</code></li><li><code>NioDatagramChannel</code></li><li><code>NioSctpChannel</code></li><li><code>NioSocketChannel</code></li><li>…</li></ul><h2 id="EventLoop-인터페이스"><a href="#EventLoop-인터페이스" class="headerlink" title="EventLoop 인터페이스"></a>EventLoop 인터페이스</h2><p>제어 흐름, 멀티스레딩, 동시성 제어를 담당한 인터페이스. <strong>연결의 수명주기 중 발생하는 이벤트를 처리</strong> 하는 Netty의 핵심 추상화이다. <code>EventLoop</code>, <code>Thread</code>, <code>EventLoopGroup</code>의 관계는 다음과 같다.  </p><ul><li>한 <code>EventLoopGroup</code>은 하나 이상의 <code>EventLoop</code>를 포함한다.</li><li>한 <code>EventLoop</code>는 수명주기 동안 한 <code>Thread</code>로 바인딩된다.</li><li>한 <code>EventLoop</code>에서 처리되는 모든 입출력 이벤트는 전용 <code>Thread</code>에서 처리한다.</li><li>한 <code>Channel</code>은 수명주기 동안 한 <code>EventLoop</code>에 등록할 수 있다.</li><li>한 <code>EventLoop</code>를 하나 이상의 <code>Channel</code>로 할당할 수 있다.</li></ul><img alt="Netty Eventloop" src="/images/2018-05-21/02.jpeg"><h2 id="ChannelFuture-인터페이스"><a href="#ChannelFuture-인터페이스" class="headerlink" title="ChannelFuture 인터페이스"></a>ChannelFuture 인터페이스</h2><p><strong>비동기 알림</strong>을 담당하는 인터페이스. Netty는 모든 입출력 작업이 비동기적이다. 즉 작업이 바로 반환되지 않아서 나중에 결과를 확인하는 방법이 필요하다. <code>ChannelFuture</code>의 <code>addListener()</code>는 작업이 완료되면 알림을 받을 <code>ChannelFutureListener</code>를 하나 등록한다.</p><br><h1 id="ChannelHandler-ChannelPipeline"><a href="#ChannelHandler-ChannelPipeline" class="headerlink" title="ChannelHandler / ChannelPipeline"></a>ChannelHandler / ChannelPipeline</h1><p>: 데이터 흐름을 관리하고 애플리케이션 처리 논리를 실행하는 컴포넌트.</p><h2 id="ChannelHandler-인터페이스"><a href="#ChannelHandler-인터페이스" class="headerlink" title="ChannelHandler 인터페이스"></a>ChannelHandler 인터페이스</h2><p>인바운드와 아웃바운드 데이터의 처리에 적용되는 모든 애플리케이션 논리의 <strong>컨테이너</strong> 역할을 담당. <code>ChannelHandler</code>의 메소드는 네트워크 이벤트(광범위한 의미)에 의해 트리거되는데, 그때 <em>거의 모든 종류의 작업</em> 에 활용할 수 있다. <code>ChannelPipeline</code>을 통해 오가는 이벤트(데이터 포함)를 처리하는 모든 코드를 위한 범용 컨테이너이다. <a href="https://koda93.github.io/Maven으로-Netty-프로젝트-시작하기/" target="_blank" rel="noopener">이전 게시글</a>에서 사용한 <code>ChannelInboundHandler</code>는 <code>ChannelHandler</code>로부터 파생된 것이다.</p><h2 id="ChannelPipeline-인터페이스"><a href="#ChannelPipeline-인터페이스" class="headerlink" title="ChannelPipeline 인터페이스"></a>ChannelPipeline 인터페이스</h2><p><code>ChannelHandler</code> 체인을 위한 컨테이너를 제공하며, 체인 상에서 인바운드와 아웃바운드 이벤트를 전파하는 API를 정의한다. <code>Channel</code>이 생성되면 여기에 자동으로 자체적인 <code>ChannelPipeline</code>이 할당된다. <code>ChannelHandler</code>는 <code>ChannelPipeline</code> 안에 설치된다.</p><ul><li><code>ChannelInitializer</code> 구현은 <code>ServerBootstrap</code>에 등록된다.</li><li><code>ChannelInitializer.initChannel()</code>이 호출되면 <code>ChannelInitializer</code>가 <code>ChannelHandler</code>의 커스텀 집합을 파이프라인에 설치한다.</li><li><code>ChannelInitializer</code>는 <code>ChannelPipeline</code>에서 자신을 제거한다.</li></ul><p>파이프라인을 통해 이벤트를 이동하는 역할은 애플리케이션의 부트스트랩 단계나 초기화 중에 설치된 <code>ChannelHandler</code>가 담당한다. <code>ChannelHandler</code>들은 이벤트를 수신하고, 구현된 처리 논리를 실행하고 체인 상의 다음 핸들러로 데이터를 전달한다. 실행되는 순서는 추가된 순서에 의해 결정된다.</p><img alt="Netty pipline" src="/images/2018-05-21/03.jpeg"><p>인바운드와 아웃바운드 핸들러를 동일한 파이프라인에 설치할 수 있으며, 메세지나 다른 인바운드 이벤트를 읽을 때 파이프라인 앞쪽부터 시작해 첫번째 <code>ChannelInboundHandler</code>로 전달된다. 데이터를 처리한 후 체인 상의 다음 <code>ChannelInboundHandler</code>로 데이터를 전달한다. 최종적으로 데이터가 파이프라인의 뒤쪽에 도착하면 모든 처리가 종료된다. 아웃바운드의 경우도 동일하고, 데이터가 네트워크 전송에 도달하면 끝난다.</p><h2 id="ChannelHandler의-하위-클래스"><a href="#ChannelHandler의-하위-클래스" class="headerlink" title="ChannelHandler의 하위 클래스"></a>ChannelHandler의 하위 클래스</h2><p><code>ChannelHandler</code>는 다양한 작업에 사용되기 때문에 종류가 많으며, 각 기능은 상위 클래스가 무엇이냐에 따라 달려있다. Netty는 어댑터 클래스 형태로 여러 기본 핸들러 구현을 제공한다. 이러한 <em>어댑터 클래스 및 해당 상위 클래스가 기본적인 작업을 자동</em>으로 해주므로 <em>특수한 동작이 필요한 메소드와 이벤트만 재정의</em>해서 사용하면된다. 이런식으로 <code>커스텀 ChannelHandler</code>를 쉽게 작성할 수 있다.</p><ul><li>커스텀 ChannelHandler를 만들 때 자주 사용할 어댑터 클래스<ul><li><code>ChannelHandlerAdapter</code></li><li><code>ChannelInboundHandlerAdapter</code></li><li><code>ChannelOutboundHandlerAdapter</code></li><li><code>ChannelDuplexHandlerAdapter</code></li></ul></li></ul><h3 id="Encoder-Decoder"><a href="#Encoder-Decoder" class="headerlink" title="Encoder / Decoder"></a>Encoder / Decoder</h3><p>네트워크 데이터는 반드시 연속된 바이트 형태여야 하기 때문에 네트워크로 데이터를 송신/수신하는 경우 데이터를 변환해야한다. 인바운드 메세지는 바이트에서 다른 포맷(보통 자바 객체)으로 변환되는 디코딩을 거치며, 아웃바운드 메세지는 반대로 현재 포맷에서 바이트로 인코딩 된다.</p><p>Netty가 제공하는 모든 인코더/디코더 어댑터 클래스는 <code>ChannelInboundHandler</code>나 <code>ChannelInboundHandler</code>를 <code>implements</code> 한다. 인바운드 데이터의 경우 인바운드 <code>Channel</code>에서 읽는 각 메세지에 대해 호출되는 <code>channelRead</code> 메소드/이벤트를 재정의하고, 이 메소드는 제공된 디코더의 <code>decode()</code> 메소드를 호출한 뒤 디코딩된 바이트를 파이프라인의 다음 <code>ChannelInboundHandler</code>로 전달한다. 아웃바인드 데이터는 반대이다.</p><br><h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><p>: Netty의 <code>Bootstrap</code> 클래스는 애플리케이션의 <strong>네트워크 레이어를 구성하는 컨테이너</strong>이다. 프로세스를 지정한 포트로 바인딩하거나 프로세스를 지정된 호스트의 지정된 포트에서 실행 중인 다른 호스트로 연결하는 등의 일을 한다.</p><p><code>Bootstrap</code>은 클라이언트용(<code>Bootstrap</code>)과 서버용(<code>ServerBootstrap</code>) 두가지가 있다. 애플리케이션이 사용하는 프로토콜, 데이터 처리 유형과는 상관없이 수행하는 기능에 따라 어떤 클래스를 사용할지 결정한다.</p><table><thead><tr><th align="center">범주</th><th align="center">Bootstrap</th><th align="center">ServerBootstrap</th></tr></thead><tbody><tr><td align="center">네트워크 기능</td><td align="center">원격 호스트와 포트로 연결</td><td align="center">로컬 포트로 바인딩</td></tr><tr><td align="center">EventLoopGroup의 수</td><td align="center">1</td><td align="center">2</td></tr></tbody></table><p>서버는 연결 요청을 수신해야 하므로 포트로 바인딩하는 <code>ServerBootstrap</code>을 이용하지만, 클라이언트는 원격 피어로 연결해야 하므로 <code>Bootstrap</code>을 이용한다.</p><p>서버를 부트스트랩할 때는 <code>EventLoopGroup</code>이 두개 필요하다. 하나는 서버의 수신 소켓을 나타내는 <code>ServerChannel</code>이 포함되어있다. 두번째는 서버가 수락한 연결마다 하나씩 들어오는 클라이언트 연결을 처리하기 위해 생성된 모든 <code>Channel</code>을 포함한다.</p><p><code>ServerChannel</code>과 연결된 <code>EventLoopGroup</code>은 들어오는 연결 요청에 대해 <code>Channel</code>을 생성해 <code>EventLoop</code>에 하나 할당한다. 연결이 수락되면 두 번째 <code>EventLoopGroup</code>이 해당 <code>Channel</code>에 <code>EventLoop</code>를 할당한다.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Netty의 Component &lt;code&gt;Channel&lt;/code&gt;, &lt;code&gt;EventLoop&lt;/code&gt;, &lt;code&gt;ChannelFuture&lt;/code&gt;, &lt;code&gt;ChannelHandler&lt;/code&gt;, &lt;code&gt;ChannelPipe
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/categories/server/netty/"/>
    
    
      <category term="Network" scheme="https://kodakyung.github.io/tags/network/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC - Neither BindingResult nor plain target object for bean name.. Error</title>
    <link href="https://kodakyung.github.io/2018/05/20/troubleshooting-2018-05-20-springmvc-neither-bindingresult-nor-plain-target-object-for-bean-name-error/"/>
    <id>https://kodakyung.github.io/2018/05/20/troubleshooting-2018-05-20-springmvc-neither-bindingresult-nor-plain-target-object-for-bean-name-error/</id>
    <published>2018-05-19T15:00:00.000Z</published>
    <updated>2020-03-19T01:36:40.953Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Neither BindingResult nor plain target object for bean name ‘command’ available as request attribute …</p></blockquote><p>commandName을 지정한 객체와 연결이 안되서 나오는 에러. 객체와 연결이 되었는데 에러가 발생하는 경우 오타 여부를 확인 해보자.  </p><br><ul><li><strong>Controller 부분</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">CommandName commandName = <span class="keyword">new</span> CommandName();</span><br><span class="line">model.addAttribute(<span class="string">"commandName"</span>, commandName); <span class="comment">// 객체 정보 넘겨줌</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><br><br>나같은 경우 view에서 form 태그의 attribute를 받는 부분에서 오타가 있어서 에러가 발생했다.<ul><li><strong>View 부분</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;form:form method=<span class="string">"post"</span> modelAttribute=<span class="string">"commandName"</span>&gt;</span><br><span class="line"><span class="comment">// 객체 정보 받아옴</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Neither BindingResult nor plain target object for bean name ‘command’ available as request attribute …&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/categories/troubleshooting/"/>
    
    
      <category term="Spring" scheme="https://kodakyung.github.io/tags/spring/"/>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/tags/troubleshooting/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC - Server 강제 종료 후 실행 오류(for Mac)</title>
    <link href="https://kodakyung.github.io/2018/05/19/troubleshooting-2018-05-19-springmvc-server-shutdown-and-execution-error-for-mac/"/>
    <id>https://kodakyung.github.io/2018/05/19/troubleshooting-2018-05-19-springmvc-server-shutdown-and-execution-error-for-mac/</id>
    <published>2018-05-18T15:00:00.000Z</published>
    <updated>2020-03-19T01:36:02.119Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>‘Starting Tomcat v9.0 Server at localhost’ has encountered a problem.<br>Port 8080 required by Tomcat v9.0 Server at localhost is already in use. …</p></blockquote><img width="363" alt="에러 메세지" src="/images/2018-05-19/01.png"><br>Spring 서버가 비정상 종료 된 후 해당 에러가 발생하는 경우, was 재시작을 위한 port가 이미 사용 중이어서 실행을 할 수 없다.<br>따라서 port를 사용하고 있는 PID를 확인한 뒤 종료해주고 서버를 재시작하면 된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo lsof -i -P | grep -i &quot;listen&quot;</span><br><span class="line">sudo lsof -i :`port_number`</span><br></pre></td></tr></table></figure><br><ul><li>listen 중인 프로세스 확인</li></ul><img width="994" alt="listen 중인 프로세스" src="/images/2018-05-19/02.png"><br><ul><li>포트 번호로 실행중인 프로세스 확인</li></ul><img width="994" alt="port 번호로 프로세스 확인" src="/images/2018-05-19/03.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo kill -15 &quot;PID&quot;</span><br></pre></td></tr></table></figure><p>해당 명령어를 입력해주면 프로세스가 종료된다. 이후 서버를 재시작하자.</p><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;‘Starting Tomcat v9.0 Server at localhost’ has encountered a problem.&lt;br&gt;Port 8080 required by Tomcat v9.0 Server at localho
      
    
    </summary>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/categories/troubleshooting/"/>
    
    
      <category term="Spring" scheme="https://kodakyung.github.io/tags/spring/"/>
    
      <category term="Troubleshooting" scheme="https://kodakyung.github.io/tags/troubleshooting/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 터미널에서 SQL파일 import/export 하기(for Mac)</title>
    <link href="https://kodakyung.github.io/2018/05/12/cs-database-20180512-mysql-file-import-for-mac/"/>
    <id>https://kodakyung.github.io/2018/05/12/cs-database-20180512-mysql-file-import-for-mac/</id>
    <published>2018-05-11T15:00:00.000Z</published>
    <updated>2020-03-19T00:43:22.654Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL Workbench를 사용하지 않고 터미널을 통해 데이터베이스에 SQL 파일을 import/export해보자.</p><br><h2 id="SQL-파일-Import"><a href="#SQL-파일-Import" class="headerlink" title="SQL 파일 Import"></a>SQL 파일 Import</h2><p>  <strong>1. sql 파일을 추가할 데이터베이스를 만든다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database &apos;db_name&apos;;</span><br><span class="line">mysql&gt; use &apos;db_name&apos;;</span><br></pre></td></tr></table></figure><img width="762" alt="Add Database" src="/images/2018-05-12/01.png"><br><p>  <strong>2. sql 파일에 대해 source 명령을 실행한다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; source &apos;db_path.sql&apos;;</span><br></pre></td></tr></table></figure><img width="762" alt="sql source" src="/images/2018-05-12/02.png"><p>Query OK가 출력되면 성공한 것.</p><p><br><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use db_name;</span><br><span class="line">mysql&gt; show tables;</span><br></pre></td></tr></table></figure><img width="762" alt="Database 확인" src="/images/2018-05-12/03.png"><p>명령어로 확인해보면 DB가 잘 추가된 것을 확인할 수 있다.</p><p><br><br></p><p>  <strong>3. 사용자(Account)에게 DB 사용권한을 부여한다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant all privileges on dbname.table to userid@localhost identified by &apos;password&apos;;</span><br><span class="line">mysql&gt; grant select on dbname.* to userid@&apos;192.168.%&apos; identified by &apos;password&apos;;</span><br></pre></td></tr></table></figure><p>특정 권한(select, insert 등)만 부여하거나, 원격 접속을 허용할 수도 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure><p>변경된 권한을 적용한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show grants for userid@host;</span><br></pre></td></tr></table></figure><p>사용자에게 부여된 권한을 확인한다.</p><br><img width="762" alt="권한 부여/확인" src="/images/2018-05-12/04.png"><br><p>  <strong>4. 사용자(Account)가 없다면 생성해준 뒤 3번을 진행한다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create user userid@localhost identified by &apos;password&apos;;</span><br></pre></td></tr></table></figure><p>localhost 부분을 %로 한다면 외부 접근이 허용된다.</p><h2 id="SQL-파일-export"><a href="#SQL-파일-export" class="headerlink" title="SQL 파일 export"></a>SQL 파일 export</h2><ul><li>mysqldump 이용</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mysqldump -u&#123;user&#125; -p&#123;password&#125; &#123;db_name&#125; &gt; &#123;db_name&#125;.sql</span><br></pre></td></tr></table></figure><br>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MySQL Workbench를 사용하지 않고 터미널을 통해 데이터베이스에 SQL 파일을 import/export해보자.&lt;/p&gt;
&lt;br&gt;

&lt;h2 id=&quot;SQL-파일-Import&quot;&gt;&lt;a href=&quot;#SQL-파일-Import&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="CS" scheme="https://kodakyung.github.io/categories/cs/"/>
    
      <category term="DataBase" scheme="https://kodakyung.github.io/categories/cs/database/"/>
    
    
      <category term="MySQL" scheme="https://kodakyung.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Maven으로 Netty 프로젝트 시작하기</title>
    <link href="https://kodakyung.github.io/2018/05/11/server-netty-2018-05-11-start-a-netty-project-with-maven/"/>
    <id>https://kodakyung.github.io/2018/05/11/server-netty-2018-05-11-start-a-netty-project-with-maven/</id>
    <published>2018-05-10T15:00:00.000Z</published>
    <updated>2020-03-19T01:12:49.194Z</updated>
    
    <content type="html"><![CDATA[<p>Netty 프로젝트를 시작하려면 우선 Netty 라이브러리를 설치해야한다. 직접 .jar 파일을 다운받아 추가하는 방법이 있고 Maven을 이용해 라이브러리를 받을 수 있다. 여기서는 Maven을 통해 라이브러리를 설치해 프로젝트를 시작해본다.<br></p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><blockquote><p>Maven은 아파치에서 개발된 소프트웨어 프로젝트 관리 도구이다. 소스 코드 관리, 라이브러리 의존성, 빌드, 테스트, 리포트, 프로젝트 배포 같은 소프트웨어 생명주기를 관리한다. 프로젝트를 진행하는데 라이브러리 갯수가 수십개가 넘어가면 코드 작성보다 설정 변경이 어렵게 되는데 이런 작업들을 자동화해준다.</p></blockquote><br><p>Maven을 따로 설치해 CLI 환경에서 프로젝트를 진행할 수 있지만 우선은 따로 설치하지 않고 Maven이 내장된 <a href="https://spring.io/tools" target="_blank" rel="noopener">STS(Spring Tool Suite)</a>을 이용하였다.</p><br><ul><li>Maven 프로젝트를 생성해준다.<img width="325" alt="Maven project 생성" src="/images/2018-05-11/01.png"></li></ul><br><ul><li><p><code>groupId</code>와 <code>artifactId</code>를 입력해 프로젝트를 생성한다.</p><img width="614" alt="Maven project groupId, artifactId 설정" src="/images/2018-05-11/02.png"><ul><li><code>groupId</code> :<br>메이븐 프로젝트를 생성한 조직이나 회사 등을 나타내는 유일한 이름. 주로 자바 패키지명 작성하는 형식과 동일하게 작성하고 필수항목이다.</li><li><code>artifactId</code> :<br>여기서 입력한 값이 프로젝트 명이 된다. 소스 코드가 포함된 프로젝트의 루트 폴더명이 된다.</li></ul></li></ul><br><ul><li>메이븐 설정파일인 pom.xml을 수정해 Netty를 설치한다.  </li></ul><p>메이븐 설정파일을 수정하면 해당하는 라이브러리를 자동으로 설치한다. 메이븐 설정에 사용되는 의존성 설정은 <a href="http://mvnrepository.com/artifact/io.netty" target="_blank" rel="noopener">메이븐 레포지터리 홈페이지</a>에 라이브러리 버전별로 기술되어 있다.</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.0.28.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><br><img width="318" alt="Maven project 생성" src="/images/2018-05-11/03.png">Netty가 Maven Dependencies에 추가되었다.<br><h3 id="EchoServerHandler-java"><a href="#EchoServerHandler-java" class="headerlink" title="EchoServerHandler.java"></a>EchoServerHandler.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span></span></span><br></pre></td></tr></table></figure><ul><li><code>@Sharable</code> : <code>ChannelHandler</code>를 여러 채널간에 안전하게 공유할 수 있음을 나타냄</li><li><code>ChannelInboundHandlerAdapter</code> : 간단한 프로젝트이므로 <code>ChannelInboundHandler</code>의 기본 구현을 제공하는 하위클래스 <code>ChannelInboundHandlerAdapter</code>로 구현한다. 해당 API는 손쉽게 각 메소드를 재정의해 이벤트 수명기에서 원하는 시점을 후크할 수 있다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span>&#123;</span><br><span class="line">  ByteBuf in = (ByteBuf) msg;</span><br><span class="line">  System.out.println(<span class="string">"Server received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">  <span class="comment">// 메세지 콘솔 로깅</span></span><br><span class="line">  ctx.write(in);</span><br><span class="line">  <span class="comment">// 아웃바운드 메세지를 플러시하지 않은 채로 받은 메세지를 발신자로 출력</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>channelRead()</code> : 메시지가 들어올 때마다 호출되는 함수. 여기서는 수신한 데이터를 모두 처리하기위해 재정의했다. 이 서버는 받은 데이터를 발신자에게 다시 보낸다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span></span>&#123;</span><br><span class="line">  ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</span><br><span class="line">  .addListener(ChannelFutureListener.CLOSE);</span><br><span class="line">  <span class="comment">// 대기 중인 메세지를 원격 피어로 플러시하고 채널을 닫음</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>channelReadComplete()</code> : <code>channelRead()</code>의 마지막 호출에서 현재 일괄 처리의 마지막 메세지를 처리했음을 알려준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">  cause.printStackTrace(); <span class="comment">// 예외 스택 추적을 출력</span></span><br><span class="line">  ctx.close(); <span class="comment">// 채널 닫음</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exceptionCaught()</code> : 읽기 작업 중 예외 발생하면 호출된다.</p><br><h3 id="EchoServer-java"><a href="#EchoServer-java" class="headerlink" title="EchoServer.java"></a>EchoServer.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(args.length != <span class="number">1</span>)&#123;</span><br><span class="line">    System.err.println(<span class="string">"Usage: "</span>+ EchoServer.class.getSimpleName() + <span class="string">"&lt;port&gt;"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// port 값을 설정</span></span><br><span class="line">  <span class="keyword">new</span> EchoServer(port).start();</span><br><span class="line">  <span class="comment">// 서버의 start() 메소드 호출</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;port&gt;</code>를 받은 뒤 서버의 <code>start()</code>를 호출한다.</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">  EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">  <span class="comment">// EventLoopGroup 생성</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    <span class="comment">// ServerBootstrap 생성</span></span><br><span class="line">    b.group(group)</span><br><span class="line">      .channel(NioServerSocketChannel.class)</span><br><span class="line">      <span class="comment">// NIO 전송 채널 이용</span></span><br><span class="line">      .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</span><br><span class="line">      <span class="comment">// 지정된 포트를 이용해 소켓 주소 설정</span></span><br><span class="line">      .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ch.pipeline().addLast(serverHandler);</span><br><span class="line">        <span class="comment">// @Shareble 이므로 EchoServerHandler 이용 가능</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      ChannelFuture f = b.bind().sync();</span><br><span class="line">      <span class="comment">// 서버를 비동기 식으로 바인딩, sync()는 바인딩이 완료되기를 대기</span></span><br><span class="line">      <span class="comment">// sync()로 인해 블로킹 된다.</span></span><br><span class="line">      f.channel().closeFuture().sync();</span><br><span class="line">      <span class="comment">// 채널의 CloseFuture를 얻고 완료될 때까지 현재 스레드를 블로킹</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      group.shutdownGracefully().sync();</span><br><span class="line">      <span class="comment">// EventLoopGroup을 종료하고 모든 리소스 해제</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ChannelInitializer</code>를 이용해 새로운 연결을 수락한 후 새로운 자식 Channel을 생성한다. <code>ChannelInitializer</code>가 <code>EchoServerHandler</code>의 하나를 Channel의 <code>ChannelPipeline</code>으로 추가한다. 이 핸들러는 인바인드 메세지에 대한 알림을 받는다.</p><ul><li><code>EchoServerHandler</code>는 비즈니스 논리를 구현</li><li><code>main()</code> 메소드는 서버를 부트스트랩 함<ul><li><strong>부트스트랩 ?</strong> 서버를 구성하는 시동 코드를 의미. 최소한 서버가 연결 요청을 수신하는 포트를 서버와 바인딩하는 코드가 있어야함.<ol><li>서버를 부트스트랩하고 바인딩하는데 이용할 <code>ServerBootstrap</code> 인스턴스 생성</li><li>새로운 연결 수락 및 데이터 R/W와 같은 이벤트 처리를 수행할 <code>NioEventLoopGroup</code> 인스턴스를 생성하고 할당한다.</li><li>서버가 바인딩하는 로컬 <code>InetSocketAddress</code>를 지정.</li><li><code>EchoServerHandler</code> 인스턴스를 이용해 새로운 각 Channel을 초기화한다.</li><li><code>ServerBootstrap.bind()</code>를 호출해 서버를 바인딩</li></ol></li></ul></li></ul><br><p>client도 똑같이 Maven 프로젝트 생성 후 pom.xml 설정을 해준다.</p><h3 id="EchoClientHanlder-java"><a href="#EchoClientHanlder-java" class="headerlink" title="EchoClientHanlder.java"></a>EchoClientHanlder.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">ByteBuf</span>&gt;</span></span><br></pre></td></tr></table></figure><p>데이터를 처리하는 <code>ChannelInboundHandler</code>의 하위 클래스인 <code>SimpleChannelInboundHandler</code>를 상속받아 작업을 처리한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 채널 활성화 알림을 받으면 메세지를 전송</span></span><br><span class="line">  ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">"Netty Start!"</span>, CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>channelActive()</code>: 서버에 대한 연결이 만들어지면 호출된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 수신한 메세지의 덤프를 로깅</span></span><br><span class="line">  System.out.println(<span class="string">"Client received: "</span> + in.toString(CharsetUtil.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>channelRead0()</code>: 서버로부터 메세지를 수신하면 호출된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span></span>&#123;</span><br><span class="line">  <span class="comment">// 예외 시 오류를 로깅하고 채널을 닫음</span></span><br><span class="line">  cause.printStackTrace();</span><br><span class="line">  ctx.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exceptionCaught</code>: 처리 중 예외가 발생하면 호출된다.</p><br><h3 id="EchoClient-java"><a href="#EchoClient-java" class="headerlink" title="EchoClient.java"></a>EchoClient.java</h3><p>클라이언트 부트스트랩 코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    <span class="comment">// bootstrap을 생성</span></span><br><span class="line">    b.group(group)</span><br><span class="line">    <span class="comment">// 클라이언트 이벤트를 처리할 EventLoopGroup 지정, NIO 구현</span></span><br><span class="line">      .channel(NioSocketChannel.class)</span><br><span class="line">      <span class="comment">// 채널 유형으로 NIO 지정</span></span><br><span class="line">      .remoteAddress(<span class="keyword">new</span> InetSocketAddress(host, port))</span><br><span class="line">      <span class="comment">// 서버의 InitSocketAddress 설정</span></span><br><span class="line">      .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;()&#123;</span><br><span class="line">        <span class="comment">// 채널이 생성될 때 파이프라인에 EchoClientHandler 하나를 추가</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          ch.pipeline().addLast(<span class="keyword">new</span> EchoClientHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    ChannelFuture f = b.connect().sync();</span><br><span class="line">    <span class="comment">// 원격 피어로 연결하고 연결이 완료되기를 기다림</span></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">    <span class="comment">// 채널이 닫힐 때 까지 블로킹</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    group.shutdownGracefully().sync();</span><br><span class="line">    <span class="comment">// 스레드 풀을 종료하고 모든 리소스 해제</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>클라이언트를 초기화하기 위한 <code>Bootstrap</code> 인스턴스를 생성한다.</li><li>새로운 연결을 생성하고 인바운드와 아웃바운드 데이터를 처리하는 것을 포함하는 이벤트 처리를 제어할 <code>NioEventLoopGroup</code> 인스턴스를 만들고 할당한다.</li><li>서버로 연결하기 위한 <code>InetSocketAddress</code>를 생성한다.</li><li>연결이 만들어지면 파이프라인에 <code>EchoClientHandler</code> 하나를 추가한다.</li><li>모든 준비가 완료되면 <code>Bootstrap.connect()</code>를 호출해 원격 서버로 연결한다.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(args.length != <span class="number">2</span>)&#123;</span><br><span class="line">    System.err.println(</span><br><span class="line">        <span class="string">"Usage: "</span> + EchoClient.class.getSimpleName() + <span class="string">" &lt;host&gt; &lt;port&gt;"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String host = args[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">new</span> EchoClient(host, port).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>실행하기 전 [Maven install]을 진행한다.<img width="328" alt="Maven install" src="/images/2018-05-11/04.png"><img width="715" alt="Maven install success" src="/images/2018-05-11/05.png"></li></ul><br><ul><li><p>[Run Configuration]에서 서버 실행시 <code>&lt;Port&gt;</code>를 전달해준다.</p><img width="212" alt="Run Configuration" src="/images/2018-05-11/06.png"><img width="589" alt="Run Configuration Port 설정" src="/images/2018-05-11/07.png"></li><li><p>서버 실행 후 클라이언트는 <code>&lt;Host&gt; &lt;Port&gt;</code> 번호를 전달한다.</p><img width="588" alt="Run Configuration client 설정" src="/images/2018-05-11/08.png"></li></ul><br><p>클라이언트가 실행되면 서버로 메세지를 보내고, 서버는 받은 메세지를 그대로 출력한 뒤 다시 클라이언트로 메세지를 보낸다. 클라이언트는 <code>channelRead0</code> 메소드를 통해 메세지를 받아서 다시 출력한다.</p><br><ul><li>Server Console 출력<img width="214" alt="Server Console" src="/images/2018-05-11/09.png"></li><li>Client Console 출력<img width="214" alt="Client Console" src="/images/2018-05-11/10.png"></li></ul><hr><p>자세한 소스코드는 <a href="https://github.com/koda93/TIL/tree/master/Netty/" target="_blank" rel="noopener">여기</a>를 참조</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Netty 프로젝트를 시작하려면 우선 Netty 라이브러리를 설치해야한다. 직접 .jar 파일을 다운받아 추가하는 방법이 있고 Maven을 이용해 라이브러리를 받을 수 있다. 여기서는 Maven을 통해 라이브러리를 설치해 프로젝트를 시작해본다.&lt;
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/categories/server/netty/"/>
    
    
      <category term="Network" scheme="https://kodakyung.github.io/tags/network/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/tags/netty/"/>
    
      <category term="Maven" scheme="https://kodakyung.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>Netty 특징과 아키텍처</title>
    <link href="https://kodakyung.github.io/2018/05/09/server-netty-2018-05-09-netty-features-architecture/"/>
    <id>https://kodakyung.github.io/2018/05/09/server-netty-2018-05-09-netty-features-architecture/</id>
    <published>2018-05-08T15:00:00.000Z</published>
    <updated>2020-03-19T01:10:10.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h2><blockquote><p>네티는 유지 관리가 용이한 고성능 프로토콜 서버와 클라이언트를 신속하게 개발하기 위한 <strong>비동기식 이벤트 기반</strong> 네트워크 애플리케이션 프레임워크이다.</p></blockquote><br><h3 id="자바의-네트워킹"><a href="#자바의-네트워킹" class="headerlink" title="자바의 네트워킹"></a>자바의 네트워킹</h3><p> 최초의 자바 API(<code>java.net</code>)은 블로킹 함수(<code>accept()</code>)만 지원했다. 따라서 다수의 클라이언트를 관리하려면 새로운 클라이언트 Socket마다 새로운 Thread를 할당해야 한다.  </p><p>여러 스레드가 입,출력을 기다리며 무한정 대기 상태가 되는 경우 리소스 낭비가 될 수 있다. 또한 각 스레드가 스택 메모리를 할당해야하는데 스택 메모리를 차지하며, JVM의 컨텍스트 전환에 따른 오버헤드 문제가 생길 수 있다.</p><p><strong>10만명 이상의 동시 연결</strong>을 지원해야할 때는 이런 방식으로는 불가능 하다.</p><br><h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><p>블로킹 시스템 호출 방식 외에 네이티브 소켓 라이브러리에는 논블로킹(non-blocking) 호출이 포함되 있다.</p><ul><li><p><code>setsocket()</code>을 이용하면 데이터가 없을 때 읽기/쓰기 호출이 즉시 반환된다.</p></li><li><p>시스템 이벤트 통지 API를 이용해 논블로킹 소켓을 등록하면 읽기/쓰기할 데이터가 준비됐는지 여부를 알 수 있다.</p><br><h4 id="셀렉터-Selector"><a href="#셀렉터-Selector" class="headerlink" title="셀렉터(Selector)"></a>셀렉터(Selector)</h4><p><code>java.nio.channels.Selector</code> 클래스는 논블로킹 Socket의 집합에서 입출력 상태를 확인할 수 있어서 기존의 블로킹 방식과 다르게 한 스레드로 여러 동시 연결을 처리할 수 있다.</p><blockquote><p>직접 Java NIO API를 통해 제작하는 애플리케이션이 많지만 부하가 높은 상황에서 안정적으로 하기는 어렵다.<br>따라서 Netty와 같은 프레임 워크를 이용하는 것이 좋다.</p></blockquote></li></ul><br><h3 id="Netty의-비동기성과-확장성"><a href="#Netty의-비동기성과-확장성" class="headerlink" title="Netty의 비동기성과 확장성"></a>Netty의 비동기성과 확장성</h3><ul><li>논 블로킹 네트워크 연결은 작업 완료를 기다릴 필요가 없다. 완전 비동기 입출력은 이 특징에 하나 더 추가되는데, 비동기 메소드는 즉시 반환하며 작업이 완료되면 직접 또는 나중에 이를 통지한다.</li><li>셀렉터는 적은 수의 스레드로 여러 연결에서 이벤트를 모니터링 할 수 있게 해준다.</li></ul><h3 id="Netty의-핵심-컴포넌트"><a href="#Netty의-핵심-컴포넌트" class="headerlink" title="Netty의 핵심 컴포넌트"></a>Netty의 핵심 컴포넌트</h3><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>하나 이상의 입출력 작업을 수행할 수 있는 HW 장치, 파일, Socket 등에 대한 열린 연결을 의미  </p><h4 id="CallBack"><a href="#CallBack" class="headerlink" title="CallBack"></a>CallBack</h4><p>네티는 이벤트를 처리할 때 내부적으로 콜백을 이용한다. 콜백이 트리거 되면 <code>ChannelHanlder</code> 인터페이스의 구현을 통해 이벤트를 처리한다.</p><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>작업이 완료되면 애플리케이션에 알린다. Future 객체는 비동기 작업의 결과를 담는 자리표시자(placeholder)의 역할을 하고, 미래의 어떤 시점에 작업이 완료되면 그 결과에 접근할 수 있게 해준다.</p><p>JDK가 <code>java.util.concurrent.Future</code> 인터페이스를 제공하지만 수동으로 작업을 해야했다. 그래서 Netty는 자체 구현 <code>ChannelFuture</code>를 제공한다.</p><h4 id="Event-amp-Handler"><a href="#Event-amp-Handler" class="headerlink" title="Event &amp; Handler"></a>Event &amp; Handler</h4><p>Netty는 작업의 상태 변화를 알리기 위해 고유한 이벤트를 이용하고, 발생한 이벤트를 기준으로 적절한 동작을 트리거한다.</p><ul><li><p>로깅</p></li><li><p>데이터 변환</p></li><li><p>흐름 제어</p></li><li><p>애플리케이션 논리  </p><ul><li><p>인바운드 이벤트</p><ul><li>연결 활성화 또는 비활성화</li><li>데이터 읽기</li><li>사용자 이벤트</li><li>오류 이벤트</li></ul></li><li><p>아웃바운드 트리거 이벤트</p><ul><li>원격 피어로 연결 열기 또는 닫기</li><li>소켓으로 데이터 쓰기 또는 플러시</li></ul></li></ul></li></ul><h4 id="각-채널의-EventLoop"><a href="#각-채널의-EventLoop" class="headerlink" title="각 채널의 EventLoop"></a>각 채널의 EventLoop</h4><ul><li>관심 이벤트 등록</li><li>이벤트를 <code>ChannelHanlder</code>로 발송</li><li>추가 동작 스케쥴링</li></ul><hr><h3 id="기타"><a href="#기타" class="headerlink" title="기타"></a>기타</h3><p><a href="http://netty.io/wiki/adopters.html" target="_blank" rel="noopener">Netty를 도입한 기업 목록</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netty&quot;&gt;&lt;a href=&quot;#Netty&quot; class=&quot;headerlink&quot; title=&quot;Netty&quot;&gt;&lt;/a&gt;Netty&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;네티는 유지 관리가 용이한 고성능 프로토콜 서버와 클라이언트를 신속하게 개발하기 
      
    
    </summary>
    
      <category term="Server" scheme="https://kodakyung.github.io/categories/server/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/categories/server/netty/"/>
    
    
      <category term="Network" scheme="https://kodakyung.github.io/tags/network/"/>
    
      <category term="Netty" scheme="https://kodakyung.github.io/tags/netty/"/>
    
  </entry>
  
</feed>
